// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_player.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetMutualFriendsForIncomingInvites_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn default() -> &'a CPlayer_GetMutualFriendsForIncomingInvites_Request {
        <CPlayer_GetMutualFriendsForIncomingInvites_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMutualFriendsForIncomingInvites_Request {
    pub fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Request {
        CPlayer_GetMutualFriendsForIncomingInvites_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetMutualFriendsForIncomingInvites_Request>(
                "CPlayer_GetMutualFriendsForIncomingInvites_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetMutualFriendsForIncomingInvites_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetMutualFriendsForIncomingInvites_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetMutualFriendsForIncomingInvites_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_IncomingInviteMutualFriendList {
    // message fields
    steamid: ::std::option::Option<u64>,
    pub mutual_friend_account_ids: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IncomingInviteMutualFriendList {
    fn default() -> &'a CPlayer_IncomingInviteMutualFriendList {
        <CPlayer_IncomingInviteMutualFriendList as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IncomingInviteMutualFriendList {
    pub fn new() -> CPlayer_IncomingInviteMutualFriendList {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // repeated uint32 mutual_friend_account_ids = 2;


    pub fn get_mutual_friend_account_ids(&self) -> &[u32] {
        &self.mutual_friend_account_ids
    }
    pub fn clear_mutual_friend_account_ids(&mut self) {
        self.mutual_friend_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_mutual_friend_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.mutual_friend_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mutual_friend_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mutual_friend_account_ids
    }

    // Take field
    pub fn take_mutual_friend_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mutual_friend_account_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPlayer_IncomingInviteMutualFriendList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mutual_friend_account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        for value in &self.mutual_friend_account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        for v in &self.mutual_friend_account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IncomingInviteMutualFriendList {
        CPlayer_IncomingInviteMutualFriendList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_IncomingInviteMutualFriendList| { &m.steamid },
                |m: &mut CPlayer_IncomingInviteMutualFriendList| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mutual_friend_account_ids",
                |m: &CPlayer_IncomingInviteMutualFriendList| { &m.mutual_friend_account_ids },
                |m: &mut CPlayer_IncomingInviteMutualFriendList| { &mut m.mutual_friend_account_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_IncomingInviteMutualFriendList>(
                "CPlayer_IncomingInviteMutualFriendList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_IncomingInviteMutualFriendList {
        static instance: ::protobuf::rt::LazyV2<CPlayer_IncomingInviteMutualFriendList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_IncomingInviteMutualFriendList::new)
    }
}

impl ::protobuf::Clear for CPlayer_IncomingInviteMutualFriendList {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.mutual_friend_account_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IncomingInviteMutualFriendList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IncomingInviteMutualFriendList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetMutualFriendsForIncomingInvites_Response {
    // message fields
    pub incoming_invite_mutual_friends_lists: ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn default() -> &'a CPlayer_GetMutualFriendsForIncomingInvites_Response {
        <CPlayer_GetMutualFriendsForIncomingInvites_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMutualFriendsForIncomingInvites_Response {
    pub fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_IncomingInviteMutualFriendList incoming_invite_mutual_friends_lists = 1;


    pub fn get_incoming_invite_mutual_friends_lists(&self) -> &[CPlayer_IncomingInviteMutualFriendList] {
        &self.incoming_invite_mutual_friends_lists
    }
    pub fn clear_incoming_invite_mutual_friends_lists(&mut self) {
        self.incoming_invite_mutual_friends_lists.clear();
    }

    // Param is passed by value, moved
    pub fn set_incoming_invite_mutual_friends_lists(&mut self, v: ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList>) {
        self.incoming_invite_mutual_friends_lists = v;
    }

    // Mutable pointer to the field.
    pub fn mut_incoming_invite_mutual_friends_lists(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList> {
        &mut self.incoming_invite_mutual_friends_lists
    }

    // Take field
    pub fn take_incoming_invite_mutual_friends_lists(&mut self) -> ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList> {
        ::std::mem::replace(&mut self.incoming_invite_mutual_friends_lists, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.incoming_invite_mutual_friends_lists {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.incoming_invite_mutual_friends_lists)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.incoming_invite_mutual_friends_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.incoming_invite_mutual_friends_lists {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Response {
        CPlayer_GetMutualFriendsForIncomingInvites_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_IncomingInviteMutualFriendList>>(
                "incoming_invite_mutual_friends_lists",
                |m: &CPlayer_GetMutualFriendsForIncomingInvites_Response| { &m.incoming_invite_mutual_friends_lists },
                |m: &mut CPlayer_GetMutualFriendsForIncomingInvites_Response| { &mut m.incoming_invite_mutual_friends_lists },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetMutualFriendsForIncomingInvites_Response>(
                "CPlayer_GetMutualFriendsForIncomingInvites_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetMutualFriendsForIncomingInvites_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetMutualFriendsForIncomingInvites_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetMutualFriendsForIncomingInvites_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn clear(&mut self) {
        self.incoming_invite_mutual_friends_lists.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetOwnedGames_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    include_appinfo: ::std::option::Option<bool>,
    include_played_free_games: ::std::option::Option<bool>,
    pub appids_filter: ::std::vec::Vec<u32>,
    include_free_sub: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetOwnedGames_Request {
    fn default() -> &'a CPlayer_GetOwnedGames_Request {
        <CPlayer_GetOwnedGames_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetOwnedGames_Request {
    pub fn new() -> CPlayer_GetOwnedGames_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool include_appinfo = 2;


    pub fn get_include_appinfo(&self) -> bool {
        self.include_appinfo.unwrap_or(false)
    }
    pub fn clear_include_appinfo(&mut self) {
        self.include_appinfo = ::std::option::Option::None;
    }

    pub fn has_include_appinfo(&self) -> bool {
        self.include_appinfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_appinfo(&mut self, v: bool) {
        self.include_appinfo = ::std::option::Option::Some(v);
    }

    // optional bool include_played_free_games = 3;


    pub fn get_include_played_free_games(&self) -> bool {
        self.include_played_free_games.unwrap_or(false)
    }
    pub fn clear_include_played_free_games(&mut self) {
        self.include_played_free_games = ::std::option::Option::None;
    }

    pub fn has_include_played_free_games(&self) -> bool {
        self.include_played_free_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_played_free_games(&mut self, v: bool) {
        self.include_played_free_games = ::std::option::Option::Some(v);
    }

    // repeated uint32 appids_filter = 4;


    pub fn get_appids_filter(&self) -> &[u32] {
        &self.appids_filter
    }
    pub fn clear_appids_filter(&mut self) {
        self.appids_filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids_filter(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids_filter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids_filter(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids_filter
    }

    // Take field
    pub fn take_appids_filter(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids_filter, ::std::vec::Vec::new())
    }

    // optional bool include_free_sub = 5;


    pub fn get_include_free_sub(&self) -> bool {
        self.include_free_sub.unwrap_or(false)
    }
    pub fn clear_include_free_sub(&mut self) {
        self.include_free_sub = ::std::option::Option::None;
    }

    pub fn has_include_free_sub(&self) -> bool {
        self.include_free_sub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_free_sub(&mut self, v: bool) {
        self.include_free_sub = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetOwnedGames_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_appinfo = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_played_free_games = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids_filter)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_free_sub = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.include_appinfo {
            my_size += 2;
        }
        if let Some(v) = self.include_played_free_games {
            my_size += 2;
        }
        for value in &self.appids_filter {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.include_free_sub {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.include_appinfo {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.include_played_free_games {
            os.write_bool(3, v)?;
        }
        for v in &self.appids_filter {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.include_free_sub {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetOwnedGames_Request {
        CPlayer_GetOwnedGames_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steamid",
                |m: &CPlayer_GetOwnedGames_Request| { &m.steamid },
                |m: &mut CPlayer_GetOwnedGames_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_appinfo",
                |m: &CPlayer_GetOwnedGames_Request| { &m.include_appinfo },
                |m: &mut CPlayer_GetOwnedGames_Request| { &mut m.include_appinfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_played_free_games",
                |m: &CPlayer_GetOwnedGames_Request| { &m.include_played_free_games },
                |m: &mut CPlayer_GetOwnedGames_Request| { &mut m.include_played_free_games },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appids_filter",
                |m: &CPlayer_GetOwnedGames_Request| { &m.appids_filter },
                |m: &mut CPlayer_GetOwnedGames_Request| { &mut m.appids_filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_free_sub",
                |m: &CPlayer_GetOwnedGames_Request| { &m.include_free_sub },
                |m: &mut CPlayer_GetOwnedGames_Request| { &mut m.include_free_sub },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetOwnedGames_Request>(
                "CPlayer_GetOwnedGames_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetOwnedGames_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetOwnedGames_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetOwnedGames_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetOwnedGames_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.include_appinfo = ::std::option::Option::None;
        self.include_played_free_games = ::std::option::Option::None;
        self.appids_filter.clear();
        self.include_free_sub = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetOwnedGames_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetOwnedGames_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetOwnedGames_Response {
    // message fields
    game_count: ::std::option::Option<u32>,
    pub games: ::protobuf::RepeatedField<CPlayer_GetOwnedGames_Response_Game>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetOwnedGames_Response {
    fn default() -> &'a CPlayer_GetOwnedGames_Response {
        <CPlayer_GetOwnedGames_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetOwnedGames_Response {
    pub fn new() -> CPlayer_GetOwnedGames_Response {
        ::std::default::Default::default()
    }

    // optional uint32 game_count = 1;


    pub fn get_game_count(&self) -> u32 {
        self.game_count.unwrap_or(0)
    }
    pub fn clear_game_count(&mut self) {
        self.game_count = ::std::option::Option::None;
    }

    pub fn has_game_count(&self) -> bool {
        self.game_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_count(&mut self, v: u32) {
        self.game_count = ::std::option::Option::Some(v);
    }

    // repeated .CPlayer_GetOwnedGames_Response.Game games = 2;


    pub fn get_games(&self) -> &[CPlayer_GetOwnedGames_Response_Game] {
        &self.games
    }
    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetOwnedGames_Response_Game>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetOwnedGames_Response_Game> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetOwnedGames_Response_Game> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetOwnedGames_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_count {
            os.write_uint32(1, v)?;
        }
        for v in &self.games {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetOwnedGames_Response {
        CPlayer_GetOwnedGames_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_count",
                |m: &CPlayer_GetOwnedGames_Response| { &m.game_count },
                |m: &mut CPlayer_GetOwnedGames_Response| { &mut m.game_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetOwnedGames_Response_Game>>(
                "games",
                |m: &CPlayer_GetOwnedGames_Response| { &m.games },
                |m: &mut CPlayer_GetOwnedGames_Response| { &mut m.games },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetOwnedGames_Response>(
                "CPlayer_GetOwnedGames_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetOwnedGames_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetOwnedGames_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetOwnedGames_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetOwnedGames_Response {
    fn clear(&mut self) {
        self.game_count = ::std::option::Option::None;
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetOwnedGames_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetOwnedGames_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetOwnedGames_Response_Game {
    // message fields
    appid: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    playtime_2weeks: ::std::option::Option<i32>,
    playtime_forever: ::std::option::Option<i32>,
    img_icon_url: ::protobuf::SingularField<::std::string::String>,
    img_logo_url: ::protobuf::SingularField<::std::string::String>,
    has_community_visible_stats: ::std::option::Option<bool>,
    playtime_windows_forever: ::std::option::Option<i32>,
    playtime_mac_forever: ::std::option::Option<i32>,
    playtime_linux_forever: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetOwnedGames_Response_Game {
    fn default() -> &'a CPlayer_GetOwnedGames_Response_Game {
        <CPlayer_GetOwnedGames_Response_Game as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetOwnedGames_Response_Game {
    pub fn new() -> CPlayer_GetOwnedGames_Response_Game {
        ::std::default::Default::default()
    }

    // optional int32 appid = 1;


    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 playtime_2weeks = 3;


    pub fn get_playtime_2weeks(&self) -> i32 {
        self.playtime_2weeks.unwrap_or(0)
    }
    pub fn clear_playtime_2weeks(&mut self) {
        self.playtime_2weeks = ::std::option::Option::None;
    }

    pub fn has_playtime_2weeks(&self) -> bool {
        self.playtime_2weeks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_2weeks(&mut self, v: i32) {
        self.playtime_2weeks = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_forever = 4;


    pub fn get_playtime_forever(&self) -> i32 {
        self.playtime_forever.unwrap_or(0)
    }
    pub fn clear_playtime_forever(&mut self) {
        self.playtime_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_forever(&self) -> bool {
        self.playtime_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_forever(&mut self, v: i32) {
        self.playtime_forever = ::std::option::Option::Some(v);
    }

    // optional string img_icon_url = 5;


    pub fn get_img_icon_url(&self) -> &str {
        match self.img_icon_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_img_icon_url(&mut self) {
        self.img_icon_url.clear();
    }

    pub fn has_img_icon_url(&self) -> bool {
        self.img_icon_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_img_icon_url(&mut self, v: ::std::string::String) {
        self.img_icon_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_img_icon_url(&mut self) -> &mut ::std::string::String {
        if self.img_icon_url.is_none() {
            self.img_icon_url.set_default();
        }
        self.img_icon_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_img_icon_url(&mut self) -> ::std::string::String {
        self.img_icon_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string img_logo_url = 6;


    pub fn get_img_logo_url(&self) -> &str {
        match self.img_logo_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_img_logo_url(&mut self) {
        self.img_logo_url.clear();
    }

    pub fn has_img_logo_url(&self) -> bool {
        self.img_logo_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_img_logo_url(&mut self, v: ::std::string::String) {
        self.img_logo_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_img_logo_url(&mut self) -> &mut ::std::string::String {
        if self.img_logo_url.is_none() {
            self.img_logo_url.set_default();
        }
        self.img_logo_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_img_logo_url(&mut self) -> ::std::string::String {
        self.img_logo_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_community_visible_stats = 7;


    pub fn get_has_community_visible_stats(&self) -> bool {
        self.has_community_visible_stats.unwrap_or(false)
    }
    pub fn clear_has_community_visible_stats(&mut self) {
        self.has_community_visible_stats = ::std::option::Option::None;
    }

    pub fn has_has_community_visible_stats(&self) -> bool {
        self.has_community_visible_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_community_visible_stats(&mut self, v: bool) {
        self.has_community_visible_stats = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_windows_forever = 8;


    pub fn get_playtime_windows_forever(&self) -> i32 {
        self.playtime_windows_forever.unwrap_or(0)
    }
    pub fn clear_playtime_windows_forever(&mut self) {
        self.playtime_windows_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_windows_forever(&self) -> bool {
        self.playtime_windows_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_windows_forever(&mut self, v: i32) {
        self.playtime_windows_forever = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_mac_forever = 9;


    pub fn get_playtime_mac_forever(&self) -> i32 {
        self.playtime_mac_forever.unwrap_or(0)
    }
    pub fn clear_playtime_mac_forever(&mut self) {
        self.playtime_mac_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_mac_forever(&self) -> bool {
        self.playtime_mac_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_mac_forever(&mut self, v: i32) {
        self.playtime_mac_forever = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_linux_forever = 10;


    pub fn get_playtime_linux_forever(&self) -> i32 {
        self.playtime_linux_forever.unwrap_or(0)
    }
    pub fn clear_playtime_linux_forever(&mut self) {
        self.playtime_linux_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_linux_forever(&self) -> bool {
        self.playtime_linux_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_linux_forever(&mut self, v: i32) {
        self.playtime_linux_forever = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetOwnedGames_Response_Game {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_2weeks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_forever = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.img_icon_url)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.img_logo_url)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_community_visible_stats = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_windows_forever = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_mac_forever = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_linux_forever = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.playtime_2weeks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_forever {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.img_icon_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.img_logo_url.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.has_community_visible_stats {
            my_size += 2;
        }
        if let Some(v) = self.playtime_windows_forever {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_mac_forever {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_linux_forever {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.playtime_2weeks {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.playtime_forever {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.img_icon_url.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.img_logo_url.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.has_community_visible_stats {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.playtime_windows_forever {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.playtime_mac_forever {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.playtime_linux_forever {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetOwnedGames_Response_Game {
        CPlayer_GetOwnedGames_Response_Game::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "appid",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.appid },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.name },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_2weeks",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.playtime_2weeks },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.playtime_2weeks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_forever",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.playtime_forever },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.playtime_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "img_icon_url",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.img_icon_url },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.img_icon_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "img_logo_url",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.img_logo_url },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.img_logo_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_community_visible_stats",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.has_community_visible_stats },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.has_community_visible_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_windows_forever",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.playtime_windows_forever },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.playtime_windows_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_mac_forever",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.playtime_mac_forever },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.playtime_mac_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_linux_forever",
                |m: &CPlayer_GetOwnedGames_Response_Game| { &m.playtime_linux_forever },
                |m: &mut CPlayer_GetOwnedGames_Response_Game| { &mut m.playtime_linux_forever },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetOwnedGames_Response_Game>(
                "CPlayer_GetOwnedGames_Response.Game",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetOwnedGames_Response_Game {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetOwnedGames_Response_Game> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetOwnedGames_Response_Game::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetOwnedGames_Response_Game {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name.clear();
        self.playtime_2weeks = ::std::option::Option::None;
        self.playtime_forever = ::std::option::Option::None;
        self.img_icon_url.clear();
        self.img_logo_url.clear();
        self.has_community_visible_stats = ::std::option::Option::None;
        self.playtime_windows_forever = ::std::option::Option::None;
        self.playtime_mac_forever = ::std::option::Option::None;
        self.playtime_linux_forever = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetOwnedGames_Response_Game {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetOwnedGames_Response_Game {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPlayNext_Request {
    // message fields
    max_age_seconds: ::std::option::Option<u32>,
    pub ignore_appids: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPlayNext_Request {
    fn default() -> &'a CPlayer_GetPlayNext_Request {
        <CPlayer_GetPlayNext_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPlayNext_Request {
    pub fn new() -> CPlayer_GetPlayNext_Request {
        ::std::default::Default::default()
    }

    // optional uint32 max_age_seconds = 1;


    pub fn get_max_age_seconds(&self) -> u32 {
        self.max_age_seconds.unwrap_or(0)
    }
    pub fn clear_max_age_seconds(&mut self) {
        self.max_age_seconds = ::std::option::Option::None;
    }

    pub fn has_max_age_seconds(&self) -> bool {
        self.max_age_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_age_seconds(&mut self, v: u32) {
        self.max_age_seconds = ::std::option::Option::Some(v);
    }

    // repeated uint32 ignore_appids = 2;


    pub fn get_ignore_appids(&self) -> &[u32] {
        &self.ignore_appids
    }
    pub fn clear_ignore_appids(&mut self) {
        self.ignore_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignore_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.ignore_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignore_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ignore_appids
    }

    // Take field
    pub fn take_ignore_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ignore_appids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPlayer_GetPlayNext_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_age_seconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ignore_appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.max_age_seconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ignore_appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.max_age_seconds {
            os.write_uint32(1, v)?;
        }
        for v in &self.ignore_appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPlayNext_Request {
        CPlayer_GetPlayNext_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_age_seconds",
                |m: &CPlayer_GetPlayNext_Request| { &m.max_age_seconds },
                |m: &mut CPlayer_GetPlayNext_Request| { &mut m.max_age_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ignore_appids",
                |m: &CPlayer_GetPlayNext_Request| { &m.ignore_appids },
                |m: &mut CPlayer_GetPlayNext_Request| { &mut m.ignore_appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPlayNext_Request>(
                "CPlayer_GetPlayNext_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPlayNext_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPlayNext_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPlayNext_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPlayNext_Request {
    fn clear(&mut self) {
        self.max_age_seconds = ::std::option::Option::None;
        self.ignore_appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPlayNext_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPlayNext_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPlayNext_Response {
    // message fields
    last_update_time: ::std::option::Option<u32>,
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPlayNext_Response {
    fn default() -> &'a CPlayer_GetPlayNext_Response {
        <CPlayer_GetPlayNext_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPlayNext_Response {
    pub fn new() -> CPlayer_GetPlayNext_Response {
        ::std::default::Default::default()
    }

    // optional uint32 last_update_time = 1;


    pub fn get_last_update_time(&self) -> u32 {
        self.last_update_time.unwrap_or(0)
    }
    pub fn clear_last_update_time(&mut self) {
        self.last_update_time = ::std::option::Option::None;
    }

    pub fn has_last_update_time(&self) -> bool {
        self.last_update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_update_time(&mut self, v: u32) {
        self.last_update_time = ::std::option::Option::Some(v);
    }

    // repeated uint32 appids = 2;


    pub fn get_appids(&self) -> &[u32] {
        &self.appids
    }
    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPlayer_GetPlayNext_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.last_update_time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.last_update_time {
            os.write_uint32(1, v)?;
        }
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPlayNext_Response {
        CPlayer_GetPlayNext_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_update_time",
                |m: &CPlayer_GetPlayNext_Response| { &m.last_update_time },
                |m: &mut CPlayer_GetPlayNext_Response| { &mut m.last_update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appids",
                |m: &CPlayer_GetPlayNext_Response| { &m.appids },
                |m: &mut CPlayer_GetPlayNext_Response| { &mut m.appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPlayNext_Response>(
                "CPlayer_GetPlayNext_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPlayNext_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPlayNext_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPlayNext_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPlayNext_Response {
    fn clear(&mut self) {
        self.last_update_time = ::std::option::Option::None;
        self.appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPlayNext_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPlayNext_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Request {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Request {
        <CPlayer_GetFriendsGameplayInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Request {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Request {
        CPlayer_GetFriendsGameplayInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetFriendsGameplayInfo_Request| { &m.appid },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Request| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsGameplayInfo_Request>(
                "CPlayer_GetFriendsGameplayInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsGameplayInfo_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsGameplayInfo_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Response {
    // message fields
    pub your_info: ::protobuf::SingularPtrField<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo>,
    pub in_game: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    pub played_recently: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    pub played_ever: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    pub owns: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    pub in_wishlist: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Response {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Response {
        <CPlayer_GetFriendsGameplayInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Response {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CPlayer_GetFriendsGameplayInfo_Response.OwnGameplayInfo your_info = 1;


    pub fn get_your_info(&self) -> &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        self.your_info.as_ref().unwrap_or_else(|| <CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_your_info(&mut self) {
        self.your_info.clear();
    }

    pub fn has_your_info(&self) -> bool {
        self.your_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_info(&mut self, v: CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo) {
        self.your_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_your_info(&mut self) -> &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        if self.your_info.is_none() {
            self.your_info.set_default();
        }
        self.your_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_your_info(&mut self) -> CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        self.your_info.take().unwrap_or_else(|| CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo in_game = 2;


    pub fn get_in_game(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.in_game
    }
    pub fn clear_in_game(&mut self) {
        self.in_game.clear();
    }

    // Param is passed by value, moved
    pub fn set_in_game(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.in_game = v;
    }

    // Mutable pointer to the field.
    pub fn mut_in_game(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.in_game
    }

    // Take field
    pub fn take_in_game(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.in_game, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo played_recently = 3;


    pub fn get_played_recently(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.played_recently
    }
    pub fn clear_played_recently(&mut self) {
        self.played_recently.clear();
    }

    // Param is passed by value, moved
    pub fn set_played_recently(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.played_recently = v;
    }

    // Mutable pointer to the field.
    pub fn mut_played_recently(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.played_recently
    }

    // Take field
    pub fn take_played_recently(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.played_recently, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo played_ever = 4;


    pub fn get_played_ever(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.played_ever
    }
    pub fn clear_played_ever(&mut self) {
        self.played_ever.clear();
    }

    // Param is passed by value, moved
    pub fn set_played_ever(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.played_ever = v;
    }

    // Mutable pointer to the field.
    pub fn mut_played_ever(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.played_ever
    }

    // Take field
    pub fn take_played_ever(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.played_ever, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo owns = 5;


    pub fn get_owns(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.owns
    }
    pub fn clear_owns(&mut self) {
        self.owns.clear();
    }

    // Param is passed by value, moved
    pub fn set_owns(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.owns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owns(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.owns
    }

    // Take field
    pub fn take_owns(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.owns, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo in_wishlist = 6;


    pub fn get_in_wishlist(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.in_wishlist
    }
    pub fn clear_in_wishlist(&mut self) {
        self.in_wishlist.clear();
    }

    // Param is passed by value, moved
    pub fn set_in_wishlist(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.in_wishlist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_in_wishlist(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.in_wishlist
    }

    // Take field
    pub fn take_in_wishlist(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.in_wishlist, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.your_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_game {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.played_recently {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.played_ever {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owns {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_wishlist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.your_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.in_game)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.played_recently)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.played_ever)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.owns)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.in_wishlist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.your_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.in_game {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.played_recently {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.played_ever {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.owns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.in_wishlist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.your_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.in_game {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.played_recently {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.played_ever {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.owns {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.in_wishlist {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Response {
        CPlayer_GetFriendsGameplayInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo>>(
                "your_info",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.your_info },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.your_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                "in_game",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.in_game },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.in_game },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                "played_recently",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.played_recently },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.played_recently },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                "played_ever",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.played_ever },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.played_ever },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                "owns",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.owns },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.owns },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                "in_wishlist",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.in_wishlist },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.in_wishlist },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsGameplayInfo_Response>(
                "CPlayer_GetFriendsGameplayInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsGameplayInfo_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsGameplayInfo_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Response {
    fn clear(&mut self) {
        self.your_info.clear();
        self.in_game.clear();
        self.played_recently.clear();
        self.played_ever.clear();
        self.owns.clear();
        self.in_wishlist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    // message fields
    steamid: ::std::option::Option<u64>,
    minutes_played: ::std::option::Option<u32>,
    minutes_played_forever: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        <CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played = 2;


    pub fn get_minutes_played(&self) -> u32 {
        self.minutes_played.unwrap_or(0)
    }
    pub fn clear_minutes_played(&mut self) {
        self.minutes_played = ::std::option::Option::None;
    }

    pub fn has_minutes_played(&self) -> bool {
        self.minutes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played(&mut self, v: u32) {
        self.minutes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_forever = 3;


    pub fn get_minutes_played_forever(&self) -> u32 {
        self.minutes_played_forever.unwrap_or(0)
    }
    pub fn clear_minutes_played_forever(&mut self) {
        self.minutes_played_forever = ::std::option::Option::None;
    }

    pub fn has_minutes_played_forever(&self) -> bool {
        self.minutes_played_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_forever(&mut self, v: u32) {
        self.minutes_played_forever = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_forever = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.minutes_played {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_forever {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.minutes_played {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minutes_played_forever {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &m.steamid },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minutes_played",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &m.minutes_played },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &mut m.minutes_played },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minutes_played_forever",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &m.minutes_played_forever },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &mut m.minutes_played_forever },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>(
                "CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.minutes_played = ::std::option::Option::None;
        self.minutes_played_forever = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    // message fields
    steamid: ::std::option::Option<u64>,
    minutes_played: ::std::option::Option<u32>,
    minutes_played_forever: ::std::option::Option<u32>,
    in_wishlist: ::std::option::Option<bool>,
    owned: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        <CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played = 2;


    pub fn get_minutes_played(&self) -> u32 {
        self.minutes_played.unwrap_or(0)
    }
    pub fn clear_minutes_played(&mut self) {
        self.minutes_played = ::std::option::Option::None;
    }

    pub fn has_minutes_played(&self) -> bool {
        self.minutes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played(&mut self, v: u32) {
        self.minutes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_forever = 3;


    pub fn get_minutes_played_forever(&self) -> u32 {
        self.minutes_played_forever.unwrap_or(0)
    }
    pub fn clear_minutes_played_forever(&mut self) {
        self.minutes_played_forever = ::std::option::Option::None;
    }

    pub fn has_minutes_played_forever(&self) -> bool {
        self.minutes_played_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_forever(&mut self, v: u32) {
        self.minutes_played_forever = ::std::option::Option::Some(v);
    }

    // optional bool in_wishlist = 4;


    pub fn get_in_wishlist(&self) -> bool {
        self.in_wishlist.unwrap_or(false)
    }
    pub fn clear_in_wishlist(&mut self) {
        self.in_wishlist = ::std::option::Option::None;
    }

    pub fn has_in_wishlist(&self) -> bool {
        self.in_wishlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_wishlist(&mut self, v: bool) {
        self.in_wishlist = ::std::option::Option::Some(v);
    }

    // optional bool owned = 5;


    pub fn get_owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }
    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_forever = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_wishlist = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.minutes_played {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_forever {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_wishlist {
            my_size += 2;
        }
        if let Some(v) = self.owned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.minutes_played {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minutes_played_forever {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_wishlist {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.owned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.steamid },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minutes_played",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.minutes_played },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.minutes_played },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minutes_played_forever",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.minutes_played_forever },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.minutes_played_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_wishlist",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.in_wishlist },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.in_wishlist },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "owned",
                |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.owned },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.owned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo>(
                "CPlayer_GetFriendsGameplayInfo_Response.OwnGameplayInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.minutes_played = ::std::option::Option::None;
        self.minutes_played_forever = ::std::option::Option::None;
        self.in_wishlist = ::std::option::Option::None;
        self.owned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Request {
    // message fields
    news_language: ::protobuf::SingularField<::std::string::String>,
    request_flags: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Request {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Request {
        <CPlayer_GetFriendsAppsActivity_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Request {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Request {
        ::std::default::Default::default()
    }

    // optional string news_language = 1;


    pub fn get_news_language(&self) -> &str {
        match self.news_language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_news_language(&mut self) {
        self.news_language.clear();
    }

    pub fn has_news_language(&self) -> bool {
        self.news_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_news_language(&mut self, v: ::std::string::String) {
        self.news_language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_news_language(&mut self) -> &mut ::std::string::String {
        if self.news_language.is_none() {
            self.news_language.set_default();
        }
        self.news_language.as_mut().unwrap()
    }

    // Take field
    pub fn take_news_language(&mut self) -> ::std::string::String {
        self.news_language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 request_flags = 2;


    pub fn get_request_flags(&self) -> u32 {
        self.request_flags.unwrap_or(0)
    }
    pub fn clear_request_flags(&mut self) {
        self.request_flags = ::std::option::Option::None;
    }

    pub fn has_request_flags(&self) -> bool {
        self.request_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_flags(&mut self, v: u32) {
        self.request_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.news_language)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.news_language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.request_flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.news_language.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.request_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Request {
        CPlayer_GetFriendsAppsActivity_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "news_language",
                |m: &CPlayer_GetFriendsAppsActivity_Request| { &m.news_language },
                |m: &mut CPlayer_GetFriendsAppsActivity_Request| { &mut m.news_language },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_flags",
                |m: &CPlayer_GetFriendsAppsActivity_Request| { &m.request_flags },
                |m: &mut CPlayer_GetFriendsAppsActivity_Request| { &mut m.request_flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsAppsActivity_Request>(
                "CPlayer_GetFriendsAppsActivity_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsAppsActivity_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsAppsActivity_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Request {
    fn clear(&mut self) {
        self.news_language.clear();
        self.request_flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Response {
    // message fields
    pub trending: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    pub recent_purchases: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    pub unowned: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    pub popular: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    pub dont_forget: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    pub being_discussed: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    pub new_to_group: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    pub returned_to_group: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    active_friend_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Response {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Response {
        <CPlayer_GetFriendsAppsActivity_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Response {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo trending = 1;


    pub fn get_trending(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.trending
    }
    pub fn clear_trending(&mut self) {
        self.trending.clear();
    }

    // Param is passed by value, moved
    pub fn set_trending(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.trending = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trending(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.trending
    }

    // Take field
    pub fn take_trending(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.trending, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo recent_purchases = 2;


    pub fn get_recent_purchases(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.recent_purchases
    }
    pub fn clear_recent_purchases(&mut self) {
        self.recent_purchases.clear();
    }

    // Param is passed by value, moved
    pub fn set_recent_purchases(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.recent_purchases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recent_purchases(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.recent_purchases
    }

    // Take field
    pub fn take_recent_purchases(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.recent_purchases, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo unowned = 3;


    pub fn get_unowned(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.unowned
    }
    pub fn clear_unowned(&mut self) {
        self.unowned.clear();
    }

    // Param is passed by value, moved
    pub fn set_unowned(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.unowned = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unowned(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.unowned
    }

    // Take field
    pub fn take_unowned(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.unowned, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo popular = 4;


    pub fn get_popular(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.popular
    }
    pub fn clear_popular(&mut self) {
        self.popular.clear();
    }

    // Param is passed by value, moved
    pub fn set_popular(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.popular = v;
    }

    // Mutable pointer to the field.
    pub fn mut_popular(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.popular
    }

    // Take field
    pub fn take_popular(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.popular, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo dont_forget = 5;


    pub fn get_dont_forget(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.dont_forget
    }
    pub fn clear_dont_forget(&mut self) {
        self.dont_forget.clear();
    }

    // Param is passed by value, moved
    pub fn set_dont_forget(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.dont_forget = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dont_forget(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.dont_forget
    }

    // Take field
    pub fn take_dont_forget(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.dont_forget, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo being_discussed = 6;


    pub fn get_being_discussed(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.being_discussed
    }
    pub fn clear_being_discussed(&mut self) {
        self.being_discussed.clear();
    }

    // Param is passed by value, moved
    pub fn set_being_discussed(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.being_discussed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_being_discussed(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.being_discussed
    }

    // Take field
    pub fn take_being_discussed(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.being_discussed, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo new_to_group = 7;


    pub fn get_new_to_group(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.new_to_group
    }
    pub fn clear_new_to_group(&mut self) {
        self.new_to_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_to_group(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.new_to_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_to_group(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.new_to_group
    }

    // Take field
    pub fn take_new_to_group(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.new_to_group, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo returned_to_group = 8;


    pub fn get_returned_to_group(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.returned_to_group
    }
    pub fn clear_returned_to_group(&mut self) {
        self.returned_to_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_returned_to_group(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.returned_to_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_returned_to_group(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.returned_to_group
    }

    // Take field
    pub fn take_returned_to_group(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.returned_to_group, ::protobuf::RepeatedField::new())
    }

    // optional uint32 active_friend_count = 9;


    pub fn get_active_friend_count(&self) -> u32 {
        self.active_friend_count.unwrap_or(0u32)
    }
    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.trending {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recent_purchases {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unowned {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.popular {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dont_forget {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.being_discussed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_to_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.returned_to_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trending)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.recent_purchases)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unowned)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.popular)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dont_forget)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.being_discussed)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.new_to_group)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.returned_to_group)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_friend_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trending {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.recent_purchases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unowned {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.popular {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dont_forget {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.being_discussed {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.new_to_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.returned_to_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.active_friend_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trending {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.recent_purchases {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unowned {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.popular {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dont_forget {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.being_discussed {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.new_to_group {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.returned_to_group {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.active_friend_count {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Response {
        CPlayer_GetFriendsAppsActivity_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "trending",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.trending },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.trending },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "recent_purchases",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.recent_purchases },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.recent_purchases },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "unowned",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.unowned },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.unowned },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "popular",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.popular },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.popular },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "dont_forget",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.dont_forget },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.dont_forget },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "being_discussed",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.being_discussed },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.being_discussed },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "new_to_group",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.new_to_group },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.new_to_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                "returned_to_group",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.returned_to_group },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.returned_to_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_friend_count",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.active_friend_count },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.active_friend_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsAppsActivity_Response>(
                "CPlayer_GetFriendsAppsActivity_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsAppsActivity_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsAppsActivity_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Response {
    fn clear(&mut self) {
        self.trending.clear();
        self.recent_purchases.clear();
        self.unowned.clear();
        self.popular.clear();
        self.dont_forget.clear();
        self.being_discussed.clear();
        self.new_to_group.clear();
        self.returned_to_group.clear();
        self.active_friend_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    // message fields
    steamid: ::std::option::Option<u64>,
    minutes_played_this_week: ::std::option::Option<u32>,
    minutes_played_two_weeks: ::std::option::Option<u32>,
    minutes_played_forever: ::std::option::Option<u32>,
    event_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        <CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_this_week = 2;


    pub fn get_minutes_played_this_week(&self) -> u32 {
        self.minutes_played_this_week.unwrap_or(0)
    }
    pub fn clear_minutes_played_this_week(&mut self) {
        self.minutes_played_this_week = ::std::option::Option::None;
    }

    pub fn has_minutes_played_this_week(&self) -> bool {
        self.minutes_played_this_week.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_this_week(&mut self, v: u32) {
        self.minutes_played_this_week = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_two_weeks = 3;


    pub fn get_minutes_played_two_weeks(&self) -> u32 {
        self.minutes_played_two_weeks.unwrap_or(0)
    }
    pub fn clear_minutes_played_two_weeks(&mut self) {
        self.minutes_played_two_weeks = ::std::option::Option::None;
    }

    pub fn has_minutes_played_two_weeks(&self) -> bool {
        self.minutes_played_two_weeks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_two_weeks(&mut self, v: u32) {
        self.minutes_played_two_weeks = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_forever = 4;


    pub fn get_minutes_played_forever(&self) -> u32 {
        self.minutes_played_forever.unwrap_or(0)
    }
    pub fn clear_minutes_played_forever(&mut self) {
        self.minutes_played_forever = ::std::option::Option::None;
    }

    pub fn has_minutes_played_forever(&self) -> bool {
        self.minutes_played_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_forever(&mut self, v: u32) {
        self.minutes_played_forever = ::std::option::Option::Some(v);
    }

    // optional uint32 event_count = 5;


    pub fn get_event_count(&self) -> u32 {
        self.event_count.unwrap_or(0)
    }
    pub fn clear_event_count(&mut self) {
        self.event_count = ::std::option::Option::None;
    }

    pub fn has_event_count(&self) -> bool {
        self.event_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_count(&mut self, v: u32) {
        self.event_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_this_week = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_two_weeks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_forever = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.minutes_played_this_week {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_two_weeks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_forever {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.minutes_played_this_week {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minutes_played_two_weeks {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.minutes_played_forever {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_count {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.steamid },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minutes_played_this_week",
                |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.minutes_played_this_week },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.minutes_played_this_week },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minutes_played_two_weeks",
                |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.minutes_played_two_weeks },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.minutes_played_two_weeks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minutes_played_forever",
                |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.minutes_played_forever },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.minutes_played_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_count",
                |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.event_count },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.event_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>(
                "CPlayer_GetFriendsAppsActivity_Response.FriendPlayTime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.minutes_played_this_week = ::std::option::Option::None;
        self.minutes_played_two_weeks = ::std::option::Option::None;
        self.minutes_played_forever = ::std::option::Option::None;
        self.event_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    // message fields
    appid: ::std::option::Option<u32>,
    pub friends: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>,
    display_order: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        <CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.FriendPlayTime friends = 2;


    pub fn get_friends(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime] {
        &self.friends
    }
    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }

    // optional uint32 display_order = 3;


    pub fn get_display_order(&self) -> u32 {
        self.display_order.unwrap_or(0)
    }
    pub fn clear_display_order(&mut self) {
        self.display_order = ::std::option::Option::None;
    }

    pub fn has_display_order(&self) -> bool {
        self.display_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_order(&mut self, v: u32) {
        self.display_order = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.display_order = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.display_order {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.display_order {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &m.appid },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>>(
                "friends",
                |m: &CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &m.friends },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &mut m.friends },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "display_order",
                |m: &CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &m.display_order },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &mut m.display_order },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>(
                "CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.friends.clear();
        self.display_order = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetGameBadgeLevels_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Request {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Request {
        <CPlayer_GetGameBadgeLevels_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Request {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Request {
        CPlayer_GetGameBadgeLevels_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetGameBadgeLevels_Request| { &m.appid },
                |m: &mut CPlayer_GetGameBadgeLevels_Request| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetGameBadgeLevels_Request>(
                "CPlayer_GetGameBadgeLevels_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetGameBadgeLevels_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetGameBadgeLevels_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetGameBadgeLevels_Response {
    // message fields
    player_level: ::std::option::Option<u32>,
    pub badges: ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Response {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Response {
        <CPlayer_GetGameBadgeLevels_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Response {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Response {
        ::std::default::Default::default()
    }

    // optional uint32 player_level = 1;


    pub fn get_player_level(&self) -> u32 {
        self.player_level.unwrap_or(0)
    }
    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: u32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // repeated .CPlayer_GetGameBadgeLevels_Response.Badge badges = 2;


    pub fn get_badges(&self) -> &[CPlayer_GetGameBadgeLevels_Response_Badge] {
        &self.badges
    }
    pub fn clear_badges(&mut self) {
        self.badges.clear();
    }

    // Param is passed by value, moved
    pub fn set_badges(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge>) {
        self.badges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_badges(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge> {
        &mut self.badges
    }

    // Take field
    pub fn take_badges(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge> {
        ::std::mem::replace(&mut self.badges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.badges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.badges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.badges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.badges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Response {
        CPlayer_GetGameBadgeLevels_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "player_level",
                |m: &CPlayer_GetGameBadgeLevels_Response| { &m.player_level },
                |m: &mut CPlayer_GetGameBadgeLevels_Response| { &mut m.player_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetGameBadgeLevels_Response_Badge>>(
                "badges",
                |m: &CPlayer_GetGameBadgeLevels_Response| { &m.badges },
                |m: &mut CPlayer_GetGameBadgeLevels_Response| { &mut m.badges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetGameBadgeLevels_Response>(
                "CPlayer_GetGameBadgeLevels_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetGameBadgeLevels_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetGameBadgeLevels_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Response {
    fn clear(&mut self) {
        self.player_level = ::std::option::Option::None;
        self.badges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetGameBadgeLevels_Response_Badge {
    // message fields
    level: ::std::option::Option<i32>,
    series: ::std::option::Option<i32>,
    border_color: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Response_Badge {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Response_Badge {
        <CPlayer_GetGameBadgeLevels_Response_Badge as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Response_Badge {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Response_Badge {
        ::std::default::Default::default()
    }

    // optional int32 level = 1;


    pub fn get_level(&self) -> i32 {
        self.level.unwrap_or(0)
    }
    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional int32 series = 2;


    pub fn get_series(&self) -> i32 {
        self.series.unwrap_or(0)
    }
    pub fn clear_series(&mut self) {
        self.series = ::std::option::Option::None;
    }

    pub fn has_series(&self) -> bool {
        self.series.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: i32) {
        self.series = ::std::option::Option::Some(v);
    }

    // optional uint32 border_color = 3;


    pub fn get_border_color(&self) -> u32 {
        self.border_color.unwrap_or(0)
    }
    pub fn clear_border_color(&mut self) {
        self.border_color = ::std::option::Option::None;
    }

    pub fn has_border_color(&self) -> bool {
        self.border_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_border_color(&mut self, v: u32) {
        self.border_color = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.series = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.border_color = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.border_color {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.level {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.series {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.border_color {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Response_Badge {
        CPlayer_GetGameBadgeLevels_Response_Badge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "level",
                |m: &CPlayer_GetGameBadgeLevels_Response_Badge| { &m.level },
                |m: &mut CPlayer_GetGameBadgeLevels_Response_Badge| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "series",
                |m: &CPlayer_GetGameBadgeLevels_Response_Badge| { &m.series },
                |m: &mut CPlayer_GetGameBadgeLevels_Response_Badge| { &mut m.series },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "border_color",
                |m: &CPlayer_GetGameBadgeLevels_Response_Badge| { &m.border_color },
                |m: &mut CPlayer_GetGameBadgeLevels_Response_Badge| { &mut m.border_color },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetGameBadgeLevels_Response_Badge>(
                "CPlayer_GetGameBadgeLevels_Response.Badge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Response_Badge {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetGameBadgeLevels_Response_Badge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetGameBadgeLevels_Response_Badge::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn clear(&mut self) {
        self.level = ::std::option::Option::None;
        self.series = ::std::option::Option::None;
        self.border_color = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileBackground_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileBackground_Request {
    fn default() -> &'a CPlayer_GetProfileBackground_Request {
        <CPlayer_GetProfileBackground_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileBackground_Request {
    pub fn new() -> CPlayer_GetProfileBackground_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileBackground_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileBackground_Request {
        CPlayer_GetProfileBackground_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetProfileBackground_Request| { &m.steamid },
                |m: &mut CPlayer_GetProfileBackground_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CPlayer_GetProfileBackground_Request| { &m.language },
                |m: &mut CPlayer_GetProfileBackground_Request| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileBackground_Request>(
                "CPlayer_GetProfileBackground_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileBackground_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileBackground_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileBackground_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileBackground_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileBackground_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileBackground_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProfileItem {
    // message fields
    communityitemid: ::std::option::Option<u64>,
    image_small: ::protobuf::SingularField<::std::string::String>,
    image_large: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    item_title: ::protobuf::SingularField<::std::string::String>,
    item_description: ::protobuf::SingularField<::std::string::String>,
    appid: ::std::option::Option<u32>,
    item_type: ::std::option::Option<u32>,
    item_class: ::std::option::Option<u32>,
    movie_webm: ::protobuf::SingularField<::std::string::String>,
    movie_mp4: ::protobuf::SingularField<::std::string::String>,
    movie_webm_small: ::protobuf::SingularField<::std::string::String>,
    movie_mp4_small: ::protobuf::SingularField<::std::string::String>,
    equipped_flags: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfileItem {
    fn default() -> &'a ProfileItem {
        <ProfileItem as ::protobuf::Message>::default_instance()
    }
}

impl ProfileItem {
    pub fn new() -> ProfileItem {
        ::std::default::Default::default()
    }

    // optional uint64 communityitemid = 1;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }

    // optional string image_small = 2;


    pub fn get_image_small(&self) -> &str {
        match self.image_small.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image_small(&mut self) {
        self.image_small.clear();
    }

    pub fn has_image_small(&self) -> bool {
        self.image_small.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_small(&mut self, v: ::std::string::String) {
        self.image_small = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_small(&mut self) -> &mut ::std::string::String {
        if self.image_small.is_none() {
            self.image_small.set_default();
        }
        self.image_small.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_small(&mut self) -> ::std::string::String {
        self.image_small.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image_large = 3;


    pub fn get_image_large(&self) -> &str {
        match self.image_large.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image_large(&mut self) {
        self.image_large.clear();
    }

    pub fn has_image_large(&self) -> bool {
        self.image_large.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_large(&mut self, v: ::std::string::String) {
        self.image_large = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_large(&mut self) -> &mut ::std::string::String {
        if self.image_large.is_none() {
            self.image_large.set_default();
        }
        self.image_large.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_large(&mut self) -> ::std::string::String {
        self.image_large.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 4;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string item_title = 5;


    pub fn get_item_title(&self) -> &str {
        match self.item_title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item_title(&mut self) {
        self.item_title.clear();
    }

    pub fn has_item_title(&self) -> bool {
        self.item_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_title(&mut self, v: ::std::string::String) {
        self.item_title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_title(&mut self) -> &mut ::std::string::String {
        if self.item_title.is_none() {
            self.item_title.set_default();
        }
        self.item_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_title(&mut self) -> ::std::string::String {
        self.item_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string item_description = 6;


    pub fn get_item_description(&self) -> &str {
        match self.item_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item_description(&mut self) {
        self.item_description.clear();
    }

    pub fn has_item_description(&self) -> bool {
        self.item_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_description(&mut self, v: ::std::string::String) {
        self.item_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
        if self.item_description.is_none() {
            self.item_description.set_default();
        }
        self.item_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_description(&mut self) -> ::std::string::String {
        self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 7;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 8;


    pub fn get_item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }
    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional uint32 item_class = 9;


    pub fn get_item_class(&self) -> u32 {
        self.item_class.unwrap_or(0)
    }
    pub fn clear_item_class(&mut self) {
        self.item_class = ::std::option::Option::None;
    }

    pub fn has_item_class(&self) -> bool {
        self.item_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_class(&mut self, v: u32) {
        self.item_class = ::std::option::Option::Some(v);
    }

    // optional string movie_webm = 10;


    pub fn get_movie_webm(&self) -> &str {
        match self.movie_webm.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_movie_webm(&mut self) {
        self.movie_webm.clear();
    }

    pub fn has_movie_webm(&self) -> bool {
        self.movie_webm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movie_webm(&mut self, v: ::std::string::String) {
        self.movie_webm = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movie_webm(&mut self) -> &mut ::std::string::String {
        if self.movie_webm.is_none() {
            self.movie_webm.set_default();
        }
        self.movie_webm.as_mut().unwrap()
    }

    // Take field
    pub fn take_movie_webm(&mut self) -> ::std::string::String {
        self.movie_webm.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string movie_mp4 = 11;


    pub fn get_movie_mp4(&self) -> &str {
        match self.movie_mp4.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_movie_mp4(&mut self) {
        self.movie_mp4.clear();
    }

    pub fn has_movie_mp4(&self) -> bool {
        self.movie_mp4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movie_mp4(&mut self, v: ::std::string::String) {
        self.movie_mp4 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movie_mp4(&mut self) -> &mut ::std::string::String {
        if self.movie_mp4.is_none() {
            self.movie_mp4.set_default();
        }
        self.movie_mp4.as_mut().unwrap()
    }

    // Take field
    pub fn take_movie_mp4(&mut self) -> ::std::string::String {
        self.movie_mp4.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string movie_webm_small = 13;


    pub fn get_movie_webm_small(&self) -> &str {
        match self.movie_webm_small.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_movie_webm_small(&mut self) {
        self.movie_webm_small.clear();
    }

    pub fn has_movie_webm_small(&self) -> bool {
        self.movie_webm_small.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movie_webm_small(&mut self, v: ::std::string::String) {
        self.movie_webm_small = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movie_webm_small(&mut self) -> &mut ::std::string::String {
        if self.movie_webm_small.is_none() {
            self.movie_webm_small.set_default();
        }
        self.movie_webm_small.as_mut().unwrap()
    }

    // Take field
    pub fn take_movie_webm_small(&mut self) -> ::std::string::String {
        self.movie_webm_small.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string movie_mp4_small = 14;


    pub fn get_movie_mp4_small(&self) -> &str {
        match self.movie_mp4_small.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_movie_mp4_small(&mut self) {
        self.movie_mp4_small.clear();
    }

    pub fn has_movie_mp4_small(&self) -> bool {
        self.movie_mp4_small.is_some()
    }

    // Param is passed by value, moved
    pub fn set_movie_mp4_small(&mut self, v: ::std::string::String) {
        self.movie_mp4_small = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_movie_mp4_small(&mut self) -> &mut ::std::string::String {
        if self.movie_mp4_small.is_none() {
            self.movie_mp4_small.set_default();
        }
        self.movie_mp4_small.as_mut().unwrap()
    }

    // Take field
    pub fn take_movie_mp4_small(&mut self) -> ::std::string::String {
        self.movie_mp4_small.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 equipped_flags = 12;


    pub fn get_equipped_flags(&self) -> u32 {
        self.equipped_flags.unwrap_or(0)
    }
    pub fn clear_equipped_flags(&mut self) {
        self.equipped_flags = ::std::option::Option::None;
    }

    pub fn has_equipped_flags(&self) -> bool {
        self.equipped_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equipped_flags(&mut self, v: u32) {
        self.equipped_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ProfileItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image_small)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image_large)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_description)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_class = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.movie_webm)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.movie_mp4)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.movie_webm_small)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.movie_mp4_small)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.equipped_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image_small.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.image_large.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.item_title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.item_description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_class {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.movie_webm.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.movie_mp4.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.movie_webm_small.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.movie_mp4_small.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.equipped_flags {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.communityitemid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.image_small.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.image_large.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.item_title.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.item_description.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.item_class {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.movie_webm.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.movie_mp4.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.movie_webm_small.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.movie_mp4_small.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.equipped_flags {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfileItem {
        ProfileItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &ProfileItem| { &m.communityitemid },
                |m: &mut ProfileItem| { &mut m.communityitemid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_small",
                |m: &ProfileItem| { &m.image_small },
                |m: &mut ProfileItem| { &mut m.image_small },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_large",
                |m: &ProfileItem| { &m.image_large },
                |m: &mut ProfileItem| { &mut m.image_large },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ProfileItem| { &m.name },
                |m: &mut ProfileItem| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_title",
                |m: &ProfileItem| { &m.item_title },
                |m: &mut ProfileItem| { &mut m.item_title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_description",
                |m: &ProfileItem| { &m.item_description },
                |m: &mut ProfileItem| { &mut m.item_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &ProfileItem| { &m.appid },
                |m: &mut ProfileItem| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_type",
                |m: &ProfileItem| { &m.item_type },
                |m: &mut ProfileItem| { &mut m.item_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_class",
                |m: &ProfileItem| { &m.item_class },
                |m: &mut ProfileItem| { &mut m.item_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "movie_webm",
                |m: &ProfileItem| { &m.movie_webm },
                |m: &mut ProfileItem| { &mut m.movie_webm },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "movie_mp4",
                |m: &ProfileItem| { &m.movie_mp4 },
                |m: &mut ProfileItem| { &mut m.movie_mp4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "movie_webm_small",
                |m: &ProfileItem| { &m.movie_webm_small },
                |m: &mut ProfileItem| { &mut m.movie_webm_small },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "movie_mp4_small",
                |m: &ProfileItem| { &m.movie_mp4_small },
                |m: &mut ProfileItem| { &mut m.movie_mp4_small },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "equipped_flags",
                |m: &ProfileItem| { &m.equipped_flags },
                |m: &mut ProfileItem| { &mut m.equipped_flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfileItem>(
                "ProfileItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfileItem {
        static instance: ::protobuf::rt::LazyV2<ProfileItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfileItem::new)
    }
}

impl ::protobuf::Clear for ProfileItem {
    fn clear(&mut self) {
        self.communityitemid = ::std::option::Option::None;
        self.image_small.clear();
        self.image_large.clear();
        self.name.clear();
        self.item_title.clear();
        self.item_description.clear();
        self.appid = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.item_class = ::std::option::Option::None;
        self.movie_webm.clear();
        self.movie_mp4.clear();
        self.movie_webm_small.clear();
        self.movie_mp4_small.clear();
        self.equipped_flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfileItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileBackground_Response {
    // message fields
    pub profile_background: ::protobuf::SingularPtrField<ProfileItem>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileBackground_Response {
    fn default() -> &'a CPlayer_GetProfileBackground_Response {
        <CPlayer_GetProfileBackground_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileBackground_Response {
    pub fn new() -> CPlayer_GetProfileBackground_Response {
        ::std::default::Default::default()
    }

    // optional .ProfileItem profile_background = 1;


    pub fn get_profile_background(&self) -> &ProfileItem {
        self.profile_background.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile_background(&mut self) {
        self.profile_background.clear();
    }

    pub fn has_profile_background(&self) -> bool {
        self.profile_background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_background(&mut self, v: ProfileItem) {
        self.profile_background = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_background(&mut self) -> &mut ProfileItem {
        if self.profile_background.is_none() {
            self.profile_background.set_default();
        }
        self.profile_background.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_background(&mut self) -> ProfileItem {
        self.profile_background.take().unwrap_or_else(|| ProfileItem::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileBackground_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.profile_background {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile_background)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.profile_background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.profile_background.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileBackground_Response {
        CPlayer_GetProfileBackground_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "profile_background",
                |m: &CPlayer_GetProfileBackground_Response| { &m.profile_background },
                |m: &mut CPlayer_GetProfileBackground_Response| { &mut m.profile_background },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileBackground_Response>(
                "CPlayer_GetProfileBackground_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileBackground_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileBackground_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileBackground_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileBackground_Response {
    fn clear(&mut self) {
        self.profile_background.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileBackground_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileBackground_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetProfileBackground_Request {
    // message fields
    communityitemid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetProfileBackground_Request {
    fn default() -> &'a CPlayer_SetProfileBackground_Request {
        <CPlayer_SetProfileBackground_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetProfileBackground_Request {
    pub fn new() -> CPlayer_SetProfileBackground_Request {
        ::std::default::Default::default()
    }

    // optional uint64 communityitemid = 1;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_SetProfileBackground_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.communityitemid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetProfileBackground_Request {
        CPlayer_SetProfileBackground_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &CPlayer_SetProfileBackground_Request| { &m.communityitemid },
                |m: &mut CPlayer_SetProfileBackground_Request| { &mut m.communityitemid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetProfileBackground_Request>(
                "CPlayer_SetProfileBackground_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetProfileBackground_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetProfileBackground_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetProfileBackground_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetProfileBackground_Request {
    fn clear(&mut self) {
        self.communityitemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetProfileBackground_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetProfileBackground_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetProfileBackground_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetProfileBackground_Response {
    fn default() -> &'a CPlayer_SetProfileBackground_Response {
        <CPlayer_SetProfileBackground_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetProfileBackground_Response {
    pub fn new() -> CPlayer_SetProfileBackground_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetProfileBackground_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetProfileBackground_Response {
        CPlayer_SetProfileBackground_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetProfileBackground_Response>(
                "CPlayer_SetProfileBackground_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetProfileBackground_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetProfileBackground_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetProfileBackground_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetProfileBackground_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetProfileBackground_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetProfileBackground_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetMiniProfileBackground_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMiniProfileBackground_Request {
    fn default() -> &'a CPlayer_GetMiniProfileBackground_Request {
        <CPlayer_GetMiniProfileBackground_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMiniProfileBackground_Request {
    pub fn new() -> CPlayer_GetMiniProfileBackground_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetMiniProfileBackground_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMiniProfileBackground_Request {
        CPlayer_GetMiniProfileBackground_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetMiniProfileBackground_Request| { &m.steamid },
                |m: &mut CPlayer_GetMiniProfileBackground_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CPlayer_GetMiniProfileBackground_Request| { &m.language },
                |m: &mut CPlayer_GetMiniProfileBackground_Request| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetMiniProfileBackground_Request>(
                "CPlayer_GetMiniProfileBackground_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetMiniProfileBackground_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetMiniProfileBackground_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetMiniProfileBackground_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetMiniProfileBackground_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMiniProfileBackground_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMiniProfileBackground_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetMiniProfileBackground_Response {
    // message fields
    pub profile_background: ::protobuf::SingularPtrField<ProfileItem>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMiniProfileBackground_Response {
    fn default() -> &'a CPlayer_GetMiniProfileBackground_Response {
        <CPlayer_GetMiniProfileBackground_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMiniProfileBackground_Response {
    pub fn new() -> CPlayer_GetMiniProfileBackground_Response {
        ::std::default::Default::default()
    }

    // optional .ProfileItem profile_background = 1;


    pub fn get_profile_background(&self) -> &ProfileItem {
        self.profile_background.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile_background(&mut self) {
        self.profile_background.clear();
    }

    pub fn has_profile_background(&self) -> bool {
        self.profile_background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_background(&mut self, v: ProfileItem) {
        self.profile_background = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_background(&mut self) -> &mut ProfileItem {
        if self.profile_background.is_none() {
            self.profile_background.set_default();
        }
        self.profile_background.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_background(&mut self) -> ProfileItem {
        self.profile_background.take().unwrap_or_else(|| ProfileItem::new())
    }
}

impl ::protobuf::Message for CPlayer_GetMiniProfileBackground_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.profile_background {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile_background)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.profile_background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.profile_background.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMiniProfileBackground_Response {
        CPlayer_GetMiniProfileBackground_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "profile_background",
                |m: &CPlayer_GetMiniProfileBackground_Response| { &m.profile_background },
                |m: &mut CPlayer_GetMiniProfileBackground_Response| { &mut m.profile_background },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetMiniProfileBackground_Response>(
                "CPlayer_GetMiniProfileBackground_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetMiniProfileBackground_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetMiniProfileBackground_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetMiniProfileBackground_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetMiniProfileBackground_Response {
    fn clear(&mut self) {
        self.profile_background.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMiniProfileBackground_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMiniProfileBackground_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetMiniProfileBackground_Request {
    // message fields
    communityitemid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetMiniProfileBackground_Request {
    fn default() -> &'a CPlayer_SetMiniProfileBackground_Request {
        <CPlayer_SetMiniProfileBackground_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetMiniProfileBackground_Request {
    pub fn new() -> CPlayer_SetMiniProfileBackground_Request {
        ::std::default::Default::default()
    }

    // optional uint64 communityitemid = 1;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_SetMiniProfileBackground_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.communityitemid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetMiniProfileBackground_Request {
        CPlayer_SetMiniProfileBackground_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &CPlayer_SetMiniProfileBackground_Request| { &m.communityitemid },
                |m: &mut CPlayer_SetMiniProfileBackground_Request| { &mut m.communityitemid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetMiniProfileBackground_Request>(
                "CPlayer_SetMiniProfileBackground_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetMiniProfileBackground_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetMiniProfileBackground_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetMiniProfileBackground_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetMiniProfileBackground_Request {
    fn clear(&mut self) {
        self.communityitemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetMiniProfileBackground_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetMiniProfileBackground_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetMiniProfileBackground_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetMiniProfileBackground_Response {
    fn default() -> &'a CPlayer_SetMiniProfileBackground_Response {
        <CPlayer_SetMiniProfileBackground_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetMiniProfileBackground_Response {
    pub fn new() -> CPlayer_SetMiniProfileBackground_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetMiniProfileBackground_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetMiniProfileBackground_Response {
        CPlayer_SetMiniProfileBackground_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetMiniProfileBackground_Response>(
                "CPlayer_SetMiniProfileBackground_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetMiniProfileBackground_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetMiniProfileBackground_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetMiniProfileBackground_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetMiniProfileBackground_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetMiniProfileBackground_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetMiniProfileBackground_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetAvatarFrame_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAvatarFrame_Request {
    fn default() -> &'a CPlayer_GetAvatarFrame_Request {
        <CPlayer_GetAvatarFrame_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAvatarFrame_Request {
    pub fn new() -> CPlayer_GetAvatarFrame_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetAvatarFrame_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAvatarFrame_Request {
        CPlayer_GetAvatarFrame_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetAvatarFrame_Request| { &m.steamid },
                |m: &mut CPlayer_GetAvatarFrame_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CPlayer_GetAvatarFrame_Request| { &m.language },
                |m: &mut CPlayer_GetAvatarFrame_Request| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetAvatarFrame_Request>(
                "CPlayer_GetAvatarFrame_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAvatarFrame_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetAvatarFrame_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetAvatarFrame_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAvatarFrame_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAvatarFrame_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAvatarFrame_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetAvatarFrame_Response {
    // message fields
    pub avatar_frame: ::protobuf::SingularPtrField<ProfileItem>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAvatarFrame_Response {
    fn default() -> &'a CPlayer_GetAvatarFrame_Response {
        <CPlayer_GetAvatarFrame_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAvatarFrame_Response {
    pub fn new() -> CPlayer_GetAvatarFrame_Response {
        ::std::default::Default::default()
    }

    // optional .ProfileItem avatar_frame = 1;


    pub fn get_avatar_frame(&self) -> &ProfileItem {
        self.avatar_frame.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar_frame(&mut self) {
        self.avatar_frame.clear();
    }

    pub fn has_avatar_frame(&self) -> bool {
        self.avatar_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_frame(&mut self, v: ProfileItem) {
        self.avatar_frame = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_frame(&mut self) -> &mut ProfileItem {
        if self.avatar_frame.is_none() {
            self.avatar_frame.set_default();
        }
        self.avatar_frame.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_frame(&mut self) -> ProfileItem {
        self.avatar_frame.take().unwrap_or_else(|| ProfileItem::new())
    }
}

impl ::protobuf::Message for CPlayer_GetAvatarFrame_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.avatar_frame {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar_frame)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.avatar_frame.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.avatar_frame.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAvatarFrame_Response {
        CPlayer_GetAvatarFrame_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "avatar_frame",
                |m: &CPlayer_GetAvatarFrame_Response| { &m.avatar_frame },
                |m: &mut CPlayer_GetAvatarFrame_Response| { &mut m.avatar_frame },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetAvatarFrame_Response>(
                "CPlayer_GetAvatarFrame_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAvatarFrame_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetAvatarFrame_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetAvatarFrame_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAvatarFrame_Response {
    fn clear(&mut self) {
        self.avatar_frame.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAvatarFrame_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAvatarFrame_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetAvatarFrame_Request {
    // message fields
    communityitemid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetAvatarFrame_Request {
    fn default() -> &'a CPlayer_SetAvatarFrame_Request {
        <CPlayer_SetAvatarFrame_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetAvatarFrame_Request {
    pub fn new() -> CPlayer_SetAvatarFrame_Request {
        ::std::default::Default::default()
    }

    // optional uint64 communityitemid = 1;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_SetAvatarFrame_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.communityitemid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetAvatarFrame_Request {
        CPlayer_SetAvatarFrame_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &CPlayer_SetAvatarFrame_Request| { &m.communityitemid },
                |m: &mut CPlayer_SetAvatarFrame_Request| { &mut m.communityitemid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetAvatarFrame_Request>(
                "CPlayer_SetAvatarFrame_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetAvatarFrame_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetAvatarFrame_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetAvatarFrame_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetAvatarFrame_Request {
    fn clear(&mut self) {
        self.communityitemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetAvatarFrame_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetAvatarFrame_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetAvatarFrame_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetAvatarFrame_Response {
    fn default() -> &'a CPlayer_SetAvatarFrame_Response {
        <CPlayer_SetAvatarFrame_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetAvatarFrame_Response {
    pub fn new() -> CPlayer_SetAvatarFrame_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetAvatarFrame_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetAvatarFrame_Response {
        CPlayer_SetAvatarFrame_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetAvatarFrame_Response>(
                "CPlayer_SetAvatarFrame_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetAvatarFrame_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetAvatarFrame_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetAvatarFrame_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetAvatarFrame_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetAvatarFrame_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetAvatarFrame_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetAnimatedAvatar_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAnimatedAvatar_Request {
    fn default() -> &'a CPlayer_GetAnimatedAvatar_Request {
        <CPlayer_GetAnimatedAvatar_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAnimatedAvatar_Request {
    pub fn new() -> CPlayer_GetAnimatedAvatar_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetAnimatedAvatar_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAnimatedAvatar_Request {
        CPlayer_GetAnimatedAvatar_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetAnimatedAvatar_Request| { &m.steamid },
                |m: &mut CPlayer_GetAnimatedAvatar_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CPlayer_GetAnimatedAvatar_Request| { &m.language },
                |m: &mut CPlayer_GetAnimatedAvatar_Request| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetAnimatedAvatar_Request>(
                "CPlayer_GetAnimatedAvatar_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAnimatedAvatar_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetAnimatedAvatar_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetAnimatedAvatar_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAnimatedAvatar_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAnimatedAvatar_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAnimatedAvatar_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetAnimatedAvatar_Response {
    // message fields
    pub avatar: ::protobuf::SingularPtrField<ProfileItem>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAnimatedAvatar_Response {
    fn default() -> &'a CPlayer_GetAnimatedAvatar_Response {
        <CPlayer_GetAnimatedAvatar_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAnimatedAvatar_Response {
    pub fn new() -> CPlayer_GetAnimatedAvatar_Response {
        ::std::default::Default::default()
    }

    // optional .ProfileItem avatar = 1;


    pub fn get_avatar(&self) -> &ProfileItem {
        self.avatar.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar(&mut self) {
        self.avatar.clear();
    }

    pub fn has_avatar(&self) -> bool {
        self.avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar(&mut self, v: ProfileItem) {
        self.avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar(&mut self) -> &mut ProfileItem {
        if self.avatar.is_none() {
            self.avatar.set_default();
        }
        self.avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar(&mut self) -> ProfileItem {
        self.avatar.take().unwrap_or_else(|| ProfileItem::new())
    }
}

impl ::protobuf::Message for CPlayer_GetAnimatedAvatar_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.avatar.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAnimatedAvatar_Response {
        CPlayer_GetAnimatedAvatar_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "avatar",
                |m: &CPlayer_GetAnimatedAvatar_Response| { &m.avatar },
                |m: &mut CPlayer_GetAnimatedAvatar_Response| { &mut m.avatar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetAnimatedAvatar_Response>(
                "CPlayer_GetAnimatedAvatar_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAnimatedAvatar_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetAnimatedAvatar_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetAnimatedAvatar_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAnimatedAvatar_Response {
    fn clear(&mut self) {
        self.avatar.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAnimatedAvatar_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAnimatedAvatar_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetAnimatedAvatar_Request {
    // message fields
    communityitemid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetAnimatedAvatar_Request {
    fn default() -> &'a CPlayer_SetAnimatedAvatar_Request {
        <CPlayer_SetAnimatedAvatar_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetAnimatedAvatar_Request {
    pub fn new() -> CPlayer_SetAnimatedAvatar_Request {
        ::std::default::Default::default()
    }

    // optional uint64 communityitemid = 1;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_SetAnimatedAvatar_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.communityitemid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetAnimatedAvatar_Request {
        CPlayer_SetAnimatedAvatar_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &CPlayer_SetAnimatedAvatar_Request| { &m.communityitemid },
                |m: &mut CPlayer_SetAnimatedAvatar_Request| { &mut m.communityitemid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetAnimatedAvatar_Request>(
                "CPlayer_SetAnimatedAvatar_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetAnimatedAvatar_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetAnimatedAvatar_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetAnimatedAvatar_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetAnimatedAvatar_Request {
    fn clear(&mut self) {
        self.communityitemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetAnimatedAvatar_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetAnimatedAvatar_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetAnimatedAvatar_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetAnimatedAvatar_Response {
    fn default() -> &'a CPlayer_SetAnimatedAvatar_Response {
        <CPlayer_SetAnimatedAvatar_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetAnimatedAvatar_Response {
    pub fn new() -> CPlayer_SetAnimatedAvatar_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetAnimatedAvatar_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetAnimatedAvatar_Response {
        CPlayer_SetAnimatedAvatar_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetAnimatedAvatar_Response>(
                "CPlayer_SetAnimatedAvatar_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetAnimatedAvatar_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetAnimatedAvatar_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetAnimatedAvatar_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetAnimatedAvatar_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetAnimatedAvatar_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetAnimatedAvatar_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileItemsOwned_Request {
    // message fields
    language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileItemsOwned_Request {
    fn default() -> &'a CPlayer_GetProfileItemsOwned_Request {
        <CPlayer_GetProfileItemsOwned_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileItemsOwned_Request {
    pub fn new() -> CPlayer_GetProfileItemsOwned_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileItemsOwned_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileItemsOwned_Request {
        CPlayer_GetProfileItemsOwned_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CPlayer_GetProfileItemsOwned_Request| { &m.language },
                |m: &mut CPlayer_GetProfileItemsOwned_Request| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileItemsOwned_Request>(
                "CPlayer_GetProfileItemsOwned_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileItemsOwned_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileItemsOwned_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileItemsOwned_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileItemsOwned_Request {
    fn clear(&mut self) {
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileItemsOwned_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileItemsOwned_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileItemsOwned_Response {
    // message fields
    pub profile_backgrounds: ::protobuf::RepeatedField<ProfileItem>,
    pub mini_profile_backgrounds: ::protobuf::RepeatedField<ProfileItem>,
    pub avatar_frames: ::protobuf::RepeatedField<ProfileItem>,
    pub animated_avatars: ::protobuf::RepeatedField<ProfileItem>,
    pub profile_modifiers: ::protobuf::RepeatedField<ProfileItem>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileItemsOwned_Response {
    fn default() -> &'a CPlayer_GetProfileItemsOwned_Response {
        <CPlayer_GetProfileItemsOwned_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileItemsOwned_Response {
    pub fn new() -> CPlayer_GetProfileItemsOwned_Response {
        ::std::default::Default::default()
    }

    // repeated .ProfileItem profile_backgrounds = 1;


    pub fn get_profile_backgrounds(&self) -> &[ProfileItem] {
        &self.profile_backgrounds
    }
    pub fn clear_profile_backgrounds(&mut self) {
        self.profile_backgrounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile_backgrounds(&mut self, v: ::protobuf::RepeatedField<ProfileItem>) {
        self.profile_backgrounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profile_backgrounds(&mut self) -> &mut ::protobuf::RepeatedField<ProfileItem> {
        &mut self.profile_backgrounds
    }

    // Take field
    pub fn take_profile_backgrounds(&mut self) -> ::protobuf::RepeatedField<ProfileItem> {
        ::std::mem::replace(&mut self.profile_backgrounds, ::protobuf::RepeatedField::new())
    }

    // repeated .ProfileItem mini_profile_backgrounds = 2;


    pub fn get_mini_profile_backgrounds(&self) -> &[ProfileItem] {
        &self.mini_profile_backgrounds
    }
    pub fn clear_mini_profile_backgrounds(&mut self) {
        self.mini_profile_backgrounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_mini_profile_backgrounds(&mut self, v: ::protobuf::RepeatedField<ProfileItem>) {
        self.mini_profile_backgrounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mini_profile_backgrounds(&mut self) -> &mut ::protobuf::RepeatedField<ProfileItem> {
        &mut self.mini_profile_backgrounds
    }

    // Take field
    pub fn take_mini_profile_backgrounds(&mut self) -> ::protobuf::RepeatedField<ProfileItem> {
        ::std::mem::replace(&mut self.mini_profile_backgrounds, ::protobuf::RepeatedField::new())
    }

    // repeated .ProfileItem avatar_frames = 3;


    pub fn get_avatar_frames(&self) -> &[ProfileItem] {
        &self.avatar_frames
    }
    pub fn clear_avatar_frames(&mut self) {
        self.avatar_frames.clear();
    }

    // Param is passed by value, moved
    pub fn set_avatar_frames(&mut self, v: ::protobuf::RepeatedField<ProfileItem>) {
        self.avatar_frames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_avatar_frames(&mut self) -> &mut ::protobuf::RepeatedField<ProfileItem> {
        &mut self.avatar_frames
    }

    // Take field
    pub fn take_avatar_frames(&mut self) -> ::protobuf::RepeatedField<ProfileItem> {
        ::std::mem::replace(&mut self.avatar_frames, ::protobuf::RepeatedField::new())
    }

    // repeated .ProfileItem animated_avatars = 4;


    pub fn get_animated_avatars(&self) -> &[ProfileItem] {
        &self.animated_avatars
    }
    pub fn clear_animated_avatars(&mut self) {
        self.animated_avatars.clear();
    }

    // Param is passed by value, moved
    pub fn set_animated_avatars(&mut self, v: ::protobuf::RepeatedField<ProfileItem>) {
        self.animated_avatars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_animated_avatars(&mut self) -> &mut ::protobuf::RepeatedField<ProfileItem> {
        &mut self.animated_avatars
    }

    // Take field
    pub fn take_animated_avatars(&mut self) -> ::protobuf::RepeatedField<ProfileItem> {
        ::std::mem::replace(&mut self.animated_avatars, ::protobuf::RepeatedField::new())
    }

    // repeated .ProfileItem profile_modifiers = 5;


    pub fn get_profile_modifiers(&self) -> &[ProfileItem] {
        &self.profile_modifiers
    }
    pub fn clear_profile_modifiers(&mut self) {
        self.profile_modifiers.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile_modifiers(&mut self, v: ::protobuf::RepeatedField<ProfileItem>) {
        self.profile_modifiers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profile_modifiers(&mut self) -> &mut ::protobuf::RepeatedField<ProfileItem> {
        &mut self.profile_modifiers
    }

    // Take field
    pub fn take_profile_modifiers(&mut self) -> ::protobuf::RepeatedField<ProfileItem> {
        ::std::mem::replace(&mut self.profile_modifiers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileItemsOwned_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.profile_backgrounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mini_profile_backgrounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar_frames {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animated_avatars {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile_modifiers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profile_backgrounds)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mini_profile_backgrounds)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.avatar_frames)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.animated_avatars)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profile_modifiers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.profile_backgrounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.mini_profile_backgrounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.avatar_frames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.animated_avatars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.profile_modifiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.profile_backgrounds {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.mini_profile_backgrounds {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.avatar_frames {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.animated_avatars {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.profile_modifiers {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileItemsOwned_Response {
        CPlayer_GetProfileItemsOwned_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "profile_backgrounds",
                |m: &CPlayer_GetProfileItemsOwned_Response| { &m.profile_backgrounds },
                |m: &mut CPlayer_GetProfileItemsOwned_Response| { &mut m.profile_backgrounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "mini_profile_backgrounds",
                |m: &CPlayer_GetProfileItemsOwned_Response| { &m.mini_profile_backgrounds },
                |m: &mut CPlayer_GetProfileItemsOwned_Response| { &mut m.mini_profile_backgrounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "avatar_frames",
                |m: &CPlayer_GetProfileItemsOwned_Response| { &m.avatar_frames },
                |m: &mut CPlayer_GetProfileItemsOwned_Response| { &mut m.avatar_frames },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "animated_avatars",
                |m: &CPlayer_GetProfileItemsOwned_Response| { &m.animated_avatars },
                |m: &mut CPlayer_GetProfileItemsOwned_Response| { &mut m.animated_avatars },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "profile_modifiers",
                |m: &CPlayer_GetProfileItemsOwned_Response| { &m.profile_modifiers },
                |m: &mut CPlayer_GetProfileItemsOwned_Response| { &mut m.profile_modifiers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileItemsOwned_Response>(
                "CPlayer_GetProfileItemsOwned_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileItemsOwned_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileItemsOwned_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileItemsOwned_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileItemsOwned_Response {
    fn clear(&mut self) {
        self.profile_backgrounds.clear();
        self.mini_profile_backgrounds.clear();
        self.avatar_frames.clear();
        self.animated_avatars.clear();
        self.profile_modifiers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileItemsOwned_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileItemsOwned_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileItemsEquipped_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileItemsEquipped_Request {
    fn default() -> &'a CPlayer_GetProfileItemsEquipped_Request {
        <CPlayer_GetProfileItemsEquipped_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileItemsEquipped_Request {
    pub fn new() -> CPlayer_GetProfileItemsEquipped_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileItemsEquipped_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileItemsEquipped_Request {
        CPlayer_GetProfileItemsEquipped_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetProfileItemsEquipped_Request| { &m.steamid },
                |m: &mut CPlayer_GetProfileItemsEquipped_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CPlayer_GetProfileItemsEquipped_Request| { &m.language },
                |m: &mut CPlayer_GetProfileItemsEquipped_Request| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileItemsEquipped_Request>(
                "CPlayer_GetProfileItemsEquipped_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileItemsEquipped_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileItemsEquipped_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileItemsEquipped_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileItemsEquipped_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileItemsEquipped_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileItemsEquipped_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileItemsEquipped_Response {
    // message fields
    pub profile_background: ::protobuf::SingularPtrField<ProfileItem>,
    pub mini_profile_background: ::protobuf::SingularPtrField<ProfileItem>,
    pub avatar_frame: ::protobuf::SingularPtrField<ProfileItem>,
    pub animated_avatar: ::protobuf::SingularPtrField<ProfileItem>,
    pub profile_modifier: ::protobuf::SingularPtrField<ProfileItem>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileItemsEquipped_Response {
    fn default() -> &'a CPlayer_GetProfileItemsEquipped_Response {
        <CPlayer_GetProfileItemsEquipped_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileItemsEquipped_Response {
    pub fn new() -> CPlayer_GetProfileItemsEquipped_Response {
        ::std::default::Default::default()
    }

    // optional .ProfileItem profile_background = 1;


    pub fn get_profile_background(&self) -> &ProfileItem {
        self.profile_background.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile_background(&mut self) {
        self.profile_background.clear();
    }

    pub fn has_profile_background(&self) -> bool {
        self.profile_background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_background(&mut self, v: ProfileItem) {
        self.profile_background = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_background(&mut self) -> &mut ProfileItem {
        if self.profile_background.is_none() {
            self.profile_background.set_default();
        }
        self.profile_background.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_background(&mut self) -> ProfileItem {
        self.profile_background.take().unwrap_or_else(|| ProfileItem::new())
    }

    // optional .ProfileItem mini_profile_background = 2;


    pub fn get_mini_profile_background(&self) -> &ProfileItem {
        self.mini_profile_background.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mini_profile_background(&mut self) {
        self.mini_profile_background.clear();
    }

    pub fn has_mini_profile_background(&self) -> bool {
        self.mini_profile_background.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mini_profile_background(&mut self, v: ProfileItem) {
        self.mini_profile_background = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mini_profile_background(&mut self) -> &mut ProfileItem {
        if self.mini_profile_background.is_none() {
            self.mini_profile_background.set_default();
        }
        self.mini_profile_background.as_mut().unwrap()
    }

    // Take field
    pub fn take_mini_profile_background(&mut self) -> ProfileItem {
        self.mini_profile_background.take().unwrap_or_else(|| ProfileItem::new())
    }

    // optional .ProfileItem avatar_frame = 3;


    pub fn get_avatar_frame(&self) -> &ProfileItem {
        self.avatar_frame.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_avatar_frame(&mut self) {
        self.avatar_frame.clear();
    }

    pub fn has_avatar_frame(&self) -> bool {
        self.avatar_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_frame(&mut self, v: ProfileItem) {
        self.avatar_frame = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_frame(&mut self) -> &mut ProfileItem {
        if self.avatar_frame.is_none() {
            self.avatar_frame.set_default();
        }
        self.avatar_frame.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_frame(&mut self) -> ProfileItem {
        self.avatar_frame.take().unwrap_or_else(|| ProfileItem::new())
    }

    // optional .ProfileItem animated_avatar = 4;


    pub fn get_animated_avatar(&self) -> &ProfileItem {
        self.animated_avatar.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_animated_avatar(&mut self) {
        self.animated_avatar.clear();
    }

    pub fn has_animated_avatar(&self) -> bool {
        self.animated_avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_animated_avatar(&mut self, v: ProfileItem) {
        self.animated_avatar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_animated_avatar(&mut self) -> &mut ProfileItem {
        if self.animated_avatar.is_none() {
            self.animated_avatar.set_default();
        }
        self.animated_avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_animated_avatar(&mut self) -> ProfileItem {
        self.animated_avatar.take().unwrap_or_else(|| ProfileItem::new())
    }

    // optional .ProfileItem profile_modifier = 5;


    pub fn get_profile_modifier(&self) -> &ProfileItem {
        self.profile_modifier.as_ref().unwrap_or_else(|| <ProfileItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile_modifier(&mut self) {
        self.profile_modifier.clear();
    }

    pub fn has_profile_modifier(&self) -> bool {
        self.profile_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_modifier(&mut self, v: ProfileItem) {
        self.profile_modifier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_modifier(&mut self) -> &mut ProfileItem {
        if self.profile_modifier.is_none() {
            self.profile_modifier.set_default();
        }
        self.profile_modifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_modifier(&mut self) -> ProfileItem {
        self.profile_modifier.take().unwrap_or_else(|| ProfileItem::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileItemsEquipped_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.profile_background {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mini_profile_background {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.avatar_frame {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.animated_avatar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile_modifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile_background)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mini_profile_background)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.avatar_frame)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.animated_avatar)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile_modifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.profile_background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mini_profile_background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.avatar_frame.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.animated_avatar.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.profile_modifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.profile_background.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mini_profile_background.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.avatar_frame.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.animated_avatar.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.profile_modifier.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileItemsEquipped_Response {
        CPlayer_GetProfileItemsEquipped_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "profile_background",
                |m: &CPlayer_GetProfileItemsEquipped_Response| { &m.profile_background },
                |m: &mut CPlayer_GetProfileItemsEquipped_Response| { &mut m.profile_background },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "mini_profile_background",
                |m: &CPlayer_GetProfileItemsEquipped_Response| { &m.mini_profile_background },
                |m: &mut CPlayer_GetProfileItemsEquipped_Response| { &mut m.mini_profile_background },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "avatar_frame",
                |m: &CPlayer_GetProfileItemsEquipped_Response| { &m.avatar_frame },
                |m: &mut CPlayer_GetProfileItemsEquipped_Response| { &mut m.avatar_frame },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "animated_avatar",
                |m: &CPlayer_GetProfileItemsEquipped_Response| { &m.animated_avatar },
                |m: &mut CPlayer_GetProfileItemsEquipped_Response| { &mut m.animated_avatar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileItem>>(
                "profile_modifier",
                |m: &CPlayer_GetProfileItemsEquipped_Response| { &m.profile_modifier },
                |m: &mut CPlayer_GetProfileItemsEquipped_Response| { &mut m.profile_modifier },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileItemsEquipped_Response>(
                "CPlayer_GetProfileItemsEquipped_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileItemsEquipped_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileItemsEquipped_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileItemsEquipped_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileItemsEquipped_Response {
    fn clear(&mut self) {
        self.profile_background.clear();
        self.mini_profile_background.clear();
        self.avatar_frame.clear();
        self.animated_avatar.clear();
        self.profile_modifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileItemsEquipped_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileItemsEquipped_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetEquippedProfileItemFlags_Request {
    // message fields
    communityitemid: ::std::option::Option<u64>,
    flags: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetEquippedProfileItemFlags_Request {
    fn default() -> &'a CPlayer_SetEquippedProfileItemFlags_Request {
        <CPlayer_SetEquippedProfileItemFlags_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetEquippedProfileItemFlags_Request {
    pub fn new() -> CPlayer_SetEquippedProfileItemFlags_Request {
        ::std::default::Default::default()
    }

    // optional uint64 communityitemid = 1;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_SetEquippedProfileItemFlags_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.communityitemid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetEquippedProfileItemFlags_Request {
        CPlayer_SetEquippedProfileItemFlags_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &CPlayer_SetEquippedProfileItemFlags_Request| { &m.communityitemid },
                |m: &mut CPlayer_SetEquippedProfileItemFlags_Request| { &mut m.communityitemid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CPlayer_SetEquippedProfileItemFlags_Request| { &m.flags },
                |m: &mut CPlayer_SetEquippedProfileItemFlags_Request| { &mut m.flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetEquippedProfileItemFlags_Request>(
                "CPlayer_SetEquippedProfileItemFlags_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetEquippedProfileItemFlags_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetEquippedProfileItemFlags_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetEquippedProfileItemFlags_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetEquippedProfileItemFlags_Request {
    fn clear(&mut self) {
        self.communityitemid = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetEquippedProfileItemFlags_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetEquippedProfileItemFlags_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetEquippedProfileItemFlags_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetEquippedProfileItemFlags_Response {
    fn default() -> &'a CPlayer_SetEquippedProfileItemFlags_Response {
        <CPlayer_SetEquippedProfileItemFlags_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetEquippedProfileItemFlags_Response {
    pub fn new() -> CPlayer_SetEquippedProfileItemFlags_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetEquippedProfileItemFlags_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetEquippedProfileItemFlags_Response {
        CPlayer_SetEquippedProfileItemFlags_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetEquippedProfileItemFlags_Response>(
                "CPlayer_SetEquippedProfileItemFlags_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetEquippedProfileItemFlags_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetEquippedProfileItemFlags_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetEquippedProfileItemFlags_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetEquippedProfileItemFlags_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetEquippedProfileItemFlags_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetEquippedProfileItemFlags_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetEmoticonList_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Request {
    fn default() -> &'a CPlayer_GetEmoticonList_Request {
        <CPlayer_GetEmoticonList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Request {
    pub fn new() -> CPlayer_GetEmoticonList_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Request {
        CPlayer_GetEmoticonList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetEmoticonList_Request>(
                "CPlayer_GetEmoticonList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetEmoticonList_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetEmoticonList_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetEmoticonList_Response {
    // message fields
    pub emoticons: ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Response {
    fn default() -> &'a CPlayer_GetEmoticonList_Response {
        <CPlayer_GetEmoticonList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Response {
    pub fn new() -> CPlayer_GetEmoticonList_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetEmoticonList_Response.Emoticon emoticons = 1;


    pub fn get_emoticons(&self) -> &[CPlayer_GetEmoticonList_Response_Emoticon] {
        &self.emoticons
    }
    pub fn clear_emoticons(&mut self) {
        self.emoticons.clear();
    }

    // Param is passed by value, moved
    pub fn set_emoticons(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon>) {
        self.emoticons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_emoticons(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon> {
        &mut self.emoticons
    }

    // Take field
    pub fn take_emoticons(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon> {
        ::std::mem::replace(&mut self.emoticons, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.emoticons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.emoticons)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.emoticons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.emoticons {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Response {
        CPlayer_GetEmoticonList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetEmoticonList_Response_Emoticon>>(
                "emoticons",
                |m: &CPlayer_GetEmoticonList_Response| { &m.emoticons },
                |m: &mut CPlayer_GetEmoticonList_Response| { &mut m.emoticons },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetEmoticonList_Response>(
                "CPlayer_GetEmoticonList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetEmoticonList_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetEmoticonList_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Response {
    fn clear(&mut self) {
        self.emoticons.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetEmoticonList_Response_Emoticon {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    count: ::std::option::Option<i32>,
    time_last_used: ::std::option::Option<u32>,
    use_count: ::std::option::Option<u32>,
    time_received: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Response_Emoticon {
    fn default() -> &'a CPlayer_GetEmoticonList_Response_Emoticon {
        <CPlayer_GetEmoticonList_Response_Emoticon as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Response_Emoticon {
    pub fn new() -> CPlayer_GetEmoticonList_Response_Emoticon {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_used = 3;


    pub fn get_time_last_used(&self) -> u32 {
        self.time_last_used.unwrap_or(0)
    }
    pub fn clear_time_last_used(&mut self) {
        self.time_last_used = ::std::option::Option::None;
    }

    pub fn has_time_last_used(&self) -> bool {
        self.time_last_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_used(&mut self, v: u32) {
        self.time_last_used = ::std::option::Option::Some(v);
    }

    // optional uint32 use_count = 4;


    pub fn get_use_count(&self) -> u32 {
        self.use_count.unwrap_or(0)
    }
    pub fn clear_use_count(&mut self) {
        self.use_count = ::std::option::Option::None;
    }

    pub fn has_use_count(&self) -> bool {
        self.use_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_count(&mut self, v: u32) {
        self.use_count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_received = 5;


    pub fn get_time_received(&self) -> u32 {
        self.time_received.unwrap_or(0)
    }
    pub fn clear_time_received(&mut self) {
        self.time_received = ::std::option::Option::None;
    }

    pub fn has_time_received(&self) -> bool {
        self.time_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_received(&mut self, v: u32) {
        self.time_received = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 6;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Response_Emoticon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_used = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.use_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_received = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_used {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_received {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.time_last_used {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.use_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.time_received {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Response_Emoticon {
        CPlayer_GetEmoticonList_Response_Emoticon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.name },
                |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.count },
                |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last_used",
                |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.time_last_used },
                |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.time_last_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "use_count",
                |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.use_count },
                |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.use_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_received",
                |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.time_received },
                |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.time_received },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.appid },
                |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetEmoticonList_Response_Emoticon>(
                "CPlayer_GetEmoticonList_Response.Emoticon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Response_Emoticon {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetEmoticonList_Response_Emoticon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetEmoticonList_Response_Emoticon::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Response_Emoticon {
    fn clear(&mut self) {
        self.name.clear();
        self.count = ::std::option::Option::None;
        self.time_last_used = ::std::option::Option::None;
        self.use_count = ::std::option::Option::None;
        self.time_received = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Response_Emoticon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Response_Emoticon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetAchievementsProgress_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    language: ::protobuf::SingularField<::std::string::String>,
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAchievementsProgress_Request {
    fn default() -> &'a CPlayer_GetAchievementsProgress_Request {
        <CPlayer_GetAchievementsProgress_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAchievementsProgress_Request {
    pub fn new() -> CPlayer_GetAchievementsProgress_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 appids = 3;


    pub fn get_appids(&self) -> &[u32] {
        &self.appids
    }
    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPlayer_GetAchievementsProgress_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.appids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.appids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAchievementsProgress_Request {
        CPlayer_GetAchievementsProgress_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steamid",
                |m: &CPlayer_GetAchievementsProgress_Request| { &m.steamid },
                |m: &mut CPlayer_GetAchievementsProgress_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CPlayer_GetAchievementsProgress_Request| { &m.language },
                |m: &mut CPlayer_GetAchievementsProgress_Request| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appids",
                |m: &CPlayer_GetAchievementsProgress_Request| { &m.appids },
                |m: &mut CPlayer_GetAchievementsProgress_Request| { &mut m.appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetAchievementsProgress_Request>(
                "CPlayer_GetAchievementsProgress_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAchievementsProgress_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetAchievementsProgress_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetAchievementsProgress_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAchievementsProgress_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.language.clear();
        self.appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAchievementsProgress_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAchievementsProgress_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetAchievementsProgress_Response {
    // message fields
    pub achievement_progress: ::protobuf::RepeatedField<CPlayer_GetAchievementsProgress_Response_AchievementProgress>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAchievementsProgress_Response {
    fn default() -> &'a CPlayer_GetAchievementsProgress_Response {
        <CPlayer_GetAchievementsProgress_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAchievementsProgress_Response {
    pub fn new() -> CPlayer_GetAchievementsProgress_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetAchievementsProgress_Response.AchievementProgress achievement_progress = 1;


    pub fn get_achievement_progress(&self) -> &[CPlayer_GetAchievementsProgress_Response_AchievementProgress] {
        &self.achievement_progress
    }
    pub fn clear_achievement_progress(&mut self) {
        self.achievement_progress.clear();
    }

    // Param is passed by value, moved
    pub fn set_achievement_progress(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetAchievementsProgress_Response_AchievementProgress>) {
        self.achievement_progress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_achievement_progress(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetAchievementsProgress_Response_AchievementProgress> {
        &mut self.achievement_progress
    }

    // Take field
    pub fn take_achievement_progress(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetAchievementsProgress_Response_AchievementProgress> {
        ::std::mem::replace(&mut self.achievement_progress, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetAchievementsProgress_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.achievement_progress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.achievement_progress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.achievement_progress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.achievement_progress {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAchievementsProgress_Response {
        CPlayer_GetAchievementsProgress_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetAchievementsProgress_Response_AchievementProgress>>(
                "achievement_progress",
                |m: &CPlayer_GetAchievementsProgress_Response| { &m.achievement_progress },
                |m: &mut CPlayer_GetAchievementsProgress_Response| { &mut m.achievement_progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetAchievementsProgress_Response>(
                "CPlayer_GetAchievementsProgress_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAchievementsProgress_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetAchievementsProgress_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetAchievementsProgress_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAchievementsProgress_Response {
    fn clear(&mut self) {
        self.achievement_progress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAchievementsProgress_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAchievementsProgress_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetAchievementsProgress_Response_AchievementProgress {
    // message fields
    appid: ::std::option::Option<u32>,
    unlocked: ::std::option::Option<u32>,
    total: ::std::option::Option<u32>,
    percentage: ::std::option::Option<f32>,
    all_unlocked: ::std::option::Option<bool>,
    cache_time: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAchievementsProgress_Response_AchievementProgress {
    fn default() -> &'a CPlayer_GetAchievementsProgress_Response_AchievementProgress {
        <CPlayer_GetAchievementsProgress_Response_AchievementProgress as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAchievementsProgress_Response_AchievementProgress {
    pub fn new() -> CPlayer_GetAchievementsProgress_Response_AchievementProgress {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 unlocked = 2;


    pub fn get_unlocked(&self) -> u32 {
        self.unlocked.unwrap_or(0)
    }
    pub fn clear_unlocked(&mut self) {
        self.unlocked = ::std::option::Option::None;
    }

    pub fn has_unlocked(&self) -> bool {
        self.unlocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlocked(&mut self, v: u32) {
        self.unlocked = ::std::option::Option::Some(v);
    }

    // optional uint32 total = 3;


    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }
    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional float percentage = 4;


    pub fn get_percentage(&self) -> f32 {
        self.percentage.unwrap_or(0.)
    }
    pub fn clear_percentage(&mut self) {
        self.percentage = ::std::option::Option::None;
    }

    pub fn has_percentage(&self) -> bool {
        self.percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_percentage(&mut self, v: f32) {
        self.percentage = ::std::option::Option::Some(v);
    }

    // optional bool all_unlocked = 5;


    pub fn get_all_unlocked(&self) -> bool {
        self.all_unlocked.unwrap_or(false)
    }
    pub fn clear_all_unlocked(&mut self) {
        self.all_unlocked = ::std::option::Option::None;
    }

    pub fn has_all_unlocked(&self) -> bool {
        self.all_unlocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_unlocked(&mut self, v: bool) {
        self.all_unlocked = ::std::option::Option::Some(v);
    }

    // optional uint32 cache_time = 6;


    pub fn get_cache_time(&self) -> u32 {
        self.cache_time.unwrap_or(0)
    }
    pub fn clear_cache_time(&mut self) {
        self.cache_time = ::std::option::Option::None;
    }

    pub fn has_cache_time(&self) -> bool {
        self.cache_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_time(&mut self, v: u32) {
        self.cache_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetAchievementsProgress_Response_AchievementProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unlocked = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.percentage = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all_unlocked = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cache_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unlocked {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.percentage {
            my_size += 5;
        }
        if let Some(v) = self.all_unlocked {
            my_size += 2;
        }
        if let Some(v) = self.cache_time {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unlocked {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.percentage {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.all_unlocked {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.cache_time {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAchievementsProgress_Response_AchievementProgress {
        CPlayer_GetAchievementsProgress_Response_AchievementProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &m.appid },
                |m: &mut CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unlocked",
                |m: &CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &m.unlocked },
                |m: &mut CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &mut m.unlocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total",
                |m: &CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &m.total },
                |m: &mut CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "percentage",
                |m: &CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &m.percentage },
                |m: &mut CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &mut m.percentage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "all_unlocked",
                |m: &CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &m.all_unlocked },
                |m: &mut CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &mut m.all_unlocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cache_time",
                |m: &CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &m.cache_time },
                |m: &mut CPlayer_GetAchievementsProgress_Response_AchievementProgress| { &mut m.cache_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetAchievementsProgress_Response_AchievementProgress>(
                "CPlayer_GetAchievementsProgress_Response.AchievementProgress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAchievementsProgress_Response_AchievementProgress {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetAchievementsProgress_Response_AchievementProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetAchievementsProgress_Response_AchievementProgress::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAchievementsProgress_Response_AchievementProgress {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unlocked = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.percentage = ::std::option::Option::None;
        self.all_unlocked = ::std::option::Option::None;
        self.cache_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAchievementsProgress_Response_AchievementProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAchievementsProgress_Response_AchievementProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFavoriteBadge_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFavoriteBadge_Request {
    fn default() -> &'a CPlayer_GetFavoriteBadge_Request {
        <CPlayer_GetFavoriteBadge_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFavoriteBadge_Request {
    pub fn new() -> CPlayer_GetFavoriteBadge_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFavoriteBadge_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFavoriteBadge_Request {
        CPlayer_GetFavoriteBadge_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steamid",
                |m: &CPlayer_GetFavoriteBadge_Request| { &m.steamid },
                |m: &mut CPlayer_GetFavoriteBadge_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFavoriteBadge_Request>(
                "CPlayer_GetFavoriteBadge_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFavoriteBadge_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFavoriteBadge_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFavoriteBadge_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFavoriteBadge_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFavoriteBadge_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFavoriteBadge_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFavoriteBadge_Response {
    // message fields
    has_favorite_badge: ::std::option::Option<bool>,
    badgeid: ::std::option::Option<u32>,
    communityitemid: ::std::option::Option<u64>,
    item_type: ::std::option::Option<u32>,
    border_color: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFavoriteBadge_Response {
    fn default() -> &'a CPlayer_GetFavoriteBadge_Response {
        <CPlayer_GetFavoriteBadge_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFavoriteBadge_Response {
    pub fn new() -> CPlayer_GetFavoriteBadge_Response {
        ::std::default::Default::default()
    }

    // optional bool has_favorite_badge = 1;


    pub fn get_has_favorite_badge(&self) -> bool {
        self.has_favorite_badge.unwrap_or(false)
    }
    pub fn clear_has_favorite_badge(&mut self) {
        self.has_favorite_badge = ::std::option::Option::None;
    }

    pub fn has_has_favorite_badge(&self) -> bool {
        self.has_favorite_badge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_favorite_badge(&mut self, v: bool) {
        self.has_favorite_badge = ::std::option::Option::Some(v);
    }

    // optional uint32 badgeid = 2;


    pub fn get_badgeid(&self) -> u32 {
        self.badgeid.unwrap_or(0)
    }
    pub fn clear_badgeid(&mut self) {
        self.badgeid = ::std::option::Option::None;
    }

    pub fn has_badgeid(&self) -> bool {
        self.badgeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badgeid(&mut self, v: u32) {
        self.badgeid = ::std::option::Option::Some(v);
    }

    // optional uint64 communityitemid = 3;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 4;


    pub fn get_item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }
    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional uint32 border_color = 5;


    pub fn get_border_color(&self) -> u32 {
        self.border_color.unwrap_or(0)
    }
    pub fn clear_border_color(&mut self) {
        self.border_color = ::std::option::Option::None;
    }

    pub fn has_border_color(&self) -> bool {
        self.border_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_border_color(&mut self, v: u32) {
        self.border_color = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 6;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 7;


    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }
    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFavoriteBadge_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_favorite_badge = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badgeid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.border_color = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.has_favorite_badge {
            my_size += 2;
        }
        if let Some(v) = self.badgeid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.border_color {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.has_favorite_badge {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.badgeid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.communityitemid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.border_color {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFavoriteBadge_Response {
        CPlayer_GetFavoriteBadge_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_favorite_badge",
                |m: &CPlayer_GetFavoriteBadge_Response| { &m.has_favorite_badge },
                |m: &mut CPlayer_GetFavoriteBadge_Response| { &mut m.has_favorite_badge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badgeid",
                |m: &CPlayer_GetFavoriteBadge_Response| { &m.badgeid },
                |m: &mut CPlayer_GetFavoriteBadge_Response| { &mut m.badgeid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &CPlayer_GetFavoriteBadge_Response| { &m.communityitemid },
                |m: &mut CPlayer_GetFavoriteBadge_Response| { &mut m.communityitemid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_type",
                |m: &CPlayer_GetFavoriteBadge_Response| { &m.item_type },
                |m: &mut CPlayer_GetFavoriteBadge_Response| { &mut m.item_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "border_color",
                |m: &CPlayer_GetFavoriteBadge_Response| { &m.border_color },
                |m: &mut CPlayer_GetFavoriteBadge_Response| { &mut m.border_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetFavoriteBadge_Response| { &m.appid },
                |m: &mut CPlayer_GetFavoriteBadge_Response| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level",
                |m: &CPlayer_GetFavoriteBadge_Response| { &m.level },
                |m: &mut CPlayer_GetFavoriteBadge_Response| { &mut m.level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetFavoriteBadge_Response>(
                "CPlayer_GetFavoriteBadge_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFavoriteBadge_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetFavoriteBadge_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetFavoriteBadge_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFavoriteBadge_Response {
    fn clear(&mut self) {
        self.has_favorite_badge = ::std::option::Option::None;
        self.badgeid = ::std::option::Option::None;
        self.communityitemid = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.border_color = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFavoriteBadge_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFavoriteBadge_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetFavoriteBadge_Request {
    // message fields
    communityitemid: ::std::option::Option<u64>,
    badgeid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetFavoriteBadge_Request {
    fn default() -> &'a CPlayer_SetFavoriteBadge_Request {
        <CPlayer_SetFavoriteBadge_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetFavoriteBadge_Request {
    pub fn new() -> CPlayer_SetFavoriteBadge_Request {
        ::std::default::Default::default()
    }

    // optional uint64 communityitemid = 1;


    pub fn get_communityitemid(&self) -> u64 {
        self.communityitemid.unwrap_or(0)
    }
    pub fn clear_communityitemid(&mut self) {
        self.communityitemid = ::std::option::Option::None;
    }

    pub fn has_communityitemid(&self) -> bool {
        self.communityitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communityitemid(&mut self, v: u64) {
        self.communityitemid = ::std::option::Option::Some(v);
    }

    // optional uint32 badgeid = 2;


    pub fn get_badgeid(&self) -> u32 {
        self.badgeid.unwrap_or(0)
    }
    pub fn clear_badgeid(&mut self) {
        self.badgeid = ::std::option::Option::None;
    }

    pub fn has_badgeid(&self) -> bool {
        self.badgeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badgeid(&mut self, v: u32) {
        self.badgeid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_SetFavoriteBadge_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.communityitemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badgeid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.communityitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.badgeid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.communityitemid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.badgeid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetFavoriteBadge_Request {
        CPlayer_SetFavoriteBadge_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "communityitemid",
                |m: &CPlayer_SetFavoriteBadge_Request| { &m.communityitemid },
                |m: &mut CPlayer_SetFavoriteBadge_Request| { &mut m.communityitemid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badgeid",
                |m: &CPlayer_SetFavoriteBadge_Request| { &m.badgeid },
                |m: &mut CPlayer_SetFavoriteBadge_Request| { &mut m.badgeid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetFavoriteBadge_Request>(
                "CPlayer_SetFavoriteBadge_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetFavoriteBadge_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetFavoriteBadge_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetFavoriteBadge_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetFavoriteBadge_Request {
    fn clear(&mut self) {
        self.communityitemid = ::std::option::Option::None;
        self.badgeid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetFavoriteBadge_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetFavoriteBadge_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetFavoriteBadge_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetFavoriteBadge_Response {
    fn default() -> &'a CPlayer_SetFavoriteBadge_Response {
        <CPlayer_SetFavoriteBadge_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetFavoriteBadge_Response {
    pub fn new() -> CPlayer_SetFavoriteBadge_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetFavoriteBadge_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetFavoriteBadge_Response {
        CPlayer_SetFavoriteBadge_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetFavoriteBadge_Response>(
                "CPlayer_SetFavoriteBadge_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetFavoriteBadge_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetFavoriteBadge_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetFavoriteBadge_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetFavoriteBadge_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetFavoriteBadge_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetFavoriteBadge_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileCustomization_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    include_inactive_customizations: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileCustomization_Request {
    fn default() -> &'a CPlayer_GetProfileCustomization_Request {
        <CPlayer_GetProfileCustomization_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileCustomization_Request {
    pub fn new() -> CPlayer_GetProfileCustomization_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool include_inactive_customizations = 2;


    pub fn get_include_inactive_customizations(&self) -> bool {
        self.include_inactive_customizations.unwrap_or(false)
    }
    pub fn clear_include_inactive_customizations(&mut self) {
        self.include_inactive_customizations = ::std::option::Option::None;
    }

    pub fn has_include_inactive_customizations(&self) -> bool {
        self.include_inactive_customizations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_inactive_customizations(&mut self, v: bool) {
        self.include_inactive_customizations = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetProfileCustomization_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_inactive_customizations = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.include_inactive_customizations {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.include_inactive_customizations {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileCustomization_Request {
        CPlayer_GetProfileCustomization_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_GetProfileCustomization_Request| { &m.steamid },
                |m: &mut CPlayer_GetProfileCustomization_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_inactive_customizations",
                |m: &CPlayer_GetProfileCustomization_Request| { &m.include_inactive_customizations },
                |m: &mut CPlayer_GetProfileCustomization_Request| { &mut m.include_inactive_customizations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileCustomization_Request>(
                "CPlayer_GetProfileCustomization_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileCustomization_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileCustomization_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileCustomization_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileCustomization_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.include_inactive_customizations = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileCustomization_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileCustomization_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProfileCustomizationSlot {
    // message fields
    slot: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    publishedfileid: ::std::option::Option<u64>,
    item_assetid: ::std::option::Option<u64>,
    item_contextid: ::std::option::Option<u64>,
    notes: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    accountid: ::std::option::Option<u32>,
    badgeid: ::std::option::Option<u32>,
    border_color: ::std::option::Option<u32>,
    item_classid: ::std::option::Option<u64>,
    item_instanceid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfileCustomizationSlot {
    fn default() -> &'a ProfileCustomizationSlot {
        <ProfileCustomizationSlot as ::protobuf::Message>::default_instance()
    }
}

impl ProfileCustomizationSlot {
    pub fn new() -> ProfileCustomizationSlot {
        ::std::default::Default::default()
    }

    // optional uint32 slot = 1;


    pub fn get_slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }
    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 publishedfileid = 3;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint64 item_assetid = 4;


    pub fn get_item_assetid(&self) -> u64 {
        self.item_assetid.unwrap_or(0)
    }
    pub fn clear_item_assetid(&mut self) {
        self.item_assetid = ::std::option::Option::None;
    }

    pub fn has_item_assetid(&self) -> bool {
        self.item_assetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_assetid(&mut self, v: u64) {
        self.item_assetid = ::std::option::Option::Some(v);
    }

    // optional uint64 item_contextid = 5;


    pub fn get_item_contextid(&self) -> u64 {
        self.item_contextid.unwrap_or(0)
    }
    pub fn clear_item_contextid(&mut self) {
        self.item_contextid = ::std::option::Option::None;
    }

    pub fn has_item_contextid(&self) -> bool {
        self.item_contextid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_contextid(&mut self, v: u64) {
        self.item_contextid = ::std::option::Option::Some(v);
    }

    // optional string notes = 6;


    pub fn get_notes(&self) -> &str {
        match self.notes.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    pub fn has_notes(&self) -> bool {
        self.notes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::string::String) {
        self.notes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notes(&mut self) -> &mut ::std::string::String {
        if self.notes.is_none() {
            self.notes.set_default();
        }
        self.notes.as_mut().unwrap()
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::string::String {
        self.notes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 7;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid = 8;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 badgeid = 9;


    pub fn get_badgeid(&self) -> u32 {
        self.badgeid.unwrap_or(0)
    }
    pub fn clear_badgeid(&mut self) {
        self.badgeid = ::std::option::Option::None;
    }

    pub fn has_badgeid(&self) -> bool {
        self.badgeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badgeid(&mut self, v: u32) {
        self.badgeid = ::std::option::Option::Some(v);
    }

    // optional uint32 border_color = 10;


    pub fn get_border_color(&self) -> u32 {
        self.border_color.unwrap_or(0)
    }
    pub fn clear_border_color(&mut self) {
        self.border_color = ::std::option::Option::None;
    }

    pub fn has_border_color(&self) -> bool {
        self.border_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_border_color(&mut self, v: u32) {
        self.border_color = ::std::option::Option::Some(v);
    }

    // optional uint64 item_classid = 11;


    pub fn get_item_classid(&self) -> u64 {
        self.item_classid.unwrap_or(0)
    }
    pub fn clear_item_classid(&mut self) {
        self.item_classid = ::std::option::Option::None;
    }

    pub fn has_item_classid(&self) -> bool {
        self.item_classid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_classid(&mut self, v: u64) {
        self.item_classid = ::std::option::Option::Some(v);
    }

    // optional uint64 item_instanceid = 12;


    pub fn get_item_instanceid(&self) -> u64 {
        self.item_instanceid.unwrap_or(0)
    }
    pub fn clear_item_instanceid(&mut self) {
        self.item_instanceid = ::std::option::Option::None;
    }

    pub fn has_item_instanceid(&self) -> bool {
        self.item_instanceid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_instanceid(&mut self, v: u64) {
        self.item_instanceid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ProfileCustomizationSlot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_assetid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_contextid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notes)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badgeid = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.border_color = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_classid = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_instanceid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_assetid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_contextid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.notes.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.badgeid {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.border_color {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_classid {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_instanceid {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.slot {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.publishedfileid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.item_assetid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.item_contextid {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.notes.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.badgeid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.border_color {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.item_classid {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.item_instanceid {
            os.write_uint64(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfileCustomizationSlot {
        ProfileCustomizationSlot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slot",
                |m: &ProfileCustomizationSlot| { &m.slot },
                |m: &mut ProfileCustomizationSlot| { &mut m.slot },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &ProfileCustomizationSlot| { &m.appid },
                |m: &mut ProfileCustomizationSlot| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "publishedfileid",
                |m: &ProfileCustomizationSlot| { &m.publishedfileid },
                |m: &mut ProfileCustomizationSlot| { &mut m.publishedfileid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_assetid",
                |m: &ProfileCustomizationSlot| { &m.item_assetid },
                |m: &mut ProfileCustomizationSlot| { &mut m.item_assetid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_contextid",
                |m: &ProfileCustomizationSlot| { &m.item_contextid },
                |m: &mut ProfileCustomizationSlot| { &mut m.item_contextid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notes",
                |m: &ProfileCustomizationSlot| { &m.notes },
                |m: &mut ProfileCustomizationSlot| { &mut m.notes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ProfileCustomizationSlot| { &m.title },
                |m: &mut ProfileCustomizationSlot| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &ProfileCustomizationSlot| { &m.accountid },
                |m: &mut ProfileCustomizationSlot| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badgeid",
                |m: &ProfileCustomizationSlot| { &m.badgeid },
                |m: &mut ProfileCustomizationSlot| { &mut m.badgeid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "border_color",
                |m: &ProfileCustomizationSlot| { &m.border_color },
                |m: &mut ProfileCustomizationSlot| { &mut m.border_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_classid",
                |m: &ProfileCustomizationSlot| { &m.item_classid },
                |m: &mut ProfileCustomizationSlot| { &mut m.item_classid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_instanceid",
                |m: &ProfileCustomizationSlot| { &m.item_instanceid },
                |m: &mut ProfileCustomizationSlot| { &mut m.item_instanceid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfileCustomizationSlot>(
                "ProfileCustomizationSlot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfileCustomizationSlot {
        static instance: ::protobuf::rt::LazyV2<ProfileCustomizationSlot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfileCustomizationSlot::new)
    }
}

impl ::protobuf::Clear for ProfileCustomizationSlot {
    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.publishedfileid = ::std::option::Option::None;
        self.item_assetid = ::std::option::Option::None;
        self.item_contextid = ::std::option::Option::None;
        self.notes.clear();
        self.title.clear();
        self.accountid = ::std::option::Option::None;
        self.badgeid = ::std::option::Option::None;
        self.border_color = ::std::option::Option::None;
        self.item_classid = ::std::option::Option::None;
        self.item_instanceid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfileCustomizationSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileCustomizationSlot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProfileCustomization {
    // message fields
    customization_type: ::std::option::Option<EProfileCustomizationType>,
    large: ::std::option::Option<bool>,
    pub slots: ::protobuf::RepeatedField<ProfileCustomizationSlot>,
    active: ::std::option::Option<bool>,
    customization_style: ::std::option::Option<EProfileCustomizationStyle>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfileCustomization {
    fn default() -> &'a ProfileCustomization {
        <ProfileCustomization as ::protobuf::Message>::default_instance()
    }
}

impl ProfileCustomization {
    pub fn new() -> ProfileCustomization {
        ::std::default::Default::default()
    }

    // optional .EProfileCustomizationType customization_type = 1;


    pub fn get_customization_type(&self) -> EProfileCustomizationType {
        self.customization_type.unwrap_or(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid)
    }
    pub fn clear_customization_type(&mut self) {
        self.customization_type = ::std::option::Option::None;
    }

    pub fn has_customization_type(&self) -> bool {
        self.customization_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customization_type(&mut self, v: EProfileCustomizationType) {
        self.customization_type = ::std::option::Option::Some(v);
    }

    // optional bool large = 2;


    pub fn get_large(&self) -> bool {
        self.large.unwrap_or(false)
    }
    pub fn clear_large(&mut self) {
        self.large = ::std::option::Option::None;
    }

    pub fn has_large(&self) -> bool {
        self.large.is_some()
    }

    // Param is passed by value, moved
    pub fn set_large(&mut self, v: bool) {
        self.large = ::std::option::Option::Some(v);
    }

    // repeated .ProfileCustomizationSlot slots = 3;


    pub fn get_slots(&self) -> &[ProfileCustomizationSlot] {
        &self.slots
    }
    pub fn clear_slots(&mut self) {
        self.slots.clear();
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: ::protobuf::RepeatedField<ProfileCustomizationSlot>) {
        self.slots = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slots(&mut self) -> &mut ::protobuf::RepeatedField<ProfileCustomizationSlot> {
        &mut self.slots
    }

    // Take field
    pub fn take_slots(&mut self) -> ::protobuf::RepeatedField<ProfileCustomizationSlot> {
        ::std::mem::replace(&mut self.slots, ::protobuf::RepeatedField::new())
    }

    // optional bool active = 4;


    pub fn get_active(&self) -> bool {
        self.active.unwrap_or(false)
    }
    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional .EProfileCustomizationStyle customization_style = 5;


    pub fn get_customization_style(&self) -> EProfileCustomizationStyle {
        self.customization_style.unwrap_or(EProfileCustomizationStyle::k_EProfileCustomizationStyleDefault)
    }
    pub fn clear_customization_style(&mut self) {
        self.customization_style = ::std::option::Option::None;
    }

    pub fn has_customization_style(&self) -> bool {
        self.customization_style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customization_style(&mut self, v: EProfileCustomizationStyle) {
        self.customization_style = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ProfileCustomization {
    fn is_initialized(&self) -> bool {
        for v in &self.slots {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.customization_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.large = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slots)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.customization_style, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.customization_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.large {
            my_size += 2;
        }
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.active {
            my_size += 2;
        }
        if let Some(v) = self.customization_style {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.customization_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.large {
            os.write_bool(2, v)?;
        }
        for v in &self.slots {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.active {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.customization_style {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfileCustomization {
        ProfileCustomization::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EProfileCustomizationType>>(
                "customization_type",
                |m: &ProfileCustomization| { &m.customization_type },
                |m: &mut ProfileCustomization| { &mut m.customization_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "large",
                |m: &ProfileCustomization| { &m.large },
                |m: &mut ProfileCustomization| { &mut m.large },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileCustomizationSlot>>(
                "slots",
                |m: &ProfileCustomization| { &m.slots },
                |m: &mut ProfileCustomization| { &mut m.slots },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &ProfileCustomization| { &m.active },
                |m: &mut ProfileCustomization| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EProfileCustomizationStyle>>(
                "customization_style",
                |m: &ProfileCustomization| { &m.customization_style },
                |m: &mut ProfileCustomization| { &mut m.customization_style },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfileCustomization>(
                "ProfileCustomization",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfileCustomization {
        static instance: ::protobuf::rt::LazyV2<ProfileCustomization> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfileCustomization::new)
    }
}

impl ::protobuf::Clear for ProfileCustomization {
    fn clear(&mut self) {
        self.customization_type = ::std::option::Option::None;
        self.large = ::std::option::Option::None;
        self.slots.clear();
        self.active = ::std::option::Option::None;
        self.customization_style = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfileCustomization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileCustomization {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProfileTheme {
    // message fields
    theme_id: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfileTheme {
    fn default() -> &'a ProfileTheme {
        <ProfileTheme as ::protobuf::Message>::default_instance()
    }
}

impl ProfileTheme {
    pub fn new() -> ProfileTheme {
        ::std::default::Default::default()
    }

    // optional string theme_id = 1;


    pub fn get_theme_id(&self) -> &str {
        match self.theme_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_theme_id(&mut self) {
        self.theme_id.clear();
    }

    pub fn has_theme_id(&self) -> bool {
        self.theme_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_theme_id(&mut self, v: ::std::string::String) {
        self.theme_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_theme_id(&mut self) -> &mut ::std::string::String {
        if self.theme_id.is_none() {
            self.theme_id.set_default();
        }
        self.theme_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_theme_id(&mut self) -> ::std::string::String {
        self.theme_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 2;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ProfileTheme {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.theme_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.theme_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.theme_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfileTheme {
        ProfileTheme::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "theme_id",
                |m: &ProfileTheme| { &m.theme_id },
                |m: &mut ProfileTheme| { &mut m.theme_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &ProfileTheme| { &m.title },
                |m: &mut ProfileTheme| { &mut m.title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfileTheme>(
                "ProfileTheme",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfileTheme {
        static instance: ::protobuf::rt::LazyV2<ProfileTheme> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfileTheme::new)
    }
}

impl ::protobuf::Clear for ProfileTheme {
    fn clear(&mut self) {
        self.theme_id.clear();
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfileTheme {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileTheme {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileCustomization_Response {
    // message fields
    pub customizations: ::protobuf::RepeatedField<ProfileCustomization>,
    slots_available: ::std::option::Option<u32>,
    pub profile_theme: ::protobuf::SingularPtrField<ProfileTheme>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileCustomization_Response {
    fn default() -> &'a CPlayer_GetProfileCustomization_Response {
        <CPlayer_GetProfileCustomization_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileCustomization_Response {
    pub fn new() -> CPlayer_GetProfileCustomization_Response {
        ::std::default::Default::default()
    }

    // repeated .ProfileCustomization customizations = 1;


    pub fn get_customizations(&self) -> &[ProfileCustomization] {
        &self.customizations
    }
    pub fn clear_customizations(&mut self) {
        self.customizations.clear();
    }

    // Param is passed by value, moved
    pub fn set_customizations(&mut self, v: ::protobuf::RepeatedField<ProfileCustomization>) {
        self.customizations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_customizations(&mut self) -> &mut ::protobuf::RepeatedField<ProfileCustomization> {
        &mut self.customizations
    }

    // Take field
    pub fn take_customizations(&mut self) -> ::protobuf::RepeatedField<ProfileCustomization> {
        ::std::mem::replace(&mut self.customizations, ::protobuf::RepeatedField::new())
    }

    // optional uint32 slots_available = 2;


    pub fn get_slots_available(&self) -> u32 {
        self.slots_available.unwrap_or(0)
    }
    pub fn clear_slots_available(&mut self) {
        self.slots_available = ::std::option::Option::None;
    }

    pub fn has_slots_available(&self) -> bool {
        self.slots_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots_available(&mut self, v: u32) {
        self.slots_available = ::std::option::Option::Some(v);
    }

    // optional .ProfileTheme profile_theme = 3;


    pub fn get_profile_theme(&self) -> &ProfileTheme {
        self.profile_theme.as_ref().unwrap_or_else(|| <ProfileTheme as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile_theme(&mut self) {
        self.profile_theme.clear();
    }

    pub fn has_profile_theme(&self) -> bool {
        self.profile_theme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_theme(&mut self, v: ProfileTheme) {
        self.profile_theme = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_theme(&mut self) -> &mut ProfileTheme {
        if self.profile_theme.is_none() {
            self.profile_theme.set_default();
        }
        self.profile_theme.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_theme(&mut self) -> ProfileTheme {
        self.profile_theme.take().unwrap_or_else(|| ProfileTheme::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileCustomization_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.customizations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile_theme {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.customizations)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slots_available = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile_theme)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.customizations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.slots_available {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.profile_theme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.customizations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.slots_available {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.profile_theme.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileCustomization_Response {
        CPlayer_GetProfileCustomization_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileCustomization>>(
                "customizations",
                |m: &CPlayer_GetProfileCustomization_Response| { &m.customizations },
                |m: &mut CPlayer_GetProfileCustomization_Response| { &mut m.customizations },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slots_available",
                |m: &CPlayer_GetProfileCustomization_Response| { &m.slots_available },
                |m: &mut CPlayer_GetProfileCustomization_Response| { &mut m.slots_available },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileTheme>>(
                "profile_theme",
                |m: &CPlayer_GetProfileCustomization_Response| { &m.profile_theme },
                |m: &mut CPlayer_GetProfileCustomization_Response| { &mut m.profile_theme },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileCustomization_Response>(
                "CPlayer_GetProfileCustomization_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileCustomization_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileCustomization_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileCustomization_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileCustomization_Response {
    fn clear(&mut self) {
        self.customizations.clear();
        self.slots_available = ::std::option::Option::None;
        self.profile_theme.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileCustomization_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileCustomization_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileThemesAvailable_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileThemesAvailable_Request {
    fn default() -> &'a CPlayer_GetProfileThemesAvailable_Request {
        <CPlayer_GetProfileThemesAvailable_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileThemesAvailable_Request {
    pub fn new() -> CPlayer_GetProfileThemesAvailable_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetProfileThemesAvailable_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileThemesAvailable_Request {
        CPlayer_GetProfileThemesAvailable_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileThemesAvailable_Request>(
                "CPlayer_GetProfileThemesAvailable_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileThemesAvailable_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileThemesAvailable_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileThemesAvailable_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileThemesAvailable_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileThemesAvailable_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileThemesAvailable_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetProfileThemesAvailable_Response {
    // message fields
    pub profile_themes: ::protobuf::RepeatedField<ProfileTheme>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetProfileThemesAvailable_Response {
    fn default() -> &'a CPlayer_GetProfileThemesAvailable_Response {
        <CPlayer_GetProfileThemesAvailable_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetProfileThemesAvailable_Response {
    pub fn new() -> CPlayer_GetProfileThemesAvailable_Response {
        ::std::default::Default::default()
    }

    // repeated .ProfileTheme profile_themes = 1;


    pub fn get_profile_themes(&self) -> &[ProfileTheme] {
        &self.profile_themes
    }
    pub fn clear_profile_themes(&mut self) {
        self.profile_themes.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile_themes(&mut self, v: ::protobuf::RepeatedField<ProfileTheme>) {
        self.profile_themes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profile_themes(&mut self) -> &mut ::protobuf::RepeatedField<ProfileTheme> {
        &mut self.profile_themes
    }

    // Take field
    pub fn take_profile_themes(&mut self) -> ::protobuf::RepeatedField<ProfileTheme> {
        ::std::mem::replace(&mut self.profile_themes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetProfileThemesAvailable_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.profile_themes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profile_themes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.profile_themes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.profile_themes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetProfileThemesAvailable_Response {
        CPlayer_GetProfileThemesAvailable_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfileTheme>>(
                "profile_themes",
                |m: &CPlayer_GetProfileThemesAvailable_Response| { &m.profile_themes },
                |m: &mut CPlayer_GetProfileThemesAvailable_Response| { &mut m.profile_themes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetProfileThemesAvailable_Response>(
                "CPlayer_GetProfileThemesAvailable_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetProfileThemesAvailable_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetProfileThemesAvailable_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetProfileThemesAvailable_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetProfileThemesAvailable_Response {
    fn clear(&mut self) {
        self.profile_themes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetProfileThemesAvailable_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetProfileThemesAvailable_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetProfileTheme_Request {
    // message fields
    theme_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetProfileTheme_Request {
    fn default() -> &'a CPlayer_SetProfileTheme_Request {
        <CPlayer_SetProfileTheme_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetProfileTheme_Request {
    pub fn new() -> CPlayer_SetProfileTheme_Request {
        ::std::default::Default::default()
    }

    // optional string theme_id = 1;


    pub fn get_theme_id(&self) -> &str {
        match self.theme_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_theme_id(&mut self) {
        self.theme_id.clear();
    }

    pub fn has_theme_id(&self) -> bool {
        self.theme_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_theme_id(&mut self, v: ::std::string::String) {
        self.theme_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_theme_id(&mut self) -> &mut ::std::string::String {
        if self.theme_id.is_none() {
            self.theme_id.set_default();
        }
        self.theme_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_theme_id(&mut self) -> ::std::string::String {
        self.theme_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_SetProfileTheme_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.theme_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.theme_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.theme_id.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetProfileTheme_Request {
        CPlayer_SetProfileTheme_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "theme_id",
                |m: &CPlayer_SetProfileTheme_Request| { &m.theme_id },
                |m: &mut CPlayer_SetProfileTheme_Request| { &mut m.theme_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetProfileTheme_Request>(
                "CPlayer_SetProfileTheme_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetProfileTheme_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetProfileTheme_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetProfileTheme_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetProfileTheme_Request {
    fn clear(&mut self) {
        self.theme_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetProfileTheme_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetProfileTheme_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetProfileTheme_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetProfileTheme_Response {
    fn default() -> &'a CPlayer_SetProfileTheme_Response {
        <CPlayer_SetProfileTheme_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetProfileTheme_Response {
    pub fn new() -> CPlayer_SetProfileTheme_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetProfileTheme_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetProfileTheme_Response {
        CPlayer_SetProfileTheme_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetProfileTheme_Response>(
                "CPlayer_SetProfileTheme_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetProfileTheme_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetProfileTheme_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetProfileTheme_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetProfileTheme_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetProfileTheme_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetProfileTheme_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PostStatusToFriends_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PostStatusToFriends_Request {
    fn default() -> &'a CPlayer_PostStatusToFriends_Request {
        <CPlayer_PostStatusToFriends_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PostStatusToFriends_Request {
    pub fn new() -> CPlayer_PostStatusToFriends_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 2;


    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_PostStatusToFriends_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.status_text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PostStatusToFriends_Request {
        CPlayer_PostStatusToFriends_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_PostStatusToFriends_Request| { &m.appid },
                |m: &mut CPlayer_PostStatusToFriends_Request| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_text",
                |m: &CPlayer_PostStatusToFriends_Request| { &m.status_text },
                |m: &mut CPlayer_PostStatusToFriends_Request| { &mut m.status_text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_PostStatusToFriends_Request>(
                "CPlayer_PostStatusToFriends_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PostStatusToFriends_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_PostStatusToFriends_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_PostStatusToFriends_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_PostStatusToFriends_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.status_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PostStatusToFriends_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PostStatusToFriends_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PostStatusToFriends_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PostStatusToFriends_Response {
    fn default() -> &'a CPlayer_PostStatusToFriends_Response {
        <CPlayer_PostStatusToFriends_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PostStatusToFriends_Response {
    pub fn new() -> CPlayer_PostStatusToFriends_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_PostStatusToFriends_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PostStatusToFriends_Response {
        CPlayer_PostStatusToFriends_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_PostStatusToFriends_Response>(
                "CPlayer_PostStatusToFriends_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PostStatusToFriends_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_PostStatusToFriends_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_PostStatusToFriends_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_PostStatusToFriends_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PostStatusToFriends_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PostStatusToFriends_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPostedStatus_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    postid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPostedStatus_Request {
    fn default() -> &'a CPlayer_GetPostedStatus_Request {
        <CPlayer_GetPostedStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPostedStatus_Request {
    pub fn new() -> CPlayer_GetPostedStatus_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 postid = 2;


    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }
    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetPostedStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.postid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPostedStatus_Request {
        CPlayer_GetPostedStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steamid",
                |m: &CPlayer_GetPostedStatus_Request| { &m.steamid },
                |m: &mut CPlayer_GetPostedStatus_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "postid",
                |m: &CPlayer_GetPostedStatus_Request| { &m.postid },
                |m: &mut CPlayer_GetPostedStatus_Request| { &mut m.postid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPostedStatus_Request>(
                "CPlayer_GetPostedStatus_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPostedStatus_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPostedStatus_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPostedStatus_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPostedStatus_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.postid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPostedStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPostedStatus_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPostedStatus_Response {
    // message fields
    accountid: ::std::option::Option<u32>,
    postid: ::std::option::Option<u64>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    deleted: ::std::option::Option<bool>,
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPostedStatus_Response {
    fn default() -> &'a CPlayer_GetPostedStatus_Response {
        <CPlayer_GetPostedStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPostedStatus_Response {
    pub fn new() -> CPlayer_GetPostedStatus_Response {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 postid = 2;


    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }
    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;


    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool deleted = 4;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 5;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetPostedStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.postid {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.status_text.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPostedStatus_Response {
        CPlayer_GetPostedStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CPlayer_GetPostedStatus_Response| { &m.accountid },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "postid",
                |m: &CPlayer_GetPostedStatus_Response| { &m.postid },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.postid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_text",
                |m: &CPlayer_GetPostedStatus_Response| { &m.status_text },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.status_text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &CPlayer_GetPostedStatus_Response| { &m.deleted },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetPostedStatus_Response| { &m.appid },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPostedStatus_Response>(
                "CPlayer_GetPostedStatus_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPostedStatus_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPostedStatus_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPostedStatus_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPostedStatus_Response {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.postid = ::std::option::Option::None;
        self.status_text.clear();
        self.deleted = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPostedStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPostedStatus_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_DeletePostedStatus_Request {
    // message fields
    postid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_DeletePostedStatus_Request {
    fn default() -> &'a CPlayer_DeletePostedStatus_Request {
        <CPlayer_DeletePostedStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_DeletePostedStatus_Request {
    pub fn new() -> CPlayer_DeletePostedStatus_Request {
        ::std::default::Default::default()
    }

    // optional uint64 postid = 1;


    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }
    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_DeletePostedStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.postid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_DeletePostedStatus_Request {
        CPlayer_DeletePostedStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "postid",
                |m: &CPlayer_DeletePostedStatus_Request| { &m.postid },
                |m: &mut CPlayer_DeletePostedStatus_Request| { &mut m.postid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_DeletePostedStatus_Request>(
                "CPlayer_DeletePostedStatus_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_DeletePostedStatus_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_DeletePostedStatus_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_DeletePostedStatus_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_DeletePostedStatus_Request {
    fn clear(&mut self) {
        self.postid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_DeletePostedStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_DeletePostedStatus_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_DeletePostedStatus_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_DeletePostedStatus_Response {
    fn default() -> &'a CPlayer_DeletePostedStatus_Response {
        <CPlayer_DeletePostedStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_DeletePostedStatus_Response {
    pub fn new() -> CPlayer_DeletePostedStatus_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_DeletePostedStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_DeletePostedStatus_Response {
        CPlayer_DeletePostedStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_DeletePostedStatus_Response>(
                "CPlayer_DeletePostedStatus_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_DeletePostedStatus_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_DeletePostedStatus_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_DeletePostedStatus_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_DeletePostedStatus_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_DeletePostedStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_DeletePostedStatus_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetLastPlayedTimes_Request {
    // message fields
    min_last_played: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Request {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Request {
        <CPlayer_GetLastPlayedTimes_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Request {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Request {
        ::std::default::Default::default()
    }

    // optional uint32 min_last_played = 1;


    pub fn get_min_last_played(&self) -> u32 {
        self.min_last_played.unwrap_or(0)
    }
    pub fn clear_min_last_played(&mut self) {
        self.min_last_played = ::std::option::Option::None;
    }

    pub fn has_min_last_played(&self) -> bool {
        self.min_last_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_last_played(&mut self, v: u32) {
        self.min_last_played = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min_last_played = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.min_last_played {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.min_last_played {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Request {
        CPlayer_GetLastPlayedTimes_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "min_last_played",
                |m: &CPlayer_GetLastPlayedTimes_Request| { &m.min_last_played },
                |m: &mut CPlayer_GetLastPlayedTimes_Request| { &mut m.min_last_played },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetLastPlayedTimes_Request>(
                "CPlayer_GetLastPlayedTimes_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetLastPlayedTimes_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetLastPlayedTimes_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Request {
    fn clear(&mut self) {
        self.min_last_played = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetLastPlayedTimes_Response {
    // message fields
    pub games: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Response {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Response {
        <CPlayer_GetLastPlayedTimes_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Response {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetLastPlayedTimes_Response.Game games = 1;


    pub fn get_games(&self) -> &[CPlayer_GetLastPlayedTimes_Response_Game] {
        &self.games
    }
    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Response {
        CPlayer_GetLastPlayedTimes_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetLastPlayedTimes_Response_Game>>(
                "games",
                |m: &CPlayer_GetLastPlayedTimes_Response| { &m.games },
                |m: &mut CPlayer_GetLastPlayedTimes_Response| { &mut m.games },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetLastPlayedTimes_Response>(
                "CPlayer_GetLastPlayedTimes_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetLastPlayedTimes_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetLastPlayedTimes_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Response {
    fn clear(&mut self) {
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetLastPlayedTimes_Response_Game {
    // message fields
    appid: ::std::option::Option<i32>,
    last_playtime: ::std::option::Option<u32>,
    playtime_2weeks: ::std::option::Option<i32>,
    playtime_forever: ::std::option::Option<i32>,
    first_playtime: ::std::option::Option<u32>,
    playtime_windows_forever: ::std::option::Option<i32>,
    playtime_mac_forever: ::std::option::Option<i32>,
    playtime_linux_forever: ::std::option::Option<i32>,
    first_windows_playtime: ::std::option::Option<u32>,
    first_mac_playtime: ::std::option::Option<u32>,
    first_linux_playtime: ::std::option::Option<u32>,
    last_windows_playtime: ::std::option::Option<u32>,
    last_mac_playtime: ::std::option::Option<u32>,
    last_linux_playtime: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Response_Game {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Response_Game {
        <CPlayer_GetLastPlayedTimes_Response_Game as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Response_Game {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Response_Game {
        ::std::default::Default::default()
    }

    // optional int32 appid = 1;


    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 last_playtime = 2;


    pub fn get_last_playtime(&self) -> u32 {
        self.last_playtime.unwrap_or(0)
    }
    pub fn clear_last_playtime(&mut self) {
        self.last_playtime = ::std::option::Option::None;
    }

    pub fn has_last_playtime(&self) -> bool {
        self.last_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_playtime(&mut self, v: u32) {
        self.last_playtime = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_2weeks = 3;


    pub fn get_playtime_2weeks(&self) -> i32 {
        self.playtime_2weeks.unwrap_or(0)
    }
    pub fn clear_playtime_2weeks(&mut self) {
        self.playtime_2weeks = ::std::option::Option::None;
    }

    pub fn has_playtime_2weeks(&self) -> bool {
        self.playtime_2weeks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_2weeks(&mut self, v: i32) {
        self.playtime_2weeks = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_forever = 4;


    pub fn get_playtime_forever(&self) -> i32 {
        self.playtime_forever.unwrap_or(0)
    }
    pub fn clear_playtime_forever(&mut self) {
        self.playtime_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_forever(&self) -> bool {
        self.playtime_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_forever(&mut self, v: i32) {
        self.playtime_forever = ::std::option::Option::Some(v);
    }

    // optional uint32 first_playtime = 5;


    pub fn get_first_playtime(&self) -> u32 {
        self.first_playtime.unwrap_or(0)
    }
    pub fn clear_first_playtime(&mut self) {
        self.first_playtime = ::std::option::Option::None;
    }

    pub fn has_first_playtime(&self) -> bool {
        self.first_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_playtime(&mut self, v: u32) {
        self.first_playtime = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_windows_forever = 6;


    pub fn get_playtime_windows_forever(&self) -> i32 {
        self.playtime_windows_forever.unwrap_or(0)
    }
    pub fn clear_playtime_windows_forever(&mut self) {
        self.playtime_windows_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_windows_forever(&self) -> bool {
        self.playtime_windows_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_windows_forever(&mut self, v: i32) {
        self.playtime_windows_forever = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_mac_forever = 7;


    pub fn get_playtime_mac_forever(&self) -> i32 {
        self.playtime_mac_forever.unwrap_or(0)
    }
    pub fn clear_playtime_mac_forever(&mut self) {
        self.playtime_mac_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_mac_forever(&self) -> bool {
        self.playtime_mac_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_mac_forever(&mut self, v: i32) {
        self.playtime_mac_forever = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_linux_forever = 8;


    pub fn get_playtime_linux_forever(&self) -> i32 {
        self.playtime_linux_forever.unwrap_or(0)
    }
    pub fn clear_playtime_linux_forever(&mut self) {
        self.playtime_linux_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_linux_forever(&self) -> bool {
        self.playtime_linux_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_linux_forever(&mut self, v: i32) {
        self.playtime_linux_forever = ::std::option::Option::Some(v);
    }

    // optional uint32 first_windows_playtime = 9;


    pub fn get_first_windows_playtime(&self) -> u32 {
        self.first_windows_playtime.unwrap_or(0)
    }
    pub fn clear_first_windows_playtime(&mut self) {
        self.first_windows_playtime = ::std::option::Option::None;
    }

    pub fn has_first_windows_playtime(&self) -> bool {
        self.first_windows_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_windows_playtime(&mut self, v: u32) {
        self.first_windows_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 first_mac_playtime = 10;


    pub fn get_first_mac_playtime(&self) -> u32 {
        self.first_mac_playtime.unwrap_or(0)
    }
    pub fn clear_first_mac_playtime(&mut self) {
        self.first_mac_playtime = ::std::option::Option::None;
    }

    pub fn has_first_mac_playtime(&self) -> bool {
        self.first_mac_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_mac_playtime(&mut self, v: u32) {
        self.first_mac_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 first_linux_playtime = 11;


    pub fn get_first_linux_playtime(&self) -> u32 {
        self.first_linux_playtime.unwrap_or(0)
    }
    pub fn clear_first_linux_playtime(&mut self) {
        self.first_linux_playtime = ::std::option::Option::None;
    }

    pub fn has_first_linux_playtime(&self) -> bool {
        self.first_linux_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_linux_playtime(&mut self, v: u32) {
        self.first_linux_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 last_windows_playtime = 12;


    pub fn get_last_windows_playtime(&self) -> u32 {
        self.last_windows_playtime.unwrap_or(0)
    }
    pub fn clear_last_windows_playtime(&mut self) {
        self.last_windows_playtime = ::std::option::Option::None;
    }

    pub fn has_last_windows_playtime(&self) -> bool {
        self.last_windows_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_windows_playtime(&mut self, v: u32) {
        self.last_windows_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 last_mac_playtime = 13;


    pub fn get_last_mac_playtime(&self) -> u32 {
        self.last_mac_playtime.unwrap_or(0)
    }
    pub fn clear_last_mac_playtime(&mut self) {
        self.last_mac_playtime = ::std::option::Option::None;
    }

    pub fn has_last_mac_playtime(&self) -> bool {
        self.last_mac_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_mac_playtime(&mut self, v: u32) {
        self.last_mac_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 last_linux_playtime = 14;


    pub fn get_last_linux_playtime(&self) -> u32 {
        self.last_linux_playtime.unwrap_or(0)
    }
    pub fn clear_last_linux_playtime(&mut self) {
        self.last_linux_playtime = ::std::option::Option::None;
    }

    pub fn has_last_linux_playtime(&self) -> bool {
        self.last_linux_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_linux_playtime(&mut self, v: u32) {
        self.last_linux_playtime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Response_Game {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_playtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_2weeks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_forever = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_playtime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_windows_forever = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_mac_forever = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_linux_forever = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_windows_playtime = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_mac_playtime = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_linux_playtime = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_windows_playtime = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_mac_playtime = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_linux_playtime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_playtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_2weeks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_forever {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_playtime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_windows_forever {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_mac_forever {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_linux_forever {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_windows_playtime {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_mac_playtime {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_linux_playtime {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_windows_playtime {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_mac_playtime {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_linux_playtime {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.last_playtime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.playtime_2weeks {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.playtime_forever {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.first_playtime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.playtime_windows_forever {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.playtime_mac_forever {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.playtime_linux_forever {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.first_windows_playtime {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.first_mac_playtime {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.first_linux_playtime {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.last_windows_playtime {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.last_mac_playtime {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.last_linux_playtime {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Response_Game {
        CPlayer_GetLastPlayedTimes_Response_Game::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "appid",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.appid },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_2weeks",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_2weeks },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_2weeks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_forever",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_forever },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "first_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_windows_forever",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_windows_forever },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_windows_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_mac_forever",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_mac_forever },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_mac_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playtime_linux_forever",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_linux_forever },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_linux_forever },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "first_windows_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_windows_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_windows_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "first_mac_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_mac_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_mac_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "first_linux_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_linux_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_linux_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_windows_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_windows_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_windows_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_mac_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_mac_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_mac_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_linux_playtime",
                |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_linux_playtime },
                |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_linux_playtime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetLastPlayedTimes_Response_Game>(
                "CPlayer_GetLastPlayedTimes_Response.Game",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Response_Game {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetLastPlayedTimes_Response_Game> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetLastPlayedTimes_Response_Game::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Response_Game {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.last_playtime = ::std::option::Option::None;
        self.playtime_2weeks = ::std::option::Option::None;
        self.playtime_forever = ::std::option::Option::None;
        self.first_playtime = ::std::option::Option::None;
        self.playtime_windows_forever = ::std::option::Option::None;
        self.playtime_mac_forever = ::std::option::Option::None;
        self.playtime_linux_forever = ::std::option::Option::None;
        self.first_windows_playtime = ::std::option::Option::None;
        self.first_mac_playtime = ::std::option::Option::None;
        self.first_linux_playtime = ::std::option::Option::None;
        self.last_windows_playtime = ::std::option::Option::None;
        self.last_mac_playtime = ::std::option::Option::None;
        self.last_linux_playtime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Response_Game {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Response_Game {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AcceptSSA_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AcceptSSA_Request {
    fn default() -> &'a CPlayer_AcceptSSA_Request {
        <CPlayer_AcceptSSA_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AcceptSSA_Request {
    pub fn new() -> CPlayer_AcceptSSA_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_AcceptSSA_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AcceptSSA_Request {
        CPlayer_AcceptSSA_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_AcceptSSA_Request>(
                "CPlayer_AcceptSSA_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AcceptSSA_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_AcceptSSA_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_AcceptSSA_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_AcceptSSA_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AcceptSSA_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AcceptSSA_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AcceptSSA_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AcceptSSA_Response {
    fn default() -> &'a CPlayer_AcceptSSA_Response {
        <CPlayer_AcceptSSA_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AcceptSSA_Response {
    pub fn new() -> CPlayer_AcceptSSA_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_AcceptSSA_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AcceptSSA_Response {
        CPlayer_AcceptSSA_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_AcceptSSA_Response>(
                "CPlayer_AcceptSSA_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AcceptSSA_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_AcceptSSA_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_AcceptSSA_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_AcceptSSA_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AcceptSSA_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AcceptSSA_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNicknameList_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Request {
    fn default() -> &'a CPlayer_GetNicknameList_Request {
        <CPlayer_GetNicknameList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Request {
    pub fn new() -> CPlayer_GetNicknameList_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Request {
        CPlayer_GetNicknameList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetNicknameList_Request>(
                "CPlayer_GetNicknameList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetNicknameList_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetNicknameList_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNicknameList_Response {
    // message fields
    pub nicknames: ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Response {
    fn default() -> &'a CPlayer_GetNicknameList_Response {
        <CPlayer_GetNicknameList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Response {
    pub fn new() -> CPlayer_GetNicknameList_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetNicknameList_Response.PlayerNickname nicknames = 1;


    pub fn get_nicknames(&self) -> &[CPlayer_GetNicknameList_Response_PlayerNickname] {
        &self.nicknames
    }
    pub fn clear_nicknames(&mut self) {
        self.nicknames.clear();
    }

    // Param is passed by value, moved
    pub fn set_nicknames(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname>) {
        self.nicknames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nicknames(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname> {
        &mut self.nicknames
    }

    // Take field
    pub fn take_nicknames(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname> {
        ::std::mem::replace(&mut self.nicknames, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.nicknames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nicknames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nicknames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nicknames {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Response {
        CPlayer_GetNicknameList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetNicknameList_Response_PlayerNickname>>(
                "nicknames",
                |m: &CPlayer_GetNicknameList_Response| { &m.nicknames },
                |m: &mut CPlayer_GetNicknameList_Response| { &mut m.nicknames },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetNicknameList_Response>(
                "CPlayer_GetNicknameList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetNicknameList_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetNicknameList_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Response {
    fn clear(&mut self) {
        self.nicknames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNicknameList_Response_PlayerNickname {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Response_PlayerNickname {
    fn default() -> &'a CPlayer_GetNicknameList_Response_PlayerNickname {
        <CPlayer_GetNicknameList_Response_PlayerNickname as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Response_PlayerNickname {
    pub fn new() -> CPlayer_GetNicknameList_Response_PlayerNickname {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Response_PlayerNickname {
        CPlayer_GetNicknameList_Response_PlayerNickname::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "accountid",
                |m: &CPlayer_GetNicknameList_Response_PlayerNickname| { &m.accountid },
                |m: &mut CPlayer_GetNicknameList_Response_PlayerNickname| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nickname",
                |m: &CPlayer_GetNicknameList_Response_PlayerNickname| { &m.nickname },
                |m: &mut CPlayer_GetNicknameList_Response_PlayerNickname| { &mut m.nickname },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetNicknameList_Response_PlayerNickname>(
                "CPlayer_GetNicknameList_Response.PlayerNickname",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Response_PlayerNickname {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetNicknameList_Response_PlayerNickname> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetNicknameList_Response_PlayerNickname::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPerFriendPreferences_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPerFriendPreferences_Request {
    fn default() -> &'a CPlayer_GetPerFriendPreferences_Request {
        <CPlayer_GetPerFriendPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPerFriendPreferences_Request {
    pub fn new() -> CPlayer_GetPerFriendPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPerFriendPreferences_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPerFriendPreferences_Request {
        CPlayer_GetPerFriendPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPerFriendPreferences_Request>(
                "CPlayer_GetPerFriendPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPerFriendPreferences_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPerFriendPreferences_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPerFriendPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPerFriendPreferences_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPerFriendPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPerFriendPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PerFriendPreferences {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    notifications_showingame: ::std::option::Option<ENotificationSetting>,
    notifications_showonline: ::std::option::Option<ENotificationSetting>,
    notifications_showmessages: ::std::option::Option<ENotificationSetting>,
    sounds_showingame: ::std::option::Option<ENotificationSetting>,
    sounds_showonline: ::std::option::Option<ENotificationSetting>,
    sounds_showmessages: ::std::option::Option<ENotificationSetting>,
    notifications_sendmobile: ::std::option::Option<ENotificationSetting>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerFriendPreferences {
    fn default() -> &'a PerFriendPreferences {
        <PerFriendPreferences as ::protobuf::Message>::default_instance()
    }
}

impl PerFriendPreferences {
    pub fn new() -> PerFriendPreferences {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ENotificationSetting notifications_showingame = 3;


    pub fn get_notifications_showingame(&self) -> ENotificationSetting {
        self.notifications_showingame.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_showingame(&mut self) {
        self.notifications_showingame = ::std::option::Option::None;
    }

    pub fn has_notifications_showingame(&self) -> bool {
        self.notifications_showingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showingame(&mut self, v: ENotificationSetting) {
        self.notifications_showingame = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting notifications_showonline = 4;


    pub fn get_notifications_showonline(&self) -> ENotificationSetting {
        self.notifications_showonline.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_showonline(&mut self) {
        self.notifications_showonline = ::std::option::Option::None;
    }

    pub fn has_notifications_showonline(&self) -> bool {
        self.notifications_showonline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showonline(&mut self, v: ENotificationSetting) {
        self.notifications_showonline = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting notifications_showmessages = 5;


    pub fn get_notifications_showmessages(&self) -> ENotificationSetting {
        self.notifications_showmessages.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_showmessages(&mut self) {
        self.notifications_showmessages = ::std::option::Option::None;
    }

    pub fn has_notifications_showmessages(&self) -> bool {
        self.notifications_showmessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showmessages(&mut self, v: ENotificationSetting) {
        self.notifications_showmessages = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting sounds_showingame = 6;


    pub fn get_sounds_showingame(&self) -> ENotificationSetting {
        self.sounds_showingame.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_sounds_showingame(&mut self) {
        self.sounds_showingame = ::std::option::Option::None;
    }

    pub fn has_sounds_showingame(&self) -> bool {
        self.sounds_showingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showingame(&mut self, v: ENotificationSetting) {
        self.sounds_showingame = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting sounds_showonline = 7;


    pub fn get_sounds_showonline(&self) -> ENotificationSetting {
        self.sounds_showonline.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_sounds_showonline(&mut self) {
        self.sounds_showonline = ::std::option::Option::None;
    }

    pub fn has_sounds_showonline(&self) -> bool {
        self.sounds_showonline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showonline(&mut self, v: ENotificationSetting) {
        self.sounds_showonline = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting sounds_showmessages = 8;


    pub fn get_sounds_showmessages(&self) -> ENotificationSetting {
        self.sounds_showmessages.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_sounds_showmessages(&mut self) {
        self.sounds_showmessages = ::std::option::Option::None;
    }

    pub fn has_sounds_showmessages(&self) -> bool {
        self.sounds_showmessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showmessages(&mut self, v: ENotificationSetting) {
        self.sounds_showmessages = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting notifications_sendmobile = 9;


    pub fn get_notifications_sendmobile(&self) -> ENotificationSetting {
        self.notifications_sendmobile.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_sendmobile(&mut self) {
        self.notifications_sendmobile = ::std::option::Option::None;
    }

    pub fn has_notifications_sendmobile(&self) -> bool {
        self.notifications_sendmobile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_sendmobile(&mut self, v: ENotificationSetting) {
        self.notifications_sendmobile = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PerFriendPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_showingame, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_showonline, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_showmessages, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sounds_showingame, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sounds_showonline, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sounds_showmessages, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_sendmobile, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.notifications_showingame {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.notifications_showonline {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.notifications_showmessages {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.sounds_showingame {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.sounds_showonline {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(v) = self.sounds_showmessages {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.notifications_sendmobile {
            my_size += ::protobuf::rt::enum_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.notifications_showingame {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.notifications_showonline {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.notifications_showmessages {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.sounds_showingame {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.sounds_showonline {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.sounds_showmessages {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.notifications_sendmobile {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerFriendPreferences {
        PerFriendPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "accountid",
                |m: &PerFriendPreferences| { &m.accountid },
                |m: &mut PerFriendPreferences| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nickname",
                |m: &PerFriendPreferences| { &m.nickname },
                |m: &mut PerFriendPreferences| { &mut m.nickname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                "notifications_showingame",
                |m: &PerFriendPreferences| { &m.notifications_showingame },
                |m: &mut PerFriendPreferences| { &mut m.notifications_showingame },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                "notifications_showonline",
                |m: &PerFriendPreferences| { &m.notifications_showonline },
                |m: &mut PerFriendPreferences| { &mut m.notifications_showonline },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                "notifications_showmessages",
                |m: &PerFriendPreferences| { &m.notifications_showmessages },
                |m: &mut PerFriendPreferences| { &mut m.notifications_showmessages },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                "sounds_showingame",
                |m: &PerFriendPreferences| { &m.sounds_showingame },
                |m: &mut PerFriendPreferences| { &mut m.sounds_showingame },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                "sounds_showonline",
                |m: &PerFriendPreferences| { &m.sounds_showonline },
                |m: &mut PerFriendPreferences| { &mut m.sounds_showonline },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                "sounds_showmessages",
                |m: &PerFriendPreferences| { &m.sounds_showmessages },
                |m: &mut PerFriendPreferences| { &mut m.sounds_showmessages },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                "notifications_sendmobile",
                |m: &PerFriendPreferences| { &m.notifications_sendmobile },
                |m: &mut PerFriendPreferences| { &mut m.notifications_sendmobile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PerFriendPreferences>(
                "PerFriendPreferences",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PerFriendPreferences {
        static instance: ::protobuf::rt::LazyV2<PerFriendPreferences> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerFriendPreferences::new)
    }
}

impl ::protobuf::Clear for PerFriendPreferences {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.notifications_showingame = ::std::option::Option::None;
        self.notifications_showonline = ::std::option::Option::None;
        self.notifications_showmessages = ::std::option::Option::None;
        self.sounds_showingame = ::std::option::Option::None;
        self.sounds_showonline = ::std::option::Option::None;
        self.sounds_showmessages = ::std::option::Option::None;
        self.notifications_sendmobile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerFriendPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerFriendPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPerFriendPreferences_Response {
    // message fields
    pub preferences: ::protobuf::RepeatedField<PerFriendPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPerFriendPreferences_Response {
    fn default() -> &'a CPlayer_GetPerFriendPreferences_Response {
        <CPlayer_GetPerFriendPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPerFriendPreferences_Response {
    pub fn new() -> CPlayer_GetPerFriendPreferences_Response {
        ::std::default::Default::default()
    }

    // repeated .PerFriendPreferences preferences = 1;


    pub fn get_preferences(&self) -> &[PerFriendPreferences] {
        &self.preferences
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: ::protobuf::RepeatedField<PerFriendPreferences>) {
        self.preferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferences(&mut self) -> &mut ::protobuf::RepeatedField<PerFriendPreferences> {
        &mut self.preferences
    }

    // Take field
    pub fn take_preferences(&mut self) -> ::protobuf::RepeatedField<PerFriendPreferences> {
        ::std::mem::replace(&mut self.preferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetPerFriendPreferences_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.preferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.preferences {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPerFriendPreferences_Response {
        CPlayer_GetPerFriendPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerFriendPreferences>>(
                "preferences",
                |m: &CPlayer_GetPerFriendPreferences_Response| { &m.preferences },
                |m: &mut CPlayer_GetPerFriendPreferences_Response| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPerFriendPreferences_Response>(
                "CPlayer_GetPerFriendPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPerFriendPreferences_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPerFriendPreferences_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPerFriendPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPerFriendPreferences_Response {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPerFriendPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPerFriendPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetPerFriendPreferences_Request {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<PerFriendPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetPerFriendPreferences_Request {
    fn default() -> &'a CPlayer_SetPerFriendPreferences_Request {
        <CPlayer_SetPerFriendPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetPerFriendPreferences_Request {
    pub fn new() -> CPlayer_SetPerFriendPreferences_Request {
        ::std::default::Default::default()
    }

    // optional .PerFriendPreferences preferences = 1;


    pub fn get_preferences(&self) -> &PerFriendPreferences {
        self.preferences.as_ref().unwrap_or_else(|| <PerFriendPreferences as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: PerFriendPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut PerFriendPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> PerFriendPreferences {
        self.preferences.take().unwrap_or_else(|| PerFriendPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_SetPerFriendPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetPerFriendPreferences_Request {
        CPlayer_SetPerFriendPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerFriendPreferences>>(
                "preferences",
                |m: &CPlayer_SetPerFriendPreferences_Request| { &m.preferences },
                |m: &mut CPlayer_SetPerFriendPreferences_Request| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetPerFriendPreferences_Request>(
                "CPlayer_SetPerFriendPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetPerFriendPreferences_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetPerFriendPreferences_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetPerFriendPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetPerFriendPreferences_Request {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetPerFriendPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetPerFriendPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetPerFriendPreferences_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetPerFriendPreferences_Response {
    fn default() -> &'a CPlayer_SetPerFriendPreferences_Response {
        <CPlayer_SetPerFriendPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetPerFriendPreferences_Response {
    pub fn new() -> CPlayer_SetPerFriendPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetPerFriendPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetPerFriendPreferences_Response {
        CPlayer_SetPerFriendPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetPerFriendPreferences_Response>(
                "CPlayer_SetPerFriendPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetPerFriendPreferences_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetPerFriendPreferences_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetPerFriendPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetPerFriendPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetPerFriendPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetPerFriendPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AddFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AddFriend_Request {
    fn default() -> &'a CPlayer_AddFriend_Request {
        <CPlayer_AddFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AddFriend_Request {
    pub fn new() -> CPlayer_AddFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_AddFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AddFriend_Request {
        CPlayer_AddFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_AddFriend_Request| { &m.steamid },
                |m: &mut CPlayer_AddFriend_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_AddFriend_Request>(
                "CPlayer_AddFriend_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AddFriend_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_AddFriend_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_AddFriend_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_AddFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AddFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AddFriend_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AddFriend_Response {
    // message fields
    invite_sent: ::std::option::Option<bool>,
    friend_relationship: ::std::option::Option<u32>,
    result: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AddFriend_Response {
    fn default() -> &'a CPlayer_AddFriend_Response {
        <CPlayer_AddFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AddFriend_Response {
    pub fn new() -> CPlayer_AddFriend_Response {
        ::std::default::Default::default()
    }

    // optional bool invite_sent = 1;


    pub fn get_invite_sent(&self) -> bool {
        self.invite_sent.unwrap_or(false)
    }
    pub fn clear_invite_sent(&mut self) {
        self.invite_sent = ::std::option::Option::None;
    }

    pub fn has_invite_sent(&self) -> bool {
        self.invite_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_sent(&mut self, v: bool) {
        self.invite_sent = ::std::option::Option::Some(v);
    }

    // optional uint32 friend_relationship = 2;


    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }
    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }

    // optional int32 result = 3;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_AddFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invite_sent = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friend_relationship = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.invite_sent {
            my_size += 2;
        }
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.invite_sent {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.friend_relationship {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AddFriend_Response {
        CPlayer_AddFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "invite_sent",
                |m: &CPlayer_AddFriend_Response| { &m.invite_sent },
                |m: &mut CPlayer_AddFriend_Response| { &mut m.invite_sent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "friend_relationship",
                |m: &CPlayer_AddFriend_Response| { &m.friend_relationship },
                |m: &mut CPlayer_AddFriend_Response| { &mut m.friend_relationship },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &CPlayer_AddFriend_Response| { &m.result },
                |m: &mut CPlayer_AddFriend_Response| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_AddFriend_Response>(
                "CPlayer_AddFriend_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AddFriend_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_AddFriend_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_AddFriend_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_AddFriend_Response {
    fn clear(&mut self) {
        self.invite_sent = ::std::option::Option::None;
        self.friend_relationship = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AddFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AddFriend_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_RemoveFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_RemoveFriend_Request {
    fn default() -> &'a CPlayer_RemoveFriend_Request {
        <CPlayer_RemoveFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_RemoveFriend_Request {
    pub fn new() -> CPlayer_RemoveFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_RemoveFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_RemoveFriend_Request {
        CPlayer_RemoveFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_RemoveFriend_Request| { &m.steamid },
                |m: &mut CPlayer_RemoveFriend_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_RemoveFriend_Request>(
                "CPlayer_RemoveFriend_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_RemoveFriend_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_RemoveFriend_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_RemoveFriend_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_RemoveFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_RemoveFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_RemoveFriend_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_RemoveFriend_Response {
    // message fields
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_RemoveFriend_Response {
    fn default() -> &'a CPlayer_RemoveFriend_Response {
        <CPlayer_RemoveFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_RemoveFriend_Response {
    pub fn new() -> CPlayer_RemoveFriend_Response {
        ::std::default::Default::default()
    }

    // optional uint32 friend_relationship = 1;


    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }
    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_RemoveFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friend_relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_relationship {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_RemoveFriend_Response {
        CPlayer_RemoveFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "friend_relationship",
                |m: &CPlayer_RemoveFriend_Response| { &m.friend_relationship },
                |m: &mut CPlayer_RemoveFriend_Response| { &mut m.friend_relationship },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_RemoveFriend_Response>(
                "CPlayer_RemoveFriend_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_RemoveFriend_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_RemoveFriend_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_RemoveFriend_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_RemoveFriend_Response {
    fn clear(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_RemoveFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_RemoveFriend_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_IgnoreFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    unignore: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IgnoreFriend_Request {
    fn default() -> &'a CPlayer_IgnoreFriend_Request {
        <CPlayer_IgnoreFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IgnoreFriend_Request {
    pub fn new() -> CPlayer_IgnoreFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool unignore = 2;


    pub fn get_unignore(&self) -> bool {
        self.unignore.unwrap_or(false)
    }
    pub fn clear_unignore(&mut self) {
        self.unignore = ::std::option::Option::None;
    }

    pub fn has_unignore(&self) -> bool {
        self.unignore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unignore(&mut self, v: bool) {
        self.unignore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_IgnoreFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unignore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.unignore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unignore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IgnoreFriend_Request {
        CPlayer_IgnoreFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CPlayer_IgnoreFriend_Request| { &m.steamid },
                |m: &mut CPlayer_IgnoreFriend_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unignore",
                |m: &CPlayer_IgnoreFriend_Request| { &m.unignore },
                |m: &mut CPlayer_IgnoreFriend_Request| { &mut m.unignore },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_IgnoreFriend_Request>(
                "CPlayer_IgnoreFriend_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_IgnoreFriend_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_IgnoreFriend_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_IgnoreFriend_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_IgnoreFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unignore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IgnoreFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IgnoreFriend_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_IgnoreFriend_Response {
    // message fields
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IgnoreFriend_Response {
    fn default() -> &'a CPlayer_IgnoreFriend_Response {
        <CPlayer_IgnoreFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IgnoreFriend_Response {
    pub fn new() -> CPlayer_IgnoreFriend_Response {
        ::std::default::Default::default()
    }

    // optional uint32 friend_relationship = 1;


    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }
    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_IgnoreFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friend_relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_relationship {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IgnoreFriend_Response {
        CPlayer_IgnoreFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "friend_relationship",
                |m: &CPlayer_IgnoreFriend_Response| { &m.friend_relationship },
                |m: &mut CPlayer_IgnoreFriend_Response| { &mut m.friend_relationship },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_IgnoreFriend_Response>(
                "CPlayer_IgnoreFriend_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_IgnoreFriend_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_IgnoreFriend_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_IgnoreFriend_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_IgnoreFriend_Response {
    fn clear(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IgnoreFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IgnoreFriend_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetCommunityPreferences_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetCommunityPreferences_Request {
    fn default() -> &'a CPlayer_GetCommunityPreferences_Request {
        <CPlayer_GetCommunityPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetCommunityPreferences_Request {
    pub fn new() -> CPlayer_GetCommunityPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetCommunityPreferences_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetCommunityPreferences_Request {
        CPlayer_GetCommunityPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetCommunityPreferences_Request>(
                "CPlayer_GetCommunityPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetCommunityPreferences_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetCommunityPreferences_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetCommunityPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetCommunityPreferences_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetCommunityPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetCommunityPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_CommunityPreferences {
    // message fields
    hide_adult_content_violence: ::std::option::Option<bool>,
    hide_adult_content_sex: ::std::option::Option<bool>,
    parenthesize_nicknames: ::std::option::Option<bool>,
    text_filter_setting: ::std::option::Option<ETextFilterSetting>,
    text_filter_ignore_friends: ::std::option::Option<bool>,
    timestamp_updated: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_CommunityPreferences {
    fn default() -> &'a CPlayer_CommunityPreferences {
        <CPlayer_CommunityPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_CommunityPreferences {
    pub fn new() -> CPlayer_CommunityPreferences {
        ::std::default::Default::default()
    }

    // optional bool hide_adult_content_violence = 1;


    pub fn get_hide_adult_content_violence(&self) -> bool {
        self.hide_adult_content_violence.unwrap_or(true)
    }
    pub fn clear_hide_adult_content_violence(&mut self) {
        self.hide_adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_hide_adult_content_violence(&self) -> bool {
        self.hide_adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_adult_content_violence(&mut self, v: bool) {
        self.hide_adult_content_violence = ::std::option::Option::Some(v);
    }

    // optional bool hide_adult_content_sex = 2;


    pub fn get_hide_adult_content_sex(&self) -> bool {
        self.hide_adult_content_sex.unwrap_or(true)
    }
    pub fn clear_hide_adult_content_sex(&mut self) {
        self.hide_adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_hide_adult_content_sex(&self) -> bool {
        self.hide_adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_adult_content_sex(&mut self, v: bool) {
        self.hide_adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional bool parenthesize_nicknames = 4;


    pub fn get_parenthesize_nicknames(&self) -> bool {
        self.parenthesize_nicknames.unwrap_or(false)
    }
    pub fn clear_parenthesize_nicknames(&mut self) {
        self.parenthesize_nicknames = ::std::option::Option::None;
    }

    pub fn has_parenthesize_nicknames(&self) -> bool {
        self.parenthesize_nicknames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parenthesize_nicknames(&mut self, v: bool) {
        self.parenthesize_nicknames = ::std::option::Option::Some(v);
    }

    // optional .ETextFilterSetting text_filter_setting = 5;


    pub fn get_text_filter_setting(&self) -> ETextFilterSetting {
        self.text_filter_setting.unwrap_or(ETextFilterSetting::k_ETextFilterSettingSteamLabOptedOut)
    }
    pub fn clear_text_filter_setting(&mut self) {
        self.text_filter_setting = ::std::option::Option::None;
    }

    pub fn has_text_filter_setting(&self) -> bool {
        self.text_filter_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_filter_setting(&mut self, v: ETextFilterSetting) {
        self.text_filter_setting = ::std::option::Option::Some(v);
    }

    // optional bool text_filter_ignore_friends = 6;


    pub fn get_text_filter_ignore_friends(&self) -> bool {
        self.text_filter_ignore_friends.unwrap_or(false)
    }
    pub fn clear_text_filter_ignore_friends(&mut self) {
        self.text_filter_ignore_friends = ::std::option::Option::None;
    }

    pub fn has_text_filter_ignore_friends(&self) -> bool {
        self.text_filter_ignore_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_filter_ignore_friends(&mut self, v: bool) {
        self.text_filter_ignore_friends = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 3;


    pub fn get_timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }
    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_CommunityPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_adult_content_violence = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_adult_content_sex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.parenthesize_nicknames = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.text_filter_setting, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.text_filter_ignore_friends = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp_updated = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hide_adult_content_violence {
            my_size += 2;
        }
        if let Some(v) = self.hide_adult_content_sex {
            my_size += 2;
        }
        if let Some(v) = self.parenthesize_nicknames {
            my_size += 2;
        }
        if let Some(v) = self.text_filter_setting {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.text_filter_ignore_friends {
            my_size += 2;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hide_adult_content_violence {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.hide_adult_content_sex {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.parenthesize_nicknames {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.text_filter_setting {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.text_filter_ignore_friends {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_CommunityPreferences {
        CPlayer_CommunityPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hide_adult_content_violence",
                |m: &CPlayer_CommunityPreferences| { &m.hide_adult_content_violence },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.hide_adult_content_violence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hide_adult_content_sex",
                |m: &CPlayer_CommunityPreferences| { &m.hide_adult_content_sex },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.hide_adult_content_sex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "parenthesize_nicknames",
                |m: &CPlayer_CommunityPreferences| { &m.parenthesize_nicknames },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.parenthesize_nicknames },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETextFilterSetting>>(
                "text_filter_setting",
                |m: &CPlayer_CommunityPreferences| { &m.text_filter_setting },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.text_filter_setting },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "text_filter_ignore_friends",
                |m: &CPlayer_CommunityPreferences| { &m.text_filter_ignore_friends },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.text_filter_ignore_friends },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp_updated",
                |m: &CPlayer_CommunityPreferences| { &m.timestamp_updated },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.timestamp_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_CommunityPreferences>(
                "CPlayer_CommunityPreferences",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_CommunityPreferences {
        static instance: ::protobuf::rt::LazyV2<CPlayer_CommunityPreferences> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_CommunityPreferences::new)
    }
}

impl ::protobuf::Clear for CPlayer_CommunityPreferences {
    fn clear(&mut self) {
        self.hide_adult_content_violence = ::std::option::Option::None;
        self.hide_adult_content_sex = ::std::option::Option::None;
        self.parenthesize_nicknames = ::std::option::Option::None;
        self.text_filter_setting = ::std::option::Option::None;
        self.text_filter_ignore_friends = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_CommunityPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_CommunityPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetCommunityPreferences_Response {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetCommunityPreferences_Response {
    fn default() -> &'a CPlayer_GetCommunityPreferences_Response {
        <CPlayer_GetCommunityPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetCommunityPreferences_Response {
    pub fn new() -> CPlayer_GetCommunityPreferences_Response {
        ::std::default::Default::default()
    }

    // optional .CPlayer_CommunityPreferences preferences = 1;


    pub fn get_preferences(&self) -> &CPlayer_CommunityPreferences {
        self.preferences.as_ref().unwrap_or_else(|| <CPlayer_CommunityPreferences as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CPlayer_CommunityPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CPlayer_CommunityPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CPlayer_CommunityPreferences {
        self.preferences.take().unwrap_or_else(|| CPlayer_CommunityPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_GetCommunityPreferences_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetCommunityPreferences_Response {
        CPlayer_GetCommunityPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>>(
                "preferences",
                |m: &CPlayer_GetCommunityPreferences_Response| { &m.preferences },
                |m: &mut CPlayer_GetCommunityPreferences_Response| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetCommunityPreferences_Response>(
                "CPlayer_GetCommunityPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetCommunityPreferences_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetCommunityPreferences_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetCommunityPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetCommunityPreferences_Response {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetCommunityPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetCommunityPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetCommunityPreferences_Request {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetCommunityPreferences_Request {
    fn default() -> &'a CPlayer_SetCommunityPreferences_Request {
        <CPlayer_SetCommunityPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetCommunityPreferences_Request {
    pub fn new() -> CPlayer_SetCommunityPreferences_Request {
        ::std::default::Default::default()
    }

    // optional .CPlayer_CommunityPreferences preferences = 1;


    pub fn get_preferences(&self) -> &CPlayer_CommunityPreferences {
        self.preferences.as_ref().unwrap_or_else(|| <CPlayer_CommunityPreferences as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CPlayer_CommunityPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CPlayer_CommunityPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CPlayer_CommunityPreferences {
        self.preferences.take().unwrap_or_else(|| CPlayer_CommunityPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_SetCommunityPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetCommunityPreferences_Request {
        CPlayer_SetCommunityPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>>(
                "preferences",
                |m: &CPlayer_SetCommunityPreferences_Request| { &m.preferences },
                |m: &mut CPlayer_SetCommunityPreferences_Request| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetCommunityPreferences_Request>(
                "CPlayer_SetCommunityPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetCommunityPreferences_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetCommunityPreferences_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetCommunityPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetCommunityPreferences_Request {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetCommunityPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetCommunityPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetCommunityPreferences_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetCommunityPreferences_Response {
    fn default() -> &'a CPlayer_SetCommunityPreferences_Response {
        <CPlayer_SetCommunityPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetCommunityPreferences_Response {
    pub fn new() -> CPlayer_SetCommunityPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetCommunityPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetCommunityPreferences_Response {
        CPlayer_SetCommunityPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_SetCommunityPreferences_Response>(
                "CPlayer_SetCommunityPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetCommunityPreferences_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_SetCommunityPreferences_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_SetCommunityPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetCommunityPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetCommunityPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetCommunityPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetTextFilterWords_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetTextFilterWords_Request {
    fn default() -> &'a CPlayer_GetTextFilterWords_Request {
        <CPlayer_GetTextFilterWords_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetTextFilterWords_Request {
    pub fn new() -> CPlayer_GetTextFilterWords_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetTextFilterWords_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetTextFilterWords_Request {
        CPlayer_GetTextFilterWords_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetTextFilterWords_Request>(
                "CPlayer_GetTextFilterWords_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetTextFilterWords_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetTextFilterWords_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetTextFilterWords_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetTextFilterWords_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetTextFilterWords_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetTextFilterWords_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_TextFilterWords {
    // message fields
    pub text_filter_custom_banned_words: ::protobuf::RepeatedField<::std::string::String>,
    pub text_filter_custom_clean_words: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_TextFilterWords {
    fn default() -> &'a CPlayer_TextFilterWords {
        <CPlayer_TextFilterWords as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_TextFilterWords {
    pub fn new() -> CPlayer_TextFilterWords {
        ::std::default::Default::default()
    }

    // repeated string text_filter_custom_banned_words = 1;


    pub fn get_text_filter_custom_banned_words(&self) -> &[::std::string::String] {
        &self.text_filter_custom_banned_words
    }
    pub fn clear_text_filter_custom_banned_words(&mut self) {
        self.text_filter_custom_banned_words.clear();
    }

    // Param is passed by value, moved
    pub fn set_text_filter_custom_banned_words(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.text_filter_custom_banned_words = v;
    }

    // Mutable pointer to the field.
    pub fn mut_text_filter_custom_banned_words(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.text_filter_custom_banned_words
    }

    // Take field
    pub fn take_text_filter_custom_banned_words(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.text_filter_custom_banned_words, ::protobuf::RepeatedField::new())
    }

    // repeated string text_filter_custom_clean_words = 2;


    pub fn get_text_filter_custom_clean_words(&self) -> &[::std::string::String] {
        &self.text_filter_custom_clean_words
    }
    pub fn clear_text_filter_custom_clean_words(&mut self) {
        self.text_filter_custom_clean_words.clear();
    }

    // Param is passed by value, moved
    pub fn set_text_filter_custom_clean_words(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.text_filter_custom_clean_words = v;
    }

    // Mutable pointer to the field.
    pub fn mut_text_filter_custom_clean_words(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.text_filter_custom_clean_words
    }

    // Take field
    pub fn take_text_filter_custom_clean_words(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.text_filter_custom_clean_words, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_TextFilterWords {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.text_filter_custom_banned_words)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.text_filter_custom_clean_words)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.text_filter_custom_banned_words {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.text_filter_custom_clean_words {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.text_filter_custom_banned_words {
            os.write_string(1, &v)?;
        };
        for v in &self.text_filter_custom_clean_words {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_TextFilterWords {
        CPlayer_TextFilterWords::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text_filter_custom_banned_words",
                |m: &CPlayer_TextFilterWords| { &m.text_filter_custom_banned_words },
                |m: &mut CPlayer_TextFilterWords| { &mut m.text_filter_custom_banned_words },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text_filter_custom_clean_words",
                |m: &CPlayer_TextFilterWords| { &m.text_filter_custom_clean_words },
                |m: &mut CPlayer_TextFilterWords| { &mut m.text_filter_custom_clean_words },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_TextFilterWords>(
                "CPlayer_TextFilterWords",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_TextFilterWords {
        static instance: ::protobuf::rt::LazyV2<CPlayer_TextFilterWords> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_TextFilterWords::new)
    }
}

impl ::protobuf::Clear for CPlayer_TextFilterWords {
    fn clear(&mut self) {
        self.text_filter_custom_banned_words.clear();
        self.text_filter_custom_clean_words.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_TextFilterWords {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_TextFilterWords {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetTextFilterWords_Response {
    // message fields
    pub words: ::protobuf::SingularPtrField<CPlayer_TextFilterWords>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetTextFilterWords_Response {
    fn default() -> &'a CPlayer_GetTextFilterWords_Response {
        <CPlayer_GetTextFilterWords_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetTextFilterWords_Response {
    pub fn new() -> CPlayer_GetTextFilterWords_Response {
        ::std::default::Default::default()
    }

    // optional .CPlayer_TextFilterWords words = 1;


    pub fn get_words(&self) -> &CPlayer_TextFilterWords {
        self.words.as_ref().unwrap_or_else(|| <CPlayer_TextFilterWords as ::protobuf::Message>::default_instance())
    }
    pub fn clear_words(&mut self) {
        self.words.clear();
    }

    pub fn has_words(&self) -> bool {
        self.words.is_some()
    }

    // Param is passed by value, moved
    pub fn set_words(&mut self, v: CPlayer_TextFilterWords) {
        self.words = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_words(&mut self) -> &mut CPlayer_TextFilterWords {
        if self.words.is_none() {
            self.words.set_default();
        }
        self.words.as_mut().unwrap()
    }

    // Take field
    pub fn take_words(&mut self) -> CPlayer_TextFilterWords {
        self.words.take().unwrap_or_else(|| CPlayer_TextFilterWords::new())
    }
}

impl ::protobuf::Message for CPlayer_GetTextFilterWords_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.words {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.words)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.words.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.words.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetTextFilterWords_Response {
        CPlayer_GetTextFilterWords_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_TextFilterWords>>(
                "words",
                |m: &CPlayer_GetTextFilterWords_Response| { &m.words },
                |m: &mut CPlayer_GetTextFilterWords_Response| { &mut m.words },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetTextFilterWords_Response>(
                "CPlayer_GetTextFilterWords_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetTextFilterWords_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetTextFilterWords_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetTextFilterWords_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetTextFilterWords_Response {
    fn clear(&mut self) {
        self.words.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetTextFilterWords_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetTextFilterWords_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNewSteamAnnouncementState_Request {
    // message fields
    language: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNewSteamAnnouncementState_Request {
    fn default() -> &'a CPlayer_GetNewSteamAnnouncementState_Request {
        <CPlayer_GetNewSteamAnnouncementState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNewSteamAnnouncementState_Request {
    pub fn new() -> CPlayer_GetNewSteamAnnouncementState_Request {
        ::std::default::Default::default()
    }

    // optional int32 language = 1;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetNewSteamAnnouncementState_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.language {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNewSteamAnnouncementState_Request {
        CPlayer_GetNewSteamAnnouncementState_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "language",
                |m: &CPlayer_GetNewSteamAnnouncementState_Request| { &m.language },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Request| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetNewSteamAnnouncementState_Request>(
                "CPlayer_GetNewSteamAnnouncementState_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNewSteamAnnouncementState_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetNewSteamAnnouncementState_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetNewSteamAnnouncementState_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNewSteamAnnouncementState_Request {
    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNewSteamAnnouncementState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNewSteamAnnouncementState_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNewSteamAnnouncementState_Response {
    // message fields
    state: ::std::option::Option<i32>,
    announcement_headline: ::protobuf::SingularField<::std::string::String>,
    announcement_url: ::protobuf::SingularField<::std::string::String>,
    time_posted: ::std::option::Option<u32>,
    announcement_gid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNewSteamAnnouncementState_Response {
    fn default() -> &'a CPlayer_GetNewSteamAnnouncementState_Response {
        <CPlayer_GetNewSteamAnnouncementState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNewSteamAnnouncementState_Response {
    pub fn new() -> CPlayer_GetNewSteamAnnouncementState_Response {
        ::std::default::Default::default()
    }

    // optional int32 state = 1;


    pub fn get_state(&self) -> i32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string announcement_headline = 2;


    pub fn get_announcement_headline(&self) -> &str {
        match self.announcement_headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_headline(&mut self) {
        self.announcement_headline.clear();
    }

    pub fn has_announcement_headline(&self) -> bool {
        self.announcement_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_headline(&mut self, v: ::std::string::String) {
        self.announcement_headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_headline(&mut self) -> &mut ::std::string::String {
        if self.announcement_headline.is_none() {
            self.announcement_headline.set_default();
        }
        self.announcement_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_headline(&mut self) -> ::std::string::String {
        self.announcement_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement_url = 3;


    pub fn get_announcement_url(&self) -> &str {
        match self.announcement_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_url(&mut self) {
        self.announcement_url.clear();
    }

    pub fn has_announcement_url(&self) -> bool {
        self.announcement_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_url(&mut self, v: ::std::string::String) {
        self.announcement_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_url(&mut self) -> &mut ::std::string::String {
        if self.announcement_url.is_none() {
            self.announcement_url.set_default();
        }
        self.announcement_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_url(&mut self) -> ::std::string::String {
        self.announcement_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_posted = 4;


    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }
    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }

    // optional uint64 announcement_gid = 5;


    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }
    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetNewSteamAnnouncementState_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_headline)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_posted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.announcement_gid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNewSteamAnnouncementState_Response {
        CPlayer_GetNewSteamAnnouncementState_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "state",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.state },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "announcement_headline",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_headline },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_headline },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "announcement_url",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_url },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_posted",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.time_posted },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.time_posted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "announcement_gid",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_gid },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_gid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetNewSteamAnnouncementState_Response>(
                "CPlayer_GetNewSteamAnnouncementState_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNewSteamAnnouncementState_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetNewSteamAnnouncementState_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetNewSteamAnnouncementState_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNewSteamAnnouncementState_Response {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.announcement_headline.clear();
        self.announcement_url.clear();
        self.time_posted = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNewSteamAnnouncementState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNewSteamAnnouncementState_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_UpdateSteamAnnouncementLastRead_Request {
    // message fields
    announcement_gid: ::std::option::Option<u64>,
    time_posted: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn default() -> &'a CPlayer_UpdateSteamAnnouncementLastRead_Request {
        <CPlayer_UpdateSteamAnnouncementLastRead_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_UpdateSteamAnnouncementLastRead_Request {
    pub fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Request {
        ::std::default::Default::default()
    }

    // optional uint64 announcement_gid = 1;


    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }
    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 time_posted = 2;


    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }
    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.announcement_gid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_posted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.announcement_gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Request {
        CPlayer_UpdateSteamAnnouncementLastRead_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "announcement_gid",
                |m: &CPlayer_UpdateSteamAnnouncementLastRead_Request| { &m.announcement_gid },
                |m: &mut CPlayer_UpdateSteamAnnouncementLastRead_Request| { &mut m.announcement_gid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_posted",
                |m: &CPlayer_UpdateSteamAnnouncementLastRead_Request| { &m.time_posted },
                |m: &mut CPlayer_UpdateSteamAnnouncementLastRead_Request| { &mut m.time_posted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_UpdateSteamAnnouncementLastRead_Request>(
                "CPlayer_UpdateSteamAnnouncementLastRead_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_UpdateSteamAnnouncementLastRead_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_UpdateSteamAnnouncementLastRead_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_UpdateSteamAnnouncementLastRead_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn clear(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
        self.time_posted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_UpdateSteamAnnouncementLastRead_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn default() -> &'a CPlayer_UpdateSteamAnnouncementLastRead_Response {
        <CPlayer_UpdateSteamAnnouncementLastRead_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_UpdateSteamAnnouncementLastRead_Response {
    pub fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Response {
        CPlayer_UpdateSteamAnnouncementLastRead_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_UpdateSteamAnnouncementLastRead_Response>(
                "CPlayer_UpdateSteamAnnouncementLastRead_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_UpdateSteamAnnouncementLastRead_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_UpdateSteamAnnouncementLastRead_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_UpdateSteamAnnouncementLastRead_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPrivacySettings_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPrivacySettings_Request {
    fn default() -> &'a CPlayer_GetPrivacySettings_Request {
        <CPlayer_GetPrivacySettings_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPrivacySettings_Request {
    pub fn new() -> CPlayer_GetPrivacySettings_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPrivacySettings_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPrivacySettings_Request {
        CPlayer_GetPrivacySettings_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPrivacySettings_Request>(
                "CPlayer_GetPrivacySettings_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPrivacySettings_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPrivacySettings_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPrivacySettings_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPrivacySettings_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPrivacySettings_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPrivacySettings_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPrivacySettings {
    // message fields
    privacy_state: ::std::option::Option<i32>,
    privacy_state_inventory: ::std::option::Option<i32>,
    privacy_state_gifts: ::std::option::Option<i32>,
    privacy_state_ownedgames: ::std::option::Option<i32>,
    privacy_state_playtime: ::std::option::Option<i32>,
    privacy_state_friendslist: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPrivacySettings {
    fn default() -> &'a CPrivacySettings {
        <CPrivacySettings as ::protobuf::Message>::default_instance()
    }
}

impl CPrivacySettings {
    pub fn new() -> CPrivacySettings {
        ::std::default::Default::default()
    }

    // optional int32 privacy_state = 1;


    pub fn get_privacy_state(&self) -> i32 {
        self.privacy_state.unwrap_or(0)
    }
    pub fn clear_privacy_state(&mut self) {
        self.privacy_state = ::std::option::Option::None;
    }

    pub fn has_privacy_state(&self) -> bool {
        self.privacy_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state(&mut self, v: i32) {
        self.privacy_state = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_inventory = 2;


    pub fn get_privacy_state_inventory(&self) -> i32 {
        self.privacy_state_inventory.unwrap_or(0)
    }
    pub fn clear_privacy_state_inventory(&mut self) {
        self.privacy_state_inventory = ::std::option::Option::None;
    }

    pub fn has_privacy_state_inventory(&self) -> bool {
        self.privacy_state_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_inventory(&mut self, v: i32) {
        self.privacy_state_inventory = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_gifts = 3;


    pub fn get_privacy_state_gifts(&self) -> i32 {
        self.privacy_state_gifts.unwrap_or(0)
    }
    pub fn clear_privacy_state_gifts(&mut self) {
        self.privacy_state_gifts = ::std::option::Option::None;
    }

    pub fn has_privacy_state_gifts(&self) -> bool {
        self.privacy_state_gifts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_gifts(&mut self, v: i32) {
        self.privacy_state_gifts = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_ownedgames = 4;


    pub fn get_privacy_state_ownedgames(&self) -> i32 {
        self.privacy_state_ownedgames.unwrap_or(0)
    }
    pub fn clear_privacy_state_ownedgames(&mut self) {
        self.privacy_state_ownedgames = ::std::option::Option::None;
    }

    pub fn has_privacy_state_ownedgames(&self) -> bool {
        self.privacy_state_ownedgames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_ownedgames(&mut self, v: i32) {
        self.privacy_state_ownedgames = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_playtime = 5;


    pub fn get_privacy_state_playtime(&self) -> i32 {
        self.privacy_state_playtime.unwrap_or(0)
    }
    pub fn clear_privacy_state_playtime(&mut self) {
        self.privacy_state_playtime = ::std::option::Option::None;
    }

    pub fn has_privacy_state_playtime(&self) -> bool {
        self.privacy_state_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_playtime(&mut self, v: i32) {
        self.privacy_state_playtime = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_friendslist = 6;


    pub fn get_privacy_state_friendslist(&self) -> i32 {
        self.privacy_state_friendslist.unwrap_or(0)
    }
    pub fn clear_privacy_state_friendslist(&mut self) {
        self.privacy_state_friendslist = ::std::option::Option::None;
    }

    pub fn has_privacy_state_friendslist(&self) -> bool {
        self.privacy_state_friendslist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_friendslist(&mut self, v: i32) {
        self.privacy_state_friendslist = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPrivacySettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_inventory = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_gifts = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_ownedgames = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_playtime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_friendslist = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.privacy_state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_inventory {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_gifts {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_ownedgames {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_playtime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_friendslist {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.privacy_state {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.privacy_state_inventory {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.privacy_state_gifts {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.privacy_state_ownedgames {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.privacy_state_playtime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.privacy_state_friendslist {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPrivacySettings {
        CPrivacySettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "privacy_state",
                |m: &CPrivacySettings| { &m.privacy_state },
                |m: &mut CPrivacySettings| { &mut m.privacy_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "privacy_state_inventory",
                |m: &CPrivacySettings| { &m.privacy_state_inventory },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "privacy_state_gifts",
                |m: &CPrivacySettings| { &m.privacy_state_gifts },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_gifts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "privacy_state_ownedgames",
                |m: &CPrivacySettings| { &m.privacy_state_ownedgames },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_ownedgames },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "privacy_state_playtime",
                |m: &CPrivacySettings| { &m.privacy_state_playtime },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_playtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "privacy_state_friendslist",
                |m: &CPrivacySettings| { &m.privacy_state_friendslist },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_friendslist },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPrivacySettings>(
                "CPrivacySettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPrivacySettings {
        static instance: ::protobuf::rt::LazyV2<CPrivacySettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPrivacySettings::new)
    }
}

impl ::protobuf::Clear for CPrivacySettings {
    fn clear(&mut self) {
        self.privacy_state = ::std::option::Option::None;
        self.privacy_state_inventory = ::std::option::Option::None;
        self.privacy_state_gifts = ::std::option::Option::None;
        self.privacy_state_ownedgames = ::std::option::Option::None;
        self.privacy_state_playtime = ::std::option::Option::None;
        self.privacy_state_friendslist = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPrivacySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPrivacySettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPrivacySettings_Response {
    // message fields
    pub privacy_settings: ::protobuf::SingularPtrField<CPrivacySettings>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPrivacySettings_Response {
    fn default() -> &'a CPlayer_GetPrivacySettings_Response {
        <CPlayer_GetPrivacySettings_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPrivacySettings_Response {
    pub fn new() -> CPlayer_GetPrivacySettings_Response {
        ::std::default::Default::default()
    }

    // optional .CPrivacySettings privacy_settings = 1;


    pub fn get_privacy_settings(&self) -> &CPrivacySettings {
        self.privacy_settings.as_ref().unwrap_or_else(|| <CPrivacySettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_privacy_settings(&mut self) {
        self.privacy_settings.clear();
    }

    pub fn has_privacy_settings(&self) -> bool {
        self.privacy_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_settings(&mut self, v: CPrivacySettings) {
        self.privacy_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privacy_settings(&mut self) -> &mut CPrivacySettings {
        if self.privacy_settings.is_none() {
            self.privacy_settings.set_default();
        }
        self.privacy_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_privacy_settings(&mut self) -> CPrivacySettings {
        self.privacy_settings.take().unwrap_or_else(|| CPrivacySettings::new())
    }
}

impl ::protobuf::Message for CPlayer_GetPrivacySettings_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.privacy_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.privacy_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.privacy_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.privacy_settings.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPrivacySettings_Response {
        CPlayer_GetPrivacySettings_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPrivacySettings>>(
                "privacy_settings",
                |m: &CPlayer_GetPrivacySettings_Response| { &m.privacy_settings },
                |m: &mut CPlayer_GetPrivacySettings_Response| { &mut m.privacy_settings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetPrivacySettings_Response>(
                "CPlayer_GetPrivacySettings_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPrivacySettings_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetPrivacySettings_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetPrivacySettings_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPrivacySettings_Response {
    fn clear(&mut self) {
        self.privacy_settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPrivacySettings_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPrivacySettings_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetDurationControl_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetDurationControl_Request {
    fn default() -> &'a CPlayer_GetDurationControl_Request {
        <CPlayer_GetDurationControl_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetDurationControl_Request {
    pub fn new() -> CPlayer_GetDurationControl_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetDurationControl_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetDurationControl_Request {
        CPlayer_GetDurationControl_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CPlayer_GetDurationControl_Request| { &m.appid },
                |m: &mut CPlayer_GetDurationControl_Request| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetDurationControl_Request>(
                "CPlayer_GetDurationControl_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetDurationControl_Request {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetDurationControl_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetDurationControl_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetDurationControl_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetDurationControl_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetDurationControl_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetDurationControl_Response {
    // message fields
    is_enabled: ::std::option::Option<bool>,
    seconds: ::std::option::Option<i32>,
    seconds_today: ::std::option::Option<i32>,
    is_steamchina_account: ::std::option::Option<bool>,
    is_age_verified: ::std::option::Option<bool>,
    seconds_allowed_today: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetDurationControl_Response {
    fn default() -> &'a CPlayer_GetDurationControl_Response {
        <CPlayer_GetDurationControl_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetDurationControl_Response {
    pub fn new() -> CPlayer_GetDurationControl_Response {
        ::std::default::Default::default()
    }

    // optional bool is_enabled = 1;


    pub fn get_is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }
    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 seconds = 2;


    pub fn get_seconds(&self) -> i32 {
        self.seconds.unwrap_or(0)
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_today = 3;


    pub fn get_seconds_today(&self) -> i32 {
        self.seconds_today.unwrap_or(0)
    }
    pub fn clear_seconds_today(&mut self) {
        self.seconds_today = ::std::option::Option::None;
    }

    pub fn has_seconds_today(&self) -> bool {
        self.seconds_today.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_today(&mut self, v: i32) {
        self.seconds_today = ::std::option::Option::Some(v);
    }

    // optional bool is_steamchina_account = 4;


    pub fn get_is_steamchina_account(&self) -> bool {
        self.is_steamchina_account.unwrap_or(false)
    }
    pub fn clear_is_steamchina_account(&mut self) {
        self.is_steamchina_account = ::std::option::Option::None;
    }

    pub fn has_is_steamchina_account(&self) -> bool {
        self.is_steamchina_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steamchina_account(&mut self, v: bool) {
        self.is_steamchina_account = ::std::option::Option::Some(v);
    }

    // optional bool is_age_verified = 5;


    pub fn get_is_age_verified(&self) -> bool {
        self.is_age_verified.unwrap_or(false)
    }
    pub fn clear_is_age_verified(&mut self) {
        self.is_age_verified = ::std::option::Option::None;
    }

    pub fn has_is_age_verified(&self) -> bool {
        self.is_age_verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_age_verified(&mut self, v: bool) {
        self.is_age_verified = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_allowed_today = 6;


    pub fn get_seconds_allowed_today(&self) -> u32 {
        self.seconds_allowed_today.unwrap_or(0)
    }
    pub fn clear_seconds_allowed_today(&mut self) {
        self.seconds_allowed_today = ::std::option::Option::None;
    }

    pub fn has_seconds_allowed_today(&self) -> bool {
        self.seconds_allowed_today.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_allowed_today(&mut self, v: u32) {
        self.seconds_allowed_today = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetDurationControl_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_enabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_today = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_steamchina_account = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_age_verified = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_allowed_today = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_enabled {
            my_size += 2;
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_today {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_steamchina_account {
            my_size += 2;
        }
        if let Some(v) = self.is_age_verified {
            my_size += 2;
        }
        if let Some(v) = self.seconds_allowed_today {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.seconds_today {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.is_steamchina_account {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_age_verified {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.seconds_allowed_today {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetDurationControl_Response {
        CPlayer_GetDurationControl_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_enabled",
                |m: &CPlayer_GetDurationControl_Response| { &m.is_enabled },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.is_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seconds",
                |m: &CPlayer_GetDurationControl_Response| { &m.seconds },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seconds_today",
                |m: &CPlayer_GetDurationControl_Response| { &m.seconds_today },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.seconds_today },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_steamchina_account",
                |m: &CPlayer_GetDurationControl_Response| { &m.is_steamchina_account },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.is_steamchina_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_age_verified",
                |m: &CPlayer_GetDurationControl_Response| { &m.is_age_verified },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.is_age_verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_allowed_today",
                |m: &CPlayer_GetDurationControl_Response| { &m.seconds_allowed_today },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.seconds_allowed_today },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_GetDurationControl_Response>(
                "CPlayer_GetDurationControl_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetDurationControl_Response {
        static instance: ::protobuf::rt::LazyV2<CPlayer_GetDurationControl_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_GetDurationControl_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetDurationControl_Response {
    fn clear(&mut self) {
        self.is_enabled = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.seconds_today = ::std::option::Option::None;
        self.is_steamchina_account = ::std::option::Option::None;
        self.is_age_verified = ::std::option::Option::None;
        self.seconds_allowed_today = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetDurationControl_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetDurationControl_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_LastPlayedTimes_Notification {
    // message fields
    pub games: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_LastPlayedTimes_Notification {
    fn default() -> &'a CPlayer_LastPlayedTimes_Notification {
        <CPlayer_LastPlayedTimes_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_LastPlayedTimes_Notification {
    pub fn new() -> CPlayer_LastPlayedTimes_Notification {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetLastPlayedTimes_Response.Game games = 1;


    pub fn get_games(&self) -> &[CPlayer_GetLastPlayedTimes_Response_Game] {
        &self.games
    }
    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_LastPlayedTimes_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_LastPlayedTimes_Notification {
        CPlayer_LastPlayedTimes_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetLastPlayedTimes_Response_Game>>(
                "games",
                |m: &CPlayer_LastPlayedTimes_Notification| { &m.games },
                |m: &mut CPlayer_LastPlayedTimes_Notification| { &mut m.games },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_LastPlayedTimes_Notification>(
                "CPlayer_LastPlayedTimes_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_LastPlayedTimes_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_LastPlayedTimes_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_LastPlayedTimes_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_LastPlayedTimes_Notification {
    fn clear(&mut self) {
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_LastPlayedTimes_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_LastPlayedTimes_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_FriendNicknameChanged_Notification {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    is_echo_to_self: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_FriendNicknameChanged_Notification {
    fn default() -> &'a CPlayer_FriendNicknameChanged_Notification {
        <CPlayer_FriendNicknameChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_FriendNicknameChanged_Notification {
    pub fn new() -> CPlayer_FriendNicknameChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_echo_to_self = 3;


    pub fn get_is_echo_to_self(&self) -> bool {
        self.is_echo_to_self.unwrap_or(false)
    }
    pub fn clear_is_echo_to_self(&mut self) {
        self.is_echo_to_self = ::std::option::Option::None;
    }

    pub fn has_is_echo_to_self(&self) -> bool {
        self.is_echo_to_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_echo_to_self(&mut self, v: bool) {
        self.is_echo_to_self = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_FriendNicknameChanged_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_echo_to_self = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_echo_to_self {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.is_echo_to_self {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_FriendNicknameChanged_Notification {
        CPlayer_FriendNicknameChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "accountid",
                |m: &CPlayer_FriendNicknameChanged_Notification| { &m.accountid },
                |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nickname",
                |m: &CPlayer_FriendNicknameChanged_Notification| { &m.nickname },
                |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.nickname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_echo_to_self",
                |m: &CPlayer_FriendNicknameChanged_Notification| { &m.is_echo_to_self },
                |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.is_echo_to_self },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_FriendNicknameChanged_Notification>(
                "CPlayer_FriendNicknameChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_FriendNicknameChanged_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_FriendNicknameChanged_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_FriendNicknameChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_FriendNicknameChanged_Notification {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.is_echo_to_self = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_FriendNicknameChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_FriendNicknameChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_FriendEquippedProfileItemsChanged_Notification {
    // message fields
    accountid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_FriendEquippedProfileItemsChanged_Notification {
    fn default() -> &'a CPlayer_FriendEquippedProfileItemsChanged_Notification {
        <CPlayer_FriendEquippedProfileItemsChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_FriendEquippedProfileItemsChanged_Notification {
    pub fn new() -> CPlayer_FriendEquippedProfileItemsChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_FriendEquippedProfileItemsChanged_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_FriendEquippedProfileItemsChanged_Notification {
        CPlayer_FriendEquippedProfileItemsChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "accountid",
                |m: &CPlayer_FriendEquippedProfileItemsChanged_Notification| { &m.accountid },
                |m: &mut CPlayer_FriendEquippedProfileItemsChanged_Notification| { &mut m.accountid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_FriendEquippedProfileItemsChanged_Notification>(
                "CPlayer_FriendEquippedProfileItemsChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_FriendEquippedProfileItemsChanged_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_FriendEquippedProfileItemsChanged_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_FriendEquippedProfileItemsChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_FriendEquippedProfileItemsChanged_Notification {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_FriendEquippedProfileItemsChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_FriendEquippedProfileItemsChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_NewSteamAnnouncementState_Notification {
    // message fields
    state: ::std::option::Option<i32>,
    announcement_headline: ::protobuf::SingularField<::std::string::String>,
    announcement_url: ::protobuf::SingularField<::std::string::String>,
    time_posted: ::std::option::Option<u32>,
    announcement_gid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_NewSteamAnnouncementState_Notification {
    fn default() -> &'a CPlayer_NewSteamAnnouncementState_Notification {
        <CPlayer_NewSteamAnnouncementState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_NewSteamAnnouncementState_Notification {
    pub fn new() -> CPlayer_NewSteamAnnouncementState_Notification {
        ::std::default::Default::default()
    }

    // optional int32 state = 1;


    pub fn get_state(&self) -> i32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string announcement_headline = 2;


    pub fn get_announcement_headline(&self) -> &str {
        match self.announcement_headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_headline(&mut self) {
        self.announcement_headline.clear();
    }

    pub fn has_announcement_headline(&self) -> bool {
        self.announcement_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_headline(&mut self, v: ::std::string::String) {
        self.announcement_headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_headline(&mut self) -> &mut ::std::string::String {
        if self.announcement_headline.is_none() {
            self.announcement_headline.set_default();
        }
        self.announcement_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_headline(&mut self) -> ::std::string::String {
        self.announcement_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement_url = 3;


    pub fn get_announcement_url(&self) -> &str {
        match self.announcement_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_url(&mut self) {
        self.announcement_url.clear();
    }

    pub fn has_announcement_url(&self) -> bool {
        self.announcement_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_url(&mut self, v: ::std::string::String) {
        self.announcement_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_url(&mut self) -> &mut ::std::string::String {
        if self.announcement_url.is_none() {
            self.announcement_url.set_default();
        }
        self.announcement_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_url(&mut self) -> ::std::string::String {
        self.announcement_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_posted = 4;


    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }
    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }

    // optional uint64 announcement_gid = 5;


    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }
    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_NewSteamAnnouncementState_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_headline)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_posted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.announcement_gid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_NewSteamAnnouncementState_Notification {
        CPlayer_NewSteamAnnouncementState_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "state",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.state },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "announcement_headline",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_headline },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_headline },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "announcement_url",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_url },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_posted",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.time_posted },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.time_posted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "announcement_gid",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_gid },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_gid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_NewSteamAnnouncementState_Notification>(
                "CPlayer_NewSteamAnnouncementState_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_NewSteamAnnouncementState_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_NewSteamAnnouncementState_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_NewSteamAnnouncementState_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_NewSteamAnnouncementState_Notification {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.announcement_headline.clear();
        self.announcement_url.clear();
        self.time_posted = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_NewSteamAnnouncementState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_NewSteamAnnouncementState_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_CommunityPreferencesChanged_Notification {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_CommunityPreferencesChanged_Notification {
    fn default() -> &'a CPlayer_CommunityPreferencesChanged_Notification {
        <CPlayer_CommunityPreferencesChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_CommunityPreferencesChanged_Notification {
    pub fn new() -> CPlayer_CommunityPreferencesChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .CPlayer_CommunityPreferences preferences = 1;


    pub fn get_preferences(&self) -> &CPlayer_CommunityPreferences {
        self.preferences.as_ref().unwrap_or_else(|| <CPlayer_CommunityPreferences as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CPlayer_CommunityPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CPlayer_CommunityPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CPlayer_CommunityPreferences {
        self.preferences.take().unwrap_or_else(|| CPlayer_CommunityPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_CommunityPreferencesChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_CommunityPreferencesChanged_Notification {
        CPlayer_CommunityPreferencesChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>>(
                "preferences",
                |m: &CPlayer_CommunityPreferencesChanged_Notification| { &m.preferences },
                |m: &mut CPlayer_CommunityPreferencesChanged_Notification| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_CommunityPreferencesChanged_Notification>(
                "CPlayer_CommunityPreferencesChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_CommunityPreferencesChanged_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_CommunityPreferencesChanged_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_CommunityPreferencesChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_CommunityPreferencesChanged_Notification {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_CommunityPreferencesChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_CommunityPreferencesChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_TextFilterWordsChanged_Notification {
    // message fields
    pub words: ::protobuf::SingularPtrField<CPlayer_TextFilterWords>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_TextFilterWordsChanged_Notification {
    fn default() -> &'a CPlayer_TextFilterWordsChanged_Notification {
        <CPlayer_TextFilterWordsChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_TextFilterWordsChanged_Notification {
    pub fn new() -> CPlayer_TextFilterWordsChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .CPlayer_TextFilterWords words = 1;


    pub fn get_words(&self) -> &CPlayer_TextFilterWords {
        self.words.as_ref().unwrap_or_else(|| <CPlayer_TextFilterWords as ::protobuf::Message>::default_instance())
    }
    pub fn clear_words(&mut self) {
        self.words.clear();
    }

    pub fn has_words(&self) -> bool {
        self.words.is_some()
    }

    // Param is passed by value, moved
    pub fn set_words(&mut self, v: CPlayer_TextFilterWords) {
        self.words = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_words(&mut self) -> &mut CPlayer_TextFilterWords {
        if self.words.is_none() {
            self.words.set_default();
        }
        self.words.as_mut().unwrap()
    }

    // Take field
    pub fn take_words(&mut self) -> CPlayer_TextFilterWords {
        self.words.take().unwrap_or_else(|| CPlayer_TextFilterWords::new())
    }
}

impl ::protobuf::Message for CPlayer_TextFilterWordsChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.words {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.words)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.words.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.words.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_TextFilterWordsChanged_Notification {
        CPlayer_TextFilterWordsChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_TextFilterWords>>(
                "words",
                |m: &CPlayer_TextFilterWordsChanged_Notification| { &m.words },
                |m: &mut CPlayer_TextFilterWordsChanged_Notification| { &mut m.words },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_TextFilterWordsChanged_Notification>(
                "CPlayer_TextFilterWordsChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_TextFilterWordsChanged_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_TextFilterWordsChanged_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_TextFilterWordsChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_TextFilterWordsChanged_Notification {
    fn clear(&mut self) {
        self.words.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_TextFilterWordsChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_TextFilterWordsChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PerFriendPreferencesChanged_Notification {
    // message fields
    accountid: ::std::option::Option<u32>,
    pub preferences: ::protobuf::SingularPtrField<PerFriendPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PerFriendPreferencesChanged_Notification {
    fn default() -> &'a CPlayer_PerFriendPreferencesChanged_Notification {
        <CPlayer_PerFriendPreferencesChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PerFriendPreferencesChanged_Notification {
    pub fn new() -> CPlayer_PerFriendPreferencesChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .PerFriendPreferences preferences = 2;


    pub fn get_preferences(&self) -> &PerFriendPreferences {
        self.preferences.as_ref().unwrap_or_else(|| <PerFriendPreferences as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: PerFriendPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut PerFriendPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> PerFriendPreferences {
        self.preferences.take().unwrap_or_else(|| PerFriendPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_PerFriendPreferencesChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PerFriendPreferencesChanged_Notification {
        CPlayer_PerFriendPreferencesChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "accountid",
                |m: &CPlayer_PerFriendPreferencesChanged_Notification| { &m.accountid },
                |m: &mut CPlayer_PerFriendPreferencesChanged_Notification| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerFriendPreferences>>(
                "preferences",
                |m: &CPlayer_PerFriendPreferencesChanged_Notification| { &m.preferences },
                |m: &mut CPlayer_PerFriendPreferencesChanged_Notification| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_PerFriendPreferencesChanged_Notification>(
                "CPlayer_PerFriendPreferencesChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PerFriendPreferencesChanged_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_PerFriendPreferencesChanged_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_PerFriendPreferencesChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_PerFriendPreferencesChanged_Notification {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PerFriendPreferencesChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PerFriendPreferencesChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PrivacySettingsChanged_Notification {
    // message fields
    pub privacy_settings: ::protobuf::SingularPtrField<CPrivacySettings>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PrivacySettingsChanged_Notification {
    fn default() -> &'a CPlayer_PrivacySettingsChanged_Notification {
        <CPlayer_PrivacySettingsChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PrivacySettingsChanged_Notification {
    pub fn new() -> CPlayer_PrivacySettingsChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .CPrivacySettings privacy_settings = 1;


    pub fn get_privacy_settings(&self) -> &CPrivacySettings {
        self.privacy_settings.as_ref().unwrap_or_else(|| <CPrivacySettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_privacy_settings(&mut self) {
        self.privacy_settings.clear();
    }

    pub fn has_privacy_settings(&self) -> bool {
        self.privacy_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_settings(&mut self, v: CPrivacySettings) {
        self.privacy_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privacy_settings(&mut self) -> &mut CPrivacySettings {
        if self.privacy_settings.is_none() {
            self.privacy_settings.set_default();
        }
        self.privacy_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_privacy_settings(&mut self) -> CPrivacySettings {
        self.privacy_settings.take().unwrap_or_else(|| CPrivacySettings::new())
    }
}

impl ::protobuf::Message for CPlayer_PrivacySettingsChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.privacy_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.privacy_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.privacy_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.privacy_settings.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PrivacySettingsChanged_Notification {
        CPlayer_PrivacySettingsChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPrivacySettings>>(
                "privacy_settings",
                |m: &CPlayer_PrivacySettingsChanged_Notification| { &m.privacy_settings },
                |m: &mut CPlayer_PrivacySettingsChanged_Notification| { &mut m.privacy_settings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPlayer_PrivacySettingsChanged_Notification>(
                "CPlayer_PrivacySettingsChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PrivacySettingsChanged_Notification {
        static instance: ::protobuf::rt::LazyV2<CPlayer_PrivacySettingsChanged_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPlayer_PrivacySettingsChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_PrivacySettingsChanged_Notification {
    fn clear(&mut self) {
        self.privacy_settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PrivacySettingsChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PrivacySettingsChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EProfileCustomizationType {
    k_EProfileCustomizationTypeInvalid = 0,
    k_EProfileCustomizationTypeRareAchievementShowcase = 1,
    k_EProfileCustomizationTypeGameCollector = 2,
    k_EProfileCustomizationTypeItemShowcase = 3,
    k_EProfileCustomizationTypeTradeShowcase = 4,
    k_EProfileCustomizationTypeBadges = 5,
    k_EProfileCustomizationTypeFavoriteGame = 6,
    k_EProfileCustomizationTypeScreenshotShowcase = 7,
    k_EProfileCustomizationTypeCustomText = 8,
    k_EProfileCustomizationTypeFavoriteGroup = 9,
    k_EProfileCustomizationTypeRecommendation = 10,
    k_EProfileCustomizationTypeWorkshopItem = 11,
    k_EProfileCustomizationTypeMyWorkshop = 12,
    k_EProfileCustomizationTypeArtworkShowcase = 13,
    k_EProfileCustomizationTypeVideoShowcase = 14,
    k_EProfileCustomizationTypeGuides = 15,
    k_EProfileCustomizationTypeMyGuides = 16,
    k_EProfileCustomizationTypeAchievements = 17,
    k_EProfileCustomizationTypeGreenlight = 18,
    k_EProfileCustomizationTypeMyGreenlight = 19,
    k_EProfileCustomizationTypeSalien = 20,
}

impl ::protobuf::ProtobufEnum for EProfileCustomizationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProfileCustomizationType> {
        match value {
            0 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid),
            1 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase),
            2 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector),
            3 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase),
            4 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase),
            5 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeBadges),
            6 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame),
            7 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase),
            8 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeCustomText),
            9 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup),
            10 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation),
            11 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem),
            12 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop),
            13 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase),
            14 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase),
            15 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGuides),
            16 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides),
            17 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievements),
            18 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight),
            19 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight),
            20 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSalien),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EProfileCustomizationType] = &[
            EProfileCustomizationType::k_EProfileCustomizationTypeInvalid,
            EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase,
            EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector,
            EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase,
            EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase,
            EProfileCustomizationType::k_EProfileCustomizationTypeBadges,
            EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame,
            EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase,
            EProfileCustomizationType::k_EProfileCustomizationTypeCustomText,
            EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup,
            EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation,
            EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem,
            EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop,
            EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase,
            EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase,
            EProfileCustomizationType::k_EProfileCustomizationTypeGuides,
            EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides,
            EProfileCustomizationType::k_EProfileCustomizationTypeAchievements,
            EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight,
            EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight,
            EProfileCustomizationType::k_EProfileCustomizationTypeSalien,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EProfileCustomizationType>("EProfileCustomizationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EProfileCustomizationType {
}

impl ::std::default::Default for EProfileCustomizationType {
    fn default() -> Self {
        EProfileCustomizationType::k_EProfileCustomizationTypeInvalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EProfileCustomizationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EProfileCustomizationStyle {
    k_EProfileCustomizationStyleDefault = 0,
    k_EProfileCustomizationStyleSelected = 1,
    k_EProfileCustomizationStyleRarest = 2,
    k_EProfileCustomizationStyleMostRecent = 3,
    k_EProfileCustomizationStyleRandom = 4,
    k_EProfileCustomizationStyleHighestRated = 5,
}

impl ::protobuf::ProtobufEnum for EProfileCustomizationStyle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProfileCustomizationStyle> {
        match value {
            0 => ::std::option::Option::Some(EProfileCustomizationStyle::k_EProfileCustomizationStyleDefault),
            1 => ::std::option::Option::Some(EProfileCustomizationStyle::k_EProfileCustomizationStyleSelected),
            2 => ::std::option::Option::Some(EProfileCustomizationStyle::k_EProfileCustomizationStyleRarest),
            3 => ::std::option::Option::Some(EProfileCustomizationStyle::k_EProfileCustomizationStyleMostRecent),
            4 => ::std::option::Option::Some(EProfileCustomizationStyle::k_EProfileCustomizationStyleRandom),
            5 => ::std::option::Option::Some(EProfileCustomizationStyle::k_EProfileCustomizationStyleHighestRated),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EProfileCustomizationStyle] = &[
            EProfileCustomizationStyle::k_EProfileCustomizationStyleDefault,
            EProfileCustomizationStyle::k_EProfileCustomizationStyleSelected,
            EProfileCustomizationStyle::k_EProfileCustomizationStyleRarest,
            EProfileCustomizationStyle::k_EProfileCustomizationStyleMostRecent,
            EProfileCustomizationStyle::k_EProfileCustomizationStyleRandom,
            EProfileCustomizationStyle::k_EProfileCustomizationStyleHighestRated,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EProfileCustomizationStyle>("EProfileCustomizationStyle", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EProfileCustomizationStyle {
}

impl ::std::default::Default for EProfileCustomizationStyle {
    fn default() -> Self {
        EProfileCustomizationStyle::k_EProfileCustomizationStyleDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for EProfileCustomizationStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ENotificationSetting {
    k_ENotificationSettingNotifyUseDefault = 0,
    k_ENotificationSettingAlways = 1,
    k_ENotificationSettingNever = 2,
}

impl ::protobuf::ProtobufEnum for ENotificationSetting {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENotificationSetting> {
        match value {
            0 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            1 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingAlways),
            2 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingNever),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ENotificationSetting] = &[
            ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ENotificationSetting::k_ENotificationSettingAlways,
            ENotificationSetting::k_ENotificationSettingNever,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ENotificationSetting>("ENotificationSetting", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ENotificationSetting {
}

impl ::std::default::Default for ENotificationSetting {
    fn default() -> Self {
        ENotificationSetting::k_ENotificationSettingNotifyUseDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for ENotificationSetting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ETextFilterSetting {
    k_ETextFilterSettingSteamLabOptedOut = 0,
    k_ETextFilterSettingEnabled = 1,
    k_ETextFilterSettingEnabledAllowProfanity = 2,
    k_ETextFilterSettingDisabled = 3,
}

impl ::protobuf::ProtobufEnum for ETextFilterSetting {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETextFilterSetting> {
        match value {
            0 => ::std::option::Option::Some(ETextFilterSetting::k_ETextFilterSettingSteamLabOptedOut),
            1 => ::std::option::Option::Some(ETextFilterSetting::k_ETextFilterSettingEnabled),
            2 => ::std::option::Option::Some(ETextFilterSetting::k_ETextFilterSettingEnabledAllowProfanity),
            3 => ::std::option::Option::Some(ETextFilterSetting::k_ETextFilterSettingDisabled),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ETextFilterSetting] = &[
            ETextFilterSetting::k_ETextFilterSettingSteamLabOptedOut,
            ETextFilterSetting::k_ETextFilterSettingEnabled,
            ETextFilterSetting::k_ETextFilterSettingEnabledAllowProfanity,
            ETextFilterSetting::k_ETextFilterSettingDisabled,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ETextFilterSetting>("ETextFilterSetting", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ETextFilterSetting {
}

impl ::std::default::Default for ETextFilterSetting {
    fn default() -> Self {
        ETextFilterSetting::k_ETextFilterSettingSteamLabOptedOut
    }
}

impl ::protobuf::reflect::ProtobufValue for ETextFilterSetting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&steammessages_player.steamclient.proto\x1a,steammessages_unified_base\
    .steamclient.proto\"4\n2CPlayer_GetMutualFriendsForIncomingInvites_Reque\
    st\"}\n&CPlayer_IncomingInviteMutualFriendList\x12\x18\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamid\x129\n\x19mutual_friend_account_ids\x18\
    \x02\x20\x03(\rR\x16mutualFriendAccountIds\"\xae\x01\n3CPlayer_GetMutual\
    FriendsForIncomingInvites_Response\x12w\n$incoming_invite_mutual_friends\
    _lists\x18\x01\x20\x03(\x0b2'.CPlayer_IncomingInviteMutualFriendListR\
    \x20incomingInviteMutualFriendsLists\"\xbc\x04\n\x1dCPlayer_GetOwnedGame\
    s_Request\x12;\n\x07steamid\x18\x01\x20\x01(\x04R\x07steamidB!\x82\xb5\
    \x18\x1dThe\x20player\x20we're\x20asking\x20about\x12l\n\x0finclude_appi\
    nfo\x18\x02\x20\x01(\x08R\x0eincludeAppinfoBC\x82\xb5\x18?true\x20if\x20\
    we\x20want\x20additional\x20details\x20(name,\x20icon)\x20about\x20each\
    \x20game\x12\xa4\x01\n\x19include_played_free_games\x18\x03\x20\x01(\x08\
    R\x16includePlayedFreeGamesBi\x82\xb5\x18eFree\x20games\x20are\x20exclud\
    ed\x20by\x20default.\x20\x20If\x20this\x20is\x20set,\x20free\x20games\
    \x20the\x20user\x20has\x20played\x20will\x20be\x20returned.\x12[\n\rappi\
    ds_filter\x18\x04\x20\x03(\rR\x0cappidsFilterB6\x82\xb5\x182if\x20set,\
    \x20restricts\x20result\x20set\x20to\x20the\x20passed\x20in\x20apps\x12l\
    \n\x10include_free_sub\x18\x05\x20\x01(\x08R\x0eincludeFreeSubBB\x82\xb5\
    \x18>Some\x20games\x20are\x20in\x20the\x20free\x20sub,\x20which\x20are\
    \x20excluded\x20by\x20default.\"\xa7\x04\n\x1eCPlayer_GetOwnedGames_Resp\
    onse\x12\x1d\n\ngame_count\x18\x01\x20\x01(\rR\tgameCount\x12:\n\x05game\
    s\x18\x02\x20\x03(\x0b2$.CPlayer_GetOwnedGames_Response.GameR\x05games\
    \x1a\xa9\x03\n\x04Game\x12\x14\n\x05appid\x18\x01\x20\x01(\x05R\x05appid\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12'\n\x0fplaytime_2weeks\
    \x18\x03\x20\x01(\x05R\x0eplaytime2weeks\x12)\n\x10playtime_forever\x18\
    \x04\x20\x01(\x05R\x0fplaytimeForever\x12\x20\n\x0cimg_icon_url\x18\x05\
    \x20\x01(\tR\nimgIconUrl\x12\x20\n\x0cimg_logo_url\x18\x06\x20\x01(\tR\n\
    imgLogoUrl\x12=\n\x1bhas_community_visible_stats\x18\x07\x20\x01(\x08R\
    \x18hasCommunityVisibleStats\x128\n\x18playtime_windows_forever\x18\x08\
    \x20\x01(\x05R\x16playtimeWindowsForever\x120\n\x14playtime_mac_forever\
    \x18\t\x20\x01(\x05R\x12playtimeMacForever\x124\n\x16playtime_linux_fore\
    ver\x18\n\x20\x01(\x05R\x14playtimeLinuxForever\"j\n\x1bCPlayer_GetPlayN\
    ext_Request\x12&\n\x0fmax_age_seconds\x18\x01\x20\x01(\rR\rmaxAgeSeconds\
    \x12#\n\rignore_appids\x18\x02\x20\x03(\rR\x0cignoreAppids\"`\n\x1cCPlay\
    er_GetPlayNext_Response\x12(\n\x10last_update_time\x18\x01\x20\x01(\rR\
    \x0elastUpdateTime\x12\x16\n\x06appids\x18\x02\x20\x03(\rR\x06appids\">\
    \n&CPlayer_GetFriendsGameplayInfo_Request\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\"\x9f\x07\n'CPlayer_GetFriendsGameplayInfo_Response\
    \x12U\n\tyour_info\x18\x01\x20\x01(\x0b28.CPlayer_GetFriendsGameplayInfo\
    _Response.OwnGameplayInfoR\x08yourInfo\x12U\n\x07in_game\x18\x02\x20\x03\
    (\x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfoR\x06\
    inGame\x12e\n\x0fplayed_recently\x18\x03\x20\x03(\x0b2<.CPlayer_GetFrien\
    dsGameplayInfo_Response.FriendsGameplayInfoR\x0eplayedRecently\x12]\n\
    \x0bplayed_ever\x18\x04\x20\x03(\x0b2<.CPlayer_GetFriendsGameplayInfo_Re\
    sponse.FriendsGameplayInfoR\nplayedEver\x12P\n\x04owns\x18\x05\x20\x03(\
    \x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfoR\x04o\
    wns\x12]\n\x0bin_wishlist\x18\x06\x20\x03(\x0b2<.CPlayer_GetFriendsGamep\
    layInfo_Response.FriendsGameplayInfoR\ninWishlist\x1a\x8c\x01\n\x13Frien\
    dsGameplayInfo\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\
    %\n\x0eminutes_played\x18\x02\x20\x01(\rR\rminutesPlayed\x124\n\x16minut\
    es_played_forever\x18\x03\x20\x01(\rR\x14minutesPlayedForever\x1a\xbf\
    \x01\n\x0fOwnGameplayInfo\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07\
    steamid\x12%\n\x0eminutes_played\x18\x02\x20\x01(\rR\rminutesPlayed\x124\
    \n\x16minutes_played_forever\x18\x03\x20\x01(\rR\x14minutesPlayedForever\
    \x12\x1f\n\x0bin_wishlist\x18\x04\x20\x01(\x08R\ninWishlist\x12\x14\n\
    \x05owned\x18\x05\x20\x01(\x08R\x05owned\"\xa3\x02\n&CPlayer_GetFriendsA\
    ppsActivity_Request\x12\x8f\x01\n\rnews_language\x18\x01\x20\x01(\tR\x0c\
    newsLanguageBj\x82\xb5\x18fLanguage\x20for\x20which\x20to\x20query\x20ab\
    out\x20news\x20items\x20(for\x20the\x20being_discussed\x20results).\x20D\
    EPRECATED\x20AND\x20UNUSED.\x12g\n\rrequest_flags\x18\x02\x20\x01(\rR\
    \x0crequestFlagsBB\x82\xb5\x18>Flags\x20describing\x20the\x20request;\
    \x20see\x20EGetFriendsAppsActivityFlags\"\x96\x15\n'CPlayer_GetFriendsAp\
    psActivity_Response\x12\xc2\x01\n\x08trending\x18\x01\x20\x03(\x0b27.CPl\
    ayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\x08trendingBm\x82\
    \xb5\x18iApps\x20that\x20friends\x20have\x20played\x20more\x20this\x20we\
    ek\x20than\x20last,\x20with\x20list\x20of\x20friends\x20who've\x20played\
    \x20more\x20this\x20week\x12\xc5\x01\n\x10recent_purchases\x18\x02\x20\
    \x03(\x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\x0fr\
    ecentPurchasesBa\x82\xb5\x18]Apps\x20friends\x20have\x20played\x20in\x20\
    the\x20past\x20two\x20weeks\x20for\x20which\x20the\x20user\x20recently\
    \x20acquired\x20a\x20license\x12\xa7\x01\n\x07unowned\x18\x03\x20\x03(\
    \x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\x07unowne\
    dBT\x82\xb5\x18PApps\x20friends\x20have\x20played\x20in\x20the\x20past\
    \x20two\x20weeks\x20for\x20which\x20the\x20user\x20has\x20no\x20license\
    \x12\xb8\x01\n\x07popular\x18\x04\x20\x03(\x0b27.CPlayer_GetFriendsAppsA\
    ctivity_Response.AppFriendsInfoR\x07popularBe\x82\xb5\x18aApps\x20friend\
    s\x20have\x20played\x20in\x20the\x20past\x20two\x20weeks,\x20for\x20whic\
    h\x20the\x20user\x20has\x20a\x20license,\x20sorted\x20by\x20count\x12\
    \xd2\x01\n\x0bdont_forget\x18\x05\x20\x03(\x0b27.CPlayer_GetFriendsAppsA\
    ctivity_Response.AppFriendsInfoR\ndontForgetBx\x82\xb5\x18tApps\x20frien\
    ds\x20have\x20played\x20in\x20the\x20past\x20two\x20weeks\x20which\x20th\
    e\x20user\x20has\x20neither\x20purchased\x20nor\x20played\x20in\x20the\
    \x20past\x20two\x20weeks\x12\xd1\x01\n\x0fbeing_discussed\x18\x06\x20\
    \x03(\x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\x0eb\
    eingDiscussedBo\x82\xb5\x18kOwned\x20apps\x20that\x20friends\x20have\x20\
    posted\x20status\x20or\x20screenshots\x20for\x20in\x20the\x20past\x20two\
    \x20weeks.\x20DEPRECATED\x20AND\x20UNUSED.\x12\xa0\x01\n\x0cnew_to_group\
    \x18\x07\x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFrien\
    dsInfoR\nnewToGroupBE\x82\xb5\x18AOwned\x20apps\x20that\x20none\x20of\
    \x20your\x20friends\x20had\x20played\x20prior\x20to\x202\x20weeks.\x12\
    \xaa\x01\n\x11returned_to_group\x18\x08\x20\x03(\x0b27.CPlayer_GetFriend\
    sAppsActivity_Response.AppFriendsInfoR\x0freturnedToGroupBE\x82\xb5\x18A\
    Owned\x20apps\x20that\x20friends\x20hadn't\x20played\x20for\x20a\x20whil\
    e,\x20but\x20are\x20again.\x12y\n\x13active_friend_count\x18\t\x20\x01(\
    \r:\x010R\x11activeFriendCountBF\x82\xb5\x18BNumber\x20of\x20friends\x20\
    with\x20non-trivial\x20activity\x20in\x20the\x20past\x20two\x20weeks.\
    \x1a\xec\x04\n\x0eFriendPlayTime\x12\x18\n\x07steamid\x18\x01\x20\x01(\
    \x06R\x07steamid\x12\x8a\x01\n\x18minutes_played_this_week\x18\x02\x20\
    \x01(\rR\x15minutesPlayedThisWeekBQ\x82\xb5\x18MMinutes\x20this\x20frien\
    d\x20played\x20the\x20game\x20(from\x20the\x20enclosing\x20structure)\
    \x20this\x20week.\x12\x94\x01\n\x18minutes_played_two_weeks\x18\x03\x20\
    \x01(\rR\x15minutesPlayedTwoWeeksB[\x82\xb5\x18WMinutes\x20this\x20frien\
    d\x20played\x20the\x20game\x20(from\x20the\x20enclosing\x20structure)\
    \x20in\x20the\x20past\x202\x20weeks.\x12\x86\x01\n\x16minutes_played_for\
    ever\x18\x04\x20\x01(\rR\x14minutesPlayedForeverBP\x82\xb5\x18LMinutes\
    \x20this\x20friend\x20played\x20the\x20game\x20(from\x20the\x20enclosing\
    \x20structure)\x20all\x20time.\x12\x92\x01\n\x0bevent_count\x18\x05\x20\
    \x01(\rR\neventCountBq\x82\xb5\x18mNumber\x20of\x20events\x20involving\
    \x20this\x20user\x20&\x20app.\x20(Only\x20set\x20for\x20results\x20in\
    \x20being_discussed.)\x20DEPRECATED\x20AND\x20UNUSED.\x1a\x95\x03\n\x0eA\
    ppFriendsInfo\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\xd2\
    \x01\n\x07friends\x18\x02\x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_\
    Response.FriendPlayTimeR\x07friendsB\x7f\x82\xb5\x18{Friends\x20(w/\x20p\
    laytime)\x20that\x20meet\x20a\x20specific\x20criteria\x20--\x20e.g.\x20f\
    or\x20trending,\x20only\x20includes\x20friends\x20w/\x20more\x20playtime\
    \x20this\x20week.\x12\x97\x01\n\rdisplay_order\x18\x03\x20\x01(\rR\x0cdi\
    splayOrderBr\x82\xb5\x18nIndex\x20indicating\x20the\x20order\x20in\x20wh\
    ich\x20this\x20app\x20should\x20be\x20displayed,\x20relative\x20to\x20ot\
    her\x20apps\x20in\x20the\x20same\x20response.\":\n\"CPlayer_GetGameBadge\
    Levels_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\xe6\x01\
    \n#CPlayer_GetGameBadgeLevels_Response\x12!\n\x0cplayer_level\x18\x01\
    \x20\x01(\rR\x0bplayerLevel\x12B\n\x06badges\x18\x02\x20\x03(\x0b2*.CPla\
    yer_GetGameBadgeLevels_Response.BadgeR\x06badges\x1aX\n\x05Badge\x12\x14\
    \n\x05level\x18\x01\x20\x01(\x05R\x05level\x12\x16\n\x06series\x18\x02\
    \x20\x01(\x05R\x06series\x12!\n\x0cborder_color\x18\x03\x20\x01(\rR\x0bb\
    orderColor\"\x7f\n$CPlayer_GetProfileBackground_Request\x12;\n\x07steami\
    d\x18\x01\x20\x01(\x06R\x07steamidB!\x82\xb5\x18\x1dThe\x20player\x20we'\
    re\x20asking\x20about\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\x08langu\
    age\"\x93\x06\n\x0bProfileItem\x12(\n\x0fcommunityitemid\x18\x01\x20\x01\
    (\x04R\x0fcommunityitemid\x12N\n\x0bimage_small\x18\x02\x20\x01(\tR\nima\
    geSmallB-\x82\xb5\x18)small\x20image\x20used\x20in\x20backpack\x20or\x20\
    selection\x125\n\x0bimage_large\x18\x03\x20\x01(\tR\nimageLargeB\x14\x82\
    \xb5\x18\x10the\x20image\x20itself\x12$\n\x04name\x18\x04\x20\x01(\tR\
    \x04nameB\x10\x82\xb5\x18\x0cenglish\x20name\x122\n\nitem_title\x18\x05\
    \x20\x01(\tR\titemTitleB\x13\x82\xb5\x18\x0flocalized\x20title\x12D\n\
    \x10item_description\x18\x06\x20\x01(\tR\x0fitemDescriptionB\x19\x82\xb5\
    \x18\x15localized\x20description\x12\x14\n\x05appid\x18\x07\x20\x01(\rR\
    \x05appid\x12\x1b\n\titem_type\x18\x08\x20\x01(\rR\x08itemType\x12\x1d\n\
    \nitem_class\x18\t\x20\x01(\rR\titemClass\x126\n\nmovie_webm\x18\n\x20\
    \x01(\tR\tmovieWebmB\x17\x82\xb5\x18\x13URL\x20to\x20webm,\x20if\x20any\
    \x123\n\tmovie_mp4\x18\x0b\x20\x01(\tR\x08movieMp4B\x16\x82\xb5\x18\x12U\
    RL\x20to\x20mp4,\x20if\x20any\x12G\n\x10movie_webm_small\x18\r\x20\x01(\
    \tR\x0emovieWebmSmallB\x1d\x82\xb5\x18\x19URL\x20to\x20small\x20webm,\
    \x20if\x20any\x12D\n\x0fmovie_mp4_small\x18\x0e\x20\x01(\tR\rmovieMp4Sma\
    llB\x1c\x82\xb5\x18\x18URL\x20to\x20small\x20mp4,\x20if\x20any\x12e\n\
    \x0eequipped_flags\x18\x0c\x20\x01(\rR\requippedFlagsB>\x82\xb5\x18:Spec\
    ial\x20flags\x20set\x20when\x20equipped\x20(EProfileItemEquippedFlag)\"d\
    \n%CPlayer_GetProfileBackground_Response\x12;\n\x12profile_background\
    \x18\x01\x20\x01(\x0b2\x0c.ProfileItemR\x11profileBackground\"P\n$CPlaye\
    r_SetProfileBackground_Request\x12(\n\x0fcommunityitemid\x18\x01\x20\x01\
    (\x04R\x0fcommunityitemid\"'\n%CPlayer_SetProfileBackground_Response\"\
    \x83\x01\n(CPlayer_GetMiniProfileBackground_Request\x12;\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamidB!\x82\xb5\x18\x1dThe\x20player\x20we'r\
    e\x20asking\x20about\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\x08langua\
    ge\"h\n)CPlayer_GetMiniProfileBackground_Response\x12;\n\x12profile_back\
    ground\x18\x01\x20\x01(\x0b2\x0c.ProfileItemR\x11profileBackground\"T\n(\
    CPlayer_SetMiniProfileBackground_Request\x12(\n\x0fcommunityitemid\x18\
    \x01\x20\x01(\x04R\x0fcommunityitemid\"+\n)CPlayer_SetMiniProfileBackgro\
    und_Response\"y\n\x1eCPlayer_GetAvatarFrame_Request\x12;\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamidB!\x82\xb5\x18\x1dThe\x20player\x20we'r\
    e\x20asking\x20about\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\x08langua\
    ge\"R\n\x1fCPlayer_GetAvatarFrame_Response\x12/\n\x0cavatar_frame\x18\
    \x01\x20\x01(\x0b2\x0c.ProfileItemR\x0bavatarFrame\"J\n\x1eCPlayer_SetAv\
    atarFrame_Request\x12(\n\x0fcommunityitemid\x18\x01\x20\x01(\x04R\x0fcom\
    munityitemid\"!\n\x1fCPlayer_SetAvatarFrame_Response\"|\n!CPlayer_GetAni\
    matedAvatar_Request\x12;\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamidB!\
    \x82\xb5\x18\x1dThe\x20player\x20we're\x20asking\x20about\x12\x1a\n\x08l\
    anguage\x18\x02\x20\x01(\tR\x08language\"J\n\"CPlayer_GetAnimatedAvatar_\
    Response\x12$\n\x06avatar\x18\x01\x20\x01(\x0b2\x0c.ProfileItemR\x06avat\
    ar\"M\n!CPlayer_SetAnimatedAvatar_Request\x12(\n\x0fcommunityitemid\x18\
    \x01\x20\x01(\x04R\x0fcommunityitemid\"$\n\"CPlayer_SetAnimatedAvatar_Re\
    sponse\"B\n$CPlayer_GetProfileItemsOwned_Request\x12\x1a\n\x08language\
    \x18\x01\x20\x01(\tR\x08language\"\xd5\x02\n%CPlayer_GetProfileItemsOwne\
    d_Response\x12=\n\x13profile_backgrounds\x18\x01\x20\x03(\x0b2\x0c.Profi\
    leItemR\x12profileBackgrounds\x12F\n\x18mini_profile_backgrounds\x18\x02\
    \x20\x03(\x0b2\x0c.ProfileItemR\x16miniProfileBackgrounds\x121\n\ravatar\
    _frames\x18\x03\x20\x03(\x0b2\x0c.ProfileItemR\x0cavatarFrames\x127\n\
    \x10animated_avatars\x18\x04\x20\x03(\x0b2\x0c.ProfileItemR\x0fanimatedA\
    vatars\x129\n\x11profile_modifiers\x18\x05\x20\x03(\x0b2\x0c.ProfileItem\
    R\x10profileModifiers\"_\n'CPlayer_GetProfileItemsEquipped_Request\x12\
    \x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1a\n\x08language\
    \x18\x02\x20\x01(\tR\x08language\"\xce\x02\n(CPlayer_GetProfileItemsEqui\
    pped_Response\x12;\n\x12profile_background\x18\x01\x20\x01(\x0b2\x0c.Pro\
    fileItemR\x11profileBackground\x12D\n\x17mini_profile_background\x18\x02\
    \x20\x01(\x0b2\x0c.ProfileItemR\x15miniProfileBackground\x12/\n\x0cavata\
    r_frame\x18\x03\x20\x01(\x0b2\x0c.ProfileItemR\x0bavatarFrame\x125\n\x0f\
    animated_avatar\x18\x04\x20\x01(\x0b2\x0c.ProfileItemR\x0eanimatedAvatar\
    \x127\n\x10profile_modifier\x18\x05\x20\x01(\x0b2\x0c.ProfileItemR\x0fpr\
    ofileModifier\"\x92\x01\n+CPlayer_SetEquippedProfileItemFlags_Request\
    \x12(\n\x0fcommunityitemid\x18\x01\x20\x01(\x04R\x0fcommunityitemid\x129\
    \n\x05flags\x18\x02\x20\x01(\rR\x05flagsB#\x82\xb5\x18\x1fSet\x20of\x20E\
    ProfileItemEquippedFlag\".\n,CPlayer_SetEquippedProfileItemFlags_Respons\
    e\"!\n\x1fCPlayer_GetEmoticonList_Request\"\xa1\x02\n\x20CPlayer_GetEmot\
    iconList_Response\x12H\n\temoticons\x18\x01\x20\x03(\x0b2*.CPlayer_GetEm\
    oticonList_Response.EmoticonR\temoticons\x1a\xb2\x01\n\x08Emoticon\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05count\x18\x02\
    \x20\x01(\x05R\x05count\x12$\n\x0etime_last_used\x18\x03\x20\x01(\rR\x0c\
    timeLastUsed\x12\x1b\n\tuse_count\x18\x04\x20\x01(\rR\x08useCount\x12#\n\
    \rtime_received\x18\x05\x20\x01(\rR\x0ctimeReceived\x12\x14\n\x05appid\
    \x18\x06\x20\x01(\rR\x05appid\"w\n'CPlayer_GetAchievementsProgress_Reque\
    st\x12\x18\n\x07steamid\x18\x01\x20\x01(\x04R\x07steamid\x12\x1a\n\x08la\
    nguage\x18\x02\x20\x01(\tR\x08language\x12\x16\n\x06appids\x18\x03\x20\
    \x03(\rR\x06appids\"\xde\x02\n(CPlayer_GetAchievementsProgress_Response\
    \x12p\n\x14achievement_progress\x18\x01\x20\x03(\x0b2=.CPlayer_GetAchiev\
    ementsProgress_Response.AchievementProgressR\x13achievementProgress\x1a\
    \xbf\x01\n\x13AchievementProgress\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12\x1a\n\x08unlocked\x18\x02\x20\x01(\rR\x08unlocked\x12\x14\
    \n\x05total\x18\x03\x20\x01(\rR\x05total\x12\x1e\n\npercentage\x18\x04\
    \x20\x01(\x02R\npercentage\x12!\n\x0call_unlocked\x18\x05\x20\x01(\x08R\
    \x0ballUnlocked\x12\x1d\n\ncache_time\x18\x06\x20\x01(\rR\tcacheTime\"<\
    \n\x20CPlayer_GetFavoriteBadge_Request\x12\x18\n\x07steamid\x18\x01\x20\
    \x01(\x04R\x07steamid\"\x81\x02\n!CPlayer_GetFavoriteBadge_Response\x12,\
    \n\x12has_favorite_badge\x18\x01\x20\x01(\x08R\x10hasFavoriteBadge\x12\
    \x18\n\x07badgeid\x18\x02\x20\x01(\rR\x07badgeid\x12(\n\x0fcommunityitem\
    id\x18\x03\x20\x01(\x04R\x0fcommunityitemid\x12\x1b\n\titem_type\x18\x04\
    \x20\x01(\rR\x08itemType\x12!\n\x0cborder_color\x18\x05\x20\x01(\rR\x0bb\
    orderColor\x12\x14\n\x05appid\x18\x06\x20\x01(\rR\x05appid\x12\x14\n\x05\
    level\x18\x07\x20\x01(\rR\x05level\"f\n\x20CPlayer_SetFavoriteBadge_Requ\
    est\x12(\n\x0fcommunityitemid\x18\x01\x20\x01(\x04R\x0fcommunityitemid\
    \x12\x18\n\x07badgeid\x18\x02\x20\x01(\rR\x07badgeid\"#\n!CPlayer_SetFav\
    oriteBadge_Response\"\x8b\x01\n'CPlayer_GetProfileCustomization_Request\
    \x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12F\n\x1finclude\
    _inactive_customizations\x18\x02\x20\x01(\x08R\x1dincludeInactiveCustomi\
    zations\"\x8b\x03\n\x18ProfileCustomizationSlot\x12\x12\n\x04slot\x18\
    \x01\x20\x01(\rR\x04slot\x12\x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\
    \x12(\n\x0fpublishedfileid\x18\x03\x20\x01(\x04R\x0fpublishedfileid\x12!\
    \n\x0citem_assetid\x18\x04\x20\x01(\x04R\x0bitemAssetid\x12%\n\x0eitem_c\
    ontextid\x18\x05\x20\x01(\x04R\ritemContextid\x12\x14\n\x05notes\x18\x06\
    \x20\x01(\tR\x05notes\x12\x14\n\x05title\x18\x07\x20\x01(\tR\x05title\
    \x12\x1c\n\taccountid\x18\x08\x20\x01(\rR\taccountid\x12\x18\n\x07badgei\
    d\x18\t\x20\x01(\rR\x07badgeid\x12!\n\x0cborder_color\x18\n\x20\x01(\rR\
    \x0bborderColor\x12!\n\x0citem_classid\x18\x0b\x20\x01(\x04R\x0bitemClas\
    sid\x12'\n\x0fitem_instanceid\x18\x0c\x20\x01(\x04R\x0eitemInstanceid\"\
    \xd7\x02\n\x14ProfileCustomization\x12m\n\x12customization_type\x18\x01\
    \x20\x01(\x0e2\x1a.EProfileCustomizationType:\"k_EProfileCustomizationTy\
    peInvalidR\x11customizationType\x12\x14\n\x05large\x18\x02\x20\x01(\x08R\
    \x05large\x12/\n\x05slots\x18\x03\x20\x03(\x0b2\x19.ProfileCustomization\
    SlotR\x05slots\x12\x16\n\x06active\x18\x04\x20\x01(\x08R\x06active\x12q\
    \n\x13customization_style\x18\x05\x20\x01(\x0e2\x1b.EProfileCustomizatio\
    nStyle:#k_EProfileCustomizationStyleDefaultR\x12customizationStyle\"?\n\
    \x0cProfileTheme\x12\x19\n\x08theme_id\x18\x01\x20\x01(\tR\x07themeId\
    \x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\"\xc6\x01\n(CPlayer_Get\
    ProfileCustomization_Response\x12=\n\x0ecustomizations\x18\x01\x20\x03(\
    \x0b2\x15.ProfileCustomizationR\x0ecustomizations\x12'\n\x0fslots_availa\
    ble\x18\x02\x20\x01(\rR\x0eslotsAvailable\x122\n\rprofile_theme\x18\x03\
    \x20\x01(\x0b2\r.ProfileThemeR\x0cprofileTheme\"+\n)CPlayer_GetProfileTh\
    emesAvailable_Request\"b\n*CPlayer_GetProfileThemesAvailable_Response\
    \x124\n\x0eprofile_themes\x18\x01\x20\x03(\x0b2\r.ProfileThemeR\rprofile\
    Themes\"<\n\x1fCPlayer_SetProfileTheme_Request\x12\x19\n\x08theme_id\x18\
    \x01\x20\x01(\tR\x07themeId\"\"\n\x20CPlayer_SetProfileTheme_Response\"\
    \\\n#CPlayer_PostStatusToFriends_Request\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\x12\x1f\n\x0bstatus_text\x18\x02\x20\x01(\tR\nstatusTe\
    xt\"&\n$CPlayer_PostStatusToFriends_Response\"v\n\x1fCPlayer_GetPostedSt\
    atus_Request\x12;\n\x07steamid\x18\x01\x20\x01(\x04R\x07steamidB!\x82\
    \xb5\x18\x1dThe\x20player\x20we're\x20asking\x20about\x12\x16\n\x06posti\
    d\x18\x02\x20\x01(\x04R\x06postid\"\xa9\x01\n\x20CPlayer_GetPostedStatus\
    _Response\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x16\n\
    \x06postid\x18\x02\x20\x01(\x04R\x06postid\x12\x1f\n\x0bstatus_text\x18\
    \x03\x20\x01(\tR\nstatusText\x12\x18\n\x07deleted\x18\x04\x20\x01(\x08R\
    \x07deleted\x12\x14\n\x05appid\x18\x05\x20\x01(\rR\x05appid\"<\n\"CPlaye\
    r_DeletePostedStatus_Request\x12\x16\n\x06postid\x18\x01\x20\x01(\x04R\
    \x06postid\"%\n#CPlayer_DeletePostedStatus_Response\"\x91\x01\n\"CPlayer\
    _GetLastPlayedTimes_Request\x12k\n\x0fmin_last_played\x18\x01\x20\x01(\r\
    R\rminLastPlayedBC\x82\xb5\x18?The\x20most\x20recent\x20last-played\x20t\
    ime\x20the\x20client\x20already\x20knows\x20about\"\xed\x05\n#CPlayer_Ge\
    tLastPlayedTimes_Response\x12?\n\x05games\x18\x01\x20\x03(\x0b2).CPlayer\
    _GetLastPlayedTimes_Response.GameR\x05games\x1a\x84\x05\n\x04Game\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\x05R\x05appid\x12#\n\rlast_playtime\x18\
    \x02\x20\x01(\rR\x0clastPlaytime\x12'\n\x0fplaytime_2weeks\x18\x03\x20\
    \x01(\x05R\x0eplaytime2weeks\x12)\n\x10playtime_forever\x18\x04\x20\x01(\
    \x05R\x0fplaytimeForever\x12%\n\x0efirst_playtime\x18\x05\x20\x01(\rR\rf\
    irstPlaytime\x128\n\x18playtime_windows_forever\x18\x06\x20\x01(\x05R\
    \x16playtimeWindowsForever\x120\n\x14playtime_mac_forever\x18\x07\x20\
    \x01(\x05R\x12playtimeMacForever\x124\n\x16playtime_linux_forever\x18\
    \x08\x20\x01(\x05R\x14playtimeLinuxForever\x124\n\x16first_windows_playt\
    ime\x18\t\x20\x01(\rR\x14firstWindowsPlaytime\x12,\n\x12first_mac_playti\
    me\x18\n\x20\x01(\rR\x10firstMacPlaytime\x120\n\x14first_linux_playtime\
    \x18\x0b\x20\x01(\rR\x12firstLinuxPlaytime\x122\n\x15last_windows_playti\
    me\x18\x0c\x20\x01(\rR\x13lastWindowsPlaytime\x12*\n\x11last_mac_playtim\
    e\x18\r\x20\x01(\rR\x0flastMacPlaytime\x12.\n\x13last_linux_playtime\x18\
    \x0e\x20\x01(\rR\x11lastLinuxPlaytime\"\x1b\n\x19CPlayer_AcceptSSA_Reque\
    st\"\x1c\n\x1aCPlayer_AcceptSSA_Response\"!\n\x1fCPlayer_GetNicknameList\
    _Request\"\xbe\x01\n\x20CPlayer_GetNicknameList_Response\x12N\n\tnicknam\
    es\x18\x01\x20\x03(\x0b20.CPlayer_GetNicknameList_Response.PlayerNicknam\
    eR\tnicknames\x1aJ\n\x0ePlayerNickname\x12\x1c\n\taccountid\x18\x01\x20\
    \x01(\x07R\taccountid\x12\x1a\n\x08nickname\x18\x02\x20\x01(\tR\x08nickn\
    ame\")\n'CPlayer_GetPerFriendPreferences_Request\"\x84\x07\n\x14PerFrien\
    dPreferences\x12\x1c\n\taccountid\x18\x01\x20\x01(\x07R\taccountid\x12\
    \x1a\n\x08nickname\x18\x02\x20\x01(\tR\x08nickname\x12x\n\x18notificatio\
    ns_showingame\x18\x03\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENotific\
    ationSettingNotifyUseDefaultR\x17notificationsShowingame\x12x\n\x18notif\
    ications_showonline\x18\x04\x20\x01(\x0e2\x15.ENotificationSetting:&k_EN\
    otificationSettingNotifyUseDefaultR\x17notificationsShowonline\x12|\n\
    \x1anotifications_showmessages\x18\x05\x20\x01(\x0e2\x15.ENotificationSe\
    tting:&k_ENotificationSettingNotifyUseDefaultR\x19notificationsShowmessa\
    ges\x12j\n\x11sounds_showingame\x18\x06\x20\x01(\x0e2\x15.ENotificationS\
    etting:&k_ENotificationSettingNotifyUseDefaultR\x10soundsShowingame\x12j\
    \n\x11sounds_showonline\x18\x07\x20\x01(\x0e2\x15.ENotificationSetting:&\
    k_ENotificationSettingNotifyUseDefaultR\x10soundsShowonline\x12n\n\x13so\
    unds_showmessages\x18\x08\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENot\
    ificationSettingNotifyUseDefaultR\x12soundsShowmessages\x12x\n\x18notifi\
    cations_sendmobile\x18\t\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENoti\
    ficationSettingNotifyUseDefaultR\x17notificationsSendmobile\"c\n(CPlayer\
    _GetPerFriendPreferences_Response\x127\n\x0bpreferences\x18\x01\x20\x03(\
    \x0b2\x15.PerFriendPreferencesR\x0bpreferences\"b\n'CPlayer_SetPerFriend\
    Preferences_Request\x127\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x15.PerF\
    riendPreferencesR\x0bpreferences\"*\n(CPlayer_SetPerFriendPreferences_Re\
    sponse\"l\n\x19CPlayer_AddFriend_Request\x12O\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamidB5\x82\xb5\x181Steam\x20ID\x20of\x20user\x20to\x20w\
    hom\x20to\x20send\x20a\x20friend\x20invite.\"\xae\x02\n\x1aCPlayer_AddFr\
    iend_Response\x12[\n\x0binvite_sent\x18\x01\x20\x01(\x08R\ninviteSentB:\
    \x82\xb5\x186True\x20if\x20the\x20operation\x20was\x20successful,\x20fal\
    se\x20otherwise.\x12\x9a\x01\n\x13friend_relationship\x18\x02\x20\x01(\r\
    R\x12friendRelationshipBi\x82\xb5\x18ethe\x20resulting\x20relationship.\
    \x20\x20Depending\x20on\x20state,\x20may\x20move\x20directly\x20to\x20fr\
    iends\x20rather\x20than\x20invite\x20sent\x12\x16\n\x06result\x18\x03\
    \x20\x01(\x05R\x06result\"[\n\x1cCPlayer_RemoveFriend_Request\x12;\n\x07\
    steamid\x18\x01\x20\x01(\x06R\x07steamidB!\x82\xb5\x18\x1dSteam\x20ID\
    \x20of\x20friend\x20to\x20remove.\"p\n\x1dCPlayer_RemoveFriend_Response\
    \x12O\n\x13friend_relationship\x18\x01\x20\x01(\rR\x12friendRelationship\
    B\x1e\x82\xb5\x18\x1athe\x20resulting\x20relationship\"\x92\x01\n\x1cCPl\
    ayer_IgnoreFriend_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07\
    steamid\x12X\n\x08unignore\x18\x02\x20\x01(\x08R\x08unignoreB<\x82\xb5\
    \x188If\x20set,\x20remove\x20from\x20ignore/block\x20list\x20instead\x20\
    of\x20adding\x20\"p\n\x1dCPlayer_IgnoreFriend_Response\x12O\n\x13friend_\
    relationship\x18\x01\x20\x01(\rR\x12friendRelationshipB\x1e\x82\xb5\x18\
    \x1athe\x20resulting\x20relationship\")\n'CPlayer_GetCommunityPreference\
    s_Request\"\xb1\x03\n\x1cCPlayer_CommunityPreferences\x12C\n\x1bhide_adu\
    lt_content_violence\x18\x01\x20\x01(\x08:\x04trueR\x18hideAdultContentVi\
    olence\x129\n\x16hide_adult_content_sex\x18\x02\x20\x01(\x08:\x04trueR\
    \x13hideAdultContentSex\x12<\n\x16parenthesize_nicknames\x18\x04\x20\x01\
    (\x08:\x05falseR\x15parenthesizeNicknames\x12i\n\x13text_filter_setting\
    \x18\x05\x20\x01(\x0e2\x13.ETextFilterSetting:$k_ETextFilterSettingSteam\
    LabOptedOutR\x11textFilterSetting\x12;\n\x1atext_filter_ignore_friends\
    \x18\x06\x20\x01(\x08R\x17textFilterIgnoreFriends\x12+\n\x11timestamp_up\
    dated\x18\x03\x20\x01(\rR\x10timestampUpdated\"k\n(CPlayer_GetCommunityP\
    references_Response\x12?\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x1d.CPla\
    yer_CommunityPreferencesR\x0bpreferences\"j\n'CPlayer_SetCommunityPrefer\
    ences_Request\x12?\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x1d.CPlayer_Co\
    mmunityPreferencesR\x0bpreferences\"*\n(CPlayer_SetCommunityPreferences_\
    Response\"$\n\"CPlayer_GetTextFilterWords_Request\"\xa3\x01\n\x17CPlayer\
    _TextFilterWords\x12D\n\x1ftext_filter_custom_banned_words\x18\x01\x20\
    \x03(\tR\x1btextFilterCustomBannedWords\x12B\n\x1etext_filter_custom_cle\
    an_words\x18\x02\x20\x03(\tR\x1atextFilterCustomCleanWords\"U\n#CPlayer_\
    GetTextFilterWords_Response\x12.\n\x05words\x18\x01\x20\x01(\x0b2\x18.CP\
    layer_TextFilterWordsR\x05words\"J\n,CPlayer_GetNewSteamAnnouncementStat\
    e_Request\x12\x1a\n\x08language\x18\x01\x20\x01(\x05R\x08language\"\xf1\
    \x01\n-CPlayer_GetNewSteamAnnouncementState_Response\x12\x14\n\x05state\
    \x18\x01\x20\x01(\x05R\x05state\x123\n\x15announcement_headline\x18\x02\
    \x20\x01(\tR\x14announcementHeadline\x12)\n\x10announcement_url\x18\x03\
    \x20\x01(\tR\x0fannouncementUrl\x12\x1f\n\x0btime_posted\x18\x04\x20\x01\
    (\rR\ntimePosted\x12)\n\x10announcement_gid\x18\x05\x20\x01(\x04R\x0fann\
    ouncementGid\"}\n/CPlayer_UpdateSteamAnnouncementLastRead_Request\x12)\n\
    \x10announcement_gid\x18\x01\x20\x01(\x04R\x0fannouncementGid\x12\x1f\n\
    \x0btime_posted\x18\x02\x20\x01(\rR\ntimePosted\"2\n0CPlayer_UpdateSteam\
    AnnouncementLastRead_Response\"$\n\"CPlayer_GetPrivacySettings_Request\"\
    \xcb\x02\n\x10CPrivacySettings\x12#\n\rprivacy_state\x18\x01\x20\x01(\
    \x05R\x0cprivacyState\x126\n\x17privacy_state_inventory\x18\x02\x20\x01(\
    \x05R\x15privacyStateInventory\x12.\n\x13privacy_state_gifts\x18\x03\x20\
    \x01(\x05R\x11privacyStateGifts\x128\n\x18privacy_state_ownedgames\x18\
    \x04\x20\x01(\x05R\x16privacyStateOwnedgames\x124\n\x16privacy_state_pla\
    ytime\x18\x05\x20\x01(\x05R\x14privacyStatePlaytime\x12:\n\x19privacy_st\
    ate_friendslist\x18\x06\x20\x01(\x05R\x17privacyStateFriendslist\"c\n#CP\
    layer_GetPrivacySettings_Response\x12<\n\x10privacy_settings\x18\x01\x20\
    \x01(\x0b2\x11.CPrivacySettingsR\x0fprivacySettings\":\n\"CPlayer_GetDur\
    ationControl_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\
    \x93\x02\n#CPlayer_GetDurationControl_Response\x12\x1d\n\nis_enabled\x18\
    \x01\x20\x01(\x08R\tisEnabled\x12\x18\n\x07seconds\x18\x02\x20\x01(\x05R\
    \x07seconds\x12#\n\rseconds_today\x18\x03\x20\x01(\x05R\x0csecondsToday\
    \x122\n\x15is_steamchina_account\x18\x04\x20\x01(\x08R\x13isSteamchinaAc\
    count\x12&\n\x0fis_age_verified\x18\x05\x20\x01(\x08R\risAgeVerified\x12\
    2\n\x15seconds_allowed_today\x18\x06\x20\x01(\rR\x13secondsAllowedToday\
    \"g\n$CPlayer_LastPlayedTimes_Notification\x12?\n\x05games\x18\x01\x20\
    \x03(\x0b2).CPlayer_GetLastPlayedTimes_Response.GameR\x05games\"\x8d\x01\
    \n*CPlayer_FriendNicknameChanged_Notification\x12\x1c\n\taccountid\x18\
    \x01\x20\x01(\x07R\taccountid\x12\x1a\n\x08nickname\x18\x02\x20\x01(\tR\
    \x08nickname\x12%\n\x0fis_echo_to_self\x18\x03\x20\x01(\x08R\x0cisEchoTo\
    Self\"V\n6CPlayer_FriendEquippedProfileItemsChanged_Notification\x12\x1c\
    \n\taccountid\x18\x01\x20\x01(\x07R\taccountid\"\xf2\x01\n.CPlayer_NewSt\
    eamAnnouncementState_Notification\x12\x14\n\x05state\x18\x01\x20\x01(\
    \x05R\x05state\x123\n\x15announcement_headline\x18\x02\x20\x01(\tR\x14an\
    nouncementHeadline\x12)\n\x10announcement_url\x18\x03\x20\x01(\tR\x0fann\
    ouncementUrl\x12\x1f\n\x0btime_posted\x18\x04\x20\x01(\rR\ntimePosted\
    \x12)\n\x10announcement_gid\x18\x05\x20\x01(\x04R\x0fannouncementGid\"s\
    \n0CPlayer_CommunityPreferencesChanged_Notification\x12?\n\x0bpreference\
    s\x18\x01\x20\x01(\x0b2\x1d.CPlayer_CommunityPreferencesR\x0bpreferences\
    \"]\n+CPlayer_TextFilterWordsChanged_Notification\x12.\n\x05words\x18\
    \x01\x20\x01(\x0b2\x18.CPlayer_TextFilterWordsR\x05words\"\x89\x01\n0CPl\
    ayer_PerFriendPreferencesChanged_Notification\x12\x1c\n\taccountid\x18\
    \x01\x20\x01(\x07R\taccountid\x127\n\x0bpreferences\x18\x02\x20\x01(\x0b\
    2\x15.PerFriendPreferencesR\x0bpreferences\"k\n+CPlayer_PrivacySettingsC\
    hanged_Notification\x12<\n\x10privacy_settings\x18\x01\x20\x01(\x0b2\x11\
    .CPrivacySettingsR\x0fprivacySettings*\xc5\x07\n\x19EProfileCustomizatio\
    nType\x12&\n\"k_EProfileCustomizationTypeInvalid\x10\0\x126\n2k_EProfile\
    CustomizationTypeRareAchievementShowcase\x10\x01\x12,\n(k_EProfileCustom\
    izationTypeGameCollector\x10\x02\x12+\n'k_EProfileCustomizationTypeItemS\
    howcase\x10\x03\x12,\n(k_EProfileCustomizationTypeTradeShowcase\x10\x04\
    \x12%\n!k_EProfileCustomizationTypeBadges\x10\x05\x12+\n'k_EProfileCusto\
    mizationTypeFavoriteGame\x10\x06\x121\n-k_EProfileCustomizationTypeScree\
    nshotShowcase\x10\x07\x12)\n%k_EProfileCustomizationTypeCustomText\x10\
    \x08\x12,\n(k_EProfileCustomizationTypeFavoriteGroup\x10\t\x12-\n)k_EPro\
    fileCustomizationTypeRecommendation\x10\n\x12+\n'k_EProfileCustomization\
    TypeWorkshopItem\x10\x0b\x12)\n%k_EProfileCustomizationTypeMyWorkshop\
    \x10\x0c\x12.\n*k_EProfileCustomizationTypeArtworkShowcase\x10\r\x12,\n(\
    k_EProfileCustomizationTypeVideoShowcase\x10\x0e\x12%\n!k_EProfileCustom\
    izationTypeGuides\x10\x0f\x12'\n#k_EProfileCustomizationTypeMyGuides\x10\
    \x10\x12+\n'k_EProfileCustomizationTypeAchievements\x10\x11\x12)\n%k_EPr\
    ofileCustomizationTypeGreenlight\x10\x12\x12+\n'k_EProfileCustomizationT\
    ypeMyGreenlight\x10\x13\x12%\n!k_EProfileCustomizationTypeSalien\x10\x14\
    *\x99\x02\n\x1aEProfileCustomizationStyle\x12'\n#k_EProfileCustomization\
    StyleDefault\x10\0\x12(\n$k_EProfileCustomizationStyleSelected\x10\x01\
    \x12&\n\"k_EProfileCustomizationStyleRarest\x10\x02\x12*\n&k_EProfileCus\
    tomizationStyleMostRecent\x10\x03\x12&\n\"k_EProfileCustomizationStyleRa\
    ndom\x10\x04\x12,\n(k_EProfileCustomizationStyleHighestRated\x10\x05*\
    \x85\x01\n\x14ENotificationSetting\x12*\n&k_ENotificationSettingNotifyUs\
    eDefault\x10\0\x12\x20\n\x1ck_ENotificationSettingAlways\x10\x01\x12\x1f\
    \n\x1bk_ENotificationSettingNever\x10\x02*\xb0\x01\n\x12ETextFilterSetti\
    ng\x12(\n$k_ETextFilterSettingSteamLabOptedOut\x10\0\x12\x1f\n\x1bk_ETex\
    tFilterSettingEnabled\x10\x01\x12-\n)k_ETextFilterSettingEnabledAllowPro\
    fanity\x10\x02\x12\x20\n\x1ck_ETextFilterSettingDisabled\x10\x032\xd34\n\
    \x06Player\x12\xef\x01\n\"GetMutualFriendsForIncomingInvites\x123.CPlaye\
    r_GetMutualFriendsForIncomingInvites_Request\x1a4.CPlayer_GetMutualFrien\
    dsForIncomingInvites_Response\"^\x82\xb5\x18ZGet\x20me\x20the\x20mutual\
    \x20friends\x20for\x20each\x20of\x20my\x20pending\x20incoming\x20invites\
    \x20(individuals\x20and\x20clans).\x12\x80\x01\n\rGetOwnedGames\x12\x1e.\
    CPlayer_GetOwnedGames_Request\x1a\x1f.CPlayer_GetOwnedGames_Response\".\
    \x82\xb5\x18*Return\x20a\x20list\x20of\x20games\x20owned\x20by\x20the\
    \x20player\x12\x7f\n\x0bGetPlayNext\x12\x1c.CPlayer_GetPlayNext_Request\
    \x1a\x1d.CPlayer_GetPlayNext_Response\"3\x82\xb5\x18/Return\x20suggested\
    \x20games\x20for\x20player\x20to\x20play\x20next.\x12\xb8\x01\n\x16GetFr\
    iendsGameplayInfo\x12'.CPlayer_GetFriendsGameplayInfo_Request\x1a(.CPlay\
    er_GetFriendsGameplayInfo_Response\"K\x82\xb5\x18GGet\x20a\x20list\x20of\
    \x20friends\x20who\x20are\x20playing,\x20have\x20played,\x20own,\x20or\
    \x20want\x20a\x20game\x12\xae\x01\n\x16GetFriendsAppsActivity\x12'.CPlay\
    er_GetFriendsAppsActivity_Request\x1a(.CPlayer_GetFriendsAppsActivity_Re\
    sponse\"A\x82\xb5\x18=Get\x20lists\x20of\x20apps\x20friends\x20are\x20ac\
    tive\x20in,\x20in\x20a\x20variety\x20of\x20ways\x12\xb6\x01\n\x12GetGame\
    BadgeLevels\x12#.CPlayer_GetGameBadgeLevels_Request\x1a$.CPlayer_GetGame\
    BadgeLevels_Response\"U\x82\xb5\x18QReturns\x20the\x20Steam\x20Level\x20\
    of\x20a\x20user,\x20the\x20Badge\x20level\x20for\x20the\x20game,\x20and\
    \x20if\x20it's\x20foil\x12\xa6\x01\n\x14GetProfileBackground\x12%.CPlaye\
    r_GetProfileBackground_Request\x1a&.CPlayer_GetProfileBackground_Respons\
    e\"?\x82\xb5\x18;Gets\x20which\x20profile\x20background\x20is\x20active\
    \x20for\x20a\x20specific\x20user\x12\x8d\x01\n\x14SetProfileBackground\
    \x12%.CPlayer_SetProfileBackground_Request\x1a&.CPlayer_SetProfileBackgr\
    ound_Response\"&\x82\xb5\x18\"Sets\x20the\x20user's\x20profile\x20backgr\
    ound\x12\xb7\x01\n\x18GetMiniProfileBackground\x12).CPlayer_GetMiniProfi\
    leBackground_Request\x1a*.CPlayer_GetMiniProfileBackground_Response\"D\
    \x82\xb5\x18@Gets\x20which\x20mini\x20profile\x20background\x20is\x20act\
    ive\x20for\x20a\x20specific\x20user\x12\x9e\x01\n\x18SetMiniProfileBackg\
    round\x12).CPlayer_SetMiniProfileBackground_Request\x1a*.CPlayer_SetMini\
    ProfileBackground_Response\"+\x82\xb5\x18'Sets\x20the\x20user's\x20mini\
    \x20profile\x20background\x12\x8e\x01\n\x0eGetAvatarFrame\x12\x1f.CPlaye\
    r_GetAvatarFrame_Request\x1a\x20.CPlayer_GetAvatarFrame_Response\"9\x82\
    \xb5\x185Gets\x20which\x20avatar\x20frame\x20is\x20active\x20for\x20a\
    \x20specific\x20user\x12\x87\x01\n\x0eSetAvatarFrame\x12\x1f.CPlayer_Set\
    AvatarFrame_Request\x1a\x20.CPlayer_SetAvatarFrame_Response\"2\x82\xb5\
    \x18.Sets\x20the\x20user's\x20avatar\x20frame\x20for\x20their\x20profile\
    \x12\x9a\x01\n\x11GetAnimatedAvatar\x12\".CPlayer_GetAnimatedAvatar_Requ\
    est\x1a#.CPlayer_GetAnimatedAvatar_Response\"<\x82\xb5\x188Gets\x20which\
    \x20animated\x20avatar\x20is\x20active\x20for\x20a\x20specific\x20user\
    \x12\x93\x01\n\x11SetAnimatedAvatar\x12\".CPlayer_SetAnimatedAvatar_Requ\
    est\x1a#.CPlayer_SetAnimatedAvatar_Response\"5\x82\xb5\x181Sets\x20the\
    \x20user's\x20animated\x20avatar\x20for\x20their\x20profile\x12\xa0\x01\
    \n\x14GetProfileItemsOwned\x12%.CPlayer_GetProfileItemsOwned_Request\x1a\
    &.CPlayer_GetProfileItemsOwned_Response\"9\x82\xb5\x185Returns\x20the\
    \x20items\x20the\x20user\x20can\x20equip\x20on\x20their\x20profile\x12\
    \xac\x01\n\x17GetProfileItemsEquipped\x12(.CPlayer_GetProfileItemsEquipp\
    ed_Request\x1a).CPlayer_GetProfileItemsEquipped_Response\"<\x82\xb5\x188\
    Returns\x20the\x20items\x20the\x20user\x20has\x20equipped\x20on\x20their\
    \x20profile\x12\xa7\x01\n\x1bSetEquippedProfileItemFlags\x12,.CPlayer_Se\
    tEquippedProfileItemFlags_Request\x1a-.CPlayer_SetEquippedProfileItemFla\
    gs_Response\"+\x82\xb5\x18'Sets\x20special\x20flags\x20on\x20the\x20equi\
    pped\x20item\x12\x91\x01\n\x0fGetEmoticonList\x12\x20.CPlayer_GetEmotico\
    nList_Request\x1a!.CPlayer_GetEmoticonList_Response\"9\x82\xb5\x185Gets\
    \x20a\x20list\x20of\x20the\x20emoticons\x20a\x20user\x20has\x20with\x20m\
    etadata\x12\xb9\x01\n\x17GetAchievementsProgress\x12(.CPlayer_GetAchieve\
    mentsProgress_Request\x1a).CPlayer_GetAchievementsProgress_Response\"I\
    \x82\xb5\x18EGets\x20the\x20achievement\x20completion\x20stats\x20for\
    \x20the\x20specified\x20list\x20of\x20apps.\x12\x90\x01\n\x10GetFavorite\
    Badge\x12!.CPlayer_GetFavoriteBadge_Request\x1a\".CPlayer_GetFavoriteBad\
    ge_Response\"5\x82\xb5\x181Gets\x20the\x20badge\x20the\x20user\x20has\
    \x20set\x20as\x20their\x20favorite\x12\x84\x01\n\x10SetFavoriteBadge\x12\
    !.CPlayer_SetFavoriteBadge_Request\x1a\".CPlayer_SetFavoriteBadge_Respon\
    se\")\x82\xb5\x18%Sets\x20the\x20badge\x20\x20as\x20the\x20users\x20favo\
    rite\x12\xa5\x01\n\x17GetProfileCustomization\x12(.CPlayer_GetProfileCus\
    tomization_Request\x1a).CPlayer_GetProfileCustomization_Response\"5\x82\
    \xb5\x181Returns\x20the\x20customizations\x20(if\x20any)\x20for\x20a\x20\
    profile\x12\x9d\x01\n\x19GetProfileThemesAvailable\x12*.CPlayer_GetProfi\
    leThemesAvailable_Request\x1a+.CPlayer_GetProfileThemesAvailable_Respons\
    e\"'\x82\xb5\x18#Gets\x20themes\x20available\x20for\x20the\x20user.\x12{\
    \n\x0fSetProfileTheme\x12\x20.CPlayer_SetProfileTheme_Request\x1a!.CPlay\
    er_SetProfileTheme_Response\"#\x82\xb5\x18\x1fSelects\x20a\x20theme\x20f\
    or\x20the\x20profile\x12\x91\x01\n\x13PostStatusToFriends\x12$.CPlayer_P\
    ostStatusToFriends_Request\x1a%.CPlayer_PostStatusToFriends_Response\"-\
    \x82\xb5\x18)Posts\x20custom\x20status\x20text\x20into\x20the\x20blotter\
    \x12\x86\x01\n\x0fGetPostedStatus\x12\x20.CPlayer_GetPostedStatus_Reques\
    t\x1a!.CPlayer_GetPostedStatus_Response\".\x82\xb5\x18*Gets\x20a\x20post\
    ed\x20status\x20text\x20for\x20a\x20user\x20by\x20id\x12\x92\x01\n\x12De\
    letePostedStatus\x12#.CPlayer_DeletePostedStatus_Request\x1a$.CPlayer_De\
    letePostedStatus_Response\"1\x82\xb5\x18-Deletes\x20a\x20posted\x20statu\
    s\x20text\x20for\x20a\x20user\x20by\x20id\x12\x95\x01\n\x18ClientGetLast\
    PlayedTimes\x12#.CPlayer_GetLastPlayedTimes_Request\x1a$.CPlayer_GetLast\
    PlayedTimes_Response\".\x82\xb5\x18*Gets\x20the\x20last-played\x20times\
    \x20for\x20the\x20account\x12c\n\tAcceptSSA\x12\x1a.CPlayer_AcceptSSA_Re\
    quest\x1a\x1b.CPlayer_AcceptSSA_Response\"\x1d\x82\xb5\x18\x19User\x20is\
    \x20accepting\x20the\x20SSA\x12\x94\x01\n\x0fGetNicknameList\x12\x20.CPl\
    ayer_GetNicknameList_Request\x1a!.CPlayer_GetNicknameList_Response\"<\
    \x82\xb5\x188Gets\x20the\x20list\x20of\x20nicknames\x20this\x20user\x20h\
    as\x20for\x20other\x20users\x12\xbd\x01\n\x17GetPerFriendPreferences\x12\
    (.CPlayer_GetPerFriendPreferences_Request\x1a).CPlayer_GetPerFriendPrefe\
    rences_Response\"M\x82\xb5\x18IGets\x20the\x20list\x20of\x20per-friend\
    \x20preferences\x20this\x20user\x20has\x20set\x20for\x20other\x20users\
    \x12\xb7\x01\n\x17SetPerFriendPreferences\x12(.CPlayer_SetPerFriendPrefe\
    rences_Request\x1a).CPlayer_SetPerFriendPreferences_Response\"G\x82\xb5\
    \x18CSets\x20the\x20logged\x20in\x20user's\x20per-friend\x20preferences\
    \x20for\x20the\x20given\x20user\x12s\n\tAddFriend\x12\x1a.CPlayer_AddFri\
    end_Request\x1a\x1b.CPlayer_AddFriend_Response\"-\x82\xb5\x18)Invites\
    \x20another\x20Steam\x20user\x20to\x20be\x20a\x20friend\x12\x82\x01\n\
    \x0cRemoveFriend\x12\x1d.CPlayer_RemoveFriend_Request\x1a\x1e.CPlayer_Re\
    moveFriend_Response\"3\x82\xb5\x18/Removes\x20a\x20friend\x20or\x20ignor\
    es\x20a\x20friend\x20suggestion\x12\xa6\x01\n\x0cIgnoreFriend\x12\x1d.CP\
    layer_IgnoreFriend_Request\x1a\x1e.CPlayer_IgnoreFriend_Response\"W\x82\
    \xb5\x18SBlocks\x20or\x20unblocks\x20communication\x20with\x20the\x20use\
    r.\x20\x20Despite\x20name,\x20can\x20be\x20a\x20non-friend.\x12\x9e\x01\
    \n\x17GetCommunityPreferences\x12(.CPlayer_GetCommunityPreferences_Reque\
    st\x1a).CPlayer_GetCommunityPreferences_Response\".\x82\xb5\x18*Returns\
    \x20the\x20player's\x20community\x20preferences\x12\x9b\x01\n\x17SetComm\
    unityPreferences\x12(.CPlayer_SetCommunityPreferences_Request\x1a).CPlay\
    er_SetCommunityPreferences_Response\"+\x82\xb5\x18'Sets\x20the\x20player\
    's\x20community\x20preferences\x12\x9b\x01\n\x12GetTextFilterWords\x12#.\
    CPlayer_GetTextFilterWords_Request\x1a$.CPlayer_GetTextFilterWords_Respo\
    nse\":\x82\xb5\x186Get\x20the\x20custom\x20text\x20filtering\x20dictiona\
    ry\x20for\x20this\x20user\x12\xde\x01\n\x1cGetNewSteamAnnouncementState\
    \x12-.CPlayer_GetNewSteamAnnouncementState_Request\x1a..CPlayer_GetNewSt\
    eamAnnouncementState_Response\"_\x82\xb5\x18[Calculates\x20and\x20return\
    s\x20what\x20to\x20display\x20for\x20UI\x20that\x20renders\x20new\x20ste\
    am\x20announcement\x20available\x12\xbc\x01\n\x1fUpdateSteamAnnouncement\
    LastRead\x120.CPlayer_UpdateSteamAnnouncementLastRead_Request\x1a1.CPlay\
    er_UpdateSteamAnnouncementLastRead_Response\"4\x82\xb5\x180Marks\x20late\
    st\x20announcement\x20timestamp\x20read\x20by\x20user\x12\x82\x01\n\x12G\
    etPrivacySettings\x12#.CPlayer_GetPrivacySettings_Request\x1a$.CPlayer_G\
    etPrivacySettings_Response\"!\x82\xb5\x18\x1dGet\x20current\x20privacy\
    \x20settings.\x12\x8c\x01\n\x12GetDurationControl\x12#.CPlayer_GetDurati\
    onControl_Request\x1a$.CPlayer_GetDurationControl_Response\"+\x82\xb5\
    \x18'Get\x20gameplay\x20duration\x20control\x20settings.\x1a-\x82\xb5\
    \x18)A\x20service\x20for\x20accessing\x20Steam\x20player\x20data2\xa6\
    \x0b\n\x0cPlayerClient\x12\x8c\x01\n\x15NotifyLastPlayedTimes\x12%.CPlay\
    er_LastPlayedTimes_Notification\x1a\x0b.NoResponse\"?\x82\xb5\x18;Notifi\
    cation\x20from\x20server\x20to\x20client\x20of\x20more\x20recent\x20play\
    \x20time\x12\xa4\x01\n\x1bNotifyFriendNicknameChanged\x12+.CPlayer_Frien\
    dNicknameChanged_Notification\x1a\x0b.NoResponse\"K\x82\xb5\x18GNotifica\
    tion\x20from\x20server\x20to\x20client\x20that\x20a\x20friend's\x20nickn\
    ame\x20has\x20changed\x12\xcb\x01\n'NotifyFriendEquippedProfileItemsChan\
    ged\x127.CPlayer_FriendEquippedProfileItemsChanged_Notification\x1a\x0b.\
    NoResponse\"Z\x82\xb5\x18VNotification\x20from\x20server\x20to\x20client\
    \x20that\x20a\x20friend's\x20equipped\x20profile\x20items\x20have\x20cha\
    nged\x12\xa4\x01\n\x1fNotifyNewSteamAnnouncementState\x12/.CPlayer_NewSt\
    eamAnnouncementState_Notification\x1a\x0b.NoResponse\"C\x82\xb5\x18?Noti\
    fies\x20client\x20of\x20changes\x20to\x20steam\x20announcement\x20state\
    \x20for\x20user\x12\xb9\x01\n!NotifyCommunityPreferencesChanged\x121.CPl\
    ayer_CommunityPreferencesChanged_Notification\x1a\x0b.NoResponse\"T\x82\
    \xb5\x18PNotification\x20from\x20server\x20to\x20client\x20that\x20their\
    \x20community\x20preferences\x20have\x20changed\x12\xb2\x01\n\x1cNotifyT\
    extFilterWordsChanged\x12,.CPlayer_TextFilterWordsChanged_Notification\
    \x1a\x0b.NoResponse\"W\x82\xb5\x18SNotification\x20from\x20server\x20to\
    \x20client\x20that\x20their\x20text\x20filtering\x20dictionary\x20has\
    \x20changed\x12\xaa\x01\n!NotifyPerFriendPreferencesChanged\x121.CPlayer\
    _PerFriendPreferencesChanged_Notification\x1a\x0b.NoResponse\"E\x82\xb5\
    \x18ANotification\x20from\x20server\x20that\x20per-friend\x20preferences\
    \x20have\x20changed\x12\x9c\x01\n#NotifyPrivacyPrivacySettingsChanged\
    \x12,.CPlayer_PrivacySettingsChanged_Notification\x1a\x0b.NoResponse\":\
    \x82\xb5\x186Notification\x20from\x20server\x20that\x20privacy\x20settin\
    gs\x20changed\x1a.\xc0\xb5\x18\x02\x82\xb5\x18&Steam\x20player\x20data\
    \x20client\x20notificationsB\x03\x80\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
