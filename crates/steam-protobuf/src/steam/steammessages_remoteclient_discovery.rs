// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_remoteclient_discovery.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastHeader {
    // message fields
    client_id: ::std::option::Option<u64>,
    msg_type: ::std::option::Option<ERemoteClientBroadcastMsg>,
    instance_id: ::std::option::Option<u64>,
    device_id: ::std::option::Option<u64>,
    device_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastHeader {
    fn default() -> &'a CMsgRemoteClientBroadcastHeader {
        <CMsgRemoteClientBroadcastHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastHeader {
    pub fn new() -> CMsgRemoteClientBroadcastHeader {
        ::std::default::Default::default()
    }

    // optional uint64 client_id = 1;


    pub fn get_client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }
    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional .ERemoteClientBroadcastMsg msg_type = 2;


    pub fn get_msg_type(&self) -> ERemoteClientBroadcastMsg {
        self.msg_type.unwrap_or(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery)
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: ERemoteClientBroadcastMsg) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional uint64 instance_id = 3;


    pub fn get_instance_id(&self) -> u64 {
        self.instance_id.unwrap_or(0)
    }
    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u64) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint64 device_id = 4;


    pub fn get_device_id(&self) -> u64 {
        self.device_id.unwrap_or(0)
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: u64) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 5;


    pub fn get_device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_device_token(&mut self) {
        self.device_token.clear();
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token.set_default();
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.client_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.msg_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.instance_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.device_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.device_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.instance_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.msg_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.device_id {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.device_token.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastHeader {
        CMsgRemoteClientBroadcastHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "client_id",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.client_id },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ERemoteClientBroadcastMsg>>(
                "msg_type",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.msg_type },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.msg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "instance_id",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.instance_id },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.instance_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "device_id",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.device_id },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "device_token",
                |m: &CMsgRemoteClientBroadcastHeader| { &m.device_token },
                |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteClientBroadcastHeader>(
                "CMsgRemoteClientBroadcastHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastHeader {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteClientBroadcastHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteClientBroadcastHeader::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastHeader {
    fn clear(&mut self) {
        self.client_id = ::std::option::Option::None;
        self.msg_type = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.device_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastStatus {
    // message fields
    version: ::std::option::Option<i32>,
    min_version: ::std::option::Option<i32>,
    connect_port: ::std::option::Option<u32>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    enabled_services: ::std::option::Option<u32>,
    ostype: ::std::option::Option<i32>,
    is64bit: ::std::option::Option<bool>,
    pub users: ::protobuf::RepeatedField<CMsgRemoteClientBroadcastStatus_User>,
    euniverse: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<u32>,
    screen_locked: ::std::option::Option<bool>,
    games_running: ::std::option::Option<bool>,
    pub mac_addresses: ::protobuf::RepeatedField<::std::string::String>,
    download_lan_peer_group: ::std::option::Option<u32>,
    broadcasting_active: ::std::option::Option<bool>,
    vr_active: ::std::option::Option<bool>,
    content_cache_port: ::std::option::Option<u32>,
    pub ip_addresses: ::protobuf::RepeatedField<::std::string::String>,
    public_ip_address: ::protobuf::SingularField<::std::string::String>,
    remoteplay_active: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastStatus {
    fn default() -> &'a CMsgRemoteClientBroadcastStatus {
        <CMsgRemoteClientBroadcastStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastStatus {
    pub fn new() -> CMsgRemoteClientBroadcastStatus {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int32 min_version = 2;


    pub fn get_min_version(&self) -> i32 {
        self.min_version.unwrap_or(0)
    }
    pub fn clear_min_version(&mut self) {
        self.min_version = ::std::option::Option::None;
    }

    pub fn has_min_version(&self) -> bool {
        self.min_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_version(&mut self, v: i32) {
        self.min_version = ::std::option::Option::Some(v);
    }

    // optional uint32 connect_port = 3;


    pub fn get_connect_port(&self) -> u32 {
        self.connect_port.unwrap_or(0)
    }
    pub fn clear_connect_port(&mut self) {
        self.connect_port = ::std::option::Option::None;
    }

    pub fn has_connect_port(&self) -> bool {
        self.connect_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_port(&mut self, v: u32) {
        self.connect_port = ::std::option::Option::Some(v);
    }

    // optional string hostname = 4;


    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 enabled_services = 6;


    pub fn get_enabled_services(&self) -> u32 {
        self.enabled_services.unwrap_or(0)
    }
    pub fn clear_enabled_services(&mut self) {
        self.enabled_services = ::std::option::Option::None;
    }

    pub fn has_enabled_services(&self) -> bool {
        self.enabled_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled_services(&mut self, v: u32) {
        self.enabled_services = ::std::option::Option::Some(v);
    }

    // optional int32 ostype = 7;


    pub fn get_ostype(&self) -> i32 {
        self.ostype.unwrap_or(0i32)
    }
    pub fn clear_ostype(&mut self) {
        self.ostype = ::std::option::Option::None;
    }

    pub fn has_ostype(&self) -> bool {
        self.ostype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ostype(&mut self, v: i32) {
        self.ostype = ::std::option::Option::Some(v);
    }

    // optional bool is64bit = 8;


    pub fn get_is64bit(&self) -> bool {
        self.is64bit.unwrap_or(false)
    }
    pub fn clear_is64bit(&mut self) {
        self.is64bit = ::std::option::Option::None;
    }

    pub fn has_is64bit(&self) -> bool {
        self.is64bit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is64bit(&mut self, v: bool) {
        self.is64bit = ::std::option::Option::Some(v);
    }

    // repeated .CMsgRemoteClientBroadcastStatus.User users = 9;


    pub fn get_users(&self) -> &[CMsgRemoteClientBroadcastStatus_User] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<CMsgRemoteClientBroadcastStatus_User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<CMsgRemoteClientBroadcastStatus_User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<CMsgRemoteClientBroadcastStatus_User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    // optional int32 euniverse = 11;


    pub fn get_euniverse(&self) -> i32 {
        self.euniverse.unwrap_or(0)
    }
    pub fn clear_euniverse(&mut self) {
        self.euniverse = ::std::option::Option::None;
    }

    pub fn has_euniverse(&self) -> bool {
        self.euniverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_euniverse(&mut self, v: i32) {
        self.euniverse = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 12;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool screen_locked = 13;


    pub fn get_screen_locked(&self) -> bool {
        self.screen_locked.unwrap_or(false)
    }
    pub fn clear_screen_locked(&mut self) {
        self.screen_locked = ::std::option::Option::None;
    }

    pub fn has_screen_locked(&self) -> bool {
        self.screen_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_locked(&mut self, v: bool) {
        self.screen_locked = ::std::option::Option::Some(v);
    }

    // optional bool games_running = 14;


    pub fn get_games_running(&self) -> bool {
        self.games_running.unwrap_or(false)
    }
    pub fn clear_games_running(&mut self) {
        self.games_running = ::std::option::Option::None;
    }

    pub fn has_games_running(&self) -> bool {
        self.games_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: bool) {
        self.games_running = ::std::option::Option::Some(v);
    }

    // repeated string mac_addresses = 15;


    pub fn get_mac_addresses(&self) -> &[::std::string::String] {
        &self.mac_addresses
    }
    pub fn clear_mac_addresses(&mut self) {
        self.mac_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mac_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mac_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mac_addresses
    }

    // Take field
    pub fn take_mac_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mac_addresses, ::protobuf::RepeatedField::new())
    }

    // optional uint32 download_lan_peer_group = 16;


    pub fn get_download_lan_peer_group(&self) -> u32 {
        self.download_lan_peer_group.unwrap_or(0)
    }
    pub fn clear_download_lan_peer_group(&mut self) {
        self.download_lan_peer_group = ::std::option::Option::None;
    }

    pub fn has_download_lan_peer_group(&self) -> bool {
        self.download_lan_peer_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_lan_peer_group(&mut self, v: u32) {
        self.download_lan_peer_group = ::std::option::Option::Some(v);
    }

    // optional bool broadcasting_active = 17;


    pub fn get_broadcasting_active(&self) -> bool {
        self.broadcasting_active.unwrap_or(false)
    }
    pub fn clear_broadcasting_active(&mut self) {
        self.broadcasting_active = ::std::option::Option::None;
    }

    pub fn has_broadcasting_active(&self) -> bool {
        self.broadcasting_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcasting_active(&mut self, v: bool) {
        self.broadcasting_active = ::std::option::Option::Some(v);
    }

    // optional bool vr_active = 18;


    pub fn get_vr_active(&self) -> bool {
        self.vr_active.unwrap_or(false)
    }
    pub fn clear_vr_active(&mut self) {
        self.vr_active = ::std::option::Option::None;
    }

    pub fn has_vr_active(&self) -> bool {
        self.vr_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_active(&mut self, v: bool) {
        self.vr_active = ::std::option::Option::Some(v);
    }

    // optional uint32 content_cache_port = 19;


    pub fn get_content_cache_port(&self) -> u32 {
        self.content_cache_port.unwrap_or(0)
    }
    pub fn clear_content_cache_port(&mut self) {
        self.content_cache_port = ::std::option::Option::None;
    }

    pub fn has_content_cache_port(&self) -> bool {
        self.content_cache_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_cache_port(&mut self, v: u32) {
        self.content_cache_port = ::std::option::Option::Some(v);
    }

    // repeated string ip_addresses = 20;


    pub fn get_ip_addresses(&self) -> &[::std::string::String] {
        &self.ip_addresses
    }
    pub fn clear_ip_addresses(&mut self) {
        self.ip_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ip_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ip_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ip_addresses
    }

    // Take field
    pub fn take_ip_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ip_addresses, ::protobuf::RepeatedField::new())
    }

    // optional string public_ip_address = 21;


    pub fn get_public_ip_address(&self) -> &str {
        match self.public_ip_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_public_ip_address(&mut self) {
        self.public_ip_address.clear();
    }

    pub fn has_public_ip_address(&self) -> bool {
        self.public_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip_address(&mut self, v: ::std::string::String) {
        self.public_ip_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip_address(&mut self) -> &mut ::std::string::String {
        if self.public_ip_address.is_none() {
            self.public_ip_address.set_default();
        }
        self.public_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip_address(&mut self) -> ::std::string::String {
        self.public_ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool remoteplay_active = 22;


    pub fn get_remoteplay_active(&self) -> bool {
        self.remoteplay_active.unwrap_or(false)
    }
    pub fn clear_remoteplay_active(&mut self) {
        self.remoteplay_active = ::std::option::Option::None;
    }

    pub fn has_remoteplay_active(&self) -> bool {
        self.remoteplay_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteplay_active(&mut self, v: bool) {
        self.remoteplay_active = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connect_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.enabled_services = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ostype = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is64bit = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.euniverse = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.screen_locked = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.games_running = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mac_addresses)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_lan_peer_group = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.broadcasting_active = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vr_active = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.content_cache_port = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ip_addresses)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.public_ip_address)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remoteplay_active = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connect_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.enabled_services {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ostype {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is64bit {
            my_size += 2;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.euniverse {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screen_locked {
            my_size += 2;
        }
        if let Some(v) = self.games_running {
            my_size += 2;
        }
        for value in &self.mac_addresses {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.download_lan_peer_group {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.broadcasting_active {
            my_size += 3;
        }
        if let Some(v) = self.vr_active {
            my_size += 3;
        }
        if let Some(v) = self.content_cache_port {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ip_addresses {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        if let Some(ref v) = self.public_ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.remoteplay_active {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.connect_port {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.enabled_services {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ostype {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.is64bit {
            os.write_bool(8, v)?;
        }
        for v in &self.users {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.euniverse {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.screen_locked {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.games_running {
            os.write_bool(14, v)?;
        }
        for v in &self.mac_addresses {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.download_lan_peer_group {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.broadcasting_active {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.vr_active {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_cache_port {
            os.write_uint32(19, v)?;
        }
        for v in &self.ip_addresses {
            os.write_string(20, &v)?;
        };
        if let Some(ref v) = self.public_ip_address.as_ref() {
            os.write_string(21, &v)?;
        }
        if let Some(v) = self.remoteplay_active {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastStatus {
        CMsgRemoteClientBroadcastStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.version },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_version",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.min_version },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.min_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "connect_port",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.connect_port },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.connect_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.hostname },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.hostname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "enabled_services",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.enabled_services },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.enabled_services },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ostype",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.ostype },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ostype },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is64bit",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.is64bit },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.is64bit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgRemoteClientBroadcastStatus_User>>(
                "users",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.users },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.users },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "euniverse",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.euniverse },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.euniverse },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.timestamp },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "screen_locked",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.screen_locked },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.screen_locked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "games_running",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.games_running },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.games_running },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mac_addresses",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.mac_addresses },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.mac_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "download_lan_peer_group",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.download_lan_peer_group },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.download_lan_peer_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "broadcasting_active",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.broadcasting_active },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.broadcasting_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "vr_active",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.vr_active },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.vr_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "content_cache_port",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.content_cache_port },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.content_cache_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_addresses",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.ip_addresses },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ip_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "public_ip_address",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.public_ip_address },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.public_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remoteplay_active",
                |m: &CMsgRemoteClientBroadcastStatus| { &m.remoteplay_active },
                |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.remoteplay_active },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteClientBroadcastStatus>(
                "CMsgRemoteClientBroadcastStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastStatus {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteClientBroadcastStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteClientBroadcastStatus::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastStatus {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.min_version = ::std::option::Option::None;
        self.connect_port = ::std::option::Option::None;
        self.hostname.clear();
        self.enabled_services = ::std::option::Option::None;
        self.ostype = ::std::option::Option::None;
        self.is64bit = ::std::option::Option::None;
        self.users.clear();
        self.euniverse = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.screen_locked = ::std::option::Option::None;
        self.games_running = ::std::option::Option::None;
        self.mac_addresses.clear();
        self.download_lan_peer_group = ::std::option::Option::None;
        self.broadcasting_active = ::std::option::Option::None;
        self.vr_active = ::std::option::Option::None;
        self.content_cache_port = ::std::option::Option::None;
        self.ip_addresses.clear();
        self.public_ip_address.clear();
        self.remoteplay_active = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastStatus_User {
    // message fields
    steamid: ::std::option::Option<u64>,
    auth_key_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastStatus_User {
    fn default() -> &'a CMsgRemoteClientBroadcastStatus_User {
        <CMsgRemoteClientBroadcastStatus_User as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastStatus_User {
    pub fn new() -> CMsgRemoteClientBroadcastStatus_User {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 auth_key_id = 2;


    pub fn get_auth_key_id(&self) -> u32 {
        self.auth_key_id.unwrap_or(0)
    }
    pub fn clear_auth_key_id(&mut self) {
        self.auth_key_id = ::std::option::Option::None;
    }

    pub fn has_auth_key_id(&self) -> bool {
        self.auth_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_key_id(&mut self, v: u32) {
        self.auth_key_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastStatus_User {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.auth_key_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.auth_key_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.auth_key_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastStatus_User {
        CMsgRemoteClientBroadcastStatus_User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgRemoteClientBroadcastStatus_User| { &m.steamid },
                |m: &mut CMsgRemoteClientBroadcastStatus_User| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "auth_key_id",
                |m: &CMsgRemoteClientBroadcastStatus_User| { &m.auth_key_id },
                |m: &mut CMsgRemoteClientBroadcastStatus_User| { &mut m.auth_key_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteClientBroadcastStatus_User>(
                "CMsgRemoteClientBroadcastStatus.User",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastStatus_User {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteClientBroadcastStatus_User> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteClientBroadcastStatus_User::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastStatus_User {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.auth_key_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastStatus_User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastStatus_User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastDiscovery {
    // message fields
    seq_num: ::std::option::Option<u32>,
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastDiscovery {
    fn default() -> &'a CMsgRemoteClientBroadcastDiscovery {
        <CMsgRemoteClientBroadcastDiscovery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastDiscovery {
    pub fn new() -> CMsgRemoteClientBroadcastDiscovery {
        ::std::default::Default::default()
    }

    // optional uint32 seq_num = 1;


    pub fn get_seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }
    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    // repeated uint64 client_ids = 2;


    pub fn get_client_ids(&self) -> &[u64] {
        &self.client_ids
    }
    pub fn clear_client_ids(&mut self) {
        self.client_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.client_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.client_ids
    }

    // Take field
    pub fn take_client_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.client_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastDiscovery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.client_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.client_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seq_num {
            os.write_uint32(1, v)?;
        }
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastDiscovery {
        CMsgRemoteClientBroadcastDiscovery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num",
                |m: &CMsgRemoteClientBroadcastDiscovery| { &m.seq_num },
                |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.seq_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "client_ids",
                |m: &CMsgRemoteClientBroadcastDiscovery| { &m.client_ids },
                |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.client_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteClientBroadcastDiscovery>(
                "CMsgRemoteClientBroadcastDiscovery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastDiscovery {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteClientBroadcastDiscovery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteClientBroadcastDiscovery::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastDiscovery {
    fn clear(&mut self) {
        self.seq_num = ::std::option::Option::None;
        self.client_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastDiscovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastDiscovery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteClientBroadcastClientIDDeconflict {
    // message fields
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastClientIDDeconflict {
    fn default() -> &'a CMsgRemoteClientBroadcastClientIDDeconflict {
        <CMsgRemoteClientBroadcastClientIDDeconflict as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastClientIDDeconflict {
    pub fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        ::std::default::Default::default()
    }

    // repeated uint64 client_ids = 2;


    pub fn get_client_ids(&self) -> &[u64] {
        &self.client_ids
    }
    pub fn clear_client_ids(&mut self) {
        self.client_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.client_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.client_ids
    }

    // Take field
    pub fn take_client_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.client_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.client_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.client_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        CMsgRemoteClientBroadcastClientIDDeconflict::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "client_ids",
                |m: &CMsgRemoteClientBroadcastClientIDDeconflict| { &m.client_ids },
                |m: &mut CMsgRemoteClientBroadcastClientIDDeconflict| { &mut m.client_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteClientBroadcastClientIDDeconflict>(
                "CMsgRemoteClientBroadcastClientIDDeconflict",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastClientIDDeconflict {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteClientBroadcastClientIDDeconflict> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteClientBroadcastClientIDDeconflict::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn clear(&mut self) {
        self.client_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceAuthorizationRequest {
    // message fields
    device_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    device_name: ::protobuf::SingularField<::std::string::String>,
    encrypted_request: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationRequest {
        <CMsgRemoteDeviceAuthorizationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        ::std::default::Default::default()
    }

    // required bytes device_token = 1;


    pub fn get_device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_device_token(&mut self) {
        self.device_token.clear();
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token.set_default();
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_name = 2;


    pub fn get_device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name.set_default();
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes encrypted_request = 3;


    pub fn get_encrypted_request(&self) -> &[u8] {
        match self.encrypted_request.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_encrypted_request(&mut self) {
        self.encrypted_request.clear();
    }

    pub fn has_encrypted_request(&self) -> bool {
        self.encrypted_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_request(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_request = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_request(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_request.is_none() {
            self.encrypted_request.set_default();
        }
        self.encrypted_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_request(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_request.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationRequest {
    fn is_initialized(&self) -> bool {
        if self.device_token.is_none() {
            return false;
        }
        if self.encrypted_request.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.device_token)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encrypted_request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.encrypted_request.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_token.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.device_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.encrypted_request.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        CMsgRemoteDeviceAuthorizationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "device_token",
                |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_token },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_name },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encrypted_request",
                |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.encrypted_request },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.encrypted_request },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceAuthorizationRequest>(
                "CMsgRemoteDeviceAuthorizationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceAuthorizationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceAuthorizationRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceAuthorizationRequest {
    fn clear(&mut self) {
        self.device_token.clear();
        self.device_name.clear();
        self.encrypted_request.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceAuthorizationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
    // message fields
    password: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    identifier: ::std::option::Option<u64>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timestamp: ::std::option::Option<u32>,
    usage: ::std::option::Option<CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage>,
    device_name: ::protobuf::SingularField<::std::string::String>,
    device_model: ::protobuf::SingularField<::std::string::String>,
    device_serial: ::protobuf::SingularField<::std::string::String>,
    device_provisioning_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
        <CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
    pub fn new() -> CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
        ::std::default::Default::default()
    }

    // optional bytes password = 1;


    pub fn get_password(&self) -> &[u8] {
        match self.password.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::vec::Vec<u8> {
        self.password.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 identifier = 2;


    pub fn get_identifier(&self) -> u64 {
        self.identifier.unwrap_or(0)
    }
    pub fn clear_identifier(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: u64) {
        self.identifier = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timestamp = 4;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5;


    pub fn get_usage(&self) -> CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage {
        self.usage.unwrap_or(CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice)
    }
    pub fn clear_usage(&mut self) {
        self.usage = ::std::option::Option::None;
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage) {
        self.usage = ::std::option::Option::Some(v);
    }

    // optional string device_name = 6;


    pub fn get_device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name.set_default();
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_model = 7;


    pub fn get_device_model(&self) -> &str {
        match self.device_model.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_model(&mut self) {
        self.device_model.clear();
    }

    pub fn has_device_model(&self) -> bool {
        self.device_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_model(&mut self, v: ::std::string::String) {
        self.device_model = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_model(&mut self) -> &mut ::std::string::String {
        if self.device_model.is_none() {
            self.device_model.set_default();
        }
        self.device_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_model(&mut self) -> ::std::string::String {
        self.device_model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_serial = 8;


    pub fn get_device_serial(&self) -> &str {
        match self.device_serial.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_serial(&mut self) {
        self.device_serial.clear();
    }

    pub fn has_device_serial(&self) -> bool {
        self.device_serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_serial(&mut self, v: ::std::string::String) {
        self.device_serial = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_serial(&mut self) -> &mut ::std::string::String {
        if self.device_serial.is_none() {
            self.device_serial.set_default();
        }
        self.device_serial.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_serial(&mut self) -> ::std::string::String {
        self.device_serial.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 device_provisioning_id = 9;


    pub fn get_device_provisioning_id(&self) -> u32 {
        self.device_provisioning_id.unwrap_or(0)
    }
    pub fn clear_device_provisioning_id(&mut self) {
        self.device_provisioning_id = ::std::option::Option::None;
    }

    pub fn has_device_provisioning_id(&self) -> bool {
        self.device_provisioning_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_provisioning_id(&mut self, v: u32) {
        self.device_provisioning_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.password)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.identifier = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.usage, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_model)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_serial)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.device_provisioning_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.identifier {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.usage {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(ref v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.device_model.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.device_serial.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.device_provisioning_id {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.password.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.identifier {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.usage {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.device_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.device_model.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.device_serial.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.device_provisioning_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
        CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "password",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.password },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "identifier",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.identifier },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.payload },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.timestamp },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage>>(
                "usage",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.usage },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.device_name },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_model",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.device_model },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.device_model },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_serial",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.device_serial },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.device_serial },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "device_provisioning_id",
                |m: &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &m.device_provisioning_id },
                |m: &mut CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket| { &mut m.device_provisioning_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket>(
                "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
    fn clear(&mut self) {
        self.password.clear();
        self.identifier = ::std::option::Option::None;
        self.payload.clear();
        self.timestamp = ::std::option::Option::None;
        self.usage = ::std::option::Option::None;
        self.device_name.clear();
        self.device_model.clear();
        self.device_serial.clear();
        self.device_provisioning_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage {
    k_EKeyEscrowUsageStreamingDevice = 0,
}

impl ::protobuf::ProtobufEnum for CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage> {
        match value {
            0 => ::std::option::Option::Some(CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage] = &[
            CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage>("CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage {
}

impl ::std::default::Default for CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage {
    fn default() -> Self {
        CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceAuthorizationCancelRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationCancelRequest {
        <CMsgRemoteDeviceAuthorizationCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationCancelRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        CMsgRemoteDeviceAuthorizationCancelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceAuthorizationCancelRequest>(
                "CMsgRemoteDeviceAuthorizationCancelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationCancelRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceAuthorizationCancelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceAuthorizationCancelRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceAuthorizationResponse {
    // message fields
    result: ::std::option::Option<ERemoteDeviceAuthorizationResult>,
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationResponse {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationResponse {
        <CMsgRemoteDeviceAuthorizationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationResponse {
    pub fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        ::std::default::Default::default()
    }

    // required .ERemoteDeviceAuthorizationResult result = 1;


    pub fn get_result(&self) -> ERemoteDeviceAuthorizationResult {
        self.result.unwrap_or(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceAuthorizationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceAuthorizationResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        CMsgRemoteDeviceAuthorizationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ERemoteDeviceAuthorizationResult>>(
                "result",
                |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.result },
                |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.steamid },
                |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceAuthorizationResponse>(
                "CMsgRemoteDeviceAuthorizationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceAuthorizationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceAuthorizationResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceAuthorizationResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceAuthorizationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingRequest {
    // message fields
    request_id: ::std::option::Option<u32>,
    maximum_resolution_x: ::std::option::Option<i32>,
    maximum_resolution_y: ::std::option::Option<i32>,
    audio_channel_count: ::std::option::Option<i32>,
    device_version: ::protobuf::SingularField<::std::string::String>,
    stream_desktop: ::std::option::Option<bool>,
    device_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pin: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    enable_video_streaming: ::std::option::Option<bool>,
    enable_audio_streaming: ::std::option::Option<bool>,
    enable_input_streaming: ::std::option::Option<bool>,
    network_test: ::std::option::Option<bool>,
    client_id: ::std::option::Option<u64>,
    pub supported_transport: ::std::vec::Vec<EStreamTransport>,
    restricted: ::std::option::Option<bool>,
    form_factor: ::std::option::Option<EStreamDeviceFormFactor>,
    gamepad_count: ::std::option::Option<i32>,
    pub gamepads: ::protobuf::RepeatedField<CMsgRemoteDeviceStreamingRequest_ReservedGamepad>,
    gameid: ::std::option::Option<u64>,
    stream_interface: ::std::option::Option<EStreamInterface>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingRequest {
        <CMsgRemoteDeviceStreamingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_x = 2;


    pub fn get_maximum_resolution_x(&self) -> i32 {
        self.maximum_resolution_x.unwrap_or(0)
    }
    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: i32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_y = 3;


    pub fn get_maximum_resolution_y(&self) -> i32 {
        self.maximum_resolution_y.unwrap_or(0)
    }
    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: i32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channel_count = 4;


    pub fn get_audio_channel_count(&self) -> i32 {
        self.audio_channel_count.unwrap_or(2i32)
    }
    pub fn clear_audio_channel_count(&mut self) {
        self.audio_channel_count = ::std::option::Option::None;
    }

    pub fn has_audio_channel_count(&self) -> bool {
        self.audio_channel_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channel_count(&mut self, v: i32) {
        self.audio_channel_count = ::std::option::Option::Some(v);
    }

    // optional string device_version = 5;


    pub fn get_device_version(&self) -> &str {
        match self.device_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_version(&mut self) {
        self.device_version.clear();
    }

    pub fn has_device_version(&self) -> bool {
        self.device_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_version(&mut self, v: ::std::string::String) {
        self.device_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_version(&mut self) -> &mut ::std::string::String {
        if self.device_version.is_none() {
            self.device_version.set_default();
        }
        self.device_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_version(&mut self) -> ::std::string::String {
        self.device_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool stream_desktop = 6;


    pub fn get_stream_desktop(&self) -> bool {
        self.stream_desktop.unwrap_or(false)
    }
    pub fn clear_stream_desktop(&mut self) {
        self.stream_desktop = ::std::option::Option::None;
    }

    pub fn has_stream_desktop(&self) -> bool {
        self.stream_desktop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_desktop(&mut self, v: bool) {
        self.stream_desktop = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 7;


    pub fn get_device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_device_token(&mut self) {
        self.device_token.clear();
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_token.is_none() {
            self.device_token.set_default();
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::std::vec::Vec<u8> {
        self.device_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pin = 8;


    pub fn get_pin(&self) -> &[u8] {
        match self.pin.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pin(&mut self) {
        self.pin.clear();
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::vec::Vec<u8>) {
        self.pin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pin.is_none() {
            self.pin.set_default();
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::vec::Vec<u8> {
        self.pin.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool enable_video_streaming = 9;


    pub fn get_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }
    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;


    pub fn get_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }
    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;


    pub fn get_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }
    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional bool network_test = 12;


    pub fn get_network_test(&self) -> bool {
        self.network_test.unwrap_or(false)
    }
    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: bool) {
        self.network_test = ::std::option::Option::Some(v);
    }

    // optional uint64 client_id = 13;


    pub fn get_client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }
    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // repeated .EStreamTransport supported_transport = 14;


    pub fn get_supported_transport(&self) -> &[EStreamTransport] {
        &self.supported_transport
    }
    pub fn clear_supported_transport(&mut self) {
        self.supported_transport.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_transport(&mut self, v: ::std::vec::Vec<EStreamTransport>) {
        self.supported_transport = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_transport(&mut self) -> &mut ::std::vec::Vec<EStreamTransport> {
        &mut self.supported_transport
    }

    // Take field
    pub fn take_supported_transport(&mut self) -> ::std::vec::Vec<EStreamTransport> {
        ::std::mem::replace(&mut self.supported_transport, ::std::vec::Vec::new())
    }

    // optional bool restricted = 15;


    pub fn get_restricted(&self) -> bool {
        self.restricted.unwrap_or(false)
    }
    pub fn clear_restricted(&mut self) {
        self.restricted = ::std::option::Option::None;
    }

    pub fn has_restricted(&self) -> bool {
        self.restricted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restricted(&mut self, v: bool) {
        self.restricted = ::std::option::Option::Some(v);
    }

    // optional .EStreamDeviceFormFactor form_factor = 16;


    pub fn get_form_factor(&self) -> EStreamDeviceFormFactor {
        self.form_factor.unwrap_or(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown)
    }
    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: EStreamDeviceFormFactor) {
        self.form_factor = ::std::option::Option::Some(v);
    }

    // optional int32 gamepad_count = 17;


    pub fn get_gamepad_count(&self) -> i32 {
        self.gamepad_count.unwrap_or(0)
    }
    pub fn clear_gamepad_count(&mut self) {
        self.gamepad_count = ::std::option::Option::None;
    }

    pub fn has_gamepad_count(&self) -> bool {
        self.gamepad_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamepad_count(&mut self, v: i32) {
        self.gamepad_count = ::std::option::Option::Some(v);
    }

    // repeated .CMsgRemoteDeviceStreamingRequest.ReservedGamepad gamepads = 18;


    pub fn get_gamepads(&self) -> &[CMsgRemoteDeviceStreamingRequest_ReservedGamepad] {
        &self.gamepads
    }
    pub fn clear_gamepads(&mut self) {
        self.gamepads.clear();
    }

    // Param is passed by value, moved
    pub fn set_gamepads(&mut self, v: ::protobuf::RepeatedField<CMsgRemoteDeviceStreamingRequest_ReservedGamepad>) {
        self.gamepads = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gamepads(&mut self) -> &mut ::protobuf::RepeatedField<CMsgRemoteDeviceStreamingRequest_ReservedGamepad> {
        &mut self.gamepads
    }

    // Take field
    pub fn take_gamepads(&mut self) -> ::protobuf::RepeatedField<CMsgRemoteDeviceStreamingRequest_ReservedGamepad> {
        ::std::mem::replace(&mut self.gamepads, ::protobuf::RepeatedField::new())
    }

    // optional uint64 gameid = 19;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional .EStreamInterface stream_interface = 20;


    pub fn get_stream_interface(&self) -> EStreamInterface {
        self.stream_interface.unwrap_or(EStreamInterface::k_EStreamInterfaceDefault)
    }
    pub fn clear_stream_interface(&mut self) {
        self.stream_interface = ::std::option::Option::None;
    }

    pub fn has_stream_interface(&self) -> bool {
        self.stream_interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_interface(&mut self, v: EStreamInterface) {
        self.stream_interface = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingRequest {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.gamepads {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximum_resolution_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximum_resolution_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.audio_channel_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_version)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stream_desktop = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.device_token)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pin)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_video_streaming = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_audio_streaming = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_input_streaming = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.network_test = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.client_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_transport, 14, &mut self.unknown_fields)?
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.restricted = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.form_factor, 16, &mut self.unknown_fields)?
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gamepad_count = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gamepads)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.stream_interface, 20, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.audio_channel_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_version.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.stream_desktop {
            my_size += 2;
        }
        if let Some(ref v) = self.device_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 2;
        }
        if let Some(v) = self.network_test {
            my_size += 2;
        }
        if let Some(v) = self.client_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.supported_transport {
            my_size += ::protobuf::rt::enum_size(14, *value);
        };
        if let Some(v) = self.restricted {
            my_size += 2;
        }
        if let Some(v) = self.form_factor {
            my_size += ::protobuf::rt::enum_size(16, v);
        }
        if let Some(v) = self.gamepad_count {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.gamepads {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stream_interface {
            my_size += ::protobuf::rt::enum_size(20, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.audio_channel_count {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.device_version.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.stream_desktop {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.device_token.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.pin.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.network_test {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.client_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.supported_transport {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.restricted {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.gamepad_count {
            os.write_int32(17, v)?;
        }
        for v in &self.gamepads {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.gameid {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.stream_interface {
            os.write_enum(20, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingRequest {
        CMsgRemoteDeviceStreamingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_id",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.request_id },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.request_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maximum_resolution_x",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_x },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maximum_resolution_y",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_y },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "audio_channel_count",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.audio_channel_count },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.audio_channel_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_version",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_version },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stream_desktop",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.stream_desktop },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.stream_desktop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "device_token",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_token },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pin",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.pin },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.pin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_video_streaming",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_video_streaming },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_video_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_audio_streaming",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_audio_streaming },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_audio_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_input_streaming",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_input_streaming },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_input_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "network_test",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.network_test },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.network_test },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "client_id",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.client_id },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamTransport>>(
                "supported_transport",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.supported_transport },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.supported_transport },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "restricted",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.restricted },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.restricted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamDeviceFormFactor>>(
                "form_factor",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.form_factor },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.form_factor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "gamepad_count",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.gamepad_count },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gamepad_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgRemoteDeviceStreamingRequest_ReservedGamepad>>(
                "gamepads",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.gamepads },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gamepads },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gameid",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.gameid },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamInterface>>(
                "stream_interface",
                |m: &CMsgRemoteDeviceStreamingRequest| { &m.stream_interface },
                |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.stream_interface },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceStreamingRequest>(
                "CMsgRemoteDeviceStreamingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceStreamingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceStreamingRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingRequest {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.audio_channel_count = ::std::option::Option::None;
        self.device_version.clear();
        self.stream_desktop = ::std::option::Option::None;
        self.device_token.clear();
        self.pin.clear();
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.network_test = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.supported_transport.clear();
        self.restricted = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.gamepad_count = ::std::option::Option::None;
        self.gamepads.clear();
        self.gameid = ::std::option::Option::None;
        self.stream_interface = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
    // message fields
    controller_type: ::std::option::Option<u32>,
    controller_subtype: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
    fn default() -> &'a CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
        <CMsgRemoteDeviceStreamingRequest_ReservedGamepad as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
    pub fn new() -> CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
        ::std::default::Default::default()
    }

    // optional uint32 controller_type = 1;


    pub fn get_controller_type(&self) -> u32 {
        self.controller_type.unwrap_or(0)
    }
    pub fn clear_controller_type(&mut self) {
        self.controller_type = ::std::option::Option::None;
    }

    pub fn has_controller_type(&self) -> bool {
        self.controller_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_type(&mut self, v: u32) {
        self.controller_type = ::std::option::Option::Some(v);
    }

    // optional uint32 controller_subtype = 2;


    pub fn get_controller_subtype(&self) -> u32 {
        self.controller_subtype.unwrap_or(0)
    }
    pub fn clear_controller_subtype(&mut self) {
        self.controller_subtype = ::std::option::Option::None;
    }

    pub fn has_controller_subtype(&self) -> bool {
        self.controller_subtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_subtype(&mut self, v: u32) {
        self.controller_subtype = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.controller_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.controller_subtype = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.controller_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.controller_subtype {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.controller_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.controller_subtype {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
        CMsgRemoteDeviceStreamingRequest_ReservedGamepad::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "controller_type",
                |m: &CMsgRemoteDeviceStreamingRequest_ReservedGamepad| { &m.controller_type },
                |m: &mut CMsgRemoteDeviceStreamingRequest_ReservedGamepad| { &mut m.controller_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "controller_subtype",
                |m: &CMsgRemoteDeviceStreamingRequest_ReservedGamepad| { &m.controller_subtype },
                |m: &mut CMsgRemoteDeviceStreamingRequest_ReservedGamepad| { &mut m.controller_subtype },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceStreamingRequest_ReservedGamepad>(
                "CMsgRemoteDeviceStreamingRequest.ReservedGamepad",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceStreamingRequest_ReservedGamepad> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceStreamingRequest_ReservedGamepad::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
    fn clear(&mut self) {
        self.controller_type = ::std::option::Option::None;
        self.controller_subtype = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingCancelRequest {
    // message fields
    request_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingCancelRequest {
        <CMsgRemoteDeviceStreamingCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingCancelRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingCancelRequest {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        CMsgRemoteDeviceStreamingCancelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_id",
                |m: &CMsgRemoteDeviceStreamingCancelRequest| { &m.request_id },
                |m: &mut CMsgRemoteDeviceStreamingCancelRequest| { &mut m.request_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceStreamingCancelRequest>(
                "CMsgRemoteDeviceStreamingCancelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingCancelRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceStreamingCancelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceStreamingCancelRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingCancelRequest {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingCancelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingProgress {
    // message fields
    request_id: ::std::option::Option<u32>,
    progress: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingProgress {
    fn default() -> &'a CMsgRemoteDeviceStreamingProgress {
        <CMsgRemoteDeviceStreamingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingProgress {
    pub fn new() -> CMsgRemoteDeviceStreamingProgress {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional float progress = 2;


    pub fn get_progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }
    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingProgress {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.progress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.progress {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingProgress {
        CMsgRemoteDeviceStreamingProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_id",
                |m: &CMsgRemoteDeviceStreamingProgress| { &m.request_id },
                |m: &mut CMsgRemoteDeviceStreamingProgress| { &mut m.request_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "progress",
                |m: &CMsgRemoteDeviceStreamingProgress| { &m.progress },
                |m: &mut CMsgRemoteDeviceStreamingProgress| { &mut m.progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceStreamingProgress>(
                "CMsgRemoteDeviceStreamingProgress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingProgress {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceStreamingProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceStreamingProgress::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingProgress {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamingResponse {
    // message fields
    request_id: ::std::option::Option<u32>,
    result: ::std::option::Option<ERemoteDeviceStreamingResult>,
    port: ::std::option::Option<u32>,
    encrypted_session_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    transport: ::std::option::Option<EStreamTransport>,
    relay_server: ::protobuf::SingularField<::std::string::String>,
    cert: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingResponse {
    fn default() -> &'a CMsgRemoteDeviceStreamingResponse {
        <CMsgRemoteDeviceStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingResponse {
    pub fn new() -> CMsgRemoteDeviceStreamingResponse {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required .ERemoteDeviceStreamingResult result = 2;


    pub fn get_result(&self) -> ERemoteDeviceStreamingResult {
        self.result.unwrap_or(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceStreamingResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint32 port = 3;


    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional bytes encrypted_session_key = 4;


    pub fn get_encrypted_session_key(&self) -> &[u8] {
        match self.encrypted_session_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_encrypted_session_key(&mut self) {
        self.encrypted_session_key.clear();
    }

    pub fn has_encrypted_session_key(&self) -> bool {
        self.encrypted_session_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_session_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encrypted_session_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_session_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encrypted_session_key.is_none() {
            self.encrypted_session_key.set_default();
        }
        self.encrypted_session_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_session_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encrypted_session_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EStreamTransport transport = 6;


    pub fn get_transport(&self) -> EStreamTransport {
        self.transport.unwrap_or(EStreamTransport::k_EStreamTransportUDP)
    }
    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: EStreamTransport) {
        self.transport = ::std::option::Option::Some(v);
    }

    // optional string relay_server = 7;


    pub fn get_relay_server(&self) -> &str {
        match self.relay_server.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_relay_server(&mut self) {
        self.relay_server.clear();
    }

    pub fn has_relay_server(&self) -> bool {
        self.relay_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_server(&mut self, v: ::std::string::String) {
        self.relay_server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay_server(&mut self) -> &mut ::std::string::String {
        if self.relay_server.is_none() {
            self.relay_server.set_default();
        }
        self.relay_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay_server(&mut self) -> ::std::string::String {
        self.relay_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cert = 8;


    pub fn get_cert(&self) -> &str {
        match self.cert.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::string::String) {
        self.cert = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::string::String {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::string::String {
        self.cert.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamingResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encrypted_session_key)?;
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.transport, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.relay_server)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encrypted_session_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.transport {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(ref v) = self.relay_server.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.cert.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.encrypted_session_key.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.relay_server.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamingResponse {
        CMsgRemoteDeviceStreamingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_id",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.request_id },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.request_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ERemoteDeviceStreamingResult>>(
                "result",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.result },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.port },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encrypted_session_key",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.encrypted_session_key },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.encrypted_session_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamTransport>>(
                "transport",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.transport },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.transport },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "relay_server",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.relay_server },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.relay_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cert",
                |m: &CMsgRemoteDeviceStreamingResponse| { &m.cert },
                |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.cert },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceStreamingResponse>(
                "CMsgRemoteDeviceStreamingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceStreamingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceStreamingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamingResponse {
    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.encrypted_session_key.clear();
        self.transport = ::std::option::Option::None;
        self.relay_server.clear();
        self.cert.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceProofRequest {
    // message fields
    challenge: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    request_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofRequest {
    fn default() -> &'a CMsgRemoteDeviceProofRequest {
        <CMsgRemoteDeviceProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofRequest {
    pub fn new() -> CMsgRemoteDeviceProofRequest {
        ::std::default::Default::default()
    }

    // required bytes challenge = 1;


    pub fn get_challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_challenge(&mut self) {
        self.challenge.clear();
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.challenge.is_none() {
            self.challenge.set_default();
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        self.challenge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 request_id = 2;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofRequest {
    fn is_initialized(&self) -> bool {
        if self.challenge.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.challenge)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.challenge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.challenge.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceProofRequest {
        CMsgRemoteDeviceProofRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "challenge",
                |m: &CMsgRemoteDeviceProofRequest| { &m.challenge },
                |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_id",
                |m: &CMsgRemoteDeviceProofRequest| { &m.request_id },
                |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.request_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceProofRequest>(
                "CMsgRemoteDeviceProofRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceProofRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceProofRequest::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceProofRequest {
    fn clear(&mut self) {
        self.challenge.clear();
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceProofRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceProofResponse {
    // message fields
    response: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    request_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofResponse {
    fn default() -> &'a CMsgRemoteDeviceProofResponse {
        <CMsgRemoteDeviceProofResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofResponse {
    pub fn new() -> CMsgRemoteDeviceProofResponse {
        ::std::default::Default::default()
    }

    // required bytes response = 1;


    pub fn get_response(&self) -> &[u8] {
        match self.response.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.response = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> ::std::vec::Vec<u8> {
        self.response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 request_id = 2;


    pub fn get_request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceProofResponse {
    fn is_initialized(&self) -> bool {
        if self.response.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.response)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.response.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceProofResponse {
        CMsgRemoteDeviceProofResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "response",
                |m: &CMsgRemoteDeviceProofResponse| { &m.response },
                |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.response },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "request_id",
                |m: &CMsgRemoteDeviceProofResponse| { &m.request_id },
                |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.request_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceProofResponse>(
                "CMsgRemoteDeviceProofResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceProofResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceProofResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceProofResponse {
    fn clear(&mut self) {
        self.response.clear();
        self.request_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceProofResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceProofResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRemoteDeviceStreamTransportSignal {
    // message fields
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamTransportSignal {
    fn default() -> &'a CMsgRemoteDeviceStreamTransportSignal {
        <CMsgRemoteDeviceStreamTransportSignal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamTransportSignal {
    pub fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 2;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRemoteDeviceStreamTransportSignal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        CMsgRemoteDeviceStreamTransportSignal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.token },
                |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.payload },
                |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.payload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRemoteDeviceStreamTransportSignal>(
                "CMsgRemoteDeviceStreamTransportSignal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamTransportSignal {
        static instance: ::protobuf::rt::LazyV2<CMsgRemoteDeviceStreamTransportSignal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRemoteDeviceStreamTransportSignal::new)
    }
}

impl ::protobuf::Clear for CMsgRemoteDeviceStreamTransportSignal {
    fn clear(&mut self) {
        self.token.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRemoteDeviceStreamTransportSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRemoteDeviceStreamTransportSignal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteClientBroadcastMsg {
    k_ERemoteClientBroadcastMsgDiscovery = 0,
    k_ERemoteClientBroadcastMsgStatus = 1,
    k_ERemoteClientBroadcastMsgOffline = 2,
    k_ERemoteDeviceAuthorizationRequest = 3,
    k_ERemoteDeviceAuthorizationResponse = 4,
    k_ERemoteDeviceStreamingRequest = 5,
    k_ERemoteDeviceStreamingResponse = 6,
    k_ERemoteDeviceProofRequest = 7,
    k_ERemoteDeviceProofResponse = 8,
    k_ERemoteDeviceAuthorizationCancelRequest = 9,
    k_ERemoteDeviceStreamingCancelRequest = 10,
    k_ERemoteClientBroadcastMsgClientIDDeconflict = 11,
    k_ERemoteDeviceStreamTransportSignal = 12,
    k_ERemoteDeviceStreamingProgress = 13,
}

impl ::protobuf::ProtobufEnum for ERemoteClientBroadcastMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            1 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            2 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            3 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            4 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            5 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            6 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            7 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            8 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            9 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            10 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            11 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            12 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            13 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteClientBroadcastMsg] = &[
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus,
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest,
            ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal,
            ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ERemoteClientBroadcastMsg>("ERemoteClientBroadcastMsg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ERemoteClientBroadcastMsg {
}

impl ::std::default::Default for ERemoteClientBroadcastMsg {
    fn default() -> Self {
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteClientBroadcastMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteClientService {
    k_ERemoteClientServiceNone = 0,
    k_ERemoteClientServiceRemoteControl = 1,
    k_ERemoteClientServiceGameStreaming = 2,
    k_ERemoteClientServiceSiteLicense = 4,
    k_ERemoteClientServiceContentCache = 8,
}

impl ::protobuf::ProtobufEnum for ERemoteClientService {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientService> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            1 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            2 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            4 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            8 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteClientService] = &[
            ERemoteClientService::k_ERemoteClientServiceNone,
            ERemoteClientService::k_ERemoteClientServiceRemoteControl,
            ERemoteClientService::k_ERemoteClientServiceGameStreaming,
            ERemoteClientService::k_ERemoteClientServiceSiteLicense,
            ERemoteClientService::k_ERemoteClientServiceContentCache,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ERemoteClientService>("ERemoteClientService", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ERemoteClientService {
}

impl ::std::default::Default for ERemoteClientService {
    fn default() -> Self {
        ERemoteClientService::k_ERemoteClientServiceNone
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteClientService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteDeviceAuthorizationResult {
    k_ERemoteDeviceAuthorizationSuccess = 0,
    k_ERemoteDeviceAuthorizationDenied = 1,
    k_ERemoteDeviceAuthorizationNotLoggedIn = 2,
    k_ERemoteDeviceAuthorizationOffline = 3,
    k_ERemoteDeviceAuthorizationBusy = 4,
    k_ERemoteDeviceAuthorizationInProgress = 5,
    k_ERemoteDeviceAuthorizationTimedOut = 6,
    k_ERemoteDeviceAuthorizationFailed = 7,
    k_ERemoteDeviceAuthorizationCanceled = 8,
}

impl ::protobuf::ProtobufEnum for ERemoteDeviceAuthorizationResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            2 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            3 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            4 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            7 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            8 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteDeviceAuthorizationResult] = &[
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed,
            ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ERemoteDeviceAuthorizationResult>("ERemoteDeviceAuthorizationResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ERemoteDeviceAuthorizationResult {
}

impl ::std::default::Default for ERemoteDeviceAuthorizationResult {
    fn default() -> Self {
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteDeviceAuthorizationResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDeviceFormFactor {
    k_EStreamDeviceFormFactorUnknown = 0,
    k_EStreamDeviceFormFactorPhone = 1,
    k_EStreamDeviceFormFactorTablet = 2,
    k_EStreamDeviceFormFactorComputer = 3,
    k_EStreamDeviceFormFactorTV = 4,
}

impl ::protobuf::ProtobufEnum for EStreamDeviceFormFactor {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match value {
            0 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            1 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            2 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            3 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            4 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDeviceFormFactor] = &[
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer,
            EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamDeviceFormFactor>("EStreamDeviceFormFactor", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamDeviceFormFactor {
}

impl ::std::default::Default for EStreamDeviceFormFactor {
    fn default() -> Self {
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamDeviceFormFactor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamTransport {
    k_EStreamTransportNone = 0,
    k_EStreamTransportUDP = 1,
    k_EStreamTransportUDPRelay = 2,
    k_EStreamTransportWebRTC = 3,
    k_EStreamTransportSDR = 4,
    k_EStreamTransportUDP_SNS = 5,
    k_EStreamTransportUDPRelay_SNS = 6,
}

impl ::protobuf::ProtobufEnum for EStreamTransport {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamTransport> {
        match value {
            0 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            1 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            2 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            3 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC),
            4 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            5 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            6 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamTransport] = &[
            EStreamTransport::k_EStreamTransportNone,
            EStreamTransport::k_EStreamTransportUDP,
            EStreamTransport::k_EStreamTransportUDPRelay,
            EStreamTransport::k_EStreamTransportWebRTC,
            EStreamTransport::k_EStreamTransportSDR,
            EStreamTransport::k_EStreamTransportUDP_SNS,
            EStreamTransport::k_EStreamTransportUDPRelay_SNS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamTransport>("EStreamTransport", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamTransport {
}

impl ::std::default::Default for EStreamTransport {
    fn default() -> Self {
        EStreamTransport::k_EStreamTransportNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamTransport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamInterface {
    k_EStreamInterfaceDefault = 0,
    k_EStreamInterfaceRecentGames = 1,
    k_EStreamInterfaceBigPicture = 2,
    k_EStreamInterfaceDesktop = 3,
}

impl ::protobuf::ProtobufEnum for EStreamInterface {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamInterface> {
        match value {
            0 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDefault),
            1 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceRecentGames),
            2 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceBigPicture),
            3 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDesktop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamInterface] = &[
            EStreamInterface::k_EStreamInterfaceDefault,
            EStreamInterface::k_EStreamInterfaceRecentGames,
            EStreamInterface::k_EStreamInterfaceBigPicture,
            EStreamInterface::k_EStreamInterfaceDesktop,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamInterface>("EStreamInterface", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamInterface {
}

impl ::std::default::Default for EStreamInterface {
    fn default() -> Self {
        EStreamInterface::k_EStreamInterfaceDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamInterface {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ERemoteDeviceStreamingResult {
    k_ERemoteDeviceStreamingSuccess = 0,
    k_ERemoteDeviceStreamingUnauthorized = 1,
    k_ERemoteDeviceStreamingScreenLocked = 2,
    k_ERemoteDeviceStreamingFailed = 3,
    k_ERemoteDeviceStreamingBusy = 4,
    k_ERemoteDeviceStreamingInProgress = 5,
    k_ERemoteDeviceStreamingCanceled = 6,
    k_ERemoteDeviceStreamingDriversNotInstalled = 7,
    k_ERemoteDeviceStreamingDisabled = 8,
    k_ERemoteDeviceStreamingBroadcastingActive = 9,
    k_ERemoteDeviceStreamingVRActive = 10,
    k_ERemoteDeviceStreamingPINRequired = 11,
    k_ERemoteDeviceStreamingTransportUnavailable = 12,
    k_ERemoteDeviceStreamingInvisible = 13,
    k_ERemoteDeviceStreamingGameLaunchFailed = 14,
}

impl ::protobuf::ProtobufEnum for ERemoteDeviceStreamingResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            2 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            3 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            4 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            7 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            8 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            9 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            10 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            11 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            12 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            13 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            14 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ERemoteDeviceStreamingResult] = &[
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible,
            ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ERemoteDeviceStreamingResult>("ERemoteDeviceStreamingResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ERemoteDeviceStreamingResult {
}

impl ::std::default::Default for ERemoteDeviceStreamingResult {
    fn default() -> Self {
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess
    }
}

impl ::protobuf::reflect::ProtobufValue for ERemoteDeviceStreamingResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*steammessages_remoteclient_discovery.proto\"\xfc\x01\n\x1fCMsgRemoteC\
    lientBroadcastHeader\x12\x1b\n\tclient_id\x18\x01\x20\x01(\x04R\x08clien\
    tId\x12[\n\x08msg_type\x18\x02\x20\x01(\x0e2\x1a.ERemoteClientBroadcastM\
    sg:$k_ERemoteClientBroadcastMsgDiscoveryR\x07msgType\x12\x1f\n\x0binstan\
    ce_id\x18\x03\x20\x01(\x04R\ninstanceId\x12\x1b\n\tdevice_id\x18\x04\x20\
    \x01(\x04R\x08deviceId\x12!\n\x0cdevice_token\x18\x05\x20\x01(\x0cR\x0bd\
    eviceToken\"\xd4\x06\n\x1fCMsgRemoteClientBroadcastStatus\x12\x18\n\x07v\
    ersion\x18\x01\x20\x01(\x05R\x07version\x12\x1f\n\x0bmin_version\x18\x02\
    \x20\x01(\x05R\nminVersion\x12!\n\x0cconnect_port\x18\x03\x20\x01(\rR\
    \x0bconnectPort\x12\x1a\n\x08hostname\x18\x04\x20\x01(\tR\x08hostname\
    \x12)\n\x10enabled_services\x18\x06\x20\x01(\rR\x0fenabledServices\x12\
    \x19\n\x06ostype\x18\x07\x20\x01(\x05:\x010R\x06ostype\x12\x18\n\x07is64\
    bit\x18\x08\x20\x01(\x08R\x07is64bit\x12;\n\x05users\x18\t\x20\x03(\x0b2\
    %.CMsgRemoteClientBroadcastStatus.UserR\x05users\x12\x1c\n\teuniverse\
    \x18\x0b\x20\x01(\x05R\teuniverse\x12\x1c\n\ttimestamp\x18\x0c\x20\x01(\
    \rR\ttimestamp\x12#\n\rscreen_locked\x18\r\x20\x01(\x08R\x0cscreenLocked\
    \x12#\n\rgames_running\x18\x0e\x20\x01(\x08R\x0cgamesRunning\x12#\n\rmac\
    _addresses\x18\x0f\x20\x03(\tR\x0cmacAddresses\x125\n\x17download_lan_pe\
    er_group\x18\x10\x20\x01(\rR\x14downloadLanPeerGroup\x12/\n\x13broadcast\
    ing_active\x18\x11\x20\x01(\x08R\x12broadcastingActive\x12\x1b\n\tvr_act\
    ive\x18\x12\x20\x01(\x08R\x08vrActive\x12,\n\x12content_cache_port\x18\
    \x13\x20\x01(\rR\x10contentCachePort\x12!\n\x0cip_addresses\x18\x14\x20\
    \x03(\tR\x0bipAddresses\x12*\n\x11public_ip_address\x18\x15\x20\x01(\tR\
    \x0fpublicIpAddress\x12+\n\x11remoteplay_active\x18\x16\x20\x01(\x08R\
    \x10remoteplayActive\x1a@\n\x04User\x12\x18\n\x07steamid\x18\x01\x20\x01\
    (\x06R\x07steamid\x12\x1e\n\x0bauth_key_id\x18\x02\x20\x01(\rR\tauthKeyI\
    d\"\\\n\"CMsgRemoteClientBroadcastDiscovery\x12\x17\n\x07seq_num\x18\x01\
    \x20\x01(\rR\x06seqNum\x12\x1d\n\nclient_ids\x18\x02\x20\x03(\x04R\tclie\
    ntIds\"L\n+CMsgRemoteClientBroadcastClientIDDeconflict\x12\x1d\n\nclient\
    _ids\x18\x02\x20\x03(\x04R\tclientIds\"\xe8\x04\n$CMsgRemoteDeviceAuthor\
    izationRequest\x12!\n\x0cdevice_token\x18\x01\x20\x02(\x0cR\x0bdeviceTok\
    en\x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\tR\ndeviceName\x12+\n\x11en\
    crypted_request\x18\x03\x20\x02(\x0cR\x10encryptedRequest\x1a\x95\x03\n\
    \x11CKeyEscrow_Ticket\x12\x1a\n\x08password\x18\x01\x20\x01(\x0cR\x08pas\
    sword\x12\x1e\n\nidentifier\x18\x02\x20\x01(\x04R\nidentifier\x12\x18\n\
    \x07payload\x18\x03\x20\x01(\x0cR\x07payload\x12\x1c\n\ttimestamp\x18\
    \x04\x20\x01(\rR\ttimestamp\x12m\n\x05usage\x18\x05\x20\x01(\x0e25.CMsgR\
    emoteDeviceAuthorizationRequest.EKeyEscrowUsage:\x20k_EKeyEscrowUsageStr\
    eamingDeviceR\x05usage\x12\x1f\n\x0bdevice_name\x18\x06\x20\x01(\tR\ndev\
    iceName\x12!\n\x0cdevice_model\x18\x07\x20\x01(\tR\x0bdeviceModel\x12#\n\
    \rdevice_serial\x18\x08\x20\x01(\tR\x0cdeviceSerial\x124\n\x16device_pro\
    visioning_id\x18\t\x20\x01(\rR\x14deviceProvisioningId\"7\n\x0fEKeyEscro\
    wUsage\x12$\n\x20k_EKeyEscrowUsageStreamingDevice\x10\0\",\n*CMsgRemoteD\
    eviceAuthorizationCancelRequest\"\xa1\x01\n%CMsgRemoteDeviceAuthorizatio\
    nResponse\x12^\n\x06result\x18\x01\x20\x02(\x0e2!.ERemoteDeviceAuthoriza\
    tionResult:#k_ERemoteDeviceAuthorizationSuccessR\x06result\x12\x18\n\x07\
    steamid\x18\x02\x20\x01(\x06R\x07steamid\"\xe0\x08\n\x20CMsgRemoteDevice\
    StreamingRequest\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestId\
    \x120\n\x14maximum_resolution_x\x18\x02\x20\x01(\x05R\x12maximumResoluti\
    onX\x120\n\x14maximum_resolution_y\x18\x03\x20\x01(\x05R\x12maximumResol\
    utionY\x121\n\x13audio_channel_count\x18\x04\x20\x01(\x05:\x012R\x11audi\
    oChannelCount\x12%\n\x0edevice_version\x18\x05\x20\x01(\tR\rdeviceVersio\
    n\x12%\n\x0estream_desktop\x18\x06\x20\x01(\x08R\rstreamDesktop\x12!\n\
    \x0cdevice_token\x18\x07\x20\x01(\x0cR\x0bdeviceToken\x12\x10\n\x03pin\
    \x18\x08\x20\x01(\x0cR\x03pin\x12:\n\x16enable_video_streaming\x18\t\x20\
    \x01(\x08:\x04trueR\x14enableVideoStreaming\x12:\n\x16enable_audio_strea\
    ming\x18\n\x20\x01(\x08:\x04trueR\x14enableAudioStreaming\x12:\n\x16enab\
    le_input_streaming\x18\x0b\x20\x01(\x08:\x04trueR\x14enableInputStreamin\
    g\x12!\n\x0cnetwork_test\x18\x0c\x20\x01(\x08R\x0bnetworkTest\x12\x1b\n\
    \tclient_id\x18\r\x20\x01(\x04R\x08clientId\x12B\n\x13supported_transpor\
    t\x18\x0e\x20\x03(\x0e2\x11.EStreamTransportR\x12supportedTransport\x12\
    \x1e\n\nrestricted\x18\x0f\x20\x01(\x08R\nrestricted\x12[\n\x0bform_fact\
    or\x18\x10\x20\x01(\x0e2\x18.EStreamDeviceFormFactor:\x20k_EStreamDevice\
    FormFactorUnknownR\nformFactor\x12#\n\rgamepad_count\x18\x11\x20\x01(\
    \x05R\x0cgamepadCount\x12M\n\x08gamepads\x18\x12\x20\x03(\x0b21.CMsgRemo\
    teDeviceStreamingRequest.ReservedGamepadR\x08gamepads\x12\x16\n\x06gamei\
    d\x18\x13\x20\x01(\x04R\x06gameid\x12W\n\x10stream_interface\x18\x14\x20\
    \x01(\x0e2\x11.EStreamInterface:\x19k_EStreamInterfaceDefaultR\x0fstream\
    Interface\x1ai\n\x0fReservedGamepad\x12'\n\x0fcontroller_type\x18\x01\
    \x20\x01(\rR\x0econtrollerType\x12-\n\x12controller_subtype\x18\x02\x20\
    \x01(\rR\x11controllerSubtype\"G\n&CMsgRemoteDeviceStreamingCancelReques\
    t\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestId\"^\n!CMsgRemoteDe\
    viceStreamingProgress\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequest\
    Id\x12\x1a\n\x08progress\x18\x02\x20\x01(\x02R\x08progress\"\xe1\x02\n!C\
    MsgRemoteDeviceStreamingResponse\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\
    \rR\trequestId\x12V\n\x06result\x18\x02\x20\x02(\x0e2\x1d.ERemoteDeviceS\
    treamingResult:\x1fk_ERemoteDeviceStreamingSuccessR\x06result\x12\x12\n\
    \x04port\x18\x03\x20\x01(\rR\x04port\x122\n\x15encrypted_session_key\x18\
    \x04\x20\x01(\x0cR\x13encryptedSessionKey\x12F\n\ttransport\x18\x06\x20\
    \x01(\x0e2\x11.EStreamTransport:\x15k_EStreamTransportUDPR\ttransport\
    \x12!\n\x0crelay_server\x18\x07\x20\x01(\tR\x0brelayServer\x12\x12\n\x04\
    cert\x18\x08\x20\x01(\tR\x04cert\"[\n\x1cCMsgRemoteDeviceProofRequest\
    \x12\x1c\n\tchallenge\x18\x01\x20\x02(\x0cR\tchallenge\x12\x1d\n\nreques\
    t_id\x18\x02\x20\x01(\rR\trequestId\"Z\n\x1dCMsgRemoteDeviceProofRespons\
    e\x12\x1a\n\x08response\x18\x01\x20\x02(\x0cR\x08response\x12\x1d\n\nreq\
    uest_id\x18\x02\x20\x01(\rR\trequestId\"W\n%CMsgRemoteDeviceStreamTransp\
    ortSignal\x12\x14\n\x05token\x18\x01\x20\x01(\x0cR\x05token\x12\x18\n\
    \x07payload\x18\x02\x20\x01(\x0cR\x07payload*\xd2\x04\n\x19ERemoteClient\
    BroadcastMsg\x12(\n$k_ERemoteClientBroadcastMsgDiscovery\x10\0\x12%\n!k_\
    ERemoteClientBroadcastMsgStatus\x10\x01\x12&\n\"k_ERemoteClientBroadcast\
    MsgOffline\x10\x02\x12'\n#k_ERemoteDeviceAuthorizationRequest\x10\x03\
    \x12(\n$k_ERemoteDeviceAuthorizationResponse\x10\x04\x12#\n\x1fk_ERemote\
    DeviceStreamingRequest\x10\x05\x12$\n\x20k_ERemoteDeviceStreamingRespons\
    e\x10\x06\x12\x1f\n\x1bk_ERemoteDeviceProofRequest\x10\x07\x12\x20\n\x1c\
    k_ERemoteDeviceProofResponse\x10\x08\x12-\n)k_ERemoteDeviceAuthorization\
    CancelRequest\x10\t\x12)\n%k_ERemoteDeviceStreamingCancelRequest\x10\n\
    \x121\n-k_ERemoteClientBroadcastMsgClientIDDeconflict\x10\x0b\x12(\n$k_E\
    RemoteDeviceStreamTransportSignal\x10\x0c\x12$\n\x20k_ERemoteDeviceStrea\
    mingProgress\x10\r*\xd7\x01\n\x14ERemoteClientService\x12\x1e\n\x1ak_ERe\
    moteClientServiceNone\x10\0\x12'\n#k_ERemoteClientServiceRemoteControl\
    \x10\x01\x12'\n#k_ERemoteClientServiceGameStreaming\x10\x02\x12%\n!k_ERe\
    moteClientServiceSiteLicense\x10\x04\x12&\n\"k_ERemoteClientServiceConte\
    ntCache\x10\x08*\x97\x03\n\x20ERemoteDeviceAuthorizationResult\x12'\n#k_\
    ERemoteDeviceAuthorizationSuccess\x10\0\x12&\n\"k_ERemoteDeviceAuthoriza\
    tionDenied\x10\x01\x12+\n'k_ERemoteDeviceAuthorizationNotLoggedIn\x10\
    \x02\x12'\n#k_ERemoteDeviceAuthorizationOffline\x10\x03\x12$\n\x20k_ERem\
    oteDeviceAuthorizationBusy\x10\x04\x12*\n&k_ERemoteDeviceAuthorizationIn\
    Progress\x10\x05\x12(\n$k_ERemoteDeviceAuthorizationTimedOut\x10\x06\x12\
    &\n\"k_ERemoteDeviceAuthorizationFailed\x10\x07\x12(\n$k_ERemoteDeviceAu\
    thorizationCanceled\x10\x08*\xd0\x01\n\x17EStreamDeviceFormFactor\x12$\n\
    \x20k_EStreamDeviceFormFactorUnknown\x10\0\x12\"\n\x1ek_EStreamDeviceFor\
    mFactorPhone\x10\x01\x12#\n\x1fk_EStreamDeviceFormFactorTablet\x10\x02\
    \x12%\n!k_EStreamDeviceFormFactorComputer\x10\x03\x12\x1f\n\x1bk_EStream\
    DeviceFormFactorTV\x10\x04*\xe5\x01\n\x10EStreamTransport\x12\x1a\n\x16k\
    _EStreamTransportNone\x10\0\x12\x19\n\x15k_EStreamTransportUDP\x10\x01\
    \x12\x1e\n\x1ak_EStreamTransportUDPRelay\x10\x02\x12\x1c\n\x18k_EStreamT\
    ransportWebRTC\x10\x03\x12\x19\n\x15k_EStreamTransportSDR\x10\x04\x12\
    \x1d\n\x19k_EStreamTransportUDP_SNS\x10\x05\x12\"\n\x1ek_EStreamTranspor\
    tUDPRelay_SNS\x10\x06*\x95\x01\n\x10EStreamInterface\x12\x1d\n\x19k_EStr\
    eamInterfaceDefault\x10\0\x12!\n\x1dk_EStreamInterfaceRecentGames\x10\
    \x01\x12\x20\n\x1ck_EStreamInterfaceBigPicture\x10\x02\x12\x1d\n\x19k_ES\
    treamInterfaceDesktop\x10\x03*\x88\x05\n\x1cERemoteDeviceStreamingResult\
    \x12#\n\x1fk_ERemoteDeviceStreamingSuccess\x10\0\x12(\n$k_ERemoteDeviceS\
    treamingUnauthorized\x10\x01\x12(\n$k_ERemoteDeviceStreamingScreenLocked\
    \x10\x02\x12\"\n\x1ek_ERemoteDeviceStreamingFailed\x10\x03\x12\x20\n\x1c\
    k_ERemoteDeviceStreamingBusy\x10\x04\x12&\n\"k_ERemoteDeviceStreamingInP\
    rogress\x10\x05\x12$\n\x20k_ERemoteDeviceStreamingCanceled\x10\x06\x12/\
    \n+k_ERemoteDeviceStreamingDriversNotInstalled\x10\x07\x12$\n\x20k_ERemo\
    teDeviceStreamingDisabled\x10\x08\x12.\n*k_ERemoteDeviceStreamingBroadca\
    stingActive\x10\t\x12$\n\x20k_ERemoteDeviceStreamingVRActive\x10\n\x12'\
    \n#k_ERemoteDeviceStreamingPINRequired\x10\x0b\x120\n,k_ERemoteDeviceStr\
    eamingTransportUnavailable\x10\x0c\x12%\n!k_ERemoteDeviceStreamingInvisi\
    ble\x10\r\x12,\n(k_ERemoteDeviceStreamingGameLaunchFailed\x10\x0eB\x02H\
    \x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
