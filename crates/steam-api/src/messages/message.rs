//! Message Module
//!
//!
//!
//!
//!
//! Check link below for more info:
//! https://github.com/ValvePython/steam/blob/09f4f51a287ee7aec1f159c7e8098add5f14bed3/steam/core/msg/headers.py

#[macro_use]
use num::FromPrimitive;
use protobuf::Message as OtherMessage;
use serde::{Deserialize, Serialize};

use steam_protobuf::steam::steammessages_base::CMsgProtoBufHeader;

use super::enums::{EMsg, EUniverse};
use super::headers::*;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
struct Message<K, V>
where
    K: SerializableMessageHeader,
    V: SerializableMessageBody,
{
    header: K,
    body: V,
}

pub trait SerializableMessageBody {
    fn new() -> Self;
    fn serialize(&self) -> Vec<u8>;
    fn deserialize_struct(packet_data: &[u8]) -> Self;
}

impl SerializableMessageBody for MsgChannelEncryptRequest {
    fn new() -> Self {
        Self { header: Default::default(), protocol_version: 1, universe: EUniverse::Public }
    }

    fn serialize(&self) -> Vec<u8> {
        bincode::serialize(&self).unwrap()
    }

    fn deserialize_struct(packet_data: &[u8]) -> Self {
        let decoded: Self = bincode::deserialize(packet_data).unwrap();
        decoded
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
struct MsgChannelEncryptRequest {
    header: StandardMessageHeader,
    protocol_version: u32,
    universe: EUniverse,
}

#[cfg(test)]
mod tests {
    use protobuf::Message;

    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::{
        EMsg, EUniverse, ExtendedMessageHeader, MsgChannelEncryptRequest, ProtobufMessageHeader,
        SerializableMessageBody, SerializableMessageHeader, StandardMessageHeader,
    };

    /// ChannelEncryptRequest
    fn get_channel_encrypt_request() -> Vec<u8> {
        let on_connection_packet = vec![
            23, 5, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 1, 0, 0, 0, 1, 0, 0, 0, 66, 126, 251, 245, 88, 122, 243, 123, 102, 163, 11, 54,
            151, 145, 31, 54,
        ];
        on_connection_packet
    }

    /// ClientChatEnter, EMsg(807)
    fn get_client_chat_enter() -> Vec<u8> {
        let struct_msg_data = vec![
            0x27, 0x03, 0x00, 0x00, 0x24, 0x02, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xAC, 0x15, 0x89, 0x00,
            0x01, 0x00, 0x10, 0x01, 0x8E, 0x56, 0x11, 0x00, 0xBC, 0x4E, 0x2A, 0x00, 0x00, 0x00,
            0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0xBC, 0x4E, 0x2A, 0x00, 0x00, 0x00, 0x70, 0x01, 0xBC, 0x4E, 0x2A, 0x00, 0x00, 0x00,
            0x70, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x53, 0x61, 0x78,
            0x74, 0x6F, 0x6E, 0x20, 0x48, 0x65, 0x6C, 0x6C, 0x00, 0x00, 0x4D, 0x65, 0x73, 0x73,
            0x61, 0x67, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x07, 0x73, 0x74, 0x65,
            0x61, 0x6D, 0x69, 0x64, 0x00, 0xAC, 0x15, 0x89, 0x00, 0x01, 0x00, 0x10, 0x01, 0x02,
            0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00, 0x7B, 0x03,
            0x00, 0x00, 0x02, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x00, 0x01, 0x00, 0x00,
            0x00, 0x08, 0x08, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4F, 0x62, 0x6A,
            0x65, 0x63, 0x74, 0x00, 0x07, 0x73, 0x74, 0x65, 0x61, 0x6D, 0x69, 0x64, 0x00, 0x00,
            0x28, 0x90, 0x00, 0x01, 0x00, 0x10, 0x01, 0x02, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73,
            0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x44, 0x65, 0x74,
            0x61, 0x69, 0x6C, 0x73, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x4D, 0x65,
            0x73, 0x73, 0x61, 0x67, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x07, 0x73,
            0x74, 0x65, 0x61, 0x6D, 0x69, 0x64, 0x00, 0xB0, 0xDC, 0x5B, 0x04, 0x01, 0x00, 0x10,
            0x01, 0x02, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x02, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4F,
            0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x07, 0x73, 0x74, 0x65, 0x61, 0x6D, 0x69, 0x64,
            0x00, 0x39, 0xCB, 0x77, 0x05, 0x01, 0x00, 0x10, 0x01, 0x02, 0x70, 0x65, 0x72, 0x6D,
            0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x02, 0x44,
            0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x08, 0xE8,
            0x03, 0x00, 0x00,
        ];
        struct_msg_data
    }

    #[test]
    fn deserialize_msg_encrypt_request() {
        let message = b"\x17\x05\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00\x01\x00\x00\x00".to_vec();
        let deserialized_from_bytes = MsgChannelEncryptRequest::deserialize_struct(&message);

        assert_eq!(message, deserialized_from_bytes.serialize());
        assert_eq!(deserialized_from_bytes.protocol_version, 1);
        assert_eq!(deserialized_from_bytes.universe, EUniverse::Public);
    }
}

//  if message is proto: emsg_enum, raw_data from packet
// new MessageHeaderProtobuf
// steammessages_base_pb2. CMSGProtobufHeader

//  if not proto: emsg_enum, raw_data from packet -> extender
// novo  ExtendedMessageHeader
