// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `steammessages_publishedfile.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Subscribe_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    list_type: ::std::option::Option<u32>,
    appid: ::std::option::Option<i32>,
    notify_client: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Subscribe_Request {
    fn default() -> &'a CPublishedFile_Subscribe_Request {
        <CPublishedFile_Subscribe_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Subscribe_Request {
    pub fn new() -> CPublishedFile_Subscribe_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 list_type = 2;

    pub fn get_list_type(&self) -> u32 {
        self.list_type.unwrap_or(0)
    }

    pub fn clear_list_type(&mut self) {
        self.list_type = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        self.list_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: u32) {
        self.list_type = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 3;

    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool notify_client = 4;

    pub fn get_notify_client(&self) -> bool {
        self.notify_client.unwrap_or(false)
    }

    pub fn clear_notify_client(&mut self) {
        self.notify_client = ::std::option::Option::None;
    }

    pub fn has_notify_client(&self) -> bool {
        self.notify_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notify_client(&mut self, v: bool) {
        self.notify_client = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_Subscribe_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.list_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.notify_client = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.list_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.notify_client {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.list_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.notify_client {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Subscribe_Request {
        CPublishedFile_Subscribe_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_Subscribe_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_Subscribe_Request| { &mut m.publishedfileid },
                CPublishedFile_Subscribe_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "list_type",
                |m: &CPublishedFile_Subscribe_Request| { &m.list_type },
                |m: &mut CPublishedFile_Subscribe_Request| { &mut m.list_type },
                CPublishedFile_Subscribe_Request::get_list_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "appid",
                |m: &CPublishedFile_Subscribe_Request| { &m.appid },
                |m: &mut CPublishedFile_Subscribe_Request| { &mut m.appid },
                CPublishedFile_Subscribe_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "notify_client",
                |m: &CPublishedFile_Subscribe_Request| { &m.notify_client },
                |m: &mut CPublishedFile_Subscribe_Request| { &mut m.notify_client },
                CPublishedFile_Subscribe_Request::get_notify_client,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Subscribe_Request>(
                "CPublishedFile_Subscribe_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Subscribe_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Subscribe_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Subscribe_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Subscribe_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.list_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.notify_client = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Subscribe_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Subscribe_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Subscribe_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Subscribe_Response {
    fn default() -> &'a CPublishedFile_Subscribe_Response {
        <CPublishedFile_Subscribe_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Subscribe_Response {
    pub fn new() -> CPublishedFile_Subscribe_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_Subscribe_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Subscribe_Response {
        CPublishedFile_Subscribe_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Subscribe_Response>(
                "CPublishedFile_Subscribe_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Subscribe_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Subscribe_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Subscribe_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Subscribe_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Subscribe_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Subscribe_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Unsubscribe_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    list_type: ::std::option::Option<u32>,
    appid: ::std::option::Option<i32>,
    notify_client: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Unsubscribe_Request {
    fn default() -> &'a CPublishedFile_Unsubscribe_Request {
        <CPublishedFile_Unsubscribe_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Unsubscribe_Request {
    pub fn new() -> CPublishedFile_Unsubscribe_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 list_type = 2;

    pub fn get_list_type(&self) -> u32 {
        self.list_type.unwrap_or(0)
    }

    pub fn clear_list_type(&mut self) {
        self.list_type = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        self.list_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: u32) {
        self.list_type = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 3;

    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool notify_client = 4;

    pub fn get_notify_client(&self) -> bool {
        self.notify_client.unwrap_or(false)
    }

    pub fn clear_notify_client(&mut self) {
        self.notify_client = ::std::option::Option::None;
    }

    pub fn has_notify_client(&self) -> bool {
        self.notify_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notify_client(&mut self, v: bool) {
        self.notify_client = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_Unsubscribe_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.list_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.notify_client = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.list_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.notify_client {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.list_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.notify_client {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Unsubscribe_Request {
        CPublishedFile_Unsubscribe_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_Unsubscribe_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.publishedfileid },
                CPublishedFile_Unsubscribe_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "list_type",
                |m: &CPublishedFile_Unsubscribe_Request| { &m.list_type },
                |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.list_type },
                CPublishedFile_Unsubscribe_Request::get_list_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "appid",
                |m: &CPublishedFile_Unsubscribe_Request| { &m.appid },
                |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.appid },
                CPublishedFile_Unsubscribe_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "notify_client",
                |m: &CPublishedFile_Unsubscribe_Request| { &m.notify_client },
                |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.notify_client },
                CPublishedFile_Unsubscribe_Request::get_notify_client,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Unsubscribe_Request>(
                "CPublishedFile_Unsubscribe_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Unsubscribe_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Unsubscribe_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Unsubscribe_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Unsubscribe_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.list_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.notify_client = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Unsubscribe_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Unsubscribe_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Unsubscribe_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Unsubscribe_Response {
    fn default() -> &'a CPublishedFile_Unsubscribe_Response {
        <CPublishedFile_Unsubscribe_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Unsubscribe_Response {
    pub fn new() -> CPublishedFile_Unsubscribe_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_Unsubscribe_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Unsubscribe_Response {
        CPublishedFile_Unsubscribe_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Unsubscribe_Response>(
                "CPublishedFile_Unsubscribe_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Unsubscribe_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Unsubscribe_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Unsubscribe_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Unsubscribe_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Unsubscribe_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Unsubscribe_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_CanSubscribe_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_CanSubscribe_Request {
    fn default() -> &'a CPublishedFile_CanSubscribe_Request {
        <CPublishedFile_CanSubscribe_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_CanSubscribe_Request {
    pub fn new() -> CPublishedFile_CanSubscribe_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_CanSubscribe_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_CanSubscribe_Request {
        CPublishedFile_CanSubscribe_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_CanSubscribe_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_CanSubscribe_Request| { &mut m.publishedfileid },
                CPublishedFile_CanSubscribe_Request::get_publishedfileid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_CanSubscribe_Request>(
                "CPublishedFile_CanSubscribe_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_CanSubscribe_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_CanSubscribe_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_CanSubscribe_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_CanSubscribe_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_CanSubscribe_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_CanSubscribe_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_CanSubscribe_Response {
    // message fields
    can_subscribe: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_CanSubscribe_Response {
    fn default() -> &'a CPublishedFile_CanSubscribe_Response {
        <CPublishedFile_CanSubscribe_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_CanSubscribe_Response {
    pub fn new() -> CPublishedFile_CanSubscribe_Response {
        ::std::default::Default::default()
    }

    // optional bool can_subscribe = 1;

    pub fn get_can_subscribe(&self) -> bool {
        self.can_subscribe.unwrap_or(false)
    }

    pub fn clear_can_subscribe(&mut self) {
        self.can_subscribe = ::std::option::Option::None;
    }

    pub fn has_can_subscribe(&self) -> bool {
        self.can_subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_subscribe(&mut self, v: bool) {
        self.can_subscribe = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_CanSubscribe_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.can_subscribe = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.can_subscribe {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.can_subscribe {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_CanSubscribe_Response {
        CPublishedFile_CanSubscribe_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "can_subscribe",
                |m: &CPublishedFile_CanSubscribe_Response| { &m.can_subscribe },
                |m: &mut CPublishedFile_CanSubscribe_Response| { &mut m.can_subscribe },
                CPublishedFile_CanSubscribe_Response::get_can_subscribe,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_CanSubscribe_Response>(
                "CPublishedFile_CanSubscribe_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_CanSubscribe_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_CanSubscribe_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_CanSubscribe_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_CanSubscribe_Response {
    fn clear(&mut self) {
        self.can_subscribe = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_CanSubscribe_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_CanSubscribe_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Publish_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    consumer_appid: ::std::option::Option<u32>,
    cloudfilename: ::protobuf::SingularField<::std::string::String>,
    preview_cloudfilename: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    file_description: ::protobuf::SingularField<::std::string::String>,
    file_type: ::std::option::Option<u32>,
    consumer_shortcut_name: ::protobuf::SingularField<::std::string::String>,
    youtube_username: ::protobuf::SingularField<::std::string::String>,
    youtube_videoid: ::protobuf::SingularField<::std::string::String>,
    visibility: ::std::option::Option<u32>,
    redirect_uri: ::protobuf::SingularField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    collection_type: ::protobuf::SingularField<::std::string::String>,
    game_type: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Publish_Request {
    fn default() -> &'a CPublishedFile_Publish_Request {
        <CPublishedFile_Publish_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Publish_Request {
    pub fn new() -> CPublishedFile_Publish_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 consumer_appid = 2;

    pub fn get_consumer_appid(&self) -> u32 {
        self.consumer_appid.unwrap_or(0)
    }

    pub fn clear_consumer_appid(&mut self) {
        self.consumer_appid = ::std::option::Option::None;
    }

    pub fn has_consumer_appid(&self) -> bool {
        self.consumer_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_appid(&mut self, v: u32) {
        self.consumer_appid = ::std::option::Option::Some(v);
    }

    // optional string cloudfilename = 3;

    pub fn get_cloudfilename(&self) -> &str {
        match self.cloudfilename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cloudfilename(&mut self) {
        self.cloudfilename.clear();
    }

    pub fn has_cloudfilename(&self) -> bool {
        self.cloudfilename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloudfilename(&mut self, v: ::std::string::String) {
        self.cloudfilename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloudfilename(&mut self) -> &mut ::std::string::String {
        if self.cloudfilename.is_none() {
            self.cloudfilename.set_default();
        }
        self.cloudfilename.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloudfilename(&mut self) -> ::std::string::String {
        self.cloudfilename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_cloudfilename = 4;

    pub fn get_preview_cloudfilename(&self) -> &str {
        match self.preview_cloudfilename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_cloudfilename(&mut self) {
        self.preview_cloudfilename.clear();
    }

    pub fn has_preview_cloudfilename(&self) -> bool {
        self.preview_cloudfilename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_cloudfilename(&mut self, v: ::std::string::String) {
        self.preview_cloudfilename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_cloudfilename(&mut self) -> &mut ::std::string::String {
        if self.preview_cloudfilename.is_none() {
            self.preview_cloudfilename.set_default();
        }
        self.preview_cloudfilename.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_cloudfilename(&mut self) -> ::std::string::String {
        self.preview_cloudfilename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_description = 6;

    pub fn get_file_description(&self) -> &str {
        match self.file_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_description(&mut self) {
        self.file_description.clear();
    }

    pub fn has_file_description(&self) -> bool {
        self.file_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_description(&mut self, v: ::std::string::String) {
        self.file_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_description(&mut self) -> &mut ::std::string::String {
        if self.file_description.is_none() {
            self.file_description.set_default();
        }
        self.file_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_description(&mut self) -> ::std::string::String {
        self.file_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_type = 7;

    pub fn get_file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }

    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional string consumer_shortcut_name = 8;

    pub fn get_consumer_shortcut_name(&self) -> &str {
        match self.consumer_shortcut_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_consumer_shortcut_name(&mut self) {
        self.consumer_shortcut_name.clear();
    }

    pub fn has_consumer_shortcut_name(&self) -> bool {
        self.consumer_shortcut_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_shortcut_name(&mut self, v: ::std::string::String) {
        self.consumer_shortcut_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_shortcut_name(&mut self) -> &mut ::std::string::String {
        if self.consumer_shortcut_name.is_none() {
            self.consumer_shortcut_name.set_default();
        }
        self.consumer_shortcut_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumer_shortcut_name(&mut self) -> ::std::string::String {
        self.consumer_shortcut_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_username = 9;

    pub fn get_youtube_username(&self) -> &str {
        match self.youtube_username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_username(&mut self) {
        self.youtube_username.clear();
    }

    pub fn has_youtube_username(&self) -> bool {
        self.youtube_username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_username(&mut self, v: ::std::string::String) {
        self.youtube_username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_username(&mut self) -> &mut ::std::string::String {
        if self.youtube_username.is_none() {
            self.youtube_username.set_default();
        }
        self.youtube_username.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_username(&mut self) -> ::std::string::String {
        self.youtube_username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_videoid = 10;

    pub fn get_youtube_videoid(&self) -> &str {
        match self.youtube_videoid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_videoid(&mut self) {
        self.youtube_videoid.clear();
    }

    pub fn has_youtube_videoid(&self) -> bool {
        self.youtube_videoid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_videoid(&mut self, v: ::std::string::String) {
        self.youtube_videoid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_videoid(&mut self) -> &mut ::std::string::String {
        if self.youtube_videoid.is_none() {
            self.youtube_videoid.set_default();
        }
        self.youtube_videoid.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_videoid(&mut self) -> ::std::string::String {
        self.youtube_videoid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 visibility = 11;

    pub fn get_visibility(&self) -> u32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: u32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional string redirect_uri = 12;

    pub fn get_redirect_uri(&self) -> &str {
        match self.redirect_uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_redirect_uri(&mut self) {
        self.redirect_uri.clear();
    }

    pub fn has_redirect_uri(&self) -> bool {
        self.redirect_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redirect_uri(&mut self, v: ::std::string::String) {
        self.redirect_uri = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redirect_uri(&mut self) -> &mut ::std::string::String {
        if self.redirect_uri.is_none() {
            self.redirect_uri.set_default();
        }
        self.redirect_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_redirect_uri(&mut self) -> ::std::string::String {
        self.redirect_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string collection_type = 14;

    pub fn get_collection_type(&self) -> &str {
        match self.collection_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_collection_type(&mut self) {
        self.collection_type.clear();
    }

    pub fn has_collection_type(&self) -> bool {
        self.collection_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collection_type(&mut self, v: ::std::string::String) {
        self.collection_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection_type(&mut self) -> &mut ::std::string::String {
        if self.collection_type.is_none() {
            self.collection_type.set_default();
        }
        self.collection_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_collection_type(&mut self) -> ::std::string::String {
        self.collection_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_type = 15;

    pub fn get_game_type(&self) -> &str {
        match self.game_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_type(&mut self) {
        self.game_type.clear();
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: ::std::string::String) {
        self.game_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_type(&mut self) -> &mut ::std::string::String {
        if self.game_type.is_none() {
            self.game_type.set_default();
        }
        self.game_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_type(&mut self) -> ::std::string::String {
        self.game_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 16;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_Publish_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consumer_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cloudfilename)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_cloudfilename)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_description)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumer_shortcut_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_username)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_videoid)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.visibility = ::std::option::Option::Some(is.read_uint32()?);
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.redirect_uri)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.collection_type)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_type)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cloudfilename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preview_cloudfilename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.file_description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_shortcut_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.youtube_username.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.youtube_videoid.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.redirect_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(v) = self.collection_type.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.game_type.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.consumer_appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cloudfilename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preview_cloudfilename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.file_description.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.consumer_shortcut_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.youtube_username.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.youtube_videoid.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.redirect_uri.as_ref() {
            os.write_string(12, v)?;
        }
        for v in &self.tags {
            os.write_string(13, &v)?;
        };
        if let Some(v) = self.collection_type.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.game_type.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Publish_Request {
        CPublishedFile_Publish_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_Publish_Request| { &m.appid },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.appid },
                CPublishedFile_Publish_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "consumer_appid",
                |m: &CPublishedFile_Publish_Request| { &m.consumer_appid },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.consumer_appid },
                CPublishedFile_Publish_Request::get_consumer_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "cloudfilename",
                |m: &CPublishedFile_Publish_Request| { &m.cloudfilename },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.cloudfilename },
                CPublishedFile_Publish_Request::get_cloudfilename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "preview_cloudfilename",
                |m: &CPublishedFile_Publish_Request| { &m.preview_cloudfilename },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.preview_cloudfilename },
                CPublishedFile_Publish_Request::get_preview_cloudfilename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "title",
                |m: &CPublishedFile_Publish_Request| { &m.title },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.title },
                CPublishedFile_Publish_Request::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_description",
                |m: &CPublishedFile_Publish_Request| { &m.file_description },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.file_description },
                CPublishedFile_Publish_Request::get_file_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_type",
                |m: &CPublishedFile_Publish_Request| { &m.file_type },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.file_type },
                CPublishedFile_Publish_Request::get_file_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "consumer_shortcut_name",
                |m: &CPublishedFile_Publish_Request| { &m.consumer_shortcut_name },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.consumer_shortcut_name },
                CPublishedFile_Publish_Request::get_consumer_shortcut_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "youtube_username",
                |m: &CPublishedFile_Publish_Request| { &m.youtube_username },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.youtube_username },
                CPublishedFile_Publish_Request::get_youtube_username,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "youtube_videoid",
                |m: &CPublishedFile_Publish_Request| { &m.youtube_videoid },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.youtube_videoid },
                CPublishedFile_Publish_Request::get_youtube_videoid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "visibility",
                |m: &CPublishedFile_Publish_Request| { &m.visibility },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.visibility },
                CPublishedFile_Publish_Request::get_visibility,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "redirect_uri",
                |m: &CPublishedFile_Publish_Request| { &m.redirect_uri },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.redirect_uri },
                CPublishedFile_Publish_Request::get_redirect_uri,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "tags",
                |m: &CPublishedFile_Publish_Request| { &m.tags },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "collection_type",
                |m: &CPublishedFile_Publish_Request| { &m.collection_type },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.collection_type },
                CPublishedFile_Publish_Request::get_collection_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "game_type",
                |m: &CPublishedFile_Publish_Request| { &m.game_type },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.game_type },
                CPublishedFile_Publish_Request::get_game_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "url",
                |m: &CPublishedFile_Publish_Request| { &m.url },
                |m: &mut CPublishedFile_Publish_Request| { &mut m.url },
                CPublishedFile_Publish_Request::get_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Publish_Request>(
                "CPublishedFile_Publish_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Publish_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Publish_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Publish_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Publish_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.consumer_appid = ::std::option::Option::None;
        self.cloudfilename.clear();
        self.preview_cloudfilename.clear();
        self.title.clear();
        self.file_description.clear();
        self.file_type = ::std::option::Option::None;
        self.consumer_shortcut_name.clear();
        self.youtube_username.clear();
        self.youtube_videoid.clear();
        self.visibility = ::std::option::Option::None;
        self.redirect_uri.clear();
        self.tags.clear();
        self.collection_type.clear();
        self.game_type.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Publish_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Publish_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Publish_Response {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    redirect_uri: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Publish_Response {
    fn default() -> &'a CPublishedFile_Publish_Response {
        <CPublishedFile_Publish_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Publish_Response {
    pub fn new() -> CPublishedFile_Publish_Response {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional string redirect_uri = 2;

    pub fn get_redirect_uri(&self) -> &str {
        match self.redirect_uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_redirect_uri(&mut self) {
        self.redirect_uri.clear();
    }

    pub fn has_redirect_uri(&self) -> bool {
        self.redirect_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redirect_uri(&mut self, v: ::std::string::String) {
        self.redirect_uri = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redirect_uri(&mut self) -> &mut ::std::string::String {
        if self.redirect_uri.is_none() {
            self.redirect_uri.set_default();
        }
        self.redirect_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_redirect_uri(&mut self) -> ::std::string::String {
        self.redirect_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_Publish_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.redirect_uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.redirect_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.redirect_uri.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Publish_Response {
        CPublishedFile_Publish_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_Publish_Response| { &m.publishedfileid },
                |m: &mut CPublishedFile_Publish_Response| { &mut m.publishedfileid },
                CPublishedFile_Publish_Response::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "redirect_uri",
                |m: &CPublishedFile_Publish_Response| { &m.redirect_uri },
                |m: &mut CPublishedFile_Publish_Response| { &mut m.redirect_uri },
                CPublishedFile_Publish_Response::get_redirect_uri,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Publish_Response>(
                "CPublishedFile_Publish_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Publish_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Publish_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Publish_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Publish_Response {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.redirect_uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Publish_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Publish_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetDetails_Request {
    // message fields
    pub publishedfileids: ::std::vec::Vec<u64>,
    includetags: ::std::option::Option<bool>,
    includeadditionalpreviews: ::std::option::Option<bool>,
    includechildren: ::std::option::Option<bool>,
    includekvtags: ::std::option::Option<bool>,
    includevotes: ::std::option::Option<bool>,
    short_description: ::std::option::Option<bool>,
    includeforsaledata: ::std::option::Option<bool>,
    includemetadata: ::std::option::Option<bool>,
    language: ::std::option::Option<i32>,
    return_playtime_stats: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    strip_description_bbcode: ::std::option::Option<bool>,
    desired_revision: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EPublishedFileRevision>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetDetails_Request {
    fn default() -> &'a CPublishedFile_GetDetails_Request {
        <CPublishedFile_GetDetails_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetDetails_Request {
    pub fn new() -> CPublishedFile_GetDetails_Request {
        ::std::default::Default::default()
    }

    // optional bool includetags = 2;

    pub fn get_includetags(&self) -> bool {
        self.includetags.unwrap_or(false)
    }

    pub fn clear_includetags(&mut self) {
        self.includetags = ::std::option::Option::None;
    }

    pub fn has_includetags(&self) -> bool {
        self.includetags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includetags(&mut self, v: bool) {
        self.includetags = ::std::option::Option::Some(v);
    }

    // optional bool includeadditionalpreviews = 3;

    pub fn get_includeadditionalpreviews(&self) -> bool {
        self.includeadditionalpreviews.unwrap_or(false)
    }

    pub fn clear_includeadditionalpreviews(&mut self) {
        self.includeadditionalpreviews = ::std::option::Option::None;
    }

    pub fn has_includeadditionalpreviews(&self) -> bool {
        self.includeadditionalpreviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeadditionalpreviews(&mut self, v: bool) {
        self.includeadditionalpreviews = ::std::option::Option::Some(v);
    }

    // optional bool includechildren = 4;

    pub fn get_includechildren(&self) -> bool {
        self.includechildren.unwrap_or(false)
    }

    pub fn clear_includechildren(&mut self) {
        self.includechildren = ::std::option::Option::None;
    }

    pub fn has_includechildren(&self) -> bool {
        self.includechildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includechildren(&mut self, v: bool) {
        self.includechildren = ::std::option::Option::Some(v);
    }

    // optional bool includekvtags = 5;

    pub fn get_includekvtags(&self) -> bool {
        self.includekvtags.unwrap_or(false)
    }

    pub fn clear_includekvtags(&mut self) {
        self.includekvtags = ::std::option::Option::None;
    }

    pub fn has_includekvtags(&self) -> bool {
        self.includekvtags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includekvtags(&mut self, v: bool) {
        self.includekvtags = ::std::option::Option::Some(v);
    }

    // optional bool includevotes = 6;

    pub fn get_includevotes(&self) -> bool {
        self.includevotes.unwrap_or(false)
    }

    pub fn clear_includevotes(&mut self) {
        self.includevotes = ::std::option::Option::None;
    }

    pub fn has_includevotes(&self) -> bool {
        self.includevotes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includevotes(&mut self, v: bool) {
        self.includevotes = ::std::option::Option::Some(v);
    }

    // optional bool short_description = 8;

    pub fn get_short_description(&self) -> bool {
        self.short_description.unwrap_or(false)
    }

    pub fn clear_short_description(&mut self) {
        self.short_description = ::std::option::Option::None;
    }

    pub fn has_short_description(&self) -> bool {
        self.short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: bool) {
        self.short_description = ::std::option::Option::Some(v);
    }

    // optional bool includeforsaledata = 10;

    pub fn get_includeforsaledata(&self) -> bool {
        self.includeforsaledata.unwrap_or(false)
    }

    pub fn clear_includeforsaledata(&mut self) {
        self.includeforsaledata = ::std::option::Option::None;
    }

    pub fn has_includeforsaledata(&self) -> bool {
        self.includeforsaledata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeforsaledata(&mut self, v: bool) {
        self.includeforsaledata = ::std::option::Option::Some(v);
    }

    // optional bool includemetadata = 11;

    pub fn get_includemetadata(&self) -> bool {
        self.includemetadata.unwrap_or(false)
    }

    pub fn clear_includemetadata(&mut self) {
        self.includemetadata = ::std::option::Option::None;
    }

    pub fn has_includemetadata(&self) -> bool {
        self.includemetadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includemetadata(&mut self, v: bool) {
        self.includemetadata = ::std::option::Option::Some(v);
    }

    // optional int32 language = 12;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint32 return_playtime_stats = 13;

    pub fn get_return_playtime_stats(&self) -> u32 {
        self.return_playtime_stats.unwrap_or(0)
    }

    pub fn clear_return_playtime_stats(&mut self) {
        self.return_playtime_stats = ::std::option::Option::None;
    }

    pub fn has_return_playtime_stats(&self) -> bool {
        self.return_playtime_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_playtime_stats(&mut self, v: u32) {
        self.return_playtime_stats = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 14;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool strip_description_bbcode = 15;

    pub fn get_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.unwrap_or(false)
    }

    pub fn clear_strip_description_bbcode(&mut self) {
        self.strip_description_bbcode = ::std::option::Option::None;
    }

    pub fn has_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_description_bbcode(&mut self, v: bool) {
        self.strip_description_bbcode = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 16;

    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        match self.desired_revision {
            Some(e) => e.enum_value_or(EPublishedFileRevision::k_EPublishedFileRevision_Default),
            None => EPublishedFileRevision::k_EPublishedFileRevision_Default,
        }
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CPublishedFile_GetDetails_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.includetags = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.includeadditionalpreviews = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.includechildren = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.includekvtags = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.includevotes = ::std::option::Option::Some(is.read_bool()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.short_description = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.includeforsaledata = ::std::option::Option::Some(is.read_bool()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.includemetadata = ::std::option::Option::Some(is.read_bool()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_playtime_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strip_description_bbcode = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desired_revision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.publishedfileids.len() as u32;
        if let Some(v) = self.includetags {
            my_size += 2;
        }
        if let Some(v) = self.includeadditionalpreviews {
            my_size += 2;
        }
        if let Some(v) = self.includechildren {
            my_size += 2;
        }
        if let Some(v) = self.includekvtags {
            my_size += 2;
        }
        if let Some(v) = self.includevotes {
            my_size += 2;
        }
        if let Some(v) = self.short_description {
            my_size += 2;
        }
        if let Some(v) = self.includeforsaledata {
            my_size += 2;
        }
        if let Some(v) = self.includemetadata {
            my_size += 2;
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.return_playtime_stats {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strip_description_bbcode {
            my_size += 2;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_or_unknown_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.publishedfileids {
            os.write_fixed64(1, *v)?;
        };
        if let Some(v) = self.includetags {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.includeadditionalpreviews {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.includechildren {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.includekvtags {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.includevotes {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.short_description {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.includeforsaledata {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.includemetadata {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.return_playtime_stats {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.strip_description_bbcode {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(16, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetDetails_Request {
        CPublishedFile_GetDetails_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "publishedfileids",
                |m: &CPublishedFile_GetDetails_Request| { &m.publishedfileids },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.publishedfileids },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "includetags",
                |m: &CPublishedFile_GetDetails_Request| { &m.includetags },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includetags },
                CPublishedFile_GetDetails_Request::get_includetags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "includeadditionalpreviews",
                |m: &CPublishedFile_GetDetails_Request| { &m.includeadditionalpreviews },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includeadditionalpreviews },
                CPublishedFile_GetDetails_Request::get_includeadditionalpreviews,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "includechildren",
                |m: &CPublishedFile_GetDetails_Request| { &m.includechildren },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includechildren },
                CPublishedFile_GetDetails_Request::get_includechildren,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "includekvtags",
                |m: &CPublishedFile_GetDetails_Request| { &m.includekvtags },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includekvtags },
                CPublishedFile_GetDetails_Request::get_includekvtags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "includevotes",
                |m: &CPublishedFile_GetDetails_Request| { &m.includevotes },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includevotes },
                CPublishedFile_GetDetails_Request::get_includevotes,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "short_description",
                |m: &CPublishedFile_GetDetails_Request| { &m.short_description },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.short_description },
                CPublishedFile_GetDetails_Request::get_short_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "includeforsaledata",
                |m: &CPublishedFile_GetDetails_Request| { &m.includeforsaledata },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includeforsaledata },
                CPublishedFile_GetDetails_Request::get_includeforsaledata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "includemetadata",
                |m: &CPublishedFile_GetDetails_Request| { &m.includemetadata },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includemetadata },
                CPublishedFile_GetDetails_Request::get_includemetadata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CPublishedFile_GetDetails_Request| { &m.language },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.language },
                CPublishedFile_GetDetails_Request::get_language,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "return_playtime_stats",
                |m: &CPublishedFile_GetDetails_Request| { &m.return_playtime_stats },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.return_playtime_stats },
                CPublishedFile_GetDetails_Request::get_return_playtime_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_GetDetails_Request| { &m.appid },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.appid },
                CPublishedFile_GetDetails_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "strip_description_bbcode",
                |m: &CPublishedFile_GetDetails_Request| { &m.strip_description_bbcode },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.strip_description_bbcode },
                CPublishedFile_GetDetails_Request::get_strip_description_bbcode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EPublishedFileRevision>(
                "desired_revision",
                |m: &CPublishedFile_GetDetails_Request| { &m.desired_revision },
                |m: &mut CPublishedFile_GetDetails_Request| { &mut m.desired_revision },
                EPublishedFileRevision::k_EPublishedFileRevision_Default,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetDetails_Request>(
                "CPublishedFile_GetDetails_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetDetails_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetDetails_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetDetails_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetDetails_Request {
    fn clear(&mut self) {
        self.publishedfileids.clear();
        self.includetags = ::std::option::Option::None;
        self.includeadditionalpreviews = ::std::option::Option::None;
        self.includechildren = ::std::option::Option::None;
        self.includekvtags = ::std::option::Option::None;
        self.includevotes = ::std::option::Option::None;
        self.short_description = ::std::option::Option::None;
        self.includeforsaledata = ::std::option::Option::None;
        self.includemetadata = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.return_playtime_stats = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.strip_description_bbcode = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetDetails_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetDetails_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct PublishedFileDetails {
    // message fields
    result: ::std::option::Option<u32>,
    publishedfileid: ::std::option::Option<u64>,
    creator: ::std::option::Option<u64>,
    creator_appid: ::std::option::Option<u32>,
    consumer_appid: ::std::option::Option<u32>,
    consumer_shortcutid: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    file_size: ::std::option::Option<u64>,
    preview_file_size: ::std::option::Option<u64>,
    file_url: ::protobuf::SingularField<::std::string::String>,
    preview_url: ::protobuf::SingularField<::std::string::String>,
    youtubevideoid: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularField<::std::string::String>,
    hcontent_file: ::std::option::Option<u64>,
    hcontent_preview: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    file_description: ::protobuf::SingularField<::std::string::String>,
    short_description: ::protobuf::SingularField<::std::string::String>,
    time_created: ::std::option::Option<u32>,
    time_updated: ::std::option::Option<u32>,
    visibility: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    workshop_file: ::std::option::Option<bool>,
    workshop_accepted: ::std::option::Option<bool>,
    show_subscribe_all: ::std::option::Option<bool>,
    num_comments_developer: ::std::option::Option<i32>,
    num_comments_public: ::std::option::Option<i32>,
    banned: ::std::option::Option<bool>,
    ban_reason: ::protobuf::SingularField<::std::string::String>,
    banner: ::std::option::Option<u64>,
    can_be_deleted: ::std::option::Option<bool>,
    incompatible: ::std::option::Option<bool>,
    app_name: ::protobuf::SingularField<::std::string::String>,
    file_type: ::std::option::Option<u32>,
    can_subscribe: ::std::option::Option<bool>,
    subscriptions: ::std::option::Option<u32>,
    favorited: ::std::option::Option<u32>,
    followers: ::std::option::Option<u32>,
    lifetime_subscriptions: ::std::option::Option<u32>,
    lifetime_favorited: ::std::option::Option<u32>,
    lifetime_followers: ::std::option::Option<u32>,
    lifetime_playtime: ::std::option::Option<u64>,
    lifetime_playtime_sessions: ::std::option::Option<u64>,
    views: ::std::option::Option<u32>,
    image_width: ::std::option::Option<u32>,
    image_height: ::std::option::Option<u32>,
    image_url: ::protobuf::SingularField<::std::string::String>,
    spoiler_tag: ::std::option::Option<bool>,
    shortcutid: ::std::option::Option<u32>,
    shortcutname: ::protobuf::SingularField<::std::string::String>,
    num_children: ::std::option::Option<u32>,
    num_reports: ::std::option::Option<u32>,
    pub previews: ::protobuf::RepeatedField<published_file_details::Preview>,
    pub tags: ::protobuf::RepeatedField<published_file_details::Tag>,
    pub children: ::protobuf::RepeatedField<published_file_details::Child>,
    pub kvtags: ::protobuf::RepeatedField<published_file_details::KVTag>,
    pub vote_data: ::protobuf::SingularPtrField<published_file_details::VoteData>,
    pub playtime_stats: ::protobuf::SingularPtrField<published_file_details::PlaytimeStats>,
    time_subscribed: ::std::option::Option<u32>,
    pub for_sale_data: ::protobuf::SingularPtrField<published_file_details::ForSaleData>,
    metadata: ::protobuf::SingularField<::std::string::String>,
    language: ::std::option::Option<i32>,
    maybe_inappropriate_sex: ::std::option::Option<bool>,
    maybe_inappropriate_violence: ::std::option::Option<bool>,
    revision_change_number: ::std::option::Option<u64>,
    revision: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EPublishedFileRevision>>,
    pub available_revisions: ::std::vec::Vec<::protobuf::ProtobufEnumOrUnknown<EPublishedFileRevision>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails {
    fn default() -> &'a PublishedFileDetails {
        <PublishedFileDetails as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails {
    pub fn new() -> PublishedFileDetails {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 publishedfileid = 2;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator = 3;

    pub fn get_creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }

    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }

    // optional uint32 creator_appid = 4;

    pub fn get_creator_appid(&self) -> u32 {
        self.creator_appid.unwrap_or(0)
    }

    pub fn clear_creator_appid(&mut self) {
        self.creator_appid = ::std::option::Option::None;
    }

    pub fn has_creator_appid(&self) -> bool {
        self.creator_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_appid(&mut self, v: u32) {
        self.creator_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 consumer_appid = 5;

    pub fn get_consumer_appid(&self) -> u32 {
        self.consumer_appid.unwrap_or(0)
    }

    pub fn clear_consumer_appid(&mut self) {
        self.consumer_appid = ::std::option::Option::None;
    }

    pub fn has_consumer_appid(&self) -> bool {
        self.consumer_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_appid(&mut self, v: u32) {
        self.consumer_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 consumer_shortcutid = 6;

    pub fn get_consumer_shortcutid(&self) -> u32 {
        self.consumer_shortcutid.unwrap_or(0)
    }

    pub fn clear_consumer_shortcutid(&mut self) {
        self.consumer_shortcutid = ::std::option::Option::None;
    }

    pub fn has_consumer_shortcutid(&self) -> bool {
        self.consumer_shortcutid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_shortcutid(&mut self, v: u32) {
        self.consumer_shortcutid = ::std::option::Option::Some(v);
    }

    // optional string filename = 7;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 file_size = 8;

    pub fn get_file_size(&self) -> u64 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint64 preview_file_size = 9;

    pub fn get_preview_file_size(&self) -> u64 {
        self.preview_file_size.unwrap_or(0)
    }

    pub fn clear_preview_file_size(&mut self) {
        self.preview_file_size = ::std::option::Option::None;
    }

    pub fn has_preview_file_size(&self) -> bool {
        self.preview_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_size(&mut self, v: u64) {
        self.preview_file_size = ::std::option::Option::Some(v);
    }

    // optional string file_url = 10;

    pub fn get_file_url(&self) -> &str {
        match self.file_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_url(&mut self) {
        self.file_url.clear();
    }

    pub fn has_file_url(&self) -> bool {
        self.file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_url(&mut self, v: ::std::string::String) {
        self.file_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_url(&mut self) -> &mut ::std::string::String {
        if self.file_url.is_none() {
            self.file_url.set_default();
        }
        self.file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_url(&mut self) -> ::std::string::String {
        self.file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_url = 11;

    pub fn get_preview_url(&self) -> &str {
        match self.preview_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_url(&mut self) {
        self.preview_url.clear();
    }

    pub fn has_preview_url(&self) -> bool {
        self.preview_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_url(&mut self, v: ::std::string::String) {
        self.preview_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_url(&mut self) -> &mut ::std::string::String {
        if self.preview_url.is_none() {
            self.preview_url.set_default();
        }
        self.preview_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_url(&mut self) -> ::std::string::String {
        self.preview_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtubevideoid = 12;

    pub fn get_youtubevideoid(&self) -> &str {
        match self.youtubevideoid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtubevideoid(&mut self) {
        self.youtubevideoid.clear();
    }

    pub fn has_youtubevideoid(&self) -> bool {
        self.youtubevideoid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtubevideoid(&mut self, v: ::std::string::String) {
        self.youtubevideoid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtubevideoid(&mut self) -> &mut ::std::string::String {
        if self.youtubevideoid.is_none() {
            self.youtubevideoid.set_default();
        }
        self.youtubevideoid.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtubevideoid(&mut self) -> ::std::string::String {
        self.youtubevideoid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 13;

    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hcontent_file = 14;

    pub fn get_hcontent_file(&self) -> u64 {
        self.hcontent_file.unwrap_or(0)
    }

    pub fn clear_hcontent_file(&mut self) {
        self.hcontent_file = ::std::option::Option::None;
    }

    pub fn has_hcontent_file(&self) -> bool {
        self.hcontent_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent_file(&mut self, v: u64) {
        self.hcontent_file = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent_preview = 15;

    pub fn get_hcontent_preview(&self) -> u64 {
        self.hcontent_preview.unwrap_or(0)
    }

    pub fn clear_hcontent_preview(&mut self) {
        self.hcontent_preview = ::std::option::Option::None;
    }

    pub fn has_hcontent_preview(&self) -> bool {
        self.hcontent_preview.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent_preview(&mut self, v: u64) {
        self.hcontent_preview = ::std::option::Option::Some(v);
    }

    // optional string title = 16;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_description = 17;

    pub fn get_file_description(&self) -> &str {
        match self.file_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_description(&mut self) {
        self.file_description.clear();
    }

    pub fn has_file_description(&self) -> bool {
        self.file_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_description(&mut self, v: ::std::string::String) {
        self.file_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_description(&mut self) -> &mut ::std::string::String {
        if self.file_description.is_none() {
            self.file_description.set_default();
        }
        self.file_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_description(&mut self) -> ::std::string::String {
        self.file_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string short_description = 18;

    pub fn get_short_description(&self) -> &str {
        match self.short_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_short_description(&mut self) {
        self.short_description.clear();
    }

    pub fn has_short_description(&self) -> bool {
        self.short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: ::std::string::String) {
        self.short_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
        if self.short_description.is_none() {
            self.short_description.set_default();
        }
        self.short_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_short_description(&mut self) -> ::std::string::String {
        self.short_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_created = 19;

    pub fn get_time_created(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }

    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 20;

    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }

    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional uint32 visibility = 21;

    pub fn get_visibility(&self) -> u32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: u32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 22;

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bool workshop_file = 23;

    pub fn get_workshop_file(&self) -> bool {
        self.workshop_file.unwrap_or(false)
    }

    pub fn clear_workshop_file(&mut self) {
        self.workshop_file = ::std::option::Option::None;
    }

    pub fn has_workshop_file(&self) -> bool {
        self.workshop_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file(&mut self, v: bool) {
        self.workshop_file = ::std::option::Option::Some(v);
    }

    // optional bool workshop_accepted = 24;

    pub fn get_workshop_accepted(&self) -> bool {
        self.workshop_accepted.unwrap_or(false)
    }

    pub fn clear_workshop_accepted(&mut self) {
        self.workshop_accepted = ::std::option::Option::None;
    }

    pub fn has_workshop_accepted(&self) -> bool {
        self.workshop_accepted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_accepted(&mut self, v: bool) {
        self.workshop_accepted = ::std::option::Option::Some(v);
    }

    // optional bool show_subscribe_all = 25;

    pub fn get_show_subscribe_all(&self) -> bool {
        self.show_subscribe_all.unwrap_or(false)
    }

    pub fn clear_show_subscribe_all(&mut self) {
        self.show_subscribe_all = ::std::option::Option::None;
    }

    pub fn has_show_subscribe_all(&self) -> bool {
        self.show_subscribe_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_subscribe_all(&mut self, v: bool) {
        self.show_subscribe_all = ::std::option::Option::Some(v);
    }

    // optional int32 num_comments_developer = 26;

    pub fn get_num_comments_developer(&self) -> i32 {
        self.num_comments_developer.unwrap_or(0)
    }

    pub fn clear_num_comments_developer(&mut self) {
        self.num_comments_developer = ::std::option::Option::None;
    }

    pub fn has_num_comments_developer(&self) -> bool {
        self.num_comments_developer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_comments_developer(&mut self, v: i32) {
        self.num_comments_developer = ::std::option::Option::Some(v);
    }

    // optional int32 num_comments_public = 27;

    pub fn get_num_comments_public(&self) -> i32 {
        self.num_comments_public.unwrap_or(0)
    }

    pub fn clear_num_comments_public(&mut self) {
        self.num_comments_public = ::std::option::Option::None;
    }

    pub fn has_num_comments_public(&self) -> bool {
        self.num_comments_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_comments_public(&mut self, v: i32) {
        self.num_comments_public = ::std::option::Option::Some(v);
    }

    // optional bool banned = 28;

    pub fn get_banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    // optional string ban_reason = 29;

    pub fn get_ban_reason(&self) -> &str {
        match self.ban_reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ban_reason(&mut self) {
        self.ban_reason.clear();
    }

    pub fn has_ban_reason(&self) -> bool {
        self.ban_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_reason(&mut self, v: ::std::string::String) {
        self.ban_reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ban_reason(&mut self) -> &mut ::std::string::String {
        if self.ban_reason.is_none() {
            self.ban_reason.set_default();
        }
        self.ban_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_ban_reason(&mut self) -> ::std::string::String {
        self.ban_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 banner = 30;

    pub fn get_banner(&self) -> u64 {
        self.banner.unwrap_or(0)
    }

    pub fn clear_banner(&mut self) {
        self.banner = ::std::option::Option::None;
    }

    pub fn has_banner(&self) -> bool {
        self.banner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banner(&mut self, v: u64) {
        self.banner = ::std::option::Option::Some(v);
    }

    // optional bool can_be_deleted = 31;

    pub fn get_can_be_deleted(&self) -> bool {
        self.can_be_deleted.unwrap_or(false)
    }

    pub fn clear_can_be_deleted(&mut self) {
        self.can_be_deleted = ::std::option::Option::None;
    }

    pub fn has_can_be_deleted(&self) -> bool {
        self.can_be_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_be_deleted(&mut self, v: bool) {
        self.can_be_deleted = ::std::option::Option::Some(v);
    }

    // optional bool incompatible = 32;

    pub fn get_incompatible(&self) -> bool {
        self.incompatible.unwrap_or(false)
    }

    pub fn clear_incompatible(&mut self) {
        self.incompatible = ::std::option::Option::None;
    }

    pub fn has_incompatible(&self) -> bool {
        self.incompatible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incompatible(&mut self, v: bool) {
        self.incompatible = ::std::option::Option::Some(v);
    }

    // optional string app_name = 33;

    pub fn get_app_name(&self) -> &str {
        match self.app_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_app_name(&mut self) {
        self.app_name.clear();
    }

    pub fn has_app_name(&self) -> bool {
        self.app_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_name(&mut self, v: ::std::string::String) {
        self.app_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_name(&mut self) -> &mut ::std::string::String {
        if self.app_name.is_none() {
            self.app_name.set_default();
        }
        self.app_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_name(&mut self) -> ::std::string::String {
        self.app_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_type = 34;

    pub fn get_file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }

    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional bool can_subscribe = 35;

    pub fn get_can_subscribe(&self) -> bool {
        self.can_subscribe.unwrap_or(false)
    }

    pub fn clear_can_subscribe(&mut self) {
        self.can_subscribe = ::std::option::Option::None;
    }

    pub fn has_can_subscribe(&self) -> bool {
        self.can_subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_subscribe(&mut self, v: bool) {
        self.can_subscribe = ::std::option::Option::Some(v);
    }

    // optional uint32 subscriptions = 36;

    pub fn get_subscriptions(&self) -> u32 {
        self.subscriptions.unwrap_or(0)
    }

    pub fn clear_subscriptions(&mut self) {
        self.subscriptions = ::std::option::Option::None;
    }

    pub fn has_subscriptions(&self) -> bool {
        self.subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriptions(&mut self, v: u32) {
        self.subscriptions = ::std::option::Option::Some(v);
    }

    // optional uint32 favorited = 37;

    pub fn get_favorited(&self) -> u32 {
        self.favorited.unwrap_or(0)
    }

    pub fn clear_favorited(&mut self) {
        self.favorited = ::std::option::Option::None;
    }

    pub fn has_favorited(&self) -> bool {
        self.favorited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorited(&mut self, v: u32) {
        self.favorited = ::std::option::Option::Some(v);
    }

    // optional uint32 followers = 38;

    pub fn get_followers(&self) -> u32 {
        self.followers.unwrap_or(0)
    }

    pub fn clear_followers(&mut self) {
        self.followers = ::std::option::Option::None;
    }

    pub fn has_followers(&self) -> bool {
        self.followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_followers(&mut self, v: u32) {
        self.followers = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_subscriptions = 39;

    pub fn get_lifetime_subscriptions(&self) -> u32 {
        self.lifetime_subscriptions.unwrap_or(0)
    }

    pub fn clear_lifetime_subscriptions(&mut self) {
        self.lifetime_subscriptions = ::std::option::Option::None;
    }

    pub fn has_lifetime_subscriptions(&self) -> bool {
        self.lifetime_subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_subscriptions(&mut self, v: u32) {
        self.lifetime_subscriptions = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_favorited = 40;

    pub fn get_lifetime_favorited(&self) -> u32 {
        self.lifetime_favorited.unwrap_or(0)
    }

    pub fn clear_lifetime_favorited(&mut self) {
        self.lifetime_favorited = ::std::option::Option::None;
    }

    pub fn has_lifetime_favorited(&self) -> bool {
        self.lifetime_favorited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_favorited(&mut self, v: u32) {
        self.lifetime_favorited = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_followers = 41;

    pub fn get_lifetime_followers(&self) -> u32 {
        self.lifetime_followers.unwrap_or(0)
    }

    pub fn clear_lifetime_followers(&mut self) {
        self.lifetime_followers = ::std::option::Option::None;
    }

    pub fn has_lifetime_followers(&self) -> bool {
        self.lifetime_followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_followers(&mut self, v: u32) {
        self.lifetime_followers = ::std::option::Option::Some(v);
    }

    // optional uint64 lifetime_playtime = 62;

    pub fn get_lifetime_playtime(&self) -> u64 {
        self.lifetime_playtime.unwrap_or(0)
    }

    pub fn clear_lifetime_playtime(&mut self) {
        self.lifetime_playtime = ::std::option::Option::None;
    }

    pub fn has_lifetime_playtime(&self) -> bool {
        self.lifetime_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_playtime(&mut self, v: u64) {
        self.lifetime_playtime = ::std::option::Option::Some(v);
    }

    // optional uint64 lifetime_playtime_sessions = 63;

    pub fn get_lifetime_playtime_sessions(&self) -> u64 {
        self.lifetime_playtime_sessions.unwrap_or(0)
    }

    pub fn clear_lifetime_playtime_sessions(&mut self) {
        self.lifetime_playtime_sessions = ::std::option::Option::None;
    }

    pub fn has_lifetime_playtime_sessions(&self) -> bool {
        self.lifetime_playtime_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_playtime_sessions(&mut self, v: u64) {
        self.lifetime_playtime_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 views = 42;

    pub fn get_views(&self) -> u32 {
        self.views.unwrap_or(0)
    }

    pub fn clear_views(&mut self) {
        self.views = ::std::option::Option::None;
    }

    pub fn has_views(&self) -> bool {
        self.views.is_some()
    }

    // Param is passed by value, moved
    pub fn set_views(&mut self, v: u32) {
        self.views = ::std::option::Option::Some(v);
    }

    // optional uint32 image_width = 43;

    pub fn get_image_width(&self) -> u32 {
        self.image_width.unwrap_or(0)
    }

    pub fn clear_image_width(&mut self) {
        self.image_width = ::std::option::Option::None;
    }

    pub fn has_image_width(&self) -> bool {
        self.image_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_width(&mut self, v: u32) {
        self.image_width = ::std::option::Option::Some(v);
    }

    // optional uint32 image_height = 44;

    pub fn get_image_height(&self) -> u32 {
        self.image_height.unwrap_or(0)
    }

    pub fn clear_image_height(&mut self) {
        self.image_height = ::std::option::Option::None;
    }

    pub fn has_image_height(&self) -> bool {
        self.image_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_height(&mut self, v: u32) {
        self.image_height = ::std::option::Option::Some(v);
    }

    // optional string image_url = 45;

    pub fn get_image_url(&self) -> &str {
        match self.image_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image_url(&mut self) {
        self.image_url.clear();
    }

    pub fn has_image_url(&self) -> bool {
        self.image_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_url(&mut self, v: ::std::string::String) {
        self.image_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
        if self.image_url.is_none() {
            self.image_url.set_default();
        }
        self.image_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_url(&mut self) -> ::std::string::String {
        self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool spoiler_tag = 46;

    pub fn get_spoiler_tag(&self) -> bool {
        self.spoiler_tag.unwrap_or(false)
    }

    pub fn clear_spoiler_tag(&mut self) {
        self.spoiler_tag = ::std::option::Option::None;
    }

    pub fn has_spoiler_tag(&self) -> bool {
        self.spoiler_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spoiler_tag(&mut self, v: bool) {
        self.spoiler_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 shortcutid = 47;

    pub fn get_shortcutid(&self) -> u32 {
        self.shortcutid.unwrap_or(0)
    }

    pub fn clear_shortcutid(&mut self) {
        self.shortcutid = ::std::option::Option::None;
    }

    pub fn has_shortcutid(&self) -> bool {
        self.shortcutid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcutid(&mut self, v: u32) {
        self.shortcutid = ::std::option::Option::Some(v);
    }

    // optional string shortcutname = 48;

    pub fn get_shortcutname(&self) -> &str {
        match self.shortcutname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shortcutname(&mut self) {
        self.shortcutname.clear();
    }

    pub fn has_shortcutname(&self) -> bool {
        self.shortcutname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcutname(&mut self, v: ::std::string::String) {
        self.shortcutname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcutname(&mut self) -> &mut ::std::string::String {
        if self.shortcutname.is_none() {
            self.shortcutname.set_default();
        }
        self.shortcutname.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcutname(&mut self) -> ::std::string::String {
        self.shortcutname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_children = 49;

    pub fn get_num_children(&self) -> u32 {
        self.num_children.unwrap_or(0)
    }

    pub fn clear_num_children(&mut self) {
        self.num_children = ::std::option::Option::None;
    }

    pub fn has_num_children(&self) -> bool {
        self.num_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_children(&mut self, v: u32) {
        self.num_children = ::std::option::Option::Some(v);
    }

    // optional uint32 num_reports = 50;

    pub fn get_num_reports(&self) -> u32 {
        self.num_reports.unwrap_or(0)
    }

    pub fn clear_num_reports(&mut self) {
        self.num_reports = ::std::option::Option::None;
    }

    pub fn has_num_reports(&self) -> bool {
        self.num_reports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reports(&mut self, v: u32) {
        self.num_reports = ::std::option::Option::Some(v);
    }

    // optional uint32 time_subscribed = 56;

    pub fn get_time_subscribed(&self) -> u32 {
        self.time_subscribed.unwrap_or(0)
    }

    pub fn clear_time_subscribed(&mut self) {
        self.time_subscribed = ::std::option::Option::None;
    }

    pub fn has_time_subscribed(&self) -> bool {
        self.time_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_subscribed(&mut self, v: u32) {
        self.time_subscribed = ::std::option::Option::Some(v);
    }

    // optional string metadata = 58;

    pub fn get_metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 61;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool maybe_inappropriate_sex = 65;

    pub fn get_maybe_inappropriate_sex(&self) -> bool {
        self.maybe_inappropriate_sex.unwrap_or(false)
    }

    pub fn clear_maybe_inappropriate_sex(&mut self) {
        self.maybe_inappropriate_sex = ::std::option::Option::None;
    }

    pub fn has_maybe_inappropriate_sex(&self) -> bool {
        self.maybe_inappropriate_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maybe_inappropriate_sex(&mut self, v: bool) {
        self.maybe_inappropriate_sex = ::std::option::Option::Some(v);
    }

    // optional bool maybe_inappropriate_violence = 66;

    pub fn get_maybe_inappropriate_violence(&self) -> bool {
        self.maybe_inappropriate_violence.unwrap_or(false)
    }

    pub fn clear_maybe_inappropriate_violence(&mut self) {
        self.maybe_inappropriate_violence = ::std::option::Option::None;
    }

    pub fn has_maybe_inappropriate_violence(&self) -> bool {
        self.maybe_inappropriate_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maybe_inappropriate_violence(&mut self, v: bool) {
        self.maybe_inappropriate_violence = ::std::option::Option::Some(v);
    }

    // optional uint64 revision_change_number = 67;

    pub fn get_revision_change_number(&self) -> u64 {
        self.revision_change_number.unwrap_or(0)
    }

    pub fn clear_revision_change_number(&mut self) {
        self.revision_change_number = ::std::option::Option::None;
    }

    pub fn has_revision_change_number(&self) -> bool {
        self.revision_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision_change_number(&mut self, v: u64) {
        self.revision_change_number = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision revision = 68;

    pub fn get_revision(&self) -> EPublishedFileRevision {
        match self.revision {
            Some(e) => e.enum_value_or(EPublishedFileRevision::k_EPublishedFileRevision_Default),
            None => EPublishedFileRevision::k_EPublishedFileRevision_Default,
        }
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: EPublishedFileRevision) {
        self.revision = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for PublishedFileDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.previews {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kvtags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vote_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.playtime_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.for_sale_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.creator = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.creator_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consumer_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consumer_shortcutid = ::std::option::Option::Some(is.read_uint32()?);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.preview_file_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_url)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_url)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtubevideoid)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hcontent_file = ::std::option::Option::Some(is.read_fixed64()?);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hcontent_preview = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_description)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.short_description)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_created = ::std::option::Option::Some(is.read_uint32()?);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.visibility = ::std::option::Option::Some(is.read_uint32()?);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.workshop_file = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.workshop_accepted = ::std::option::Option::Some(is.read_bool()?);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.show_subscribe_all = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_comments_developer = ::std::option::Option::Some(is.read_int32()?);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_comments_public = ::std::option::Option::Some(is.read_int32()?);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ban_reason)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.banner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.can_be_deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.incompatible = ::std::option::Option::Some(is.read_bool()?);
                },
                33 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.app_name)?;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.can_subscribe = ::std::option::Option::Some(is.read_bool()?);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.subscriptions = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.favorited = ::std::option::Option::Some(is.read_uint32()?);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.followers = ::std::option::Option::Some(is.read_uint32()?);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lifetime_subscriptions = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lifetime_favorited = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lifetime_followers = ::std::option::Option::Some(is.read_uint32()?);
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lifetime_playtime = ::std::option::Option::Some(is.read_uint64()?);
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lifetime_playtime_sessions = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.views = ::std::option::Option::Some(is.read_uint32()?);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.image_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.image_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image_url)?;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.spoiler_tag = ::std::option::Option::Some(is.read_bool()?);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.shortcutid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shortcutname)?;
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_children = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.num_reports = ::std::option::Option::Some(is.read_uint32()?);
                },
                51 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.previews)?;
                },
                52 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.tags)?;
                },
                53 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.children)?;
                },
                54 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.kvtags)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_message_into::<published_file_details::VoteData, _>(wire_type, is, &mut self.vote_data)?;
                },
                64 => {
                    ::protobuf::rt::read_singular_message_into::<published_file_details::PlaytimeStats, _>(wire_type, is, &mut self.playtime_stats)?;
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_subscribed = ::std::option::Option::Some(is.read_uint32()?);
                },
                57 => {
                    ::protobuf::rt::read_singular_message_into::<published_file_details::ForSaleData, _>(wire_type, is, &mut self.for_sale_data)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.metadata)?;
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maybe_inappropriate_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maybe_inappropriate_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.revision_change_number = ::std::option::Option::Some(is.read_uint64()?);
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.revision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                69 => {
                    ::protobuf::rt::read_repeated_enum_or_unknown_into(wire_type, is, &mut self.available_revisions)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator {
            my_size += 9;
        }
        if let Some(v) = self.creator_appid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_shortcutid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.preview_file_size {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.preview_url.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.youtubevideoid.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.hcontent_file {
            my_size += 9;
        }
        if let Some(v) = self.hcontent_preview {
            my_size += 9;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.file_description.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.short_description.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.time_created {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.workshop_file {
            my_size += 3;
        }
        if let Some(v) = self.workshop_accepted {
            my_size += 3;
        }
        if let Some(v) = self.show_subscribe_all {
            my_size += 3;
        }
        if let Some(v) = self.num_comments_developer {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_comments_public {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.banned {
            my_size += 3;
        }
        if let Some(v) = self.ban_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.banner {
            my_size += 10;
        }
        if let Some(v) = self.can_be_deleted {
            my_size += 3;
        }
        if let Some(v) = self.incompatible {
            my_size += 3;
        }
        if let Some(v) = self.app_name.as_ref() {
            my_size += ::protobuf::rt::string_size(33, &v);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.can_subscribe {
            my_size += 3;
        }
        if let Some(v) = self.subscriptions {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.favorited {
            my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.followers {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_subscriptions {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_favorited {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_followers {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_playtime {
            my_size += ::protobuf::rt::value_size(62, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_playtime_sessions {
            my_size += ::protobuf::rt::value_size(63, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.views {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_width {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_height {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_url.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        if let Some(v) = self.spoiler_tag {
            my_size += 3;
        }
        if let Some(v) = self.shortcutid {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shortcutname.as_ref() {
            my_size += ::protobuf::rt::string_size(48, &v);
        }
        if let Some(v) = self.num_children {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_reports {
            my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.previews {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.children {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.kvtags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.vote_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.playtime_stats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.time_subscribed {
            my_size += ::protobuf::rt::value_size(56, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.for_sale_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(58, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maybe_inappropriate_sex {
            my_size += 3;
        }
        if let Some(v) = self.maybe_inappropriate_violence {
            my_size += 3;
        }
        if let Some(v) = self.revision_change_number {
            my_size += ::protobuf::rt::value_size(67, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::enum_or_unknown_size(68, v);
        }
        for value in &self.available_revisions {
            my_size += ::protobuf::rt::enum_or_unknown_size(69, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.publishedfileid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.creator {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.creator_appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.consumer_appid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.consumer_shortcutid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.preview_file_size {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.file_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.preview_url.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.youtubevideoid.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.hcontent_file {
            os.write_fixed64(14, v)?;
        }
        if let Some(v) = self.hcontent_preview {
            os.write_fixed64(15, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.file_description.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.short_description.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.time_created {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.workshop_file {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.workshop_accepted {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.show_subscribe_all {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.num_comments_developer {
            os.write_int32(26, v)?;
        }
        if let Some(v) = self.num_comments_public {
            os.write_int32(27, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.ban_reason.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.banner {
            os.write_fixed64(30, v)?;
        }
        if let Some(v) = self.can_be_deleted {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.incompatible {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.app_name.as_ref() {
            os.write_string(33, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.can_subscribe {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.subscriptions {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.favorited {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.followers {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.lifetime_subscriptions {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.lifetime_favorited {
            os.write_uint32(40, v)?;
        }
        if let Some(v) = self.lifetime_followers {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.lifetime_playtime {
            os.write_uint64(62, v)?;
        }
        if let Some(v) = self.lifetime_playtime_sessions {
            os.write_uint64(63, v)?;
        }
        if let Some(v) = self.views {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.image_width {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.image_height {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.image_url.as_ref() {
            os.write_string(45, v)?;
        }
        if let Some(v) = self.spoiler_tag {
            os.write_bool(46, v)?;
        }
        if let Some(v) = self.shortcutid {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.shortcutname.as_ref() {
            os.write_string(48, v)?;
        }
        if let Some(v) = self.num_children {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.num_reports {
            os.write_uint32(50, v)?;
        }
        for v in &self.previews {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        };
        for v in &self.tags {
            ::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
        };
        for v in &self.children {
            ::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
        };
        for v in &self.kvtags {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        };
        if let Some(v) = self.vote_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(55, v, os)?;
        }
        if let Some(v) = self.playtime_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
        }
        if let Some(v) = self.time_subscribed {
            os.write_uint32(56, v)?;
        }
        if let Some(v) = self.for_sale_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(57, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_string(58, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(61, v)?;
        }
        if let Some(v) = self.maybe_inappropriate_sex {
            os.write_bool(65, v)?;
        }
        if let Some(v) = self.maybe_inappropriate_violence {
            os.write_bool(66, v)?;
        }
        if let Some(v) = self.revision_change_number {
            os.write_uint64(67, v)?;
        }
        if let Some(v) = self.revision {
            os.write_enum(68, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        for v in &self.available_revisions {
            os.write_enum(69, ::protobuf::ProtobufEnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails {
        PublishedFileDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "result",
                |m: &PublishedFileDetails| { &m.result },
                |m: &mut PublishedFileDetails| { &mut m.result },
                PublishedFileDetails::get_result,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &PublishedFileDetails| { &m.publishedfileid },
                |m: &mut PublishedFileDetails| { &mut m.publishedfileid },
                PublishedFileDetails::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "creator",
                |m: &PublishedFileDetails| { &m.creator },
                |m: &mut PublishedFileDetails| { &mut m.creator },
                PublishedFileDetails::get_creator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "creator_appid",
                |m: &PublishedFileDetails| { &m.creator_appid },
                |m: &mut PublishedFileDetails| { &mut m.creator_appid },
                PublishedFileDetails::get_creator_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "consumer_appid",
                |m: &PublishedFileDetails| { &m.consumer_appid },
                |m: &mut PublishedFileDetails| { &mut m.consumer_appid },
                PublishedFileDetails::get_consumer_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "consumer_shortcutid",
                |m: &PublishedFileDetails| { &m.consumer_shortcutid },
                |m: &mut PublishedFileDetails| { &mut m.consumer_shortcutid },
                PublishedFileDetails::get_consumer_shortcutid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &PublishedFileDetails| { &m.filename },
                |m: &mut PublishedFileDetails| { &mut m.filename },
                PublishedFileDetails::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "file_size",
                |m: &PublishedFileDetails| { &m.file_size },
                |m: &mut PublishedFileDetails| { &mut m.file_size },
                PublishedFileDetails::get_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "preview_file_size",
                |m: &PublishedFileDetails| { &m.preview_file_size },
                |m: &mut PublishedFileDetails| { &mut m.preview_file_size },
                PublishedFileDetails::get_preview_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_url",
                |m: &PublishedFileDetails| { &m.file_url },
                |m: &mut PublishedFileDetails| { &mut m.file_url },
                PublishedFileDetails::get_file_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "preview_url",
                |m: &PublishedFileDetails| { &m.preview_url },
                |m: &mut PublishedFileDetails| { &mut m.preview_url },
                PublishedFileDetails::get_preview_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "youtubevideoid",
                |m: &PublishedFileDetails| { &m.youtubevideoid },
                |m: &mut PublishedFileDetails| { &mut m.youtubevideoid },
                PublishedFileDetails::get_youtubevideoid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "url",
                |m: &PublishedFileDetails| { &m.url },
                |m: &mut PublishedFileDetails| { &mut m.url },
                PublishedFileDetails::get_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "hcontent_file",
                |m: &PublishedFileDetails| { &m.hcontent_file },
                |m: &mut PublishedFileDetails| { &mut m.hcontent_file },
                PublishedFileDetails::get_hcontent_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "hcontent_preview",
                |m: &PublishedFileDetails| { &m.hcontent_preview },
                |m: &mut PublishedFileDetails| { &mut m.hcontent_preview },
                PublishedFileDetails::get_hcontent_preview,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "title",
                |m: &PublishedFileDetails| { &m.title },
                |m: &mut PublishedFileDetails| { &mut m.title },
                PublishedFileDetails::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_description",
                |m: &PublishedFileDetails| { &m.file_description },
                |m: &mut PublishedFileDetails| { &mut m.file_description },
                PublishedFileDetails::get_file_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "short_description",
                |m: &PublishedFileDetails| { &m.short_description },
                |m: &mut PublishedFileDetails| { &mut m.short_description },
                PublishedFileDetails::get_short_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_created",
                |m: &PublishedFileDetails| { &m.time_created },
                |m: &mut PublishedFileDetails| { &mut m.time_created },
                PublishedFileDetails::get_time_created,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_updated",
                |m: &PublishedFileDetails| { &m.time_updated },
                |m: &mut PublishedFileDetails| { &mut m.time_updated },
                PublishedFileDetails::get_time_updated,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "visibility",
                |m: &PublishedFileDetails| { &m.visibility },
                |m: &mut PublishedFileDetails| { &mut m.visibility },
                PublishedFileDetails::get_visibility,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "flags",
                |m: &PublishedFileDetails| { &m.flags },
                |m: &mut PublishedFileDetails| { &mut m.flags },
                PublishedFileDetails::get_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "workshop_file",
                |m: &PublishedFileDetails| { &m.workshop_file },
                |m: &mut PublishedFileDetails| { &mut m.workshop_file },
                PublishedFileDetails::get_workshop_file,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "workshop_accepted",
                |m: &PublishedFileDetails| { &m.workshop_accepted },
                |m: &mut PublishedFileDetails| { &mut m.workshop_accepted },
                PublishedFileDetails::get_workshop_accepted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "show_subscribe_all",
                |m: &PublishedFileDetails| { &m.show_subscribe_all },
                |m: &mut PublishedFileDetails| { &mut m.show_subscribe_all },
                PublishedFileDetails::get_show_subscribe_all,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "num_comments_developer",
                |m: &PublishedFileDetails| { &m.num_comments_developer },
                |m: &mut PublishedFileDetails| { &mut m.num_comments_developer },
                PublishedFileDetails::get_num_comments_developer,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "num_comments_public",
                |m: &PublishedFileDetails| { &m.num_comments_public },
                |m: &mut PublishedFileDetails| { &mut m.num_comments_public },
                PublishedFileDetails::get_num_comments_public,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "banned",
                |m: &PublishedFileDetails| { &m.banned },
                |m: &mut PublishedFileDetails| { &mut m.banned },
                PublishedFileDetails::get_banned,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "ban_reason",
                |m: &PublishedFileDetails| { &m.ban_reason },
                |m: &mut PublishedFileDetails| { &mut m.ban_reason },
                PublishedFileDetails::get_ban_reason,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "banner",
                |m: &PublishedFileDetails| { &m.banner },
                |m: &mut PublishedFileDetails| { &mut m.banner },
                PublishedFileDetails::get_banner,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "can_be_deleted",
                |m: &PublishedFileDetails| { &m.can_be_deleted },
                |m: &mut PublishedFileDetails| { &mut m.can_be_deleted },
                PublishedFileDetails::get_can_be_deleted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "incompatible",
                |m: &PublishedFileDetails| { &m.incompatible },
                |m: &mut PublishedFileDetails| { &mut m.incompatible },
                PublishedFileDetails::get_incompatible,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "app_name",
                |m: &PublishedFileDetails| { &m.app_name },
                |m: &mut PublishedFileDetails| { &mut m.app_name },
                PublishedFileDetails::get_app_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_type",
                |m: &PublishedFileDetails| { &m.file_type },
                |m: &mut PublishedFileDetails| { &mut m.file_type },
                PublishedFileDetails::get_file_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "can_subscribe",
                |m: &PublishedFileDetails| { &m.can_subscribe },
                |m: &mut PublishedFileDetails| { &mut m.can_subscribe },
                PublishedFileDetails::get_can_subscribe,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "subscriptions",
                |m: &PublishedFileDetails| { &m.subscriptions },
                |m: &mut PublishedFileDetails| { &mut m.subscriptions },
                PublishedFileDetails::get_subscriptions,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "favorited",
                |m: &PublishedFileDetails| { &m.favorited },
                |m: &mut PublishedFileDetails| { &mut m.favorited },
                PublishedFileDetails::get_favorited,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "followers",
                |m: &PublishedFileDetails| { &m.followers },
                |m: &mut PublishedFileDetails| { &mut m.followers },
                PublishedFileDetails::get_followers,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "lifetime_subscriptions",
                |m: &PublishedFileDetails| { &m.lifetime_subscriptions },
                |m: &mut PublishedFileDetails| { &mut m.lifetime_subscriptions },
                PublishedFileDetails::get_lifetime_subscriptions,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "lifetime_favorited",
                |m: &PublishedFileDetails| { &m.lifetime_favorited },
                |m: &mut PublishedFileDetails| { &mut m.lifetime_favorited },
                PublishedFileDetails::get_lifetime_favorited,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "lifetime_followers",
                |m: &PublishedFileDetails| { &m.lifetime_followers },
                |m: &mut PublishedFileDetails| { &mut m.lifetime_followers },
                PublishedFileDetails::get_lifetime_followers,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "lifetime_playtime",
                |m: &PublishedFileDetails| { &m.lifetime_playtime },
                |m: &mut PublishedFileDetails| { &mut m.lifetime_playtime },
                PublishedFileDetails::get_lifetime_playtime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "lifetime_playtime_sessions",
                |m: &PublishedFileDetails| { &m.lifetime_playtime_sessions },
                |m: &mut PublishedFileDetails| { &mut m.lifetime_playtime_sessions },
                PublishedFileDetails::get_lifetime_playtime_sessions,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "views",
                |m: &PublishedFileDetails| { &m.views },
                |m: &mut PublishedFileDetails| { &mut m.views },
                PublishedFileDetails::get_views,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "image_width",
                |m: &PublishedFileDetails| { &m.image_width },
                |m: &mut PublishedFileDetails| { &mut m.image_width },
                PublishedFileDetails::get_image_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "image_height",
                |m: &PublishedFileDetails| { &m.image_height },
                |m: &mut PublishedFileDetails| { &mut m.image_height },
                PublishedFileDetails::get_image_height,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "image_url",
                |m: &PublishedFileDetails| { &m.image_url },
                |m: &mut PublishedFileDetails| { &mut m.image_url },
                PublishedFileDetails::get_image_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "spoiler_tag",
                |m: &PublishedFileDetails| { &m.spoiler_tag },
                |m: &mut PublishedFileDetails| { &mut m.spoiler_tag },
                PublishedFileDetails::get_spoiler_tag,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "shortcutid",
                |m: &PublishedFileDetails| { &m.shortcutid },
                |m: &mut PublishedFileDetails| { &mut m.shortcutid },
                PublishedFileDetails::get_shortcutid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "shortcutname",
                |m: &PublishedFileDetails| { &m.shortcutname },
                |m: &mut PublishedFileDetails| { &mut m.shortcutname },
                PublishedFileDetails::get_shortcutname,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_children",
                |m: &PublishedFileDetails| { &m.num_children },
                |m: &mut PublishedFileDetails| { &mut m.num_children },
                PublishedFileDetails::get_num_children,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "num_reports",
                |m: &PublishedFileDetails| { &m.num_reports },
                |m: &mut PublishedFileDetails| { &mut m.num_reports },
                PublishedFileDetails::get_num_reports,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<published_file_details::Preview>>(
                "previews",
                |m: &PublishedFileDetails| { &m.previews },
                |m: &mut PublishedFileDetails| { &mut m.previews },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<published_file_details::Tag>>(
                "tags",
                |m: &PublishedFileDetails| { &m.tags },
                |m: &mut PublishedFileDetails| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<published_file_details::Child>>(
                "children",
                |m: &PublishedFileDetails| { &m.children },
                |m: &mut PublishedFileDetails| { &mut m.children },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<published_file_details::KVTag>>(
                "kvtags",
                |m: &PublishedFileDetails| { &m.kvtags },
                |m: &mut PublishedFileDetails| { &mut m.kvtags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<published_file_details::VoteData>, _>(
                "vote_data",
                |m: &PublishedFileDetails| { &m.vote_data },
                |m: &mut PublishedFileDetails| { &mut m.vote_data },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<published_file_details::PlaytimeStats>, _>(
                "playtime_stats",
                |m: &PublishedFileDetails| { &m.playtime_stats },
                |m: &mut PublishedFileDetails| { &mut m.playtime_stats },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_subscribed",
                |m: &PublishedFileDetails| { &m.time_subscribed },
                |m: &mut PublishedFileDetails| { &mut m.time_subscribed },
                PublishedFileDetails::get_time_subscribed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<published_file_details::ForSaleData>, _>(
                "for_sale_data",
                |m: &PublishedFileDetails| { &m.for_sale_data },
                |m: &mut PublishedFileDetails| { &mut m.for_sale_data },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "metadata",
                |m: &PublishedFileDetails| { &m.metadata },
                |m: &mut PublishedFileDetails| { &mut m.metadata },
                PublishedFileDetails::get_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &PublishedFileDetails| { &m.language },
                |m: &mut PublishedFileDetails| { &mut m.language },
                PublishedFileDetails::get_language,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "maybe_inappropriate_sex",
                |m: &PublishedFileDetails| { &m.maybe_inappropriate_sex },
                |m: &mut PublishedFileDetails| { &mut m.maybe_inappropriate_sex },
                PublishedFileDetails::get_maybe_inappropriate_sex,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "maybe_inappropriate_violence",
                |m: &PublishedFileDetails| { &m.maybe_inappropriate_violence },
                |m: &mut PublishedFileDetails| { &mut m.maybe_inappropriate_violence },
                PublishedFileDetails::get_maybe_inappropriate_violence,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "revision_change_number",
                |m: &PublishedFileDetails| { &m.revision_change_number },
                |m: &mut PublishedFileDetails| { &mut m.revision_change_number },
                PublishedFileDetails::get_revision_change_number,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EPublishedFileRevision>(
                "revision",
                |m: &PublishedFileDetails| { &m.revision },
                |m: &mut PublishedFileDetails| { &mut m.revision },
                EPublishedFileRevision::k_EPublishedFileRevision_Default,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeEnumOrUnknown<EPublishedFileRevision>>(
                "available_revisions",
                |m: &PublishedFileDetails| { &m.available_revisions },
                |m: &mut PublishedFileDetails| { &mut m.available_revisions },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails>(
                "PublishedFileDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PublishedFileDetails {
        static instance: ::protobuf::rt::Lazy<PublishedFileDetails> = ::protobuf::rt::Lazy::INIT;
        instance.get(PublishedFileDetails::new)
    }
}

impl ::protobuf::Clear for PublishedFileDetails {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.publishedfileid = ::std::option::Option::None;
        self.creator = ::std::option::Option::None;
        self.creator_appid = ::std::option::Option::None;
        self.consumer_appid = ::std::option::Option::None;
        self.consumer_shortcutid = ::std::option::Option::None;
        self.filename.clear();
        self.file_size = ::std::option::Option::None;
        self.preview_file_size = ::std::option::Option::None;
        self.file_url.clear();
        self.preview_url.clear();
        self.youtubevideoid.clear();
        self.url.clear();
        self.hcontent_file = ::std::option::Option::None;
        self.hcontent_preview = ::std::option::Option::None;
        self.title.clear();
        self.file_description.clear();
        self.short_description.clear();
        self.time_created = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.workshop_file = ::std::option::Option::None;
        self.workshop_accepted = ::std::option::Option::None;
        self.show_subscribe_all = ::std::option::Option::None;
        self.num_comments_developer = ::std::option::Option::None;
        self.num_comments_public = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.ban_reason.clear();
        self.banner = ::std::option::Option::None;
        self.can_be_deleted = ::std::option::Option::None;
        self.incompatible = ::std::option::Option::None;
        self.app_name.clear();
        self.file_type = ::std::option::Option::None;
        self.can_subscribe = ::std::option::Option::None;
        self.subscriptions = ::std::option::Option::None;
        self.favorited = ::std::option::Option::None;
        self.followers = ::std::option::Option::None;
        self.lifetime_subscriptions = ::std::option::Option::None;
        self.lifetime_favorited = ::std::option::Option::None;
        self.lifetime_followers = ::std::option::Option::None;
        self.lifetime_playtime = ::std::option::Option::None;
        self.lifetime_playtime_sessions = ::std::option::Option::None;
        self.views = ::std::option::Option::None;
        self.image_width = ::std::option::Option::None;
        self.image_height = ::std::option::Option::None;
        self.image_url.clear();
        self.spoiler_tag = ::std::option::Option::None;
        self.shortcutid = ::std::option::Option::None;
        self.shortcutname.clear();
        self.num_children = ::std::option::Option::None;
        self.num_reports = ::std::option::Option::None;
        self.previews.clear();
        self.tags.clear();
        self.children.clear();
        self.kvtags.clear();
        self.vote_data.clear();
        self.playtime_stats.clear();
        self.time_subscribed = ::std::option::Option::None;
        self.for_sale_data.clear();
        self.metadata.clear();
        self.language = ::std::option::Option::None;
        self.maybe_inappropriate_sex = ::std::option::Option::None;
        self.maybe_inappropriate_violence = ::std::option::Option::None;
        self.revision_change_number = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.available_revisions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails {
}

/// Nested message and enums of message `PublishedFileDetails`
pub mod published_file_details {
    #[derive(PartialEq,Clone,Default)]
    pub struct Tag {
        // message fields
        tag: ::protobuf::SingularField<::std::string::String>,
        adminonly: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as ::protobuf::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional string tag = 1;

        pub fn get_tag(&self) -> &str {
            match self.tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_tag(&mut self) {
            self.tag.clear();
        }

        pub fn has_tag(&self) -> bool {
            self.tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag(&mut self, v: ::std::string::String) {
            self.tag = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_tag(&mut self) -> &mut ::std::string::String {
            if self.tag.is_none() {
                self.tag.set_default();
            }
            self.tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_tag(&mut self) -> ::std::string::String {
            self.tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool adminonly = 2;

        pub fn get_adminonly(&self) -> bool {
            self.adminonly.unwrap_or(false)
        }

        pub fn clear_adminonly(&mut self) {
            self.adminonly = ::std::option::Option::None;
        }

        pub fn has_adminonly(&self) -> bool {
            self.adminonly.is_some()
        }

        // Param is passed by value, moved
        pub fn set_adminonly(&mut self, v: bool) {
            self.adminonly = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Tag {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.adminonly = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.tag.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.adminonly {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.tag.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.adminonly {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "tag",
                    |m: &Tag| { &m.tag },
                    |m: &mut Tag| { &mut m.tag },
                    Tag::get_tag,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "adminonly",
                    |m: &Tag| { &m.adminonly },
                    |m: &mut Tag| { &mut m.adminonly },
                    Tag::get_adminonly,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Tag>(
                    "PublishedFileDetails.Tag",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Tag {
            static instance: ::protobuf::rt::Lazy<Tag> = ::protobuf::rt::Lazy::INIT;
            instance.get(Tag::new)
        }
    }

    impl ::protobuf::Clear for Tag {
        fn clear(&mut self) {
            self.tag.clear();
            self.adminonly = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Tag {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct Preview {
        // message fields
        previewid: ::std::option::Option<u64>,
        sortorder: ::std::option::Option<u32>,
        url: ::protobuf::SingularField<::std::string::String>,
        size: ::std::option::Option<u32>,
        filename: ::protobuf::SingularField<::std::string::String>,
        youtubevideoid: ::protobuf::SingularField<::std::string::String>,
        preview_type: ::std::option::Option<u32>,
        external_reference: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Preview {
        fn default() -> &'a Preview {
            <Preview as ::protobuf::Message>::default_instance()
        }
    }

    impl Preview {
        pub fn new() -> Preview {
            ::std::default::Default::default()
        }

        // optional uint64 previewid = 1;

        pub fn get_previewid(&self) -> u64 {
            self.previewid.unwrap_or(0)
        }

        pub fn clear_previewid(&mut self) {
            self.previewid = ::std::option::Option::None;
        }

        pub fn has_previewid(&self) -> bool {
            self.previewid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_previewid(&mut self, v: u64) {
            self.previewid = ::std::option::Option::Some(v);
        }

        // optional uint32 sortorder = 2;

        pub fn get_sortorder(&self) -> u32 {
            self.sortorder.unwrap_or(0)
        }

        pub fn clear_sortorder(&mut self) {
            self.sortorder = ::std::option::Option::None;
        }

        pub fn has_sortorder(&self) -> bool {
            self.sortorder.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sortorder(&mut self, v: u32) {
            self.sortorder = ::std::option::Option::Some(v);
        }

        // optional string url = 3;

        pub fn get_url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url.clear();
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url.set_default();
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 size = 4;

        pub fn get_size(&self) -> u32 {
            self.size.unwrap_or(0)
        }

        pub fn clear_size(&mut self) {
            self.size = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            self.size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: u32) {
            self.size = ::std::option::Option::Some(v);
        }

        // optional string filename = 5;

        pub fn get_filename(&self) -> &str {
            match self.filename.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_filename(&mut self) {
            self.filename.clear();
        }

        pub fn has_filename(&self) -> bool {
            self.filename.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filename(&mut self, v: ::std::string::String) {
            self.filename = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_filename(&mut self) -> &mut ::std::string::String {
            if self.filename.is_none() {
                self.filename.set_default();
            }
            self.filename.as_mut().unwrap()
        }

        // Take field
        pub fn take_filename(&mut self) -> ::std::string::String {
            self.filename.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string youtubevideoid = 6;

        pub fn get_youtubevideoid(&self) -> &str {
            match self.youtubevideoid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_youtubevideoid(&mut self) {
            self.youtubevideoid.clear();
        }

        pub fn has_youtubevideoid(&self) -> bool {
            self.youtubevideoid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_youtubevideoid(&mut self, v: ::std::string::String) {
            self.youtubevideoid = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_youtubevideoid(&mut self) -> &mut ::std::string::String {
            if self.youtubevideoid.is_none() {
                self.youtubevideoid.set_default();
            }
            self.youtubevideoid.as_mut().unwrap()
        }

        // Take field
        pub fn take_youtubevideoid(&mut self) -> ::std::string::String {
            self.youtubevideoid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 preview_type = 7;

        pub fn get_preview_type(&self) -> u32 {
            self.preview_type.unwrap_or(0)
        }

        pub fn clear_preview_type(&mut self) {
            self.preview_type = ::std::option::Option::None;
        }

        pub fn has_preview_type(&self) -> bool {
            self.preview_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_preview_type(&mut self, v: u32) {
            self.preview_type = ::std::option::Option::Some(v);
        }

        // optional string external_reference = 8;

        pub fn get_external_reference(&self) -> &str {
            match self.external_reference.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_external_reference(&mut self) {
            self.external_reference.clear();
        }

        pub fn has_external_reference(&self) -> bool {
            self.external_reference.is_some()
        }

        // Param is passed by value, moved
        pub fn set_external_reference(&mut self, v: ::std::string::String) {
            self.external_reference = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_external_reference(&mut self) -> &mut ::std::string::String {
            if self.external_reference.is_none() {
                self.external_reference.set_default();
            }
            self.external_reference.as_mut().unwrap()
        }

        // Take field
        pub fn take_external_reference(&mut self) -> ::std::string::String {
            self.external_reference.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Preview {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.previewid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.sortorder = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                    },
                    6 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtubevideoid)?;
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.preview_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    8 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.external_reference)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.previewid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.sortorder {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.size {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.filename.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.youtubevideoid.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.preview_type {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.external_reference.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.previewid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.sortorder {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.size {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.filename.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.youtubevideoid.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.preview_type {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.external_reference.as_ref() {
                os.write_string(8, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Preview {
            Preview::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "previewid",
                    |m: &Preview| { &m.previewid },
                    |m: &mut Preview| { &mut m.previewid },
                    Preview::get_previewid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "sortorder",
                    |m: &Preview| { &m.sortorder },
                    |m: &mut Preview| { &mut m.sortorder },
                    Preview::get_sortorder,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "url",
                    |m: &Preview| { &m.url },
                    |m: &mut Preview| { &mut m.url },
                    Preview::get_url,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "size",
                    |m: &Preview| { &m.size },
                    |m: &mut Preview| { &mut m.size },
                    Preview::get_size,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "filename",
                    |m: &Preview| { &m.filename },
                    |m: &mut Preview| { &mut m.filename },
                    Preview::get_filename,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "youtubevideoid",
                    |m: &Preview| { &m.youtubevideoid },
                    |m: &mut Preview| { &mut m.youtubevideoid },
                    Preview::get_youtubevideoid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "preview_type",
                    |m: &Preview| { &m.preview_type },
                    |m: &mut Preview| { &mut m.preview_type },
                    Preview::get_preview_type,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "external_reference",
                    |m: &Preview| { &m.external_reference },
                    |m: &mut Preview| { &mut m.external_reference },
                    Preview::get_external_reference,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Preview>(
                    "PublishedFileDetails.Preview",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Preview {
            static instance: ::protobuf::rt::Lazy<Preview> = ::protobuf::rt::Lazy::INIT;
            instance.get(Preview::new)
        }
    }

    impl ::protobuf::Clear for Preview {
        fn clear(&mut self) {
            self.previewid = ::std::option::Option::None;
            self.sortorder = ::std::option::Option::None;
            self.url.clear();
            self.size = ::std::option::Option::None;
            self.filename.clear();
            self.youtubevideoid.clear();
            self.preview_type = ::std::option::Option::None;
            self.external_reference.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Preview {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Preview {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct Child {
        // message fields
        publishedfileid: ::std::option::Option<u64>,
        sortorder: ::std::option::Option<u32>,
        file_type: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Child {
        fn default() -> &'a Child {
            <Child as ::protobuf::Message>::default_instance()
        }
    }

    impl Child {
        pub fn new() -> Child {
            ::std::default::Default::default()
        }

        // optional uint64 publishedfileid = 1;

        pub fn get_publishedfileid(&self) -> u64 {
            self.publishedfileid.unwrap_or(0)
        }

        pub fn clear_publishedfileid(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
        }

        pub fn has_publishedfileid(&self) -> bool {
            self.publishedfileid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_publishedfileid(&mut self, v: u64) {
            self.publishedfileid = ::std::option::Option::Some(v);
        }

        // optional uint32 sortorder = 2;

        pub fn get_sortorder(&self) -> u32 {
            self.sortorder.unwrap_or(0)
        }

        pub fn clear_sortorder(&mut self) {
            self.sortorder = ::std::option::Option::None;
        }

        pub fn has_sortorder(&self) -> bool {
            self.sortorder.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sortorder(&mut self, v: u32) {
            self.sortorder = ::std::option::Option::Some(v);
        }

        // optional uint32 file_type = 3;

        pub fn get_file_type(&self) -> u32 {
            self.file_type.unwrap_or(0)
        }

        pub fn clear_file_type(&mut self) {
            self.file_type = ::std::option::Option::None;
        }

        pub fn has_file_type(&self) -> bool {
            self.file_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_type(&mut self, v: u32) {
            self.file_type = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Child {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.sortorder = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.file_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.publishedfileid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.sortorder {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.file_type {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.publishedfileid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.sortorder {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.file_type {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Child {
            Child::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "publishedfileid",
                    |m: &Child| { &m.publishedfileid },
                    |m: &mut Child| { &mut m.publishedfileid },
                    Child::get_publishedfileid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "sortorder",
                    |m: &Child| { &m.sortorder },
                    |m: &mut Child| { &mut m.sortorder },
                    Child::get_sortorder,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "file_type",
                    |m: &Child| { &m.file_type },
                    |m: &mut Child| { &mut m.file_type },
                    Child::get_file_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Child>(
                    "PublishedFileDetails.Child",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Child {
            static instance: ::protobuf::rt::Lazy<Child> = ::protobuf::rt::Lazy::INIT;
            instance.get(Child::new)
        }
    }

    impl ::protobuf::Clear for Child {
        fn clear(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
            self.sortorder = ::std::option::Option::None;
            self.file_type = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Child {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Child {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct KVTag {
        // message fields
        key: ::protobuf::SingularField<::std::string::String>,
        value: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a KVTag {
        fn default() -> &'a KVTag {
            <KVTag as ::protobuf::Message>::default_instance()
        }
    }

    impl KVTag {
        pub fn new() -> KVTag {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn get_key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key.clear();
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key.set_default();
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn get_value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value.clear();
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value.set_default();
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for KVTag {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> KVTag {
            KVTag::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "key",
                    |m: &KVTag| { &m.key },
                    |m: &mut KVTag| { &mut m.key },
                    KVTag::get_key,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "value",
                    |m: &KVTag| { &m.value },
                    |m: &mut KVTag| { &mut m.value },
                    KVTag::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KVTag>(
                    "PublishedFileDetails.KVTag",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static KVTag {
            static instance: ::protobuf::rt::Lazy<KVTag> = ::protobuf::rt::Lazy::INIT;
            instance.get(KVTag::new)
        }
    }

    impl ::protobuf::Clear for KVTag {
        fn clear(&mut self) {
            self.key.clear();
            self.value.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for KVTag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KVTag {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct VoteData {
        // message fields
        score: ::std::option::Option<f32>,
        votes_up: ::std::option::Option<u32>,
        votes_down: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a VoteData {
        fn default() -> &'a VoteData {
            <VoteData as ::protobuf::Message>::default_instance()
        }
    }

    impl VoteData {
        pub fn new() -> VoteData {
            ::std::default::Default::default()
        }

        // optional float score = 1;

        pub fn get_score(&self) -> f32 {
            self.score.unwrap_or(0.)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: f32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 votes_up = 2;

        pub fn get_votes_up(&self) -> u32 {
            self.votes_up.unwrap_or(0)
        }

        pub fn clear_votes_up(&mut self) {
            self.votes_up = ::std::option::Option::None;
        }

        pub fn has_votes_up(&self) -> bool {
            self.votes_up.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_up(&mut self, v: u32) {
            self.votes_up = ::std::option::Option::Some(v);
        }

        // optional uint32 votes_down = 3;

        pub fn get_votes_down(&self) -> u32 {
            self.votes_down.unwrap_or(0)
        }

        pub fn clear_votes_down(&mut self) {
            self.votes_down = ::std::option::Option::None;
        }

        pub fn has_votes_down(&self) -> bool {
            self.votes_down.is_some()
        }

        // Param is passed by value, moved
        pub fn set_votes_down(&mut self, v: u32) {
            self.votes_down = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for VoteData {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.score = ::std::option::Option::Some(is.read_float()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.votes_up = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.votes_down = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.score {
                my_size += 5;
            }
            if let Some(v) = self.votes_up {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.votes_down {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.score {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.votes_up {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.votes_down {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> VoteData {
            VoteData::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                    "score",
                    |m: &VoteData| { &m.score },
                    |m: &mut VoteData| { &mut m.score },
                    VoteData::get_score,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "votes_up",
                    |m: &VoteData| { &m.votes_up },
                    |m: &mut VoteData| { &mut m.votes_up },
                    VoteData::get_votes_up,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "votes_down",
                    |m: &VoteData| { &m.votes_down },
                    |m: &mut VoteData| { &mut m.votes_down },
                    VoteData::get_votes_down,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VoteData>(
                    "PublishedFileDetails.VoteData",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static VoteData {
            static instance: ::protobuf::rt::Lazy<VoteData> = ::protobuf::rt::Lazy::INIT;
            instance.get(VoteData::new)
        }
    }

    impl ::protobuf::Clear for VoteData {
        fn clear(&mut self) {
            self.score = ::std::option::Option::None;
            self.votes_up = ::std::option::Option::None;
            self.votes_down = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for VoteData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for VoteData {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct ForSaleData {
        // message fields
        is_for_sale: ::std::option::Option<bool>,
        price_category: ::std::option::Option<u32>,
        estatus: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<super::EPublishedFileForSaleStatus>>,
        price_category_floor: ::std::option::Option<u32>,
        price_is_pay_what_you_want: ::std::option::Option<bool>,
        discount_percentage: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a ForSaleData {
        fn default() -> &'a ForSaleData {
            <ForSaleData as ::protobuf::Message>::default_instance()
        }
    }

    impl ForSaleData {
        pub fn new() -> ForSaleData {
            ::std::default::Default::default()
        }

        // optional bool is_for_sale = 1;

        pub fn get_is_for_sale(&self) -> bool {
            self.is_for_sale.unwrap_or(false)
        }

        pub fn clear_is_for_sale(&mut self) {
            self.is_for_sale = ::std::option::Option::None;
        }

        pub fn has_is_for_sale(&self) -> bool {
            self.is_for_sale.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_for_sale(&mut self, v: bool) {
            self.is_for_sale = ::std::option::Option::Some(v);
        }

        // optional uint32 price_category = 2;

        pub fn get_price_category(&self) -> u32 {
            self.price_category.unwrap_or(0)
        }

        pub fn clear_price_category(&mut self) {
            self.price_category = ::std::option::Option::None;
        }

        pub fn has_price_category(&self) -> bool {
            self.price_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price_category(&mut self, v: u32) {
            self.price_category = ::std::option::Option::Some(v);
        }

        // optional .EPublishedFileForSaleStatus estatus = 3;

        pub fn get_estatus(&self) -> super::EPublishedFileForSaleStatus {
            match self.estatus {
                Some(e) => e.enum_value_or(super::EPublishedFileForSaleStatus::k_PFFSS_NotForSale),
                None => super::EPublishedFileForSaleStatus::k_PFFSS_NotForSale,
            }
        }

        pub fn clear_estatus(&mut self) {
            self.estatus = ::std::option::Option::None;
        }

        pub fn has_estatus(&self) -> bool {
            self.estatus.is_some()
        }

        // Param is passed by value, moved
        pub fn set_estatus(&mut self, v: super::EPublishedFileForSaleStatus) {
            self.estatus = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
        }

        // optional uint32 price_category_floor = 4;

        pub fn get_price_category_floor(&self) -> u32 {
            self.price_category_floor.unwrap_or(0)
        }

        pub fn clear_price_category_floor(&mut self) {
            self.price_category_floor = ::std::option::Option::None;
        }

        pub fn has_price_category_floor(&self) -> bool {
            self.price_category_floor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price_category_floor(&mut self, v: u32) {
            self.price_category_floor = ::std::option::Option::Some(v);
        }

        // optional bool price_is_pay_what_you_want = 5;

        pub fn get_price_is_pay_what_you_want(&self) -> bool {
            self.price_is_pay_what_you_want.unwrap_or(false)
        }

        pub fn clear_price_is_pay_what_you_want(&mut self) {
            self.price_is_pay_what_you_want = ::std::option::Option::None;
        }

        pub fn has_price_is_pay_what_you_want(&self) -> bool {
            self.price_is_pay_what_you_want.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price_is_pay_what_you_want(&mut self, v: bool) {
            self.price_is_pay_what_you_want = ::std::option::Option::Some(v);
        }

        // optional uint32 discount_percentage = 6;

        pub fn get_discount_percentage(&self) -> u32 {
            self.discount_percentage.unwrap_or(0)
        }

        pub fn clear_discount_percentage(&mut self) {
            self.discount_percentage = ::std::option::Option::None;
        }

        pub fn has_discount_percentage(&self) -> bool {
            self.discount_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_discount_percentage(&mut self, v: u32) {
            self.discount_percentage = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ForSaleData {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.is_for_sale = ::std::option::Option::Some(is.read_bool()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.price_category = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.estatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.price_category_floor = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.price_is_pay_what_you_want = ::std::option::Option::Some(is.read_bool()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.discount_percentage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.is_for_sale {
                my_size += 2;
            }
            if let Some(v) = self.price_category {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.estatus {
                my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
            }
            if let Some(v) = self.price_category_floor {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.price_is_pay_what_you_want {
                my_size += 2;
            }
            if let Some(v) = self.discount_percentage {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.is_for_sale {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.price_category {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.estatus {
                os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.price_category_floor {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.price_is_pay_what_you_want {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.discount_percentage {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> ForSaleData {
            ForSaleData::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "is_for_sale",
                    |m: &ForSaleData| { &m.is_for_sale },
                    |m: &mut ForSaleData| { &mut m.is_for_sale },
                    ForSaleData::get_is_for_sale,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "price_category",
                    |m: &ForSaleData| { &m.price_category },
                    |m: &mut ForSaleData| { &mut m.price_category },
                    ForSaleData::get_price_category,
                ));
                fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, super::EPublishedFileForSaleStatus>(
                    "estatus",
                    |m: &ForSaleData| { &m.estatus },
                    |m: &mut ForSaleData| { &mut m.estatus },
                    super::EPublishedFileForSaleStatus::k_PFFSS_NotForSale,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "price_category_floor",
                    |m: &ForSaleData| { &m.price_category_floor },
                    |m: &mut ForSaleData| { &mut m.price_category_floor },
                    ForSaleData::get_price_category_floor,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "price_is_pay_what_you_want",
                    |m: &ForSaleData| { &m.price_is_pay_what_you_want },
                    |m: &mut ForSaleData| { &mut m.price_is_pay_what_you_want },
                    ForSaleData::get_price_is_pay_what_you_want,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "discount_percentage",
                    |m: &ForSaleData| { &m.discount_percentage },
                    |m: &mut ForSaleData| { &mut m.discount_percentage },
                    ForSaleData::get_discount_percentage,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForSaleData>(
                    "PublishedFileDetails.ForSaleData",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static ForSaleData {
            static instance: ::protobuf::rt::Lazy<ForSaleData> = ::protobuf::rt::Lazy::INIT;
            instance.get(ForSaleData::new)
        }
    }

    impl ::protobuf::Clear for ForSaleData {
        fn clear(&mut self) {
            self.is_for_sale = ::std::option::Option::None;
            self.price_category = ::std::option::Option::None;
            self.estatus = ::std::option::Option::None;
            self.price_category_floor = ::std::option::Option::None;
            self.price_is_pay_what_you_want = ::std::option::Option::None;
            self.discount_percentage = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for ForSaleData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ForSaleData {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct PlaytimeStats {
        // message fields
        playtime_seconds: ::std::option::Option<u64>,
        num_sessions: ::std::option::Option<u64>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PlaytimeStats {
        fn default() -> &'a PlaytimeStats {
            <PlaytimeStats as ::protobuf::Message>::default_instance()
        }
    }

    impl PlaytimeStats {
        pub fn new() -> PlaytimeStats {
            ::std::default::Default::default()
        }

        // optional uint64 playtime_seconds = 1;

        pub fn get_playtime_seconds(&self) -> u64 {
            self.playtime_seconds.unwrap_or(0)
        }

        pub fn clear_playtime_seconds(&mut self) {
            self.playtime_seconds = ::std::option::Option::None;
        }

        pub fn has_playtime_seconds(&self) -> bool {
            self.playtime_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime_seconds(&mut self, v: u64) {
            self.playtime_seconds = ::std::option::Option::Some(v);
        }

        // optional uint64 num_sessions = 2;

        pub fn get_num_sessions(&self) -> u64 {
            self.num_sessions.unwrap_or(0)
        }

        pub fn clear_num_sessions(&mut self) {
            self.num_sessions = ::std::option::Option::None;
        }

        pub fn has_num_sessions(&self) -> bool {
            self.num_sessions.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_sessions(&mut self, v: u64) {
            self.num_sessions = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for PlaytimeStats {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.playtime_seconds = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.num_sessions = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.playtime_seconds {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.num_sessions {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.playtime_seconds {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.num_sessions {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PlaytimeStats {
            PlaytimeStats::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "playtime_seconds",
                    |m: &PlaytimeStats| { &m.playtime_seconds },
                    |m: &mut PlaytimeStats| { &mut m.playtime_seconds },
                    PlaytimeStats::get_playtime_seconds,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "num_sessions",
                    |m: &PlaytimeStats| { &m.num_sessions },
                    |m: &mut PlaytimeStats| { &mut m.num_sessions },
                    PlaytimeStats::get_num_sessions,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlaytimeStats>(
                    "PublishedFileDetails.PlaytimeStats",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PlaytimeStats {
            static instance: ::protobuf::rt::Lazy<PlaytimeStats> = ::protobuf::rt::Lazy::INIT;
            instance.get(PlaytimeStats::new)
        }
    }

    impl ::protobuf::Clear for PlaytimeStats {
        fn clear(&mut self) {
            self.playtime_seconds = ::std::option::Option::None;
            self.num_sessions = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PlaytimeStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlaytimeStats {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetDetails_Response {
    // message fields
    pub publishedfiledetails: ::protobuf::RepeatedField<PublishedFileDetails>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetDetails_Response {
    fn default() -> &'a CPublishedFile_GetDetails_Response {
        <CPublishedFile_GetDetails_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetDetails_Response {
    pub fn new() -> CPublishedFile_GetDetails_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_GetDetails_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.publishedfiledetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.publishedfiledetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.publishedfiledetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.publishedfiledetails {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetDetails_Response {
        CPublishedFile_GetDetails_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<PublishedFileDetails>>(
                "publishedfiledetails",
                |m: &CPublishedFile_GetDetails_Response| { &m.publishedfiledetails },
                |m: &mut CPublishedFile_GetDetails_Response| { &mut m.publishedfiledetails },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetDetails_Response>(
                "CPublishedFile_GetDetails_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetDetails_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetDetails_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetDetails_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetDetails_Response {
    fn clear(&mut self) {
        self.publishedfiledetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetDetails_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetDetails_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetItemInfo_Request {
    // message fields
    app_id: ::std::option::Option<u32>,
    last_time_updated: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<cpublished_file_get_item_info_request::WorkshopItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetItemInfo_Request {
    fn default() -> &'a CPublishedFile_GetItemInfo_Request {
        <CPublishedFile_GetItemInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetItemInfo_Request {
    pub fn new() -> CPublishedFile_GetItemInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;

    pub fn get_last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }

    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetItemInfo_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.last_time_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.workshop_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetItemInfo_Request {
        CPublishedFile_GetItemInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CPublishedFile_GetItemInfo_Request| { &m.app_id },
                |m: &mut CPublishedFile_GetItemInfo_Request| { &mut m.app_id },
                CPublishedFile_GetItemInfo_Request::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "last_time_updated",
                |m: &CPublishedFile_GetItemInfo_Request| { &m.last_time_updated },
                |m: &mut CPublishedFile_GetItemInfo_Request| { &mut m.last_time_updated },
                CPublishedFile_GetItemInfo_Request::get_last_time_updated,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_item_info_request::WorkshopItem>>(
                "workshop_items",
                |m: &CPublishedFile_GetItemInfo_Request| { &m.workshop_items },
                |m: &mut CPublishedFile_GetItemInfo_Request| { &mut m.workshop_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetItemInfo_Request>(
                "CPublishedFile_GetItemInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetItemInfo_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetItemInfo_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetItemInfo_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetItemInfo_Request {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.workshop_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetItemInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetItemInfo_Request {
}

/// Nested message and enums of message `CPublishedFile_GetItemInfo_Request`
pub mod cpublished_file_get_item_info_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct WorkshopItem {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        time_updated: ::std::option::Option<u32>,
        desired_revision: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<super::EPublishedFileRevision>>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItem {
        fn default() -> &'a WorkshopItem {
            <WorkshopItem as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItem {
        pub fn new() -> WorkshopItem {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn get_time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional .EPublishedFileRevision desired_revision = 3;

        pub fn get_desired_revision(&self) -> super::EPublishedFileRevision {
            match self.desired_revision {
                Some(e) => e.enum_value_or(super::EPublishedFileRevision::k_EPublishedFileRevision_Default),
                None => super::EPublishedFileRevision::k_EPublishedFileRevision_Default,
            }
        }

        pub fn clear_desired_revision(&mut self) {
            self.desired_revision = ::std::option::Option::None;
        }

        pub fn has_desired_revision(&self) -> bool {
            self.desired_revision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desired_revision(&mut self, v: super::EPublishedFileRevision) {
            self.desired_revision = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
        }
    }

    impl ::protobuf::Message for WorkshopItem {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.desired_revision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.desired_revision {
                my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.desired_revision {
                os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> WorkshopItem {
            WorkshopItem::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &WorkshopItem| { &m.published_file_id },
                    |m: &mut WorkshopItem| { &mut m.published_file_id },
                    WorkshopItem::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_updated",
                    |m: &WorkshopItem| { &m.time_updated },
                    |m: &mut WorkshopItem| { &mut m.time_updated },
                    WorkshopItem::get_time_updated,
                ));
                fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, super::EPublishedFileRevision>(
                    "desired_revision",
                    |m: &WorkshopItem| { &m.desired_revision },
                    |m: &mut WorkshopItem| { &mut m.desired_revision },
                    super::EPublishedFileRevision::k_EPublishedFileRevision_Default,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkshopItem>(
                    "CPublishedFile_GetItemInfo_Request.WorkshopItem",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static WorkshopItem {
            static instance: ::protobuf::rt::Lazy<WorkshopItem> = ::protobuf::rt::Lazy::INIT;
            instance.get(WorkshopItem::new)
        }
    }

    impl ::protobuf::Clear for WorkshopItem {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.desired_revision = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for WorkshopItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItem {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetItemInfo_Response {
    // message fields
    update_time: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<cpublished_file_get_item_info_response::WorkshopItemInfo>,
    pub private_items: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetItemInfo_Response {
    fn default() -> &'a CPublishedFile_GetItemInfo_Response {
        <CPublishedFile_GetItemInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetItemInfo_Response {
    pub fn new() -> CPublishedFile_GetItemInfo_Response {
        ::std::default::Default::default()
    }

    // optional uint32 update_time = 1;

    pub fn get_update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }

    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetItemInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.workshop_items)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.private_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 9 * self.private_items.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.update_time {
            os.write_uint32(1, v)?;
        }
        for v in &self.workshop_items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.private_items {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetItemInfo_Response {
        CPublishedFile_GetItemInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "update_time",
                |m: &CPublishedFile_GetItemInfo_Response| { &m.update_time },
                |m: &mut CPublishedFile_GetItemInfo_Response| { &mut m.update_time },
                CPublishedFile_GetItemInfo_Response::get_update_time,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_item_info_response::WorkshopItemInfo>>(
                "workshop_items",
                |m: &CPublishedFile_GetItemInfo_Response| { &m.workshop_items },
                |m: &mut CPublishedFile_GetItemInfo_Response| { &mut m.workshop_items },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "private_items",
                |m: &CPublishedFile_GetItemInfo_Response| { &m.private_items },
                |m: &mut CPublishedFile_GetItemInfo_Response| { &mut m.private_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetItemInfo_Response>(
                "CPublishedFile_GetItemInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetItemInfo_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetItemInfo_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetItemInfo_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetItemInfo_Response {
    fn clear(&mut self) {
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.private_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetItemInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetItemInfo_Response {
}

/// Nested message and enums of message `CPublishedFile_GetItemInfo_Response`
pub mod cpublished_file_get_item_info_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct WorkshopItemInfo {
        // message fields
        published_file_id: ::std::option::Option<u64>,
        time_updated: ::std::option::Option<u32>,
        manifest_id: ::std::option::Option<u64>,
        flags: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemInfo {
        fn default() -> &'a WorkshopItemInfo {
            <WorkshopItemInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemInfo {
        pub fn new() -> WorkshopItemInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 published_file_id = 1;

        pub fn get_published_file_id(&self) -> u64 {
            self.published_file_id.unwrap_or(0)
        }

        pub fn clear_published_file_id(&mut self) {
            self.published_file_id = ::std::option::Option::None;
        }

        pub fn has_published_file_id(&self) -> bool {
            self.published_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_file_id(&mut self, v: u64) {
            self.published_file_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_updated = 2;

        pub fn get_time_updated(&self) -> u32 {
            self.time_updated.unwrap_or(0)
        }

        pub fn clear_time_updated(&mut self) {
            self.time_updated = ::std::option::Option::None;
        }

        pub fn has_time_updated(&self) -> bool {
            self.time_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_updated(&mut self, v: u32) {
            self.time_updated = ::std::option::Option::Some(v);
        }

        // optional fixed64 manifest_id = 3;

        pub fn get_manifest_id(&self) -> u64 {
            self.manifest_id.unwrap_or(0)
        }

        pub fn clear_manifest_id(&mut self) {
            self.manifest_id = ::std::option::Option::None;
        }

        pub fn has_manifest_id(&self) -> bool {
            self.manifest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manifest_id(&mut self, v: u64) {
            self.manifest_id = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 4;

        pub fn get_flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for WorkshopItemInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.manifest_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.published_file_id {
                my_size += 9;
            }
            if let Some(v) = self.time_updated {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.manifest_id {
                my_size += 9;
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.published_file_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.time_updated {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.manifest_id {
                os.write_fixed64(3, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> WorkshopItemInfo {
            WorkshopItemInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "published_file_id",
                    |m: &WorkshopItemInfo| { &m.published_file_id },
                    |m: &mut WorkshopItemInfo| { &mut m.published_file_id },
                    WorkshopItemInfo::get_published_file_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_updated",
                    |m: &WorkshopItemInfo| { &m.time_updated },
                    |m: &mut WorkshopItemInfo| { &mut m.time_updated },
                    WorkshopItemInfo::get_time_updated,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "manifest_id",
                    |m: &WorkshopItemInfo| { &m.manifest_id },
                    |m: &mut WorkshopItemInfo| { &mut m.manifest_id },
                    WorkshopItemInfo::get_manifest_id,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "flags",
                    |m: &WorkshopItemInfo| { &m.flags },
                    |m: &mut WorkshopItemInfo| { &mut m.flags },
                    WorkshopItemInfo::get_flags,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkshopItemInfo>(
                    "CPublishedFile_GetItemInfo_Response.WorkshopItemInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static WorkshopItemInfo {
            static instance: ::protobuf::rt::Lazy<WorkshopItemInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(WorkshopItemInfo::new)
        }
    }

    impl ::protobuf::Clear for WorkshopItemInfo {
        fn clear(&mut self) {
            self.published_file_id = ::std::option::Option::None;
            self.time_updated = ::std::option::Option::None;
            self.manifest_id = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for WorkshopItemInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetUserFiles_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    page: ::std::option::Option<u32>,
    numperpage: ::std::option::Option<u32>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    sortmethod: ::protobuf::SingularField<::std::string::String>,
    privacy: ::std::option::Option<u32>,
    pub requiredtags: ::protobuf::RepeatedField<::std::string::String>,
    pub excludedtags: ::protobuf::RepeatedField<::std::string::String>,
    pub required_kv_tags: ::protobuf::RepeatedField<cpublished_file_get_user_files_request::KVTag>,
    filetype: ::std::option::Option<u32>,
    creator_appid: ::std::option::Option<u32>,
    match_cloud_filename: ::protobuf::SingularField<::std::string::String>,
    cache_max_age_seconds: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    pub taggroups: ::protobuf::RepeatedField<cpublished_file_get_user_files_request::TagGroup>,
    totalonly: ::std::option::Option<bool>,
    ids_only: ::std::option::Option<bool>,
    return_vote_data: ::std::option::Option<bool>,
    return_tags: ::std::option::Option<bool>,
    return_kv_tags: ::std::option::Option<bool>,
    return_previews: ::std::option::Option<bool>,
    return_children: ::std::option::Option<bool>,
    return_short_description: ::std::option::Option<bool>,
    return_for_sale_data: ::std::option::Option<bool>,
    return_metadata: ::std::option::Option<bool>,
    return_playtime_stats: ::std::option::Option<u32>,
    strip_description_bbcode: ::std::option::Option<bool>,
    desired_revision: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EPublishedFileRevision>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserFiles_Request {
    fn default() -> &'a CPublishedFile_GetUserFiles_Request {
        <CPublishedFile_GetUserFiles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserFiles_Request {
    pub fn new() -> CPublishedFile_GetUserFiles_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 page = 4;

    pub fn get_page(&self) -> u32 {
        self.page.unwrap_or(1u32)
    }

    pub fn clear_page(&mut self) {
        self.page = ::std::option::Option::None;
    }

    pub fn has_page(&self) -> bool {
        self.page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = ::std::option::Option::Some(v);
    }

    // optional uint32 numperpage = 5;

    pub fn get_numperpage(&self) -> u32 {
        self.numperpage.unwrap_or(1u32)
    }

    pub fn clear_numperpage(&mut self) {
        self.numperpage = ::std::option::Option::None;
    }

    pub fn has_numperpage(&self) -> bool {
        self.numperpage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numperpage(&mut self, v: u32) {
        self.numperpage = ::std::option::Option::Some(v);
    }

    // optional string type = 6;

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => v,
            None => "myfiles",
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sortmethod = 7;

    pub fn get_sortmethod(&self) -> &str {
        match self.sortmethod.as_ref() {
            Some(v) => v,
            None => "lastupdated",
        }
    }

    pub fn clear_sortmethod(&mut self) {
        self.sortmethod.clear();
    }

    pub fn has_sortmethod(&self) -> bool {
        self.sortmethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sortmethod(&mut self, v: ::std::string::String) {
        self.sortmethod = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortmethod(&mut self) -> &mut ::std::string::String {
        if self.sortmethod.is_none() {
            self.sortmethod.set_default();
        }
        self.sortmethod.as_mut().unwrap()
    }

    // Take field
    pub fn take_sortmethod(&mut self) -> ::std::string::String {
        self.sortmethod.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 privacy = 9;

    pub fn get_privacy(&self) -> u32 {
        self.privacy.unwrap_or(0)
    }

    pub fn clear_privacy(&mut self) {
        self.privacy = ::std::option::Option::None;
    }

    pub fn has_privacy(&self) -> bool {
        self.privacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy(&mut self, v: u32) {
        self.privacy = ::std::option::Option::Some(v);
    }

    // optional uint32 filetype = 14;

    pub fn get_filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }

    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional uint32 creator_appid = 15;

    pub fn get_creator_appid(&self) -> u32 {
        self.creator_appid.unwrap_or(0)
    }

    pub fn clear_creator_appid(&mut self) {
        self.creator_appid = ::std::option::Option::None;
    }

    pub fn has_creator_appid(&self) -> bool {
        self.creator_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_appid(&mut self, v: u32) {
        self.creator_appid = ::std::option::Option::Some(v);
    }

    // optional string match_cloud_filename = 16;

    pub fn get_match_cloud_filename(&self) -> &str {
        match self.match_cloud_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_match_cloud_filename(&mut self) {
        self.match_cloud_filename.clear();
    }

    pub fn has_match_cloud_filename(&self) -> bool {
        self.match_cloud_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_cloud_filename(&mut self, v: ::std::string::String) {
        self.match_cloud_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_cloud_filename(&mut self) -> &mut ::std::string::String {
        if self.match_cloud_filename.is_none() {
            self.match_cloud_filename.set_default();
        }
        self.match_cloud_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_cloud_filename(&mut self) -> ::std::string::String {
        self.match_cloud_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 cache_max_age_seconds = 27;

    pub fn get_cache_max_age_seconds(&self) -> u32 {
        self.cache_max_age_seconds.unwrap_or(0u32)
    }

    pub fn clear_cache_max_age_seconds(&mut self) {
        self.cache_max_age_seconds = ::std::option::Option::None;
    }

    pub fn has_cache_max_age_seconds(&self) -> bool {
        self.cache_max_age_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_max_age_seconds(&mut self, v: u32) {
        self.cache_max_age_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 language = 29;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool totalonly = 17;

    pub fn get_totalonly(&self) -> bool {
        self.totalonly.unwrap_or(false)
    }

    pub fn clear_totalonly(&mut self) {
        self.totalonly = ::std::option::Option::None;
    }

    pub fn has_totalonly(&self) -> bool {
        self.totalonly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalonly(&mut self, v: bool) {
        self.totalonly = ::std::option::Option::Some(v);
    }

    // optional bool ids_only = 18;

    pub fn get_ids_only(&self) -> bool {
        self.ids_only.unwrap_or(false)
    }

    pub fn clear_ids_only(&mut self) {
        self.ids_only = ::std::option::Option::None;
    }

    pub fn has_ids_only(&self) -> bool {
        self.ids_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ids_only(&mut self, v: bool) {
        self.ids_only = ::std::option::Option::Some(v);
    }

    // optional bool return_vote_data = 19;

    pub fn get_return_vote_data(&self) -> bool {
        self.return_vote_data.unwrap_or(true)
    }

    pub fn clear_return_vote_data(&mut self) {
        self.return_vote_data = ::std::option::Option::None;
    }

    pub fn has_return_vote_data(&self) -> bool {
        self.return_vote_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_vote_data(&mut self, v: bool) {
        self.return_vote_data = ::std::option::Option::Some(v);
    }

    // optional bool return_tags = 20;

    pub fn get_return_tags(&self) -> bool {
        self.return_tags.unwrap_or(false)
    }

    pub fn clear_return_tags(&mut self) {
        self.return_tags = ::std::option::Option::None;
    }

    pub fn has_return_tags(&self) -> bool {
        self.return_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_tags(&mut self, v: bool) {
        self.return_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_kv_tags = 21;

    pub fn get_return_kv_tags(&self) -> bool {
        self.return_kv_tags.unwrap_or(true)
    }

    pub fn clear_return_kv_tags(&mut self) {
        self.return_kv_tags = ::std::option::Option::None;
    }

    pub fn has_return_kv_tags(&self) -> bool {
        self.return_kv_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_kv_tags(&mut self, v: bool) {
        self.return_kv_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_previews = 22;

    pub fn get_return_previews(&self) -> bool {
        self.return_previews.unwrap_or(false)
    }

    pub fn clear_return_previews(&mut self) {
        self.return_previews = ::std::option::Option::None;
    }

    pub fn has_return_previews(&self) -> bool {
        self.return_previews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_previews(&mut self, v: bool) {
        self.return_previews = ::std::option::Option::Some(v);
    }

    // optional bool return_children = 23;

    pub fn get_return_children(&self) -> bool {
        self.return_children.unwrap_or(false)
    }

    pub fn clear_return_children(&mut self) {
        self.return_children = ::std::option::Option::None;
    }

    pub fn has_return_children(&self) -> bool {
        self.return_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_children(&mut self, v: bool) {
        self.return_children = ::std::option::Option::Some(v);
    }

    // optional bool return_short_description = 24;

    pub fn get_return_short_description(&self) -> bool {
        self.return_short_description.unwrap_or(true)
    }

    pub fn clear_return_short_description(&mut self) {
        self.return_short_description = ::std::option::Option::None;
    }

    pub fn has_return_short_description(&self) -> bool {
        self.return_short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_short_description(&mut self, v: bool) {
        self.return_short_description = ::std::option::Option::Some(v);
    }

    // optional bool return_for_sale_data = 26;

    pub fn get_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.unwrap_or(false)
    }

    pub fn clear_return_for_sale_data(&mut self) {
        self.return_for_sale_data = ::std::option::Option::None;
    }

    pub fn has_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_for_sale_data(&mut self, v: bool) {
        self.return_for_sale_data = ::std::option::Option::Some(v);
    }

    // optional bool return_metadata = 28;

    pub fn get_return_metadata(&self) -> bool {
        self.return_metadata.unwrap_or(false)
    }

    pub fn clear_return_metadata(&mut self) {
        self.return_metadata = ::std::option::Option::None;
    }

    pub fn has_return_metadata(&self) -> bool {
        self.return_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_metadata(&mut self, v: bool) {
        self.return_metadata = ::std::option::Option::Some(v);
    }

    // optional uint32 return_playtime_stats = 31;

    pub fn get_return_playtime_stats(&self) -> u32 {
        self.return_playtime_stats.unwrap_or(0)
    }

    pub fn clear_return_playtime_stats(&mut self) {
        self.return_playtime_stats = ::std::option::Option::None;
    }

    pub fn has_return_playtime_stats(&self) -> bool {
        self.return_playtime_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_playtime_stats(&mut self, v: u32) {
        self.return_playtime_stats = ::std::option::Option::Some(v);
    }

    // optional bool strip_description_bbcode = 32;

    pub fn get_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.unwrap_or(false)
    }

    pub fn clear_strip_description_bbcode(&mut self) {
        self.strip_description_bbcode = ::std::option::Option::None;
    }

    pub fn has_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_description_bbcode(&mut self, v: bool) {
        self.strip_description_bbcode = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 33;

    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        match self.desired_revision {
            Some(e) => e.enum_value_or(EPublishedFileRevision::k_EPublishedFileRevision_Default),
            None => EPublishedFileRevision::k_EPublishedFileRevision_Default,
        }
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserFiles_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.required_kv_tags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.taggroups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.page = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.numperpage = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sortmethod)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.requiredtags)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludedtags)?;
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.required_kv_tags)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.creator_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.match_cloud_filename)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cache_max_age_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.taggroups)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.totalonly = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ids_only = ::std::option::Option::Some(is.read_bool()?);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_vote_data = ::std::option::Option::Some(is.read_bool()?);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_kv_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_previews = ::std::option::Option::Some(is.read_bool()?);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_children = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_short_description = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_for_sale_data = ::std::option::Option::Some(is.read_bool()?);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_metadata = ::std::option::Option::Some(is.read_bool()?);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_playtime_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strip_description_bbcode = ::std::option::Option::Some(is.read_bool()?);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desired_revision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.page {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numperpage {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.sortmethod.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.privacy {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requiredtags {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.excludedtags {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.required_kv_tags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator_appid {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_cloud_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.cache_max_age_seconds {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.taggroups {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.totalonly {
            my_size += 3;
        }
        if let Some(v) = self.ids_only {
            my_size += 3;
        }
        if let Some(v) = self.return_vote_data {
            my_size += 3;
        }
        if let Some(v) = self.return_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_kv_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_previews {
            my_size += 3;
        }
        if let Some(v) = self.return_children {
            my_size += 3;
        }
        if let Some(v) = self.return_short_description {
            my_size += 3;
        }
        if let Some(v) = self.return_for_sale_data {
            my_size += 3;
        }
        if let Some(v) = self.return_metadata {
            my_size += 3;
        }
        if let Some(v) = self.return_playtime_stats {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strip_description_bbcode {
            my_size += 3;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_or_unknown_size(33, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.page {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.numperpage {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.field_type.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.sortmethod.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.privacy {
            os.write_uint32(9, v)?;
        }
        for v in &self.requiredtags {
            os.write_string(10, &v)?;
        };
        for v in &self.excludedtags {
            os.write_string(11, &v)?;
        };
        for v in &self.required_kv_tags {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        };
        if let Some(v) = self.filetype {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.creator_appid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.match_cloud_filename.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.cache_max_age_seconds {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(29, v)?;
        }
        for v in &self.taggroups {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        };
        if let Some(v) = self.totalonly {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.ids_only {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.return_vote_data {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.return_tags {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.return_kv_tags {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.return_previews {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.return_children {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.return_short_description {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.return_for_sale_data {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.return_metadata {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.return_playtime_stats {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.strip_description_bbcode {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(33, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserFiles_Request {
        CPublishedFile_GetUserFiles_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.steamid },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.steamid },
                CPublishedFile_GetUserFiles_Request::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.appid },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.appid },
                CPublishedFile_GetUserFiles_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "page",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.page },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.page },
                CPublishedFile_GetUserFiles_Request::get_page,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "numperpage",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.numperpage },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.numperpage },
                CPublishedFile_GetUserFiles_Request::get_numperpage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "type",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.field_type },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.field_type },
                CPublishedFile_GetUserFiles_Request::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "sortmethod",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.sortmethod },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.sortmethod },
                CPublishedFile_GetUserFiles_Request::get_sortmethod,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "privacy",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.privacy },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.privacy },
                CPublishedFile_GetUserFiles_Request::get_privacy,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "requiredtags",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.requiredtags },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.requiredtags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "excludedtags",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.excludedtags },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.excludedtags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_user_files_request::KVTag>>(
                "required_kv_tags",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.required_kv_tags },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.required_kv_tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "filetype",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.filetype },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.filetype },
                CPublishedFile_GetUserFiles_Request::get_filetype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "creator_appid",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.creator_appid },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.creator_appid },
                CPublishedFile_GetUserFiles_Request::get_creator_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "match_cloud_filename",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.match_cloud_filename },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.match_cloud_filename },
                CPublishedFile_GetUserFiles_Request::get_match_cloud_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cache_max_age_seconds",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.cache_max_age_seconds },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.cache_max_age_seconds },
                CPublishedFile_GetUserFiles_Request::get_cache_max_age_seconds,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.language },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.language },
                CPublishedFile_GetUserFiles_Request::get_language,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_user_files_request::TagGroup>>(
                "taggroups",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.taggroups },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.taggroups },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "totalonly",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.totalonly },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.totalonly },
                CPublishedFile_GetUserFiles_Request::get_totalonly,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "ids_only",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.ids_only },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.ids_only },
                CPublishedFile_GetUserFiles_Request::get_ids_only,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_vote_data",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_vote_data },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_vote_data },
                CPublishedFile_GetUserFiles_Request::get_return_vote_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_tags",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_tags },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_tags },
                CPublishedFile_GetUserFiles_Request::get_return_tags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_kv_tags",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_kv_tags },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_kv_tags },
                CPublishedFile_GetUserFiles_Request::get_return_kv_tags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_previews",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_previews },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_previews },
                CPublishedFile_GetUserFiles_Request::get_return_previews,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_children",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_children },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_children },
                CPublishedFile_GetUserFiles_Request::get_return_children,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_short_description",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_short_description },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_short_description },
                CPublishedFile_GetUserFiles_Request::get_return_short_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_for_sale_data",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_for_sale_data },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_for_sale_data },
                CPublishedFile_GetUserFiles_Request::get_return_for_sale_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_metadata",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_metadata },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_metadata },
                CPublishedFile_GetUserFiles_Request::get_return_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "return_playtime_stats",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.return_playtime_stats },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_playtime_stats },
                CPublishedFile_GetUserFiles_Request::get_return_playtime_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "strip_description_bbcode",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.strip_description_bbcode },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.strip_description_bbcode },
                CPublishedFile_GetUserFiles_Request::get_strip_description_bbcode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EPublishedFileRevision>(
                "desired_revision",
                |m: &CPublishedFile_GetUserFiles_Request| { &m.desired_revision },
                |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.desired_revision },
                EPublishedFileRevision::k_EPublishedFileRevision_Default,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserFiles_Request>(
                "CPublishedFile_GetUserFiles_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetUserFiles_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetUserFiles_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetUserFiles_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserFiles_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.page = ::std::option::Option::None;
        self.numperpage = ::std::option::Option::None;
        self.field_type.clear();
        self.sortmethod.clear();
        self.privacy = ::std::option::Option::None;
        self.requiredtags.clear();
        self.excludedtags.clear();
        self.required_kv_tags.clear();
        self.filetype = ::std::option::Option::None;
        self.creator_appid = ::std::option::Option::None;
        self.match_cloud_filename.clear();
        self.cache_max_age_seconds = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.taggroups.clear();
        self.totalonly = ::std::option::Option::None;
        self.ids_only = ::std::option::Option::None;
        self.return_vote_data = ::std::option::Option::None;
        self.return_tags = ::std::option::Option::None;
        self.return_kv_tags = ::std::option::Option::None;
        self.return_previews = ::std::option::Option::None;
        self.return_children = ::std::option::Option::None;
        self.return_short_description = ::std::option::Option::None;
        self.return_for_sale_data = ::std::option::Option::None;
        self.return_metadata = ::std::option::Option::None;
        self.return_playtime_stats = ::std::option::Option::None;
        self.strip_description_bbcode = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserFiles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserFiles_Request {
}

/// Nested message and enums of message `CPublishedFile_GetUserFiles_Request`
pub mod cpublished_file_get_user_files_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct KVTag {
        // message fields
        key: ::protobuf::SingularField<::std::string::String>,
        value: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a KVTag {
        fn default() -> &'a KVTag {
            <KVTag as ::protobuf::Message>::default_instance()
        }
    }

    impl KVTag {
        pub fn new() -> KVTag {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn get_key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key.clear();
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key.set_default();
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn get_value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value.clear();
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value.set_default();
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for KVTag {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> KVTag {
            KVTag::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "key",
                    |m: &KVTag| { &m.key },
                    |m: &mut KVTag| { &mut m.key },
                    KVTag::get_key,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "value",
                    |m: &KVTag| { &m.value },
                    |m: &mut KVTag| { &mut m.value },
                    KVTag::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KVTag>(
                    "CPublishedFile_GetUserFiles_Request.KVTag",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static KVTag {
            static instance: ::protobuf::rt::Lazy<KVTag> = ::protobuf::rt::Lazy::INIT;
            instance.get(KVTag::new)
        }
    }

    impl ::protobuf::Clear for KVTag {
        fn clear(&mut self) {
            self.key.clear();
            self.value.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for KVTag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KVTag {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct TagGroup {
        // message fields
        pub tags: ::protobuf::RepeatedField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a TagGroup {
        fn default() -> &'a TagGroup {
            <TagGroup as ::protobuf::Message>::default_instance()
        }
    }

    impl TagGroup {
        pub fn new() -> TagGroup {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for TagGroup {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            for value in &self.tags {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            for v in &self.tags {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> TagGroup {
            TagGroup::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                    "tags",
                    |m: &TagGroup| { &m.tags },
                    |m: &mut TagGroup| { &mut m.tags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TagGroup>(
                    "CPublishedFile_GetUserFiles_Request.TagGroup",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static TagGroup {
            static instance: ::protobuf::rt::Lazy<TagGroup> = ::protobuf::rt::Lazy::INIT;
            instance.get(TagGroup::new)
        }
    }

    impl ::protobuf::Clear for TagGroup {
        fn clear(&mut self) {
            self.tags.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for TagGroup {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TagGroup {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetUserFiles_Response {
    // message fields
    total: ::std::option::Option<u32>,
    startindex: ::std::option::Option<u32>,
    pub publishedfiledetails: ::protobuf::RepeatedField<PublishedFileDetails>,
    pub apps: ::protobuf::RepeatedField<cpublished_file_get_user_files_response::App>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserFiles_Response {
    fn default() -> &'a CPublishedFile_GetUserFiles_Response {
        <CPublishedFile_GetUserFiles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserFiles_Response {
    pub fn new() -> CPublishedFile_GetUserFiles_Response {
        ::std::default::Default::default()
    }

    // optional uint32 total = 1;

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional uint32 startindex = 2;

    pub fn get_startindex(&self) -> u32 {
        self.startindex.unwrap_or(0)
    }

    pub fn clear_startindex(&mut self) {
        self.startindex = ::std::option::Option::None;
    }

    pub fn has_startindex(&self) -> bool {
        self.startindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startindex(&mut self, v: u32) {
        self.startindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserFiles_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.publishedfiledetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.startindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.publishedfiledetails)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfiledetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.startindex {
            os.write_uint32(2, v)?;
        }
        for v in &self.publishedfiledetails {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.apps {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserFiles_Response {
        CPublishedFile_GetUserFiles_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total",
                |m: &CPublishedFile_GetUserFiles_Response| { &m.total },
                |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.total },
                CPublishedFile_GetUserFiles_Response::get_total,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "startindex",
                |m: &CPublishedFile_GetUserFiles_Response| { &m.startindex },
                |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.startindex },
                CPublishedFile_GetUserFiles_Response::get_startindex,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<PublishedFileDetails>>(
                "publishedfiledetails",
                |m: &CPublishedFile_GetUserFiles_Response| { &m.publishedfiledetails },
                |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.publishedfiledetails },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_user_files_response::App>>(
                "apps",
                |m: &CPublishedFile_GetUserFiles_Response| { &m.apps },
                |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserFiles_Response>(
                "CPublishedFile_GetUserFiles_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetUserFiles_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetUserFiles_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetUserFiles_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserFiles_Response {
    fn clear(&mut self) {
        self.total = ::std::option::Option::None;
        self.startindex = ::std::option::Option::None;
        self.publishedfiledetails.clear();
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserFiles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserFiles_Response {
}

/// Nested message and enums of message `CPublishedFile_GetUserFiles_Response`
pub mod cpublished_file_get_user_files_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct App {
        // message fields
        appid: ::std::option::Option<u32>,
        name: ::protobuf::SingularField<::std::string::String>,
        shortcutid: ::std::option::Option<u32>,
        private: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a App {
        fn default() -> &'a App {
            <App as ::protobuf::Message>::default_instance()
        }
    }

    impl App {
        pub fn new() -> App {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn get_name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name.clear();
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name.set_default();
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 shortcutid = 3;

        pub fn get_shortcutid(&self) -> u32 {
            self.shortcutid.unwrap_or(0)
        }

        pub fn clear_shortcutid(&mut self) {
            self.shortcutid = ::std::option::Option::None;
        }

        pub fn has_shortcutid(&self) -> bool {
            self.shortcutid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shortcutid(&mut self, v: u32) {
            self.shortcutid = ::std::option::Option::Some(v);
        }

        // optional bool private = 4;

        pub fn get_private(&self) -> bool {
            self.private.unwrap_or(false)
        }

        pub fn clear_private(&mut self) {
            self.private = ::std::option::Option::None;
        }

        pub fn has_private(&self) -> bool {
            self.private.is_some()
        }

        // Param is passed by value, moved
        pub fn set_private(&mut self, v: bool) {
            self.private = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for App {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.shortcutid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.private = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.shortcutid {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.private {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.shortcutid {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.private {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> App {
            App::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &App| { &m.appid },
                    |m: &mut App| { &mut m.appid },
                    App::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "name",
                    |m: &App| { &m.name },
                    |m: &mut App| { &mut m.name },
                    App::get_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "shortcutid",
                    |m: &App| { &m.shortcutid },
                    |m: &mut App| { &mut m.shortcutid },
                    App::get_shortcutid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "private",
                    |m: &App| { &m.private },
                    |m: &mut App| { &mut m.private },
                    App::get_private,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<App>(
                    "CPublishedFile_GetUserFiles_Response.App",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static App {
            static instance: ::protobuf::rt::Lazy<App> = ::protobuf::rt::Lazy::INIT;
            instance.get(App::new)
        }
    }

    impl ::protobuf::Clear for App {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.name.clear();
            self.shortcutid = ::std::option::Option::None;
            self.private = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for App {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for App {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_AreFilesInSubscriptionList_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    pub publishedfileids: ::std::vec::Vec<u64>,
    listtype: ::std::option::Option<u32>,
    filetype: ::std::option::Option<u32>,
    workshopfiletype: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AreFilesInSubscriptionList_Request {
    fn default() -> &'a CPublishedFile_AreFilesInSubscriptionList_Request {
        <CPublishedFile_AreFilesInSubscriptionList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AreFilesInSubscriptionList_Request {
    pub fn new() -> CPublishedFile_AreFilesInSubscriptionList_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 listtype = 3;

    pub fn get_listtype(&self) -> u32 {
        self.listtype.unwrap_or(0)
    }

    pub fn clear_listtype(&mut self) {
        self.listtype = ::std::option::Option::None;
    }

    pub fn has_listtype(&self) -> bool {
        self.listtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listtype(&mut self, v: u32) {
        self.listtype = ::std::option::Option::Some(v);
    }

    // optional uint32 filetype = 4;

    pub fn get_filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }

    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional uint32 workshopfiletype = 5;

    pub fn get_workshopfiletype(&self) -> u32 {
        self.workshopfiletype.unwrap_or(0)
    }

    pub fn clear_workshopfiletype(&mut self) {
        self.workshopfiletype = ::std::option::Option::None;
    }

    pub fn has_workshopfiletype(&self) -> bool {
        self.workshopfiletype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshopfiletype(&mut self, v: u32) {
        self.workshopfiletype = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_AreFilesInSubscriptionList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.listtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.workshopfiletype = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.publishedfileids.len() as u32;
        if let Some(v) = self.listtype {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.workshopfiletype {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfileids {
            os.write_fixed64(2, *v)?;
        };
        if let Some(v) = self.listtype {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filetype {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.workshopfiletype {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AreFilesInSubscriptionList_Request {
        CPublishedFile_AreFilesInSubscriptionList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.appid },
                |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.appid },
                CPublishedFile_AreFilesInSubscriptionList_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "publishedfileids",
                |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.publishedfileids },
                |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.publishedfileids },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "listtype",
                |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.listtype },
                |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.listtype },
                CPublishedFile_AreFilesInSubscriptionList_Request::get_listtype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "filetype",
                |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.filetype },
                |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.filetype },
                CPublishedFile_AreFilesInSubscriptionList_Request::get_filetype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "workshopfiletype",
                |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.workshopfiletype },
                |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.workshopfiletype },
                CPublishedFile_AreFilesInSubscriptionList_Request::get_workshopfiletype,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AreFilesInSubscriptionList_Request>(
                "CPublishedFile_AreFilesInSubscriptionList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_AreFilesInSubscriptionList_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_AreFilesInSubscriptionList_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_AreFilesInSubscriptionList_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_AreFilesInSubscriptionList_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileids.clear();
        self.listtype = ::std::option::Option::None;
        self.filetype = ::std::option::Option::None;
        self.workshopfiletype = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AreFilesInSubscriptionList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AreFilesInSubscriptionList_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_AreFilesInSubscriptionList_Response {
    // message fields
    pub files: ::protobuf::RepeatedField<cpublished_file_are_files_in_subscription_list_response::InList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AreFilesInSubscriptionList_Response {
    fn default() -> &'a CPublishedFile_AreFilesInSubscriptionList_Response {
        <CPublishedFile_AreFilesInSubscriptionList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AreFilesInSubscriptionList_Response {
    pub fn new() -> CPublishedFile_AreFilesInSubscriptionList_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_AreFilesInSubscriptionList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AreFilesInSubscriptionList_Response {
        CPublishedFile_AreFilesInSubscriptionList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_are_files_in_subscription_list_response::InList>>(
                "files",
                |m: &CPublishedFile_AreFilesInSubscriptionList_Response| { &m.files },
                |m: &mut CPublishedFile_AreFilesInSubscriptionList_Response| { &mut m.files },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AreFilesInSubscriptionList_Response>(
                "CPublishedFile_AreFilesInSubscriptionList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_AreFilesInSubscriptionList_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_AreFilesInSubscriptionList_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_AreFilesInSubscriptionList_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_AreFilesInSubscriptionList_Response {
    fn clear(&mut self) {
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AreFilesInSubscriptionList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AreFilesInSubscriptionList_Response {
}

/// Nested message and enums of message `CPublishedFile_AreFilesInSubscriptionList_Response`
pub mod cpublished_file_are_files_in_subscription_list_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct InList {
        // message fields
        publishedfileid: ::std::option::Option<u64>,
        inlist: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a InList {
        fn default() -> &'a InList {
            <InList as ::protobuf::Message>::default_instance()
        }
    }

    impl InList {
        pub fn new() -> InList {
            ::std::default::Default::default()
        }

        // optional fixed64 publishedfileid = 1;

        pub fn get_publishedfileid(&self) -> u64 {
            self.publishedfileid.unwrap_or(0)
        }

        pub fn clear_publishedfileid(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
        }

        pub fn has_publishedfileid(&self) -> bool {
            self.publishedfileid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_publishedfileid(&mut self, v: u64) {
            self.publishedfileid = ::std::option::Option::Some(v);
        }

        // optional bool inlist = 2;

        pub fn get_inlist(&self) -> bool {
            self.inlist.unwrap_or(false)
        }

        pub fn clear_inlist(&mut self) {
            self.inlist = ::std::option::Option::None;
        }

        pub fn has_inlist(&self) -> bool {
            self.inlist.is_some()
        }

        // Param is passed by value, moved
        pub fn set_inlist(&mut self, v: bool) {
            self.inlist = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for InList {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.publishedfileid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.inlist = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.publishedfileid {
                my_size += 9;
            }
            if let Some(v) = self.inlist {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.publishedfileid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.inlist {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> InList {
            InList::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "publishedfileid",
                    |m: &InList| { &m.publishedfileid },
                    |m: &mut InList| { &mut m.publishedfileid },
                    InList::get_publishedfileid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "inlist",
                    |m: &InList| { &m.inlist },
                    |m: &mut InList| { &mut m.inlist },
                    InList::get_inlist,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InList>(
                    "CPublishedFile_AreFilesInSubscriptionList_Response.InList",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static InList {
            static instance: ::protobuf::rt::Lazy<InList> = ::protobuf::rt::Lazy::INIT;
            instance.get(InList::new)
        }
    }

    impl ::protobuf::Clear for InList {
        fn clear(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
            self.inlist = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for InList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InList {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Update_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    publishedfileid: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    file_description: ::protobuf::SingularField<::std::string::String>,
    visibility: ::std::option::Option<u32>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    filename: ::protobuf::SingularField<::std::string::String>,
    preview_filename: ::protobuf::SingularField<::std::string::String>,
    image_width: ::std::option::Option<u32>,
    image_height: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Update_Request {
    fn default() -> &'a CPublishedFile_Update_Request {
        <CPublishedFile_Update_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Update_Request {
    pub fn new() -> CPublishedFile_Update_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 publishedfileid = 2;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional string title = 3;

    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_description = 4;

    pub fn get_file_description(&self) -> &str {
        match self.file_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_description(&mut self) {
        self.file_description.clear();
    }

    pub fn has_file_description(&self) -> bool {
        self.file_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_description(&mut self, v: ::std::string::String) {
        self.file_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_description(&mut self) -> &mut ::std::string::String {
        if self.file_description.is_none() {
            self.file_description.set_default();
        }
        self.file_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_description(&mut self) -> ::std::string::String {
        self.file_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 visibility = 5;

    pub fn get_visibility(&self) -> u32 {
        self.visibility.unwrap_or(0)
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: u32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional string filename = 7;

    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_filename = 8;

    pub fn get_preview_filename(&self) -> &str {
        match self.preview_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preview_filename(&mut self) {
        self.preview_filename.clear();
    }

    pub fn has_preview_filename(&self) -> bool {
        self.preview_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_filename(&mut self, v: ::std::string::String) {
        self.preview_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_filename(&mut self) -> &mut ::std::string::String {
        if self.preview_filename.is_none() {
            self.preview_filename.set_default();
        }
        self.preview_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_filename(&mut self) -> ::std::string::String {
        self.preview_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 image_width = 15;

    pub fn get_image_width(&self) -> u32 {
        self.image_width.unwrap_or(0)
    }

    pub fn clear_image_width(&mut self) {
        self.image_width = ::std::option::Option::None;
    }

    pub fn has_image_width(&self) -> bool {
        self.image_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_width(&mut self, v: u32) {
        self.image_width = ::std::option::Option::Some(v);
    }

    // optional uint32 image_height = 16;

    pub fn get_image_height(&self) -> u32 {
        self.image_height.unwrap_or(0)
    }

    pub fn clear_image_height(&mut self) {
        self.image_height = ::std::option::Option::None;
    }

    pub fn has_image_height(&self) -> bool {
        self.image_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_height(&mut self, v: u32) {
        self.image_height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_Update_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.visibility = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_filename)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.image_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.image_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.file_description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.preview_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.image_width {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_height {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.file_description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_uint32(5, v)?;
        }
        for v in &self.tags {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.filename.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.preview_filename.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.image_width {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.image_height {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Update_Request {
        CPublishedFile_Update_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_Update_Request| { &m.appid },
                |m: &mut CPublishedFile_Update_Request| { &mut m.appid },
                CPublishedFile_Update_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "publishedfileid",
                |m: &CPublishedFile_Update_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_Update_Request| { &mut m.publishedfileid },
                CPublishedFile_Update_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "title",
                |m: &CPublishedFile_Update_Request| { &m.title },
                |m: &mut CPublishedFile_Update_Request| { &mut m.title },
                CPublishedFile_Update_Request::get_title,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "file_description",
                |m: &CPublishedFile_Update_Request| { &m.file_description },
                |m: &mut CPublishedFile_Update_Request| { &mut m.file_description },
                CPublishedFile_Update_Request::get_file_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "visibility",
                |m: &CPublishedFile_Update_Request| { &m.visibility },
                |m: &mut CPublishedFile_Update_Request| { &mut m.visibility },
                CPublishedFile_Update_Request::get_visibility,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "tags",
                |m: &CPublishedFile_Update_Request| { &m.tags },
                |m: &mut CPublishedFile_Update_Request| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "filename",
                |m: &CPublishedFile_Update_Request| { &m.filename },
                |m: &mut CPublishedFile_Update_Request| { &mut m.filename },
                CPublishedFile_Update_Request::get_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "preview_filename",
                |m: &CPublishedFile_Update_Request| { &m.preview_filename },
                |m: &mut CPublishedFile_Update_Request| { &mut m.preview_filename },
                CPublishedFile_Update_Request::get_preview_filename,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "image_width",
                |m: &CPublishedFile_Update_Request| { &m.image_width },
                |m: &mut CPublishedFile_Update_Request| { &mut m.image_width },
                CPublishedFile_Update_Request::get_image_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "image_height",
                |m: &CPublishedFile_Update_Request| { &m.image_height },
                |m: &mut CPublishedFile_Update_Request| { &mut m.image_height },
                CPublishedFile_Update_Request::get_image_height,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Update_Request>(
                "CPublishedFile_Update_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Update_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Update_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Update_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Update_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileid = ::std::option::Option::None;
        self.title.clear();
        self.file_description.clear();
        self.visibility = ::std::option::Option::None;
        self.tags.clear();
        self.filename.clear();
        self.preview_filename.clear();
        self.image_width = ::std::option::Option::None;
        self.image_height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Update_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Update_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_Update_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Update_Response {
    fn default() -> &'a CPublishedFile_Update_Response {
        <CPublishedFile_Update_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Update_Response {
    pub fn new() -> CPublishedFile_Update_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_Update_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Update_Response {
        CPublishedFile_Update_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Update_Response>(
                "CPublishedFile_Update_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_Update_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_Update_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_Update_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_Update_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Update_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Update_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetChangeHistoryEntry_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistoryEntry_Request {
    fn default() -> &'a CPublishedFile_GetChangeHistoryEntry_Request {
        <CPublishedFile_GetChangeHistoryEntry_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistoryEntry_Request {
    pub fn new() -> CPublishedFile_GetChangeHistoryEntry_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 language = 3;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistoryEntry_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistoryEntry_Request {
        CPublishedFile_GetChangeHistoryEntry_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "publishedfileid",
                |m: &CPublishedFile_GetChangeHistoryEntry_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_GetChangeHistoryEntry_Request| { &mut m.publishedfileid },
                CPublishedFile_GetChangeHistoryEntry_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "timestamp",
                |m: &CPublishedFile_GetChangeHistoryEntry_Request| { &m.timestamp },
                |m: &mut CPublishedFile_GetChangeHistoryEntry_Request| { &mut m.timestamp },
                CPublishedFile_GetChangeHistoryEntry_Request::get_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CPublishedFile_GetChangeHistoryEntry_Request| { &m.language },
                |m: &mut CPublishedFile_GetChangeHistoryEntry_Request| { &mut m.language },
                CPublishedFile_GetChangeHistoryEntry_Request::get_language,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistoryEntry_Request>(
                "CPublishedFile_GetChangeHistoryEntry_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistoryEntry_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetChangeHistoryEntry_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetChangeHistoryEntry_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistoryEntry_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistoryEntry_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistoryEntry_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetChangeHistoryEntry_Response {
    // message fields
    change_description: ::protobuf::SingularField<::std::string::String>,
    language: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistoryEntry_Response {
    fn default() -> &'a CPublishedFile_GetChangeHistoryEntry_Response {
        <CPublishedFile_GetChangeHistoryEntry_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistoryEntry_Response {
    pub fn new() -> CPublishedFile_GetChangeHistoryEntry_Response {
        ::std::default::Default::default()
    }

    // optional string change_description = 1;

    pub fn get_change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_change_description(&mut self) {
        self.change_description.clear();
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description.set_default();
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistoryEntry_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.change_description)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.change_description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.change_description.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistoryEntry_Response {
        CPublishedFile_GetChangeHistoryEntry_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "change_description",
                |m: &CPublishedFile_GetChangeHistoryEntry_Response| { &m.change_description },
                |m: &mut CPublishedFile_GetChangeHistoryEntry_Response| { &mut m.change_description },
                CPublishedFile_GetChangeHistoryEntry_Response::get_change_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CPublishedFile_GetChangeHistoryEntry_Response| { &m.language },
                |m: &mut CPublishedFile_GetChangeHistoryEntry_Response| { &mut m.language },
                CPublishedFile_GetChangeHistoryEntry_Response::get_language,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistoryEntry_Response>(
                "CPublishedFile_GetChangeHistoryEntry_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistoryEntry_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetChangeHistoryEntry_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetChangeHistoryEntry_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistoryEntry_Response {
    fn clear(&mut self) {
        self.change_description.clear();
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistoryEntry_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistoryEntry_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetChangeHistory_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    total_only: ::std::option::Option<bool>,
    startindex: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistory_Request {
    fn default() -> &'a CPublishedFile_GetChangeHistory_Request {
        <CPublishedFile_GetChangeHistory_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistory_Request {
    pub fn new() -> CPublishedFile_GetChangeHistory_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional bool total_only = 2;

    pub fn get_total_only(&self) -> bool {
        self.total_only.unwrap_or(false)
    }

    pub fn clear_total_only(&mut self) {
        self.total_only = ::std::option::Option::None;
    }

    pub fn has_total_only(&self) -> bool {
        self.total_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_only(&mut self, v: bool) {
        self.total_only = ::std::option::Option::Some(v);
    }

    // optional uint32 startindex = 3;

    pub fn get_startindex(&self) -> u32 {
        self.startindex.unwrap_or(0)
    }

    pub fn clear_startindex(&mut self) {
        self.startindex = ::std::option::Option::None;
    }

    pub fn has_startindex(&self) -> bool {
        self.startindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startindex(&mut self, v: u32) {
        self.startindex = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 4;

    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 language = 5;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistory_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total_only = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.startindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.total_only {
            my_size += 2;
        }
        if let Some(v) = self.startindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.total_only {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.startindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistory_Request {
        CPublishedFile_GetChangeHistory_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "publishedfileid",
                |m: &CPublishedFile_GetChangeHistory_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.publishedfileid },
                CPublishedFile_GetChangeHistory_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "total_only",
                |m: &CPublishedFile_GetChangeHistory_Request| { &m.total_only },
                |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.total_only },
                CPublishedFile_GetChangeHistory_Request::get_total_only,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "startindex",
                |m: &CPublishedFile_GetChangeHistory_Request| { &m.startindex },
                |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.startindex },
                CPublishedFile_GetChangeHistory_Request::get_startindex,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count",
                |m: &CPublishedFile_GetChangeHistory_Request| { &m.count },
                |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.count },
                CPublishedFile_GetChangeHistory_Request::get_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CPublishedFile_GetChangeHistory_Request| { &m.language },
                |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.language },
                CPublishedFile_GetChangeHistory_Request::get_language,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistory_Request>(
                "CPublishedFile_GetChangeHistory_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistory_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetChangeHistory_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetChangeHistory_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistory_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.total_only = ::std::option::Option::None;
        self.startindex = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistory_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistory_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetChangeHistory_Response {
    // message fields
    pub changes: ::protobuf::RepeatedField<cpublished_file_get_change_history_response::ChangeLog>,
    total: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistory_Response {
    fn default() -> &'a CPublishedFile_GetChangeHistory_Response {
        <CPublishedFile_GetChangeHistory_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistory_Response {
    pub fn new() -> CPublishedFile_GetChangeHistory_Response {
        ::std::default::Default::default()
    }

    // optional uint32 total = 2;

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistory_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.changes)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.changes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistory_Response {
        CPublishedFile_GetChangeHistory_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_change_history_response::ChangeLog>>(
                "changes",
                |m: &CPublishedFile_GetChangeHistory_Response| { &m.changes },
                |m: &mut CPublishedFile_GetChangeHistory_Response| { &mut m.changes },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total",
                |m: &CPublishedFile_GetChangeHistory_Response| { &m.total },
                |m: &mut CPublishedFile_GetChangeHistory_Response| { &mut m.total },
                CPublishedFile_GetChangeHistory_Response::get_total,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistory_Response>(
                "CPublishedFile_GetChangeHistory_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistory_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetChangeHistory_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetChangeHistory_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistory_Response {
    fn clear(&mut self) {
        self.changes.clear();
        self.total = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistory_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistory_Response {
}

/// Nested message and enums of message `CPublishedFile_GetChangeHistory_Response`
pub mod cpublished_file_get_change_history_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct ChangeLog {
        // message fields
        timestamp: ::std::option::Option<u32>,
        change_description: ::protobuf::SingularField<::std::string::String>,
        language: ::std::option::Option<i32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a ChangeLog {
        fn default() -> &'a ChangeLog {
            <ChangeLog as ::protobuf::Message>::default_instance()
        }
    }

    impl ChangeLog {
        pub fn new() -> ChangeLog {
            ::std::default::Default::default()
        }

        // optional uint32 timestamp = 1;

        pub fn get_timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string change_description = 2;

        pub fn get_change_description(&self) -> &str {
            match self.change_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_change_description(&mut self) {
            self.change_description.clear();
        }

        pub fn has_change_description(&self) -> bool {
            self.change_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_change_description(&mut self, v: ::std::string::String) {
            self.change_description = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
            if self.change_description.is_none() {
                self.change_description.set_default();
            }
            self.change_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_change_description(&mut self) -> ::std::string::String {
            self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 language = 3;

        pub fn get_language(&self) -> i32 {
            self.language.unwrap_or(0)
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: i32) {
            self.language = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ChangeLog {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.change_description)?;
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.language = ::std::option::Option::Some(is.read_int32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.change_description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.language {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.change_description.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.language {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> ChangeLog {
            ChangeLog::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "timestamp",
                    |m: &ChangeLog| { &m.timestamp },
                    |m: &mut ChangeLog| { &mut m.timestamp },
                    ChangeLog::get_timestamp,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "change_description",
                    |m: &ChangeLog| { &m.change_description },
                    |m: &mut ChangeLog| { &mut m.change_description },
                    ChangeLog::get_change_description,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "language",
                    |m: &ChangeLog| { &m.language },
                    |m: &mut ChangeLog| { &mut m.language },
                    ChangeLog::get_language,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangeLog>(
                    "CPublishedFile_GetChangeHistory_Response.ChangeLog",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static ChangeLog {
            static instance: ::protobuf::rt::Lazy<ChangeLog> = ::protobuf::rt::Lazy::INIT;
            instance.get(ChangeLog::new)
        }
    }

    impl ::protobuf::Clear for ChangeLog {
        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.change_description.clear();
            self.language = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for ChangeLog {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChangeLog {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_RefreshVotingQueue_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    matching_file_type: ::std::option::Option<u32>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    match_all_tags: ::std::option::Option<bool>,
    pub excluded_tags: ::protobuf::RepeatedField<::std::string::String>,
    desired_queue_size: ::std::option::Option<u32>,
    desired_revision: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EPublishedFileRevision>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RefreshVotingQueue_Request {
    fn default() -> &'a CPublishedFile_RefreshVotingQueue_Request {
        <CPublishedFile_RefreshVotingQueue_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RefreshVotingQueue_Request {
    pub fn new() -> CPublishedFile_RefreshVotingQueue_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_file_type = 2;

    pub fn get_matching_file_type(&self) -> u32 {
        self.matching_file_type.unwrap_or(0)
    }

    pub fn clear_matching_file_type(&mut self) {
        self.matching_file_type = ::std::option::Option::None;
    }

    pub fn has_matching_file_type(&self) -> bool {
        self.matching_file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_file_type(&mut self, v: u32) {
        self.matching_file_type = ::std::option::Option::Some(v);
    }

    // optional bool match_all_tags = 4;

    pub fn get_match_all_tags(&self) -> bool {
        self.match_all_tags.unwrap_or(true)
    }

    pub fn clear_match_all_tags(&mut self) {
        self.match_all_tags = ::std::option::Option::None;
    }

    pub fn has_match_all_tags(&self) -> bool {
        self.match_all_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_all_tags(&mut self, v: bool) {
        self.match_all_tags = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_queue_size = 6;

    pub fn get_desired_queue_size(&self) -> u32 {
        self.desired_queue_size.unwrap_or(0)
    }

    pub fn clear_desired_queue_size(&mut self) {
        self.desired_queue_size = ::std::option::Option::None;
    }

    pub fn has_desired_queue_size(&self) -> bool {
        self.desired_queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_queue_size(&mut self, v: u32) {
        self.desired_queue_size = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 8;

    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        match self.desired_revision {
            Some(e) => e.enum_value_or(EPublishedFileRevision::k_EPublishedFileRevision_Default),
            None => EPublishedFileRevision::k_EPublishedFileRevision_Default,
        }
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CPublishedFile_RefreshVotingQueue_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.matching_file_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.match_all_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excluded_tags)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desired_queue_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desired_revision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_file_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.match_all_tags {
            my_size += 2;
        }
        for value in &self.excluded_tags {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.desired_queue_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_or_unknown_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.matching_file_type {
            os.write_uint32(2, v)?;
        }
        for v in &self.tags {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.match_all_tags {
            os.write_bool(4, v)?;
        }
        for v in &self.excluded_tags {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.desired_queue_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(8, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RefreshVotingQueue_Request {
        CPublishedFile_RefreshVotingQueue_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.appid },
                |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.appid },
                CPublishedFile_RefreshVotingQueue_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "matching_file_type",
                |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.matching_file_type },
                |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.matching_file_type },
                CPublishedFile_RefreshVotingQueue_Request::get_matching_file_type,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "tags",
                |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.tags },
                |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "match_all_tags",
                |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.match_all_tags },
                |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.match_all_tags },
                CPublishedFile_RefreshVotingQueue_Request::get_match_all_tags,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "excluded_tags",
                |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.excluded_tags },
                |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.excluded_tags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "desired_queue_size",
                |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.desired_queue_size },
                |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.desired_queue_size },
                CPublishedFile_RefreshVotingQueue_Request::get_desired_queue_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EPublishedFileRevision>(
                "desired_revision",
                |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.desired_revision },
                |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.desired_revision },
                EPublishedFileRevision::k_EPublishedFileRevision_Default,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RefreshVotingQueue_Request>(
                "CPublishedFile_RefreshVotingQueue_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_RefreshVotingQueue_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_RefreshVotingQueue_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_RefreshVotingQueue_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_RefreshVotingQueue_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.matching_file_type = ::std::option::Option::None;
        self.tags.clear();
        self.match_all_tags = ::std::option::Option::None;
        self.excluded_tags.clear();
        self.desired_queue_size = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RefreshVotingQueue_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RefreshVotingQueue_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_RefreshVotingQueue_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RefreshVotingQueue_Response {
    fn default() -> &'a CPublishedFile_RefreshVotingQueue_Response {
        <CPublishedFile_RefreshVotingQueue_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RefreshVotingQueue_Response {
    pub fn new() -> CPublishedFile_RefreshVotingQueue_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_RefreshVotingQueue_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RefreshVotingQueue_Response {
        CPublishedFile_RefreshVotingQueue_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RefreshVotingQueue_Response>(
                "CPublishedFile_RefreshVotingQueue_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_RefreshVotingQueue_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_RefreshVotingQueue_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_RefreshVotingQueue_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_RefreshVotingQueue_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RefreshVotingQueue_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RefreshVotingQueue_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_QueryFiles_Request {
    // message fields
    query_type: ::std::option::Option<u32>,
    page: ::std::option::Option<u32>,
    cursor: ::protobuf::SingularField<::std::string::String>,
    numperpage: ::std::option::Option<u32>,
    creator_appid: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    pub requiredtags: ::protobuf::RepeatedField<::std::string::String>,
    pub excludedtags: ::protobuf::RepeatedField<::std::string::String>,
    match_all_tags: ::std::option::Option<bool>,
    pub required_flags: ::protobuf::RepeatedField<::std::string::String>,
    pub omitted_flags: ::protobuf::RepeatedField<::std::string::String>,
    search_text: ::protobuf::SingularField<::std::string::String>,
    filetype: ::std::option::Option<u32>,
    child_publishedfileid: ::std::option::Option<u64>,
    days: ::std::option::Option<u32>,
    include_recent_votes_only: ::std::option::Option<bool>,
    cache_max_age_seconds: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    pub required_kv_tags: ::protobuf::RepeatedField<cpublished_file_query_files_request::KVTag>,
    pub taggroups: ::protobuf::RepeatedField<cpublished_file_query_files_request::TagGroup>,
    totalonly: ::std::option::Option<bool>,
    ids_only: ::std::option::Option<bool>,
    return_vote_data: ::std::option::Option<bool>,
    return_tags: ::std::option::Option<bool>,
    return_kv_tags: ::std::option::Option<bool>,
    return_previews: ::std::option::Option<bool>,
    return_children: ::std::option::Option<bool>,
    return_short_description: ::std::option::Option<bool>,
    return_for_sale_data: ::std::option::Option<bool>,
    return_metadata: ::std::option::Option<bool>,
    return_playtime_stats: ::std::option::Option<u32>,
    return_details: ::std::option::Option<bool>,
    strip_description_bbcode: ::std::option::Option<bool>,
    desired_revision: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EPublishedFileRevision>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_QueryFiles_Request {
    fn default() -> &'a CPublishedFile_QueryFiles_Request {
        <CPublishedFile_QueryFiles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_QueryFiles_Request {
    pub fn new() -> CPublishedFile_QueryFiles_Request {
        ::std::default::Default::default()
    }

    // optional uint32 query_type = 1;

    pub fn get_query_type(&self) -> u32 {
        self.query_type.unwrap_or(0)
    }

    pub fn clear_query_type(&mut self) {
        self.query_type = ::std::option::Option::None;
    }

    pub fn has_query_type(&self) -> bool {
        self.query_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_type(&mut self, v: u32) {
        self.query_type = ::std::option::Option::Some(v);
    }

    // optional uint32 page = 2;

    pub fn get_page(&self) -> u32 {
        self.page.unwrap_or(0)
    }

    pub fn clear_page(&mut self) {
        self.page = ::std::option::Option::None;
    }

    pub fn has_page(&self) -> bool {
        self.page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = ::std::option::Option::Some(v);
    }

    // optional string cursor = 39;

    pub fn get_cursor(&self) -> &str {
        match self.cursor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        if self.cursor.is_none() {
            self.cursor.set_default();
        }
        self.cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        self.cursor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 numperpage = 3;

    pub fn get_numperpage(&self) -> u32 {
        self.numperpage.unwrap_or(1u32)
    }

    pub fn clear_numperpage(&mut self) {
        self.numperpage = ::std::option::Option::None;
    }

    pub fn has_numperpage(&self) -> bool {
        self.numperpage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numperpage(&mut self, v: u32) {
        self.numperpage = ::std::option::Option::Some(v);
    }

    // optional uint32 creator_appid = 4;

    pub fn get_creator_appid(&self) -> u32 {
        self.creator_appid.unwrap_or(0)
    }

    pub fn clear_creator_appid(&mut self) {
        self.creator_appid = ::std::option::Option::None;
    }

    pub fn has_creator_appid(&self) -> bool {
        self.creator_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_appid(&mut self, v: u32) {
        self.creator_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 5;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool match_all_tags = 8;

    pub fn get_match_all_tags(&self) -> bool {
        self.match_all_tags.unwrap_or(true)
    }

    pub fn clear_match_all_tags(&mut self) {
        self.match_all_tags = ::std::option::Option::None;
    }

    pub fn has_match_all_tags(&self) -> bool {
        self.match_all_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_all_tags(&mut self, v: bool) {
        self.match_all_tags = ::std::option::Option::Some(v);
    }

    // optional string search_text = 11;

    pub fn get_search_text(&self) -> &str {
        match self.search_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_text(&mut self) {
        self.search_text.clear();
    }

    pub fn has_search_text(&self) -> bool {
        self.search_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_text(&mut self, v: ::std::string::String) {
        self.search_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_text(&mut self) -> &mut ::std::string::String {
        if self.search_text.is_none() {
            self.search_text.set_default();
        }
        self.search_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_text(&mut self) -> ::std::string::String {
        self.search_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 filetype = 12;

    pub fn get_filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }

    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional fixed64 child_publishedfileid = 13;

    pub fn get_child_publishedfileid(&self) -> u64 {
        self.child_publishedfileid.unwrap_or(0)
    }

    pub fn clear_child_publishedfileid(&mut self) {
        self.child_publishedfileid = ::std::option::Option::None;
    }

    pub fn has_child_publishedfileid(&self) -> bool {
        self.child_publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_publishedfileid(&mut self, v: u64) {
        self.child_publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 days = 14;

    pub fn get_days(&self) -> u32 {
        self.days.unwrap_or(0)
    }

    pub fn clear_days(&mut self) {
        self.days = ::std::option::Option::None;
    }

    pub fn has_days(&self) -> bool {
        self.days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days(&mut self, v: u32) {
        self.days = ::std::option::Option::Some(v);
    }

    // optional bool include_recent_votes_only = 15;

    pub fn get_include_recent_votes_only(&self) -> bool {
        self.include_recent_votes_only.unwrap_or(false)
    }

    pub fn clear_include_recent_votes_only(&mut self) {
        self.include_recent_votes_only = ::std::option::Option::None;
    }

    pub fn has_include_recent_votes_only(&self) -> bool {
        self.include_recent_votes_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_recent_votes_only(&mut self, v: bool) {
        self.include_recent_votes_only = ::std::option::Option::Some(v);
    }

    // optional uint32 cache_max_age_seconds = 31;

    pub fn get_cache_max_age_seconds(&self) -> u32 {
        self.cache_max_age_seconds.unwrap_or(0u32)
    }

    pub fn clear_cache_max_age_seconds(&mut self) {
        self.cache_max_age_seconds = ::std::option::Option::None;
    }

    pub fn has_cache_max_age_seconds(&self) -> bool {
        self.cache_max_age_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_max_age_seconds(&mut self, v: u32) {
        self.cache_max_age_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 language = 33;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool totalonly = 16;

    pub fn get_totalonly(&self) -> bool {
        self.totalonly.unwrap_or(false)
    }

    pub fn clear_totalonly(&mut self) {
        self.totalonly = ::std::option::Option::None;
    }

    pub fn has_totalonly(&self) -> bool {
        self.totalonly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalonly(&mut self, v: bool) {
        self.totalonly = ::std::option::Option::Some(v);
    }

    // optional bool ids_only = 35;

    pub fn get_ids_only(&self) -> bool {
        self.ids_only.unwrap_or(false)
    }

    pub fn clear_ids_only(&mut self) {
        self.ids_only = ::std::option::Option::None;
    }

    pub fn has_ids_only(&self) -> bool {
        self.ids_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ids_only(&mut self, v: bool) {
        self.ids_only = ::std::option::Option::Some(v);
    }

    // optional bool return_vote_data = 17;

    pub fn get_return_vote_data(&self) -> bool {
        self.return_vote_data.unwrap_or(false)
    }

    pub fn clear_return_vote_data(&mut self) {
        self.return_vote_data = ::std::option::Option::None;
    }

    pub fn has_return_vote_data(&self) -> bool {
        self.return_vote_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_vote_data(&mut self, v: bool) {
        self.return_vote_data = ::std::option::Option::Some(v);
    }

    // optional bool return_tags = 18;

    pub fn get_return_tags(&self) -> bool {
        self.return_tags.unwrap_or(false)
    }

    pub fn clear_return_tags(&mut self) {
        self.return_tags = ::std::option::Option::None;
    }

    pub fn has_return_tags(&self) -> bool {
        self.return_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_tags(&mut self, v: bool) {
        self.return_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_kv_tags = 19;

    pub fn get_return_kv_tags(&self) -> bool {
        self.return_kv_tags.unwrap_or(false)
    }

    pub fn clear_return_kv_tags(&mut self) {
        self.return_kv_tags = ::std::option::Option::None;
    }

    pub fn has_return_kv_tags(&self) -> bool {
        self.return_kv_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_kv_tags(&mut self, v: bool) {
        self.return_kv_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_previews = 20;

    pub fn get_return_previews(&self) -> bool {
        self.return_previews.unwrap_or(false)
    }

    pub fn clear_return_previews(&mut self) {
        self.return_previews = ::std::option::Option::None;
    }

    pub fn has_return_previews(&self) -> bool {
        self.return_previews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_previews(&mut self, v: bool) {
        self.return_previews = ::std::option::Option::Some(v);
    }

    // optional bool return_children = 21;

    pub fn get_return_children(&self) -> bool {
        self.return_children.unwrap_or(false)
    }

    pub fn clear_return_children(&mut self) {
        self.return_children = ::std::option::Option::None;
    }

    pub fn has_return_children(&self) -> bool {
        self.return_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_children(&mut self, v: bool) {
        self.return_children = ::std::option::Option::Some(v);
    }

    // optional bool return_short_description = 22;

    pub fn get_return_short_description(&self) -> bool {
        self.return_short_description.unwrap_or(false)
    }

    pub fn clear_return_short_description(&mut self) {
        self.return_short_description = ::std::option::Option::None;
    }

    pub fn has_return_short_description(&self) -> bool {
        self.return_short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_short_description(&mut self, v: bool) {
        self.return_short_description = ::std::option::Option::Some(v);
    }

    // optional bool return_for_sale_data = 30;

    pub fn get_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.unwrap_or(false)
    }

    pub fn clear_return_for_sale_data(&mut self) {
        self.return_for_sale_data = ::std::option::Option::None;
    }

    pub fn has_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_for_sale_data(&mut self, v: bool) {
        self.return_for_sale_data = ::std::option::Option::Some(v);
    }

    // optional bool return_metadata = 32;

    pub fn get_return_metadata(&self) -> bool {
        self.return_metadata.unwrap_or(false)
    }

    pub fn clear_return_metadata(&mut self) {
        self.return_metadata = ::std::option::Option::None;
    }

    pub fn has_return_metadata(&self) -> bool {
        self.return_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_metadata(&mut self, v: bool) {
        self.return_metadata = ::std::option::Option::Some(v);
    }

    // optional uint32 return_playtime_stats = 36;

    pub fn get_return_playtime_stats(&self) -> u32 {
        self.return_playtime_stats.unwrap_or(0)
    }

    pub fn clear_return_playtime_stats(&mut self) {
        self.return_playtime_stats = ::std::option::Option::None;
    }

    pub fn has_return_playtime_stats(&self) -> bool {
        self.return_playtime_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_playtime_stats(&mut self, v: u32) {
        self.return_playtime_stats = ::std::option::Option::Some(v);
    }

    // optional bool return_details = 37;

    pub fn get_return_details(&self) -> bool {
        self.return_details.unwrap_or(false)
    }

    pub fn clear_return_details(&mut self) {
        self.return_details = ::std::option::Option::None;
    }

    pub fn has_return_details(&self) -> bool {
        self.return_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_details(&mut self, v: bool) {
        self.return_details = ::std::option::Option::Some(v);
    }

    // optional bool strip_description_bbcode = 38;

    pub fn get_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.unwrap_or(false)
    }

    pub fn clear_strip_description_bbcode(&mut self) {
        self.strip_description_bbcode = ::std::option::Option::None;
    }

    pub fn has_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_description_bbcode(&mut self, v: bool) {
        self.strip_description_bbcode = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 40;

    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        match self.desired_revision {
            Some(e) => e.enum_value_or(EPublishedFileRevision::k_EPublishedFileRevision_Default),
            None => EPublishedFileRevision::k_EPublishedFileRevision_Default,
        }
    }

    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CPublishedFile_QueryFiles_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.required_kv_tags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.taggroups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.page = ::std::option::Option::Some(is.read_uint32()?);
                },
                39 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.numperpage = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.creator_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.requiredtags)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludedtags)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.match_all_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.required_flags)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.omitted_flags)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.search_text)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.child_publishedfileid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.days = ::std::option::Option::Some(is.read_uint32()?);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.include_recent_votes_only = ::std::option::Option::Some(is.read_bool()?);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cache_max_age_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.required_kv_tags)?;
                },
                42 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.taggroups)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.totalonly = ::std::option::Option::Some(is.read_bool()?);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ids_only = ::std::option::Option::Some(is.read_bool()?);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_vote_data = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_kv_tags = ::std::option::Option::Some(is.read_bool()?);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_previews = ::std::option::Option::Some(is.read_bool()?);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_children = ::std::option::Option::Some(is.read_bool()?);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_short_description = ::std::option::Option::Some(is.read_bool()?);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_for_sale_data = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_metadata = ::std::option::Option::Some(is.read_bool()?);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_playtime_stats = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.return_details = ::std::option::Option::Some(is.read_bool()?);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.strip_description_bbcode = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desired_revision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.query_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.page {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cursor.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.numperpage {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator_appid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requiredtags {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.excludedtags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.match_all_tags {
            my_size += 2;
        }
        for value in &self.required_flags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.omitted_flags {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.search_text.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.days {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.include_recent_votes_only {
            my_size += 2;
        }
        if let Some(v) = self.cache_max_age_seconds {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.required_kv_tags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.taggroups {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.totalonly {
            my_size += 3;
        }
        if let Some(v) = self.ids_only {
            my_size += 3;
        }
        if let Some(v) = self.return_vote_data {
            my_size += 3;
        }
        if let Some(v) = self.return_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_kv_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_previews {
            my_size += 3;
        }
        if let Some(v) = self.return_children {
            my_size += 3;
        }
        if let Some(v) = self.return_short_description {
            my_size += 3;
        }
        if let Some(v) = self.return_for_sale_data {
            my_size += 3;
        }
        if let Some(v) = self.return_metadata {
            my_size += 3;
        }
        if let Some(v) = self.return_playtime_stats {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.return_details {
            my_size += 3;
        }
        if let Some(v) = self.strip_description_bbcode {
            my_size += 3;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_or_unknown_size(40, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.query_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.page {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cursor.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.numperpage {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.creator_appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        for v in &self.requiredtags {
            os.write_string(6, &v)?;
        };
        for v in &self.excludedtags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.match_all_tags {
            os.write_bool(8, v)?;
        }
        for v in &self.required_flags {
            os.write_string(9, &v)?;
        };
        for v in &self.omitted_flags {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.search_text.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.filetype {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.child_publishedfileid {
            os.write_fixed64(13, v)?;
        }
        if let Some(v) = self.days {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.include_recent_votes_only {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.cache_max_age_seconds {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(33, v)?;
        }
        for v in &self.required_kv_tags {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        };
        for v in &self.taggroups {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        if let Some(v) = self.totalonly {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.ids_only {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.return_vote_data {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.return_tags {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.return_kv_tags {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.return_previews {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.return_children {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.return_short_description {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.return_for_sale_data {
            os.write_bool(30, v)?;
        }
        if let Some(v) = self.return_metadata {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.return_playtime_stats {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.return_details {
            os.write_bool(37, v)?;
        }
        if let Some(v) = self.strip_description_bbcode {
            os.write_bool(38, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(40, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_QueryFiles_Request {
        CPublishedFile_QueryFiles_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "query_type",
                |m: &CPublishedFile_QueryFiles_Request| { &m.query_type },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.query_type },
                CPublishedFile_QueryFiles_Request::get_query_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "page",
                |m: &CPublishedFile_QueryFiles_Request| { &m.page },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.page },
                CPublishedFile_QueryFiles_Request::get_page,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "cursor",
                |m: &CPublishedFile_QueryFiles_Request| { &m.cursor },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.cursor },
                CPublishedFile_QueryFiles_Request::get_cursor,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "numperpage",
                |m: &CPublishedFile_QueryFiles_Request| { &m.numperpage },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.numperpage },
                CPublishedFile_QueryFiles_Request::get_numperpage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "creator_appid",
                |m: &CPublishedFile_QueryFiles_Request| { &m.creator_appid },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.creator_appid },
                CPublishedFile_QueryFiles_Request::get_creator_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_QueryFiles_Request| { &m.appid },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.appid },
                CPublishedFile_QueryFiles_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "requiredtags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.requiredtags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.requiredtags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "excludedtags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.excludedtags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.excludedtags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "match_all_tags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.match_all_tags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.match_all_tags },
                CPublishedFile_QueryFiles_Request::get_match_all_tags,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "required_flags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.required_flags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.required_flags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                "omitted_flags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.omitted_flags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.omitted_flags },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "search_text",
                |m: &CPublishedFile_QueryFiles_Request| { &m.search_text },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.search_text },
                CPublishedFile_QueryFiles_Request::get_search_text,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "filetype",
                |m: &CPublishedFile_QueryFiles_Request| { &m.filetype },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.filetype },
                CPublishedFile_QueryFiles_Request::get_filetype,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "child_publishedfileid",
                |m: &CPublishedFile_QueryFiles_Request| { &m.child_publishedfileid },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.child_publishedfileid },
                CPublishedFile_QueryFiles_Request::get_child_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "days",
                |m: &CPublishedFile_QueryFiles_Request| { &m.days },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.days },
                CPublishedFile_QueryFiles_Request::get_days,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "include_recent_votes_only",
                |m: &CPublishedFile_QueryFiles_Request| { &m.include_recent_votes_only },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.include_recent_votes_only },
                CPublishedFile_QueryFiles_Request::get_include_recent_votes_only,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cache_max_age_seconds",
                |m: &CPublishedFile_QueryFiles_Request| { &m.cache_max_age_seconds },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.cache_max_age_seconds },
                CPublishedFile_QueryFiles_Request::get_cache_max_age_seconds,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CPublishedFile_QueryFiles_Request| { &m.language },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.language },
                CPublishedFile_QueryFiles_Request::get_language,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_query_files_request::KVTag>>(
                "required_kv_tags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.required_kv_tags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.required_kv_tags },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_query_files_request::TagGroup>>(
                "taggroups",
                |m: &CPublishedFile_QueryFiles_Request| { &m.taggroups },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.taggroups },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "totalonly",
                |m: &CPublishedFile_QueryFiles_Request| { &m.totalonly },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.totalonly },
                CPublishedFile_QueryFiles_Request::get_totalonly,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "ids_only",
                |m: &CPublishedFile_QueryFiles_Request| { &m.ids_only },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.ids_only },
                CPublishedFile_QueryFiles_Request::get_ids_only,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_vote_data",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_vote_data },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_vote_data },
                CPublishedFile_QueryFiles_Request::get_return_vote_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_tags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_tags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_tags },
                CPublishedFile_QueryFiles_Request::get_return_tags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_kv_tags",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_kv_tags },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_kv_tags },
                CPublishedFile_QueryFiles_Request::get_return_kv_tags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_previews",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_previews },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_previews },
                CPublishedFile_QueryFiles_Request::get_return_previews,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_children",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_children },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_children },
                CPublishedFile_QueryFiles_Request::get_return_children,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_short_description",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_short_description },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_short_description },
                CPublishedFile_QueryFiles_Request::get_return_short_description,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_for_sale_data",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_for_sale_data },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_for_sale_data },
                CPublishedFile_QueryFiles_Request::get_return_for_sale_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_metadata",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_metadata },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_metadata },
                CPublishedFile_QueryFiles_Request::get_return_metadata,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "return_playtime_stats",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_playtime_stats },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_playtime_stats },
                CPublishedFile_QueryFiles_Request::get_return_playtime_stats,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "return_details",
                |m: &CPublishedFile_QueryFiles_Request| { &m.return_details },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_details },
                CPublishedFile_QueryFiles_Request::get_return_details,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "strip_description_bbcode",
                |m: &CPublishedFile_QueryFiles_Request| { &m.strip_description_bbcode },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.strip_description_bbcode },
                CPublishedFile_QueryFiles_Request::get_strip_description_bbcode,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EPublishedFileRevision>(
                "desired_revision",
                |m: &CPublishedFile_QueryFiles_Request| { &m.desired_revision },
                |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.desired_revision },
                EPublishedFileRevision::k_EPublishedFileRevision_Default,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_QueryFiles_Request>(
                "CPublishedFile_QueryFiles_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_QueryFiles_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_QueryFiles_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_QueryFiles_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_QueryFiles_Request {
    fn clear(&mut self) {
        self.query_type = ::std::option::Option::None;
        self.page = ::std::option::Option::None;
        self.cursor.clear();
        self.numperpage = ::std::option::Option::None;
        self.creator_appid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.requiredtags.clear();
        self.excludedtags.clear();
        self.match_all_tags = ::std::option::Option::None;
        self.required_flags.clear();
        self.omitted_flags.clear();
        self.search_text.clear();
        self.filetype = ::std::option::Option::None;
        self.child_publishedfileid = ::std::option::Option::None;
        self.days = ::std::option::Option::None;
        self.include_recent_votes_only = ::std::option::Option::None;
        self.cache_max_age_seconds = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.required_kv_tags.clear();
        self.taggroups.clear();
        self.totalonly = ::std::option::Option::None;
        self.ids_only = ::std::option::Option::None;
        self.return_vote_data = ::std::option::Option::None;
        self.return_tags = ::std::option::Option::None;
        self.return_kv_tags = ::std::option::Option::None;
        self.return_previews = ::std::option::Option::None;
        self.return_children = ::std::option::Option::None;
        self.return_short_description = ::std::option::Option::None;
        self.return_for_sale_data = ::std::option::Option::None;
        self.return_metadata = ::std::option::Option::None;
        self.return_playtime_stats = ::std::option::Option::None;
        self.return_details = ::std::option::Option::None;
        self.strip_description_bbcode = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_QueryFiles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_QueryFiles_Request {
}

/// Nested message and enums of message `CPublishedFile_QueryFiles_Request`
pub mod cpublished_file_query_files_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct KVTag {
        // message fields
        key: ::protobuf::SingularField<::std::string::String>,
        value: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a KVTag {
        fn default() -> &'a KVTag {
            <KVTag as ::protobuf::Message>::default_instance()
        }
    }

    impl KVTag {
        pub fn new() -> KVTag {
            ::std::default::Default::default()
        }

        // optional string key = 1;

        pub fn get_key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key.clear();
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key.set_default();
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn get_value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value.clear();
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value.set_default();
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for KVTag {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.key.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> KVTag {
            KVTag::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "key",
                    |m: &KVTag| { &m.key },
                    |m: &mut KVTag| { &mut m.key },
                    KVTag::get_key,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "value",
                    |m: &KVTag| { &m.value },
                    |m: &mut KVTag| { &mut m.value },
                    KVTag::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KVTag>(
                    "CPublishedFile_QueryFiles_Request.KVTag",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static KVTag {
            static instance: ::protobuf::rt::Lazy<KVTag> = ::protobuf::rt::Lazy::INIT;
            instance.get(KVTag::new)
        }
    }

    impl ::protobuf::Clear for KVTag {
        fn clear(&mut self) {
            self.key.clear();
            self.value.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for KVTag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KVTag {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct TagGroup {
        // message fields
        pub tags: ::protobuf::RepeatedField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a TagGroup {
        fn default() -> &'a TagGroup {
            <TagGroup as ::protobuf::Message>::default_instance()
        }
    }

    impl TagGroup {
        pub fn new() -> TagGroup {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for TagGroup {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            for value in &self.tags {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            for v in &self.tags {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> TagGroup {
            TagGroup::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                    "tags",
                    |m: &TagGroup| { &m.tags },
                    |m: &mut TagGroup| { &mut m.tags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TagGroup>(
                    "CPublishedFile_QueryFiles_Request.TagGroup",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static TagGroup {
            static instance: ::protobuf::rt::Lazy<TagGroup> = ::protobuf::rt::Lazy::INIT;
            instance.get(TagGroup::new)
        }
    }

    impl ::protobuf::Clear for TagGroup {
        fn clear(&mut self) {
            self.tags.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for TagGroup {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TagGroup {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_QueryFiles_Response {
    // message fields
    total: ::std::option::Option<u32>,
    pub publishedfiledetails: ::protobuf::RepeatedField<PublishedFileDetails>,
    next_cursor: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_QueryFiles_Response {
    fn default() -> &'a CPublishedFile_QueryFiles_Response {
        <CPublishedFile_QueryFiles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_QueryFiles_Response {
    pub fn new() -> CPublishedFile_QueryFiles_Response {
        ::std::default::Default::default()
    }

    // optional uint32 total = 1;

    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional string next_cursor = 3;

    pub fn get_next_cursor(&self) -> &str {
        match self.next_cursor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_next_cursor(&mut self) {
        self.next_cursor.clear();
    }

    pub fn has_next_cursor(&self) -> bool {
        self.next_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_cursor(&mut self, v: ::std::string::String) {
        self.next_cursor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_cursor(&mut self) -> &mut ::std::string::String {
        if self.next_cursor.is_none() {
            self.next_cursor.set_default();
        }
        self.next_cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_cursor(&mut self) -> ::std::string::String {
        self.next_cursor.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_QueryFiles_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.publishedfiledetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.total = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.publishedfiledetails)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.next_cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfiledetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.next_cursor.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfiledetails {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.next_cursor.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_QueryFiles_Response {
        CPublishedFile_QueryFiles_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "total",
                |m: &CPublishedFile_QueryFiles_Response| { &m.total },
                |m: &mut CPublishedFile_QueryFiles_Response| { &mut m.total },
                CPublishedFile_QueryFiles_Response::get_total,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<PublishedFileDetails>>(
                "publishedfiledetails",
                |m: &CPublishedFile_QueryFiles_Response| { &m.publishedfiledetails },
                |m: &mut CPublishedFile_QueryFiles_Response| { &mut m.publishedfiledetails },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "next_cursor",
                |m: &CPublishedFile_QueryFiles_Response| { &m.next_cursor },
                |m: &mut CPublishedFile_QueryFiles_Response| { &mut m.next_cursor },
                CPublishedFile_QueryFiles_Response::get_next_cursor,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_QueryFiles_Response>(
                "CPublishedFile_QueryFiles_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_QueryFiles_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_QueryFiles_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_QueryFiles_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_QueryFiles_Response {
    fn clear(&mut self) {
        self.total = ::std::option::Option::None;
        self.publishedfiledetails.clear();
        self.next_cursor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_QueryFiles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_QueryFiles_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_AddAppRelationship_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    relationship: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddAppRelationship_Request {
    fn default() -> &'a CPublishedFile_AddAppRelationship_Request {
        <CPublishedFile_AddAppRelationship_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddAppRelationship_Request {
    pub fn new() -> CPublishedFile_AddAppRelationship_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 relationship = 3;

    pub fn get_relationship(&self) -> u32 {
        self.relationship.unwrap_or(0)
    }

    pub fn clear_relationship(&mut self) {
        self.relationship = ::std::option::Option::None;
    }

    pub fn has_relationship(&self) -> bool {
        self.relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relationship(&mut self, v: u32) {
        self.relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_AddAppRelationship_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.relationship = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relationship {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.relationship {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddAppRelationship_Request {
        CPublishedFile_AddAppRelationship_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_AddAppRelationship_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_AddAppRelationship_Request| { &mut m.publishedfileid },
                CPublishedFile_AddAppRelationship_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_AddAppRelationship_Request| { &m.appid },
                |m: &mut CPublishedFile_AddAppRelationship_Request| { &mut m.appid },
                CPublishedFile_AddAppRelationship_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "relationship",
                |m: &CPublishedFile_AddAppRelationship_Request| { &m.relationship },
                |m: &mut CPublishedFile_AddAppRelationship_Request| { &mut m.relationship },
                CPublishedFile_AddAppRelationship_Request::get_relationship,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddAppRelationship_Request>(
                "CPublishedFile_AddAppRelationship_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_AddAppRelationship_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_AddAppRelationship_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_AddAppRelationship_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_AddAppRelationship_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddAppRelationship_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddAppRelationship_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_AddAppRelationship_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddAppRelationship_Response {
    fn default() -> &'a CPublishedFile_AddAppRelationship_Response {
        <CPublishedFile_AddAppRelationship_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddAppRelationship_Response {
    pub fn new() -> CPublishedFile_AddAppRelationship_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_AddAppRelationship_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddAppRelationship_Response {
        CPublishedFile_AddAppRelationship_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddAppRelationship_Response>(
                "CPublishedFile_AddAppRelationship_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_AddAppRelationship_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_AddAppRelationship_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_AddAppRelationship_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_AddAppRelationship_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddAppRelationship_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddAppRelationship_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_RemoveAppRelationship_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    relationship: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveAppRelationship_Request {
    fn default() -> &'a CPublishedFile_RemoveAppRelationship_Request {
        <CPublishedFile_RemoveAppRelationship_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveAppRelationship_Request {
    pub fn new() -> CPublishedFile_RemoveAppRelationship_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 relationship = 3;

    pub fn get_relationship(&self) -> u32 {
        self.relationship.unwrap_or(0)
    }

    pub fn clear_relationship(&mut self) {
        self.relationship = ::std::option::Option::None;
    }

    pub fn has_relationship(&self) -> bool {
        self.relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relationship(&mut self, v: u32) {
        self.relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveAppRelationship_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.relationship = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relationship {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.relationship {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveAppRelationship_Request {
        CPublishedFile_RemoveAppRelationship_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_RemoveAppRelationship_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_RemoveAppRelationship_Request| { &mut m.publishedfileid },
                CPublishedFile_RemoveAppRelationship_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_RemoveAppRelationship_Request| { &m.appid },
                |m: &mut CPublishedFile_RemoveAppRelationship_Request| { &mut m.appid },
                CPublishedFile_RemoveAppRelationship_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "relationship",
                |m: &CPublishedFile_RemoveAppRelationship_Request| { &m.relationship },
                |m: &mut CPublishedFile_RemoveAppRelationship_Request| { &mut m.relationship },
                CPublishedFile_RemoveAppRelationship_Request::get_relationship,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveAppRelationship_Request>(
                "CPublishedFile_RemoveAppRelationship_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_RemoveAppRelationship_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_RemoveAppRelationship_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_RemoveAppRelationship_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveAppRelationship_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveAppRelationship_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveAppRelationship_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_RemoveAppRelationship_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveAppRelationship_Response {
    fn default() -> &'a CPublishedFile_RemoveAppRelationship_Response {
        <CPublishedFile_RemoveAppRelationship_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveAppRelationship_Response {
    pub fn new() -> CPublishedFile_RemoveAppRelationship_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveAppRelationship_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveAppRelationship_Response {
        CPublishedFile_RemoveAppRelationship_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveAppRelationship_Response>(
                "CPublishedFile_RemoveAppRelationship_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_RemoveAppRelationship_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_RemoveAppRelationship_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_RemoveAppRelationship_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveAppRelationship_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveAppRelationship_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveAppRelationship_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetAppRelationships_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetAppRelationships_Request {
    fn default() -> &'a CPublishedFile_GetAppRelationships_Request {
        <CPublishedFile_GetAppRelationships_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetAppRelationships_Request {
    pub fn new() -> CPublishedFile_GetAppRelationships_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetAppRelationships_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetAppRelationships_Request {
        CPublishedFile_GetAppRelationships_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_GetAppRelationships_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_GetAppRelationships_Request| { &mut m.publishedfileid },
                CPublishedFile_GetAppRelationships_Request::get_publishedfileid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetAppRelationships_Request>(
                "CPublishedFile_GetAppRelationships_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetAppRelationships_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetAppRelationships_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetAppRelationships_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetAppRelationships_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetAppRelationships_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetAppRelationships_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetAppRelationships_Response {
    // message fields
    pub app_relationships: ::protobuf::RepeatedField<cpublished_file_get_app_relationships_response::AppRelationship>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetAppRelationships_Response {
    fn default() -> &'a CPublishedFile_GetAppRelationships_Response {
        <CPublishedFile_GetAppRelationships_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetAppRelationships_Response {
    pub fn new() -> CPublishedFile_GetAppRelationships_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_GetAppRelationships_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.app_relationships {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.app_relationships)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.app_relationships {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.app_relationships {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetAppRelationships_Response {
        CPublishedFile_GetAppRelationships_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_app_relationships_response::AppRelationship>>(
                "app_relationships",
                |m: &CPublishedFile_GetAppRelationships_Response| { &m.app_relationships },
                |m: &mut CPublishedFile_GetAppRelationships_Response| { &mut m.app_relationships },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetAppRelationships_Response>(
                "CPublishedFile_GetAppRelationships_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetAppRelationships_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetAppRelationships_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetAppRelationships_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetAppRelationships_Response {
    fn clear(&mut self) {
        self.app_relationships.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetAppRelationships_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetAppRelationships_Response {
}

/// Nested message and enums of message `CPublishedFile_GetAppRelationships_Response`
pub mod cpublished_file_get_app_relationships_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct AppRelationship {
        // message fields
        appid: ::std::option::Option<u32>,
        relationship: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AppRelationship {
        fn default() -> &'a AppRelationship {
            <AppRelationship as ::protobuf::Message>::default_instance()
        }
    }

    impl AppRelationship {
        pub fn new() -> AppRelationship {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 relationship = 2;

        pub fn get_relationship(&self) -> u32 {
            self.relationship.unwrap_or(0)
        }

        pub fn clear_relationship(&mut self) {
            self.relationship = ::std::option::Option::None;
        }

        pub fn has_relationship(&self) -> bool {
            self.relationship.is_some()
        }

        // Param is passed by value, moved
        pub fn set_relationship(&mut self, v: u32) {
            self.relationship = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AppRelationship {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.relationship = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.relationship {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.relationship {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AppRelationship {
            AppRelationship::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &AppRelationship| { &m.appid },
                    |m: &mut AppRelationship| { &mut m.appid },
                    AppRelationship::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "relationship",
                    |m: &AppRelationship| { &m.relationship },
                    |m: &mut AppRelationship| { &mut m.relationship },
                    AppRelationship::get_relationship,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppRelationship>(
                    "CPublishedFile_GetAppRelationships_Response.AppRelationship",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AppRelationship {
            static instance: ::protobuf::rt::Lazy<AppRelationship> = ::protobuf::rt::Lazy::INIT;
            instance.get(AppRelationship::new)
        }
    }

    impl ::protobuf::Clear for AppRelationship {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.relationship = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AppRelationship {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppRelationship {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_StartPlaytimeTracking_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    pub publishedfileids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StartPlaytimeTracking_Request {
    fn default() -> &'a CPublishedFile_StartPlaytimeTracking_Request {
        <CPublishedFile_StartPlaytimeTracking_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StartPlaytimeTracking_Request {
    pub fn new() -> CPublishedFile_StartPlaytimeTracking_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_StartPlaytimeTracking_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfileids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfileids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StartPlaytimeTracking_Request {
        CPublishedFile_StartPlaytimeTracking_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_StartPlaytimeTracking_Request| { &m.appid },
                |m: &mut CPublishedFile_StartPlaytimeTracking_Request| { &mut m.appid },
                CPublishedFile_StartPlaytimeTracking_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64>(
                "publishedfileids",
                |m: &CPublishedFile_StartPlaytimeTracking_Request| { &m.publishedfileids },
                |m: &mut CPublishedFile_StartPlaytimeTracking_Request| { &mut m.publishedfileids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StartPlaytimeTracking_Request>(
                "CPublishedFile_StartPlaytimeTracking_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_StartPlaytimeTracking_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_StartPlaytimeTracking_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_StartPlaytimeTracking_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_StartPlaytimeTracking_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StartPlaytimeTracking_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StartPlaytimeTracking_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_StartPlaytimeTracking_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StartPlaytimeTracking_Response {
    fn default() -> &'a CPublishedFile_StartPlaytimeTracking_Response {
        <CPublishedFile_StartPlaytimeTracking_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StartPlaytimeTracking_Response {
    pub fn new() -> CPublishedFile_StartPlaytimeTracking_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_StartPlaytimeTracking_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StartPlaytimeTracking_Response {
        CPublishedFile_StartPlaytimeTracking_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StartPlaytimeTracking_Response>(
                "CPublishedFile_StartPlaytimeTracking_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_StartPlaytimeTracking_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_StartPlaytimeTracking_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_StartPlaytimeTracking_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_StartPlaytimeTracking_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StartPlaytimeTracking_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StartPlaytimeTracking_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_StopPlaytimeTracking_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    pub publishedfileids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTracking_Request {
    fn default() -> &'a CPublishedFile_StopPlaytimeTracking_Request {
        <CPublishedFile_StopPlaytimeTracking_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTracking_Request {
    pub fn new() -> CPublishedFile_StopPlaytimeTracking_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTracking_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfileids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfileids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTracking_Request {
        CPublishedFile_StopPlaytimeTracking_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_StopPlaytimeTracking_Request| { &m.appid },
                |m: &mut CPublishedFile_StopPlaytimeTracking_Request| { &mut m.appid },
                CPublishedFile_StopPlaytimeTracking_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64>(
                "publishedfileids",
                |m: &CPublishedFile_StopPlaytimeTracking_Request| { &m.publishedfileids },
                |m: &mut CPublishedFile_StopPlaytimeTracking_Request| { &mut m.publishedfileids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTracking_Request>(
                "CPublishedFile_StopPlaytimeTracking_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTracking_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_StopPlaytimeTracking_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_StopPlaytimeTracking_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTracking_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTracking_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTracking_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_StopPlaytimeTracking_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTracking_Response {
    fn default() -> &'a CPublishedFile_StopPlaytimeTracking_Response {
        <CPublishedFile_StopPlaytimeTracking_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTracking_Response {
    pub fn new() -> CPublishedFile_StopPlaytimeTracking_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTracking_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTracking_Response {
        CPublishedFile_StopPlaytimeTracking_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTracking_Response>(
                "CPublishedFile_StopPlaytimeTracking_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTracking_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_StopPlaytimeTracking_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_StopPlaytimeTracking_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTracking_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTracking_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTracking_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn default() -> &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        <CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    pub fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request| { &m.appid },
                |m: &mut CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request| { &mut m.appid },
                CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request>(
                "CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn default() -> &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        <CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    pub fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response>(
                "CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    pub controller_config_usage: ::protobuf::RepeatedField<cpublished_file_set_playtime_for_controller_configs_request::ControllerConfigUsage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn default() -> &'a CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        <CPublishedFile_SetPlaytimeForControllerConfigs_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    pub fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.controller_config_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.controller_config_usage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.controller_config_usage {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.controller_config_usage {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        CPublishedFile_SetPlaytimeForControllerConfigs_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &m.appid },
                |m: &mut CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &mut m.appid },
                CPublishedFile_SetPlaytimeForControllerConfigs_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_set_playtime_for_controller_configs_request::ControllerConfigUsage>>(
                "controller_config_usage",
                |m: &CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &m.controller_config_usage },
                |m: &mut CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &mut m.controller_config_usage },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_SetPlaytimeForControllerConfigs_Request>(
                "CPublishedFile_SetPlaytimeForControllerConfigs_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_SetPlaytimeForControllerConfigs_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_SetPlaytimeForControllerConfigs_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.controller_config_usage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
}

/// Nested message and enums of message `CPublishedFile_SetPlaytimeForControllerConfigs_Request`
pub mod cpublished_file_set_playtime_for_controller_configs_request {
    #[derive(PartialEq,Clone,Default)]
    pub struct ControllerConfigUsage {
        // message fields
        publishedfileid: ::std::option::Option<u64>,
        seconds_active: ::std::option::Option<f32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a ControllerConfigUsage {
        fn default() -> &'a ControllerConfigUsage {
            <ControllerConfigUsage as ::protobuf::Message>::default_instance()
        }
    }

    impl ControllerConfigUsage {
        pub fn new() -> ControllerConfigUsage {
            ::std::default::Default::default()
        }

        // optional uint64 publishedfileid = 1;

        pub fn get_publishedfileid(&self) -> u64 {
            self.publishedfileid.unwrap_or(0)
        }

        pub fn clear_publishedfileid(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
        }

        pub fn has_publishedfileid(&self) -> bool {
            self.publishedfileid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_publishedfileid(&mut self, v: u64) {
            self.publishedfileid = ::std::option::Option::Some(v);
        }

        // optional float seconds_active = 2;

        pub fn get_seconds_active(&self) -> f32 {
            self.seconds_active.unwrap_or(0.)
        }

        pub fn clear_seconds_active(&mut self) {
            self.seconds_active = ::std::option::Option::None;
        }

        pub fn has_seconds_active(&self) -> bool {
            self.seconds_active.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_active(&mut self, v: f32) {
            self.seconds_active = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for ControllerConfigUsage {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.seconds_active = ::std::option::Option::Some(is.read_float()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.publishedfileid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.seconds_active {
                my_size += 5;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.publishedfileid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.seconds_active {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> ControllerConfigUsage {
            ControllerConfigUsage::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                    "publishedfileid",
                    |m: &ControllerConfigUsage| { &m.publishedfileid },
                    |m: &mut ControllerConfigUsage| { &mut m.publishedfileid },
                    ControllerConfigUsage::get_publishedfileid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                    "seconds_active",
                    |m: &ControllerConfigUsage| { &m.seconds_active },
                    |m: &mut ControllerConfigUsage| { &mut m.seconds_active },
                    ControllerConfigUsage::get_seconds_active,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ControllerConfigUsage>(
                    "CPublishedFile_SetPlaytimeForControllerConfigs_Request.ControllerConfigUsage",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static ControllerConfigUsage {
            static instance: ::protobuf::rt::Lazy<ControllerConfigUsage> = ::protobuf::rt::Lazy::INIT;
            instance.get(ControllerConfigUsage::new)
        }
    }

    impl ::protobuf::Clear for ControllerConfigUsage {
        fn clear(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
            self.seconds_active = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for ControllerConfigUsage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ControllerConfigUsage {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn default() -> &'a CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        <CPublishedFile_SetPlaytimeForControllerConfigs_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    pub fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        CPublishedFile_SetPlaytimeForControllerConfigs_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_SetPlaytimeForControllerConfigs_Response>(
                "CPublishedFile_SetPlaytimeForControllerConfigs_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_SetPlaytimeForControllerConfigs_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_SetPlaytimeForControllerConfigs_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_AddChild_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    child_publishedfileid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddChild_Request {
    fn default() -> &'a CPublishedFile_AddChild_Request {
        <CPublishedFile_AddChild_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddChild_Request {
    pub fn new() -> CPublishedFile_AddChild_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint64 child_publishedfileid = 2;

    pub fn get_child_publishedfileid(&self) -> u64 {
        self.child_publishedfileid.unwrap_or(0)
    }

    pub fn clear_child_publishedfileid(&mut self) {
        self.child_publishedfileid = ::std::option::Option::None;
    }

    pub fn has_child_publishedfileid(&self) -> bool {
        self.child_publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_publishedfileid(&mut self, v: u64) {
        self.child_publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_AddChild_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.child_publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_publishedfileid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.child_publishedfileid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddChild_Request {
        CPublishedFile_AddChild_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_AddChild_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_AddChild_Request| { &mut m.publishedfileid },
                CPublishedFile_AddChild_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "child_publishedfileid",
                |m: &CPublishedFile_AddChild_Request| { &m.child_publishedfileid },
                |m: &mut CPublishedFile_AddChild_Request| { &mut m.child_publishedfileid },
                CPublishedFile_AddChild_Request::get_child_publishedfileid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddChild_Request>(
                "CPublishedFile_AddChild_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_AddChild_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_AddChild_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_AddChild_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_AddChild_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.child_publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddChild_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddChild_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_AddChild_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddChild_Response {
    fn default() -> &'a CPublishedFile_AddChild_Response {
        <CPublishedFile_AddChild_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddChild_Response {
    pub fn new() -> CPublishedFile_AddChild_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_AddChild_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddChild_Response {
        CPublishedFile_AddChild_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddChild_Response>(
                "CPublishedFile_AddChild_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_AddChild_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_AddChild_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_AddChild_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_AddChild_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddChild_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddChild_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_RemoveChild_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    child_publishedfileid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveChild_Request {
    fn default() -> &'a CPublishedFile_RemoveChild_Request {
        <CPublishedFile_RemoveChild_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveChild_Request {
    pub fn new() -> CPublishedFile_RemoveChild_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;

    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }

    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint64 child_publishedfileid = 2;

    pub fn get_child_publishedfileid(&self) -> u64 {
        self.child_publishedfileid.unwrap_or(0)
    }

    pub fn clear_child_publishedfileid(&mut self) {
        self.child_publishedfileid = ::std::option::Option::None;
    }

    pub fn has_child_publishedfileid(&self) -> bool {
        self.child_publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_publishedfileid(&mut self, v: u64) {
        self.child_publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveChild_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.child_publishedfileid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_publishedfileid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.child_publishedfileid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveChild_Request {
        CPublishedFile_RemoveChild_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "publishedfileid",
                |m: &CPublishedFile_RemoveChild_Request| { &m.publishedfileid },
                |m: &mut CPublishedFile_RemoveChild_Request| { &mut m.publishedfileid },
                CPublishedFile_RemoveChild_Request::get_publishedfileid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "child_publishedfileid",
                |m: &CPublishedFile_RemoveChild_Request| { &m.child_publishedfileid },
                |m: &mut CPublishedFile_RemoveChild_Request| { &mut m.child_publishedfileid },
                CPublishedFile_RemoveChild_Request::get_child_publishedfileid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveChild_Request>(
                "CPublishedFile_RemoveChild_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_RemoveChild_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_RemoveChild_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_RemoveChild_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveChild_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.child_publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveChild_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveChild_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_RemoveChild_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveChild_Response {
    fn default() -> &'a CPublishedFile_RemoveChild_Response {
        <CPublishedFile_RemoveChild_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveChild_Response {
    pub fn new() -> CPublishedFile_RemoveChild_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveChild_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveChild_Response {
        CPublishedFile_RemoveChild_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveChild_Response>(
                "CPublishedFile_RemoveChild_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_RemoveChild_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_RemoveChild_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_RemoveChild_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveChild_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveChild_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveChild_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetUserVoteSummary_Request {
    // message fields
    pub publishedfileids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserVoteSummary_Request {
    fn default() -> &'a CPublishedFile_GetUserVoteSummary_Request {
        <CPublishedFile_GetUserVoteSummary_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserVoteSummary_Request {
    pub fn new() -> CPublishedFile_GetUserVoteSummary_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserVoteSummary_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.publishedfileids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.publishedfileids {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserVoteSummary_Request {
        CPublishedFile_GetUserVoteSummary_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64>(
                "publishedfileids",
                |m: &CPublishedFile_GetUserVoteSummary_Request| { &m.publishedfileids },
                |m: &mut CPublishedFile_GetUserVoteSummary_Request| { &mut m.publishedfileids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserVoteSummary_Request>(
                "CPublishedFile_GetUserVoteSummary_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetUserVoteSummary_Request {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetUserVoteSummary_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetUserVoteSummary_Request::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserVoteSummary_Request {
    fn clear(&mut self) {
        self.publishedfileids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserVoteSummary_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserVoteSummary_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_GetUserVoteSummary_Response {
    // message fields
    pub summaries: ::protobuf::RepeatedField<cpublished_file_get_user_vote_summary_response::VoteSummary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserVoteSummary_Response {
    fn default() -> &'a CPublishedFile_GetUserVoteSummary_Response {
        <CPublishedFile_GetUserVoteSummary_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserVoteSummary_Response {
    pub fn new() -> CPublishedFile_GetUserVoteSummary_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserVoteSummary_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.summaries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.summaries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.summaries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserVoteSummary_Response {
        CPublishedFile_GetUserVoteSummary_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_get_user_vote_summary_response::VoteSummary>>(
                "summaries",
                |m: &CPublishedFile_GetUserVoteSummary_Response| { &m.summaries },
                |m: &mut CPublishedFile_GetUserVoteSummary_Response| { &mut m.summaries },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserVoteSummary_Response>(
                "CPublishedFile_GetUserVoteSummary_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_GetUserVoteSummary_Response {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_GetUserVoteSummary_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_GetUserVoteSummary_Response::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserVoteSummary_Response {
    fn clear(&mut self) {
        self.summaries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserVoteSummary_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserVoteSummary_Response {
}

/// Nested message and enums of message `CPublishedFile_GetUserVoteSummary_Response`
pub mod cpublished_file_get_user_vote_summary_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct VoteSummary {
        // message fields
        publishedfileid: ::std::option::Option<u64>,
        vote_for: ::std::option::Option<bool>,
        vote_against: ::std::option::Option<bool>,
        reported: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a VoteSummary {
        fn default() -> &'a VoteSummary {
            <VoteSummary as ::protobuf::Message>::default_instance()
        }
    }

    impl VoteSummary {
        pub fn new() -> VoteSummary {
            ::std::default::Default::default()
        }

        // optional fixed64 publishedfileid = 1;

        pub fn get_publishedfileid(&self) -> u64 {
            self.publishedfileid.unwrap_or(0)
        }

        pub fn clear_publishedfileid(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
        }

        pub fn has_publishedfileid(&self) -> bool {
            self.publishedfileid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_publishedfileid(&mut self, v: u64) {
            self.publishedfileid = ::std::option::Option::Some(v);
        }

        // optional bool vote_for = 2;

        pub fn get_vote_for(&self) -> bool {
            self.vote_for.unwrap_or(false)
        }

        pub fn clear_vote_for(&mut self) {
            self.vote_for = ::std::option::Option::None;
        }

        pub fn has_vote_for(&self) -> bool {
            self.vote_for.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_for(&mut self, v: bool) {
            self.vote_for = ::std::option::Option::Some(v);
        }

        // optional bool vote_against = 3;

        pub fn get_vote_against(&self) -> bool {
            self.vote_against.unwrap_or(false)
        }

        pub fn clear_vote_against(&mut self) {
            self.vote_against = ::std::option::Option::None;
        }

        pub fn has_vote_against(&self) -> bool {
            self.vote_against.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_against(&mut self, v: bool) {
            self.vote_against = ::std::option::Option::Some(v);
        }

        // optional bool reported = 4;

        pub fn get_reported(&self) -> bool {
            self.reported.unwrap_or(false)
        }

        pub fn clear_reported(&mut self) {
            self.reported = ::std::option::Option::None;
        }

        pub fn has_reported(&self) -> bool {
            self.reported.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reported(&mut self, v: bool) {
            self.reported = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for VoteSummary {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.publishedfileid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.vote_for = ::std::option::Option::Some(is.read_bool()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.vote_against = ::std::option::Option::Some(is.read_bool()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.reported = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.publishedfileid {
                my_size += 9;
            }
            if let Some(v) = self.vote_for {
                my_size += 2;
            }
            if let Some(v) = self.vote_against {
                my_size += 2;
            }
            if let Some(v) = self.reported {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.publishedfileid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.vote_for {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.vote_against {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.reported {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> VoteSummary {
            VoteSummary::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "publishedfileid",
                    |m: &VoteSummary| { &m.publishedfileid },
                    |m: &mut VoteSummary| { &mut m.publishedfileid },
                    VoteSummary::get_publishedfileid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "vote_for",
                    |m: &VoteSummary| { &m.vote_for },
                    |m: &mut VoteSummary| { &mut m.vote_for },
                    VoteSummary::get_vote_for,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "vote_against",
                    |m: &VoteSummary| { &m.vote_against },
                    |m: &mut VoteSummary| { &mut m.vote_against },
                    VoteSummary::get_vote_against,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "reported",
                    |m: &VoteSummary| { &m.reported },
                    |m: &mut VoteSummary| { &mut m.reported },
                    VoteSummary::get_reported,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VoteSummary>(
                    "CPublishedFile_GetUserVoteSummary_Response.VoteSummary",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static VoteSummary {
            static instance: ::protobuf::rt::Lazy<VoteSummary> = ::protobuf::rt::Lazy::INIT;
            instance.get(VoteSummary::new)
        }
    }

    impl ::protobuf::Clear for VoteSummary {
        fn clear(&mut self) {
            self.publishedfileid = ::std::option::Option::None;
            self.vote_for = ::std::option::Option::None;
            self.vote_against = ::std::option::Option::None;
            self.reported = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for VoteSummary {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for VoteSummary {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_FileSubscribed_Notification {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    file_hcontent: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    rtime_subscribed: ::std::option::Option<u32>,
    is_depot_content: ::std::option::Option<bool>,
    rtime_updated: ::std::option::Option<u32>,
    pub revisions: ::protobuf::RepeatedField<cpublished_file_file_subscribed_notification::RevisionData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_FileSubscribed_Notification {
    fn default() -> &'a CPublishedFile_FileSubscribed_Notification {
        <CPublishedFile_FileSubscribed_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_FileSubscribed_Notification {
    pub fn new() -> CPublishedFile_FileSubscribed_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 file_hcontent = 3;

    pub fn get_file_hcontent(&self) -> u64 {
        self.file_hcontent.unwrap_or(0)
    }

    pub fn clear_file_hcontent(&mut self) {
        self.file_hcontent = ::std::option::Option::None;
    }

    pub fn has_file_hcontent(&self) -> bool {
        self.file_hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_hcontent(&mut self, v: u64) {
        self.file_hcontent = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 4;

    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_subscribed = 5;

    pub fn get_rtime_subscribed(&self) -> u32 {
        self.rtime_subscribed.unwrap_or(0)
    }

    pub fn clear_rtime_subscribed(&mut self) {
        self.rtime_subscribed = ::std::option::Option::None;
    }

    pub fn has_rtime_subscribed(&self) -> bool {
        self.rtime_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_subscribed(&mut self, v: u32) {
        self.rtime_subscribed = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 6;

    pub fn get_is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }

    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_updated = 7;

    pub fn get_rtime_updated(&self) -> u32 {
        self.rtime_updated.unwrap_or(0)
    }

    pub fn clear_rtime_updated(&mut self) {
        self.rtime_updated = ::std::option::Option::None;
    }

    pub fn has_rtime_updated(&self) -> bool {
        self.rtime_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_updated(&mut self, v: u32) {
        self.rtime_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_FileSubscribed_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.revisions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rtime_subscribed = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_depot_content = ::std::option::Option::Some(is.read_bool()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rtime_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.revisions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_hcontent {
            my_size += 9;
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime_subscribed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_depot_content {
            my_size += 2;
        }
        if let Some(v) = self.rtime_updated {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.revisions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_hcontent {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtime_subscribed {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.rtime_updated {
            os.write_uint32(7, v)?;
        }
        for v in &self.revisions {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_FileSubscribed_Notification {
        CPublishedFile_FileSubscribed_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.published_file_id },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.published_file_id },
                CPublishedFile_FileSubscribed_Notification::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.app_id },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.app_id },
                CPublishedFile_FileSubscribed_Notification::get_app_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "file_hcontent",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.file_hcontent },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.file_hcontent },
                CPublishedFile_FileSubscribed_Notification::get_file_hcontent,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "file_size",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.file_size },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.file_size },
                CPublishedFile_FileSubscribed_Notification::get_file_size,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "rtime_subscribed",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.rtime_subscribed },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.rtime_subscribed },
                CPublishedFile_FileSubscribed_Notification::get_rtime_subscribed,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_depot_content",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.is_depot_content },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.is_depot_content },
                CPublishedFile_FileSubscribed_Notification::get_is_depot_content,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "rtime_updated",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.rtime_updated },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.rtime_updated },
                CPublishedFile_FileSubscribed_Notification::get_rtime_updated,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cpublished_file_file_subscribed_notification::RevisionData>>(
                "revisions",
                |m: &CPublishedFile_FileSubscribed_Notification| { &m.revisions },
                |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.revisions },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_FileSubscribed_Notification>(
                "CPublishedFile_FileSubscribed_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_FileSubscribed_Notification {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_FileSubscribed_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_FileSubscribed_Notification::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_FileSubscribed_Notification {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.rtime_subscribed = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.rtime_updated = ::std::option::Option::None;
        self.revisions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_FileSubscribed_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_FileSubscribed_Notification {
}

/// Nested message and enums of message `CPublishedFile_FileSubscribed_Notification`
pub mod cpublished_file_file_subscribed_notification {
    #[derive(PartialEq,Clone,Default)]
    pub struct RevisionData {
        // message fields
        revision: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<super::EPublishedFileRevision>>,
        file_hcontent: ::std::option::Option<u64>,
        rtime_updated: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a RevisionData {
        fn default() -> &'a RevisionData {
            <RevisionData as ::protobuf::Message>::default_instance()
        }
    }

    impl RevisionData {
        pub fn new() -> RevisionData {
            ::std::default::Default::default()
        }

        // optional .EPublishedFileRevision revision = 1;

        pub fn get_revision(&self) -> super::EPublishedFileRevision {
            match self.revision {
                Some(e) => e.enum_value_or(super::EPublishedFileRevision::k_EPublishedFileRevision_Default),
                None => super::EPublishedFileRevision::k_EPublishedFileRevision_Default,
            }
        }

        pub fn clear_revision(&mut self) {
            self.revision = ::std::option::Option::None;
        }

        pub fn has_revision(&self) -> bool {
            self.revision.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revision(&mut self, v: super::EPublishedFileRevision) {
            self.revision = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
        }

        // optional fixed64 file_hcontent = 2;

        pub fn get_file_hcontent(&self) -> u64 {
            self.file_hcontent.unwrap_or(0)
        }

        pub fn clear_file_hcontent(&mut self) {
            self.file_hcontent = ::std::option::Option::None;
        }

        pub fn has_file_hcontent(&self) -> bool {
            self.file_hcontent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_file_hcontent(&mut self, v: u64) {
            self.file_hcontent = ::std::option::Option::Some(v);
        }

        // optional uint32 rtime_updated = 3;

        pub fn get_rtime_updated(&self) -> u32 {
            self.rtime_updated.unwrap_or(0)
        }

        pub fn clear_rtime_updated(&mut self) {
            self.rtime_updated = ::std::option::Option::None;
        }

        pub fn has_rtime_updated(&self) -> bool {
            self.rtime_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtime_updated(&mut self, v: u32) {
            self.rtime_updated = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for RevisionData {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.revision = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.file_hcontent = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.rtime_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.revision {
                my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
            }
            if let Some(v) = self.file_hcontent {
                my_size += 9;
            }
            if let Some(v) = self.rtime_updated {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.revision {
                os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.file_hcontent {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.rtime_updated {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> RevisionData {
            RevisionData::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, super::EPublishedFileRevision>(
                    "revision",
                    |m: &RevisionData| { &m.revision },
                    |m: &mut RevisionData| { &mut m.revision },
                    super::EPublishedFileRevision::k_EPublishedFileRevision_Default,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "file_hcontent",
                    |m: &RevisionData| { &m.file_hcontent },
                    |m: &mut RevisionData| { &mut m.file_hcontent },
                    RevisionData::get_file_hcontent,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "rtime_updated",
                    |m: &RevisionData| { &m.rtime_updated },
                    |m: &mut RevisionData| { &mut m.rtime_updated },
                    RevisionData::get_rtime_updated,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RevisionData>(
                    "CPublishedFile_FileSubscribed_Notification.RevisionData",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static RevisionData {
            static instance: ::protobuf::rt::Lazy<RevisionData> = ::protobuf::rt::Lazy::INIT;
            instance.get(RevisionData::new)
        }
    }

    impl ::protobuf::Clear for RevisionData {
        fn clear(&mut self) {
            self.revision = ::std::option::Option::None;
            self.file_hcontent = ::std::option::Option::None;
            self.rtime_updated = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for RevisionData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RevisionData {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_FileUnsubscribed_Notification {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_FileUnsubscribed_Notification {
    fn default() -> &'a CPublishedFile_FileUnsubscribed_Notification {
        <CPublishedFile_FileUnsubscribed_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_FileUnsubscribed_Notification {
    pub fn new() -> CPublishedFile_FileUnsubscribed_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_FileUnsubscribed_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_FileUnsubscribed_Notification {
        CPublishedFile_FileUnsubscribed_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CPublishedFile_FileUnsubscribed_Notification| { &m.published_file_id },
                |m: &mut CPublishedFile_FileUnsubscribed_Notification| { &mut m.published_file_id },
                CPublishedFile_FileUnsubscribed_Notification::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CPublishedFile_FileUnsubscribed_Notification| { &m.app_id },
                |m: &mut CPublishedFile_FileUnsubscribed_Notification| { &mut m.app_id },
                CPublishedFile_FileUnsubscribed_Notification::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_FileUnsubscribed_Notification>(
                "CPublishedFile_FileUnsubscribed_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_FileUnsubscribed_Notification {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_FileUnsubscribed_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_FileUnsubscribed_Notification::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_FileUnsubscribed_Notification {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_FileUnsubscribed_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_FileUnsubscribed_Notification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPublishedFile_FileDeleted_Client_Notification {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_FileDeleted_Client_Notification {
    fn default() -> &'a CPublishedFile_FileDeleted_Client_Notification {
        <CPublishedFile_FileDeleted_Client_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_FileDeleted_Client_Notification {
    pub fn new() -> CPublishedFile_FileDeleted_Client_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;

    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }

    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;

    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_FileDeleted_Client_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.published_file_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_FileDeleted_Client_Notification {
        CPublishedFile_FileDeleted_Client_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "published_file_id",
                |m: &CPublishedFile_FileDeleted_Client_Notification| { &m.published_file_id },
                |m: &mut CPublishedFile_FileDeleted_Client_Notification| { &mut m.published_file_id },
                CPublishedFile_FileDeleted_Client_Notification::get_published_file_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "app_id",
                |m: &CPublishedFile_FileDeleted_Client_Notification| { &m.app_id },
                |m: &mut CPublishedFile_FileDeleted_Client_Notification| { &mut m.app_id },
                CPublishedFile_FileDeleted_Client_Notification::get_app_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_FileDeleted_Client_Notification>(
                "CPublishedFile_FileDeleted_Client_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPublishedFile_FileDeleted_Client_Notification {
        static instance: ::protobuf::rt::Lazy<CPublishedFile_FileDeleted_Client_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPublishedFile_FileDeleted_Client_Notification::new)
    }
}

impl ::protobuf::Clear for CPublishedFile_FileDeleted_Client_Notification {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_FileDeleted_Client_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_FileDeleted_Client_Notification {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EPublishedFileRevision {
    k_EPublishedFileRevision_Default = 0,
    k_EPublishedFileRevision_Latest = 1,
    k_EPublishedFileRevision_ApprovedSnapshot = 2,
    k_EPublishedFileRevision_ApprovedSnapshot_China = 3,
    k_EPublishedFileRevision_RejectedSnapshot = 4,
    k_EPublishedFileRevision_RejectedSnapshot_China = 5,
}

impl ::protobuf::ProtobufEnum for EPublishedFileRevision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileRevision> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_Default),
            1 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_Latest),
            2 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot),
            3 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot_China),
            4 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot),
            5 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot_China),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPublishedFileRevision] = &[
            EPublishedFileRevision::k_EPublishedFileRevision_Default,
            EPublishedFileRevision::k_EPublishedFileRevision_Latest,
            EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot,
            EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot_China,
            EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot,
            EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot_China,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EPublishedFileRevision>("EPublishedFileRevision", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EPublishedFileRevision {
    fn default() -> Self {
        EPublishedFileRevision::k_EPublishedFileRevision_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for EPublishedFileRevision {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EPublishedFileForSaleStatus {
    k_PFFSS_NotForSale = 0,
    k_PFFSS_PendingApproval = 1,
    k_PFFSS_ApprovedForSale = 2,
    k_PFFSS_RejectedForSale = 3,
    k_PFFSS_NoLongerForSale = 4,
    k_PFFSS_TentativeApproval = 5,
}

impl ::protobuf::ProtobufEnum for EPublishedFileForSaleStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileForSaleStatus> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_NotForSale),
            1 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_PendingApproval),
            2 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_ApprovedForSale),
            3 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_RejectedForSale),
            4 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_NoLongerForSale),
            5 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_TentativeApproval),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPublishedFileForSaleStatus] = &[
            EPublishedFileForSaleStatus::k_PFFSS_NotForSale,
            EPublishedFileForSaleStatus::k_PFFSS_PendingApproval,
            EPublishedFileForSaleStatus::k_PFFSS_ApprovedForSale,
            EPublishedFileForSaleStatus::k_PFFSS_RejectedForSale,
            EPublishedFileForSaleStatus::k_PFFSS_NoLongerForSale,
            EPublishedFileForSaleStatus::k_PFFSS_TentativeApproval,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EPublishedFileForSaleStatus>("EPublishedFileForSaleStatus", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EPublishedFileForSaleStatus {
    fn default() -> Self {
        EPublishedFileForSaleStatus::k_PFFSS_NotForSale
    }
}

impl ::protobuf::reflect::ProtobufValue for EPublishedFileForSaleStatus {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_publishedfile.steamclient.proto\x1a,steammessages_unifi\
    ed_base.steamclient.proto\"\xa4\x01\n\x20CPublishedFile_Subscribe_Reques\
    t\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\x12\
    \x1b\n\tlist_type\x18\x02\x20\x01(\rR\x08listType\x12\x14\n\x05appid\x18\
    \x03\x20\x01(\x05R\x05appid\x12#\n\rnotify_client\x18\x04\x20\x01(\x08R\
    \x0cnotifyClient\"#\n!CPublishedFile_Subscribe_Response\"\xa6\x01\n\"CPu\
    blishedFile_Unsubscribe_Request\x12(\n\x0fpublishedfileid\x18\x01\x20\
    \x01(\x04R\x0fpublishedfileid\x12\x1b\n\tlist_type\x18\x02\x20\x01(\rR\
    \x08listType\x12\x14\n\x05appid\x18\x03\x20\x01(\x05R\x05appid\x12#\n\rn\
    otify_client\x18\x04\x20\x01(\x08R\x0cnotifyClient\"%\n#CPublishedFile_U\
    nsubscribe_Response\"O\n#CPublishedFile_CanSubscribe_Request\x12(\n\x0fp\
    ublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\"K\n$CPublishedF\
    ile_CanSubscribe_Response\x12#\n\rcan_subscribe\x18\x01\x20\x01(\x08R\
    \x0ccanSubscribe\"\x9e\x0c\n\x1eCPublishedFile_Publish_Request\x12C\n\
    \x05appid\x18\x01\x20\x01(\rR\x05appidB-\x82\xb5\x18)App\x20Id\x20this\
    \x20file\x20is\x20being\x20published\x20FROM.\x12R\n\x0econsumer_appid\
    \x18\x02\x20\x01(\rR\rconsumerAppidB+\x82\xb5\x18'App\x20Id\x20this\x20f\
    ile\x20is\x20being\x20published\x20TO.\x12Z\n\rcloudfilename\x18\x03\x20\
    \x01(\tR\rcloudfilenameB4\x82\xb5\x180Name\x20of\x20the\x20file\x20to\
    \x20publish\x20in\x20the\x20user's\x20cloud.\x12q\n\x15preview_cloudfile\
    name\x18\x04\x20\x01(\tR\x14previewCloudfilenameB<\x82\xb5\x188Name\x20o\
    f\x20the\x20file\x20to\x20use\x20as\x20the\x20published\x20file's\x20pre\
    view.\x12<\n\x05title\x18\x05\x20\x01(\tR\x05titleB&\x82\xb5\x18\"Text\
    \x20title\x20for\x20the\x20published\x20file.\x12W\n\x10file_description\
    \x18\x06\x20\x01(\tR\x0ffileDescriptionB,\x82\xb5\x18(Text\x20descriptio\
    n\x20for\x20the\x20published\x20file.\x12V\n\tfile_type\x18\x07\x20\x01(\
    \rR\x08fileTypeB9\x82\xb5\x185(EWorkshopFileType)\x20Type\x20of\x20Works\
    hop\x20file\x20to\x20publish.\x12_\n\x16consumer_shortcut_name\x18\x08\
    \x20\x01(\tR\x14consumerShortcutNameB)\x82\xb5\x18%Shortcut\x20name\x20f\
    or\x20the\x20published\x20file.\x12Z\n\x10youtube_username\x18\t\x20\x01\
    (\tR\x0fyoutubeUsernameB/\x82\xb5\x18+(Optional)\x20User's\x20YouTube\
    \x20account\x20username.\x12l\n\x0fyoutube_videoid\x18\n\x20\x01(\tR\x0e\
    youtubeVideoidBC\x82\xb5\x18?(Optional)\x20Video\x20Id\x20of\x20a\x20You\
    Tube\x20video\x20for\x20this\x20published\x20file.\x12\x8d\x01\n\nvisibi\
    lity\x18\x0b\x20\x01(\rR\nvisibilityBm\x82\xb5\x18i(ERemoteStoragePublis\
    hedFileVisibility)\x20Visibility\x20of\x20the\x20published\x20file\x20(p\
    rivate,\x20friends,\x20public,\x20etc.)\x12x\n\x0credirect_uri\x18\x0c\
    \x20\x01(\tR\x0bredirectUriBU\x82\xb5\x18Q(Optional)\x20If\x20supplied,\
    \x20the\x20resulting\x20published\x20file's\x20Id\x20is\x20appended\x20t\
    o\x20the\x20URI.\x12J\n\x04tags\x18\r\x20\x03(\tR\x04tagsB6\x82\xb5\x182\
    Array\x20of\x20text\x20tags\x20to\x20apply\x20to\x20the\x20published\x20\
    file.\x12i\n\x0fcollection_type\x18\x0e\x20\x01(\tR\x0ecollectionTypeB@\
    \x82\xb5\x18<(Optional)\x20Type\x20of\x20collection\x20the\x20published\
    \x20file\x20represents.\x12W\n\tgame_type\x18\x0f\x20\x01(\tR\x08gameTyp\
    eB:\x82\xb5\x186(Optional)\x20Type\x20of\x20game\x20the\x20published\x20\
    file\x20represents.\x12`\n\x03url\x18\x10\x20\x01(\tR\x03urlBN\x82\xb5\
    \x18J(Optional)\x20If\x20this\x20represents\x20a\x20game,\x20this\x20is\
    \x20the\x20URL\x20to\x20that\x20game's\x20page.\"n\n\x1fCPublishedFile_P\
    ublish_Response\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpubli\
    shedfileid\x12!\n\x0credirect_uri\x18\x02\x20\x01(\tR\x0bredirectUri\"\
    \xa2\x0b\n!CPublishedFile_GetDetails_Request\x12b\n\x10publishedfileids\
    \x18\x01\x20\x03(\x06R\x10publishedfileidsB6\x82\xb5\x182Set\x20of\x20pu\
    blished\x20file\x20Ids\x20to\x20retrieve\x20details\x20for.\x12^\n\x0bin\
    cludetags\x18\x02\x20\x01(\x08R\x0bincludetagsB<\x82\xb5\x188If\x20true,\
    \x20return\x20tag\x20information\x20in\x20the\x20returned\x20details.\
    \x12~\n\x19includeadditionalpreviews\x18\x03\x20\x01(\x08R\x19includeadd\
    itionalpreviewsB@\x82\xb5\x18<If\x20true,\x20return\x20preview\x20inform\
    ation\x20in\x20the\x20returned\x20details.\x12_\n\x0fincludechildren\x18\
    \x04\x20\x01(\x08R\x0fincludechildrenB5\x82\xb5\x181If\x20true,\x20retur\
    n\x20children\x20in\x20the\x20returned\x20details.\x12a\n\rincludekvtags\
    \x18\x05\x20\x01(\x08R\rincludekvtagsB;\x82\xb5\x187If\x20true,\x20retur\
    n\x20key\x20value\x20tags\x20in\x20the\x20returned\x20details.\x12Z\n\
    \x0cincludevotes\x18\x06\x20\x01(\x08R\x0cincludevotesB6\x82\xb5\x182If\
    \x20true,\x20return\x20vote\x20data\x20in\x20the\x20returned\x20details.\
    \x12u\n\x11short_description\x18\x08\x20\x01(\x08R\x10shortDescriptionBH\
    \x82\xb5\x18DIf\x20true,\x20return\x20a\x20short\x20description\x20inste\
    ad\x20of\x20the\x20full\x20description.\x12`\n\x12includeforsaledata\x18\
    \n\x20\x01(\x08R\x12includeforsaledataB0\x82\xb5\x18,If\x20true,\x20retu\
    rn\x20pricing\x20data,\x20if\x20applicable.\x12S\n\x0fincludemetadata\
    \x18\x0b\x20\x01(\x08R\x0fincludemetadataB)\x82\xb5\x18%If\x20true,\x20p\
    opulate\x20the\x20metadata\x20field.\x12_\n\x08language\x18\x0c\x20\x01(\
    \x05:\x010R\x08languageB@\x82\xb5\x18<Specifies\x20the\x20localized\x20t\
    ext\x20to\x20return.\x20Defaults\x20to\x20English.\x12|\n\x15return_play\
    time_stats\x18\r\x20\x01(\rR\x13returnPlaytimeStatsBH\x82\xb5\x18DReturn\
    \x20playtime\x20stats\x20for\x20the\x20specified\x20number\x20of\x20days\
    \x20before\x20today.\x12\x14\n\x05appid\x18\x0e\x20\x01(\rR\x05appid\x12\
    ^\n\x18strip_description_bbcode\x18\x0f\x20\x01(\x08R\x16stripDescriptio\
    nBbcodeB$\x82\xb5\x18\x20Strips\x20BBCode\x20from\x20descriptions.\x12\
    \x95\x01\n\x10desired_revision\x18\x10\x20\x01(\x0e2\x17.EPublishedFileR\
    evision:\x20k_EPublishedFileRevision_DefaultR\x0fdesiredRevisionB/\x82\
    \xb5\x18+Return\x20the\x20data\x20for\x20the\x20specified\x20revision.\"\
    \xcf\x20\n\x14PublishedFileDetails\x12\x16\n\x06result\x18\x01\x20\x01(\
    \rR\x06result\x12(\n\x0fpublishedfileid\x18\x02\x20\x01(\x04R\x0fpublish\
    edfileid\x12\x18\n\x07creator\x18\x03\x20\x01(\x06R\x07creator\x12#\n\rc\
    reator_appid\x18\x04\x20\x01(\rR\x0ccreatorAppid\x12%\n\x0econsumer_appi\
    d\x18\x05\x20\x01(\rR\rconsumerAppid\x12/\n\x13consumer_shortcutid\x18\
    \x06\x20\x01(\rR\x12consumerShortcutid\x12\x1a\n\x08filename\x18\x07\x20\
    \x01(\tR\x08filename\x12\x1b\n\tfile_size\x18\x08\x20\x01(\x04R\x08fileS\
    ize\x12*\n\x11preview_file_size\x18\t\x20\x01(\x04R\x0fpreviewFileSize\
    \x12\x19\n\x08file_url\x18\n\x20\x01(\tR\x07fileUrl\x12\x1f\n\x0bpreview\
    _url\x18\x0b\x20\x01(\tR\npreviewUrl\x12&\n\x0eyoutubevideoid\x18\x0c\
    \x20\x01(\tR\x0eyoutubevideoid\x12\x10\n\x03url\x18\r\x20\x01(\tR\x03url\
    \x12#\n\rhcontent_file\x18\x0e\x20\x01(\x06R\x0chcontentFile\x12)\n\x10h\
    content_preview\x18\x0f\x20\x01(\x06R\x0fhcontentPreview\x12\x14\n\x05ti\
    tle\x18\x10\x20\x01(\tR\x05title\x12)\n\x10file_description\x18\x11\x20\
    \x01(\tR\x0ffileDescription\x12+\n\x11short_description\x18\x12\x20\x01(\
    \tR\x10shortDescription\x12!\n\x0ctime_created\x18\x13\x20\x01(\rR\x0bti\
    meCreated\x12!\n\x0ctime_updated\x18\x14\x20\x01(\rR\x0btimeUpdated\x12\
    \x1e\n\nvisibility\x18\x15\x20\x01(\rR\nvisibility\x12\x14\n\x05flags\
    \x18\x16\x20\x01(\rR\x05flags\x12#\n\rworkshop_file\x18\x17\x20\x01(\x08\
    R\x0cworkshopFile\x12+\n\x11workshop_accepted\x18\x18\x20\x01(\x08R\x10w\
    orkshopAccepted\x12,\n\x12show_subscribe_all\x18\x19\x20\x01(\x08R\x10sh\
    owSubscribeAll\x124\n\x16num_comments_developer\x18\x1a\x20\x01(\x05R\
    \x14numCommentsDeveloper\x12.\n\x13num_comments_public\x18\x1b\x20\x01(\
    \x05R\x11numCommentsPublic\x12\x16\n\x06banned\x18\x1c\x20\x01(\x08R\x06\
    banned\x12\x1d\n\nban_reason\x18\x1d\x20\x01(\tR\tbanReason\x12\x16\n\
    \x06banner\x18\x1e\x20\x01(\x06R\x06banner\x12$\n\x0ecan_be_deleted\x18\
    \x1f\x20\x01(\x08R\x0ccanBeDeleted\x12\"\n\x0cincompatible\x18\x20\x20\
    \x01(\x08R\x0cincompatible\x12\x19\n\x08app_name\x18!\x20\x01(\tR\x07app\
    Name\x12\x1b\n\tfile_type\x18\"\x20\x01(\rR\x08fileType\x12#\n\rcan_subs\
    cribe\x18#\x20\x01(\x08R\x0ccanSubscribe\x12$\n\rsubscriptions\x18$\x20\
    \x01(\rR\rsubscriptions\x12\x1c\n\tfavorited\x18%\x20\x01(\rR\tfavorited\
    \x12\x1c\n\tfollowers\x18&\x20\x01(\rR\tfollowers\x125\n\x16lifetime_sub\
    scriptions\x18'\x20\x01(\rR\x15lifetimeSubscriptions\x12-\n\x12lifetime_\
    favorited\x18(\x20\x01(\rR\x11lifetimeFavorited\x12-\n\x12lifetime_follo\
    wers\x18)\x20\x01(\rR\x11lifetimeFollowers\x12+\n\x11lifetime_playtime\
    \x18>\x20\x01(\x04R\x10lifetimePlaytime\x12<\n\x1alifetime_playtime_sess\
    ions\x18?\x20\x01(\x04R\x18lifetimePlaytimeSessions\x12\x14\n\x05views\
    \x18*\x20\x01(\rR\x05views\x12\x1f\n\x0bimage_width\x18+\x20\x01(\rR\nim\
    ageWidth\x12!\n\x0cimage_height\x18,\x20\x01(\rR\x0bimageHeight\x12\x1b\
    \n\timage_url\x18-\x20\x01(\tR\x08imageUrl\x12\x1f\n\x0bspoiler_tag\x18.\
    \x20\x01(\x08R\nspoilerTag\x12\x1e\n\nshortcutid\x18/\x20\x01(\rR\nshort\
    cutid\x12\"\n\x0cshortcutname\x180\x20\x01(\tR\x0cshortcutname\x12!\n\
    \x0cnum_children\x181\x20\x01(\rR\x0bnumChildren\x12\x1f\n\x0bnum_report\
    s\x182\x20\x01(\rR\nnumReports\x129\n\x08previews\x183\x20\x03(\x0b2\x1d\
    .PublishedFileDetails.PreviewR\x08previews\x12-\n\x04tags\x184\x20\x03(\
    \x0b2\x19.PublishedFileDetails.TagR\x04tags\x127\n\x08children\x185\x20\
    \x03(\x0b2\x1b.PublishedFileDetails.ChildR\x08children\x123\n\x06kvtags\
    \x186\x20\x03(\x0b2\x1b.PublishedFileDetails.KVTagR\x06kvtags\x12;\n\tvo\
    te_data\x187\x20\x01(\x0b2\x1e.PublishedFileDetails.VoteDataR\x08voteDat\
    a\x12J\n\x0eplaytime_stats\x18@\x20\x01(\x0b2#.PublishedFileDetails.Play\
    timeStatsR\rplaytimeStats\x12\x82\x01\n\x0ftime_subscribed\x188\x20\x01(\
    \rR\x0etimeSubscribedBY\x82\xb5\x18UOnly\x20valid\x20in\x20PublishedFile\
    .GetUserFiles\x20and\x20not\x20normal\x20PublishedFile.GetDetail\x20call\
    s\x12n\n\rfor_sale_data\x189\x20\x01(\x0b2!.PublishedFileDetails.ForSale\
    DataR\x0bforSaleDataB'\x82\xb5\x18#Pricing\x20information,\x20if\x20appl\
    icable.\x12A\n\x08metadata\x18:\x20\x01(\tR\x08metadataB%\x82\xb5\x18!Me\
    tadata\x20associated\x20with\x20the\x20item\x12M\n\x08language\x18=\x20\
    \x01(\x05:\x010R\x08languageB.\x82\xb5\x18*The\x20language\x20of\x20the\
    \x20title\x20and\x20description.\x126\n\x17maybe_inappropriate_sex\x18A\
    \x20\x01(\x08R\x15maybeInappropriateSex\x12@\n\x1cmaybe_inappropriate_vi\
    olence\x18B\x20\x01(\x08R\x1amaybeInappropriateViolence\x12g\n\x16revisi\
    on_change_number\x18C\x20\x01(\x04R\x14revisionChangeNumberB1\x82\xb5\
    \x18-The\x20change\x20number\x20for\x20the\x20specified\x20revision.\x12\
    \xe6\x01\n\x08revision\x18D\x20\x01(\x0e2\x17.EPublishedFileRevision:\
    \x20k_EPublishedFileRevision_DefaultR\x08revisionB\x8e\x01\x82\xb5\x18\
    \x89\x01The\x20revision\x20of\x20the\x20data\x20returned,\x20usually\x20\
    k_EPublishedFileRevision_Latest,\x20but\x20can\x20be\x20another\x20revis\
    ion/snapshot\x20depending\x20on\x20the\x20caller.\x12a\n\x13available_re\
    visions\x18E\x20\x03(\x0e2\x17.EPublishedFileRevisionR\x12availableRevis\
    ionsB\x17\x82\xb5\x18\x13Available\x20revisions\x1a5\n\x03Tag\x12\x10\n\
    \x03tag\x18\x01\x20\x01(\tR\x03tag\x12\x1c\n\tadminonly\x18\x02\x20\x01(\
    \x08R\tadminonly\x1a\x81\x02\n\x07Preview\x12\x1c\n\tpreviewid\x18\x01\
    \x20\x01(\x04R\tpreviewid\x12\x1c\n\tsortorder\x18\x02\x20\x01(\rR\tsort\
    order\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12\x12\n\x04size\x18\
    \x04\x20\x01(\rR\x04size\x12\x1a\n\x08filename\x18\x05\x20\x01(\tR\x08fi\
    lename\x12&\n\x0eyoutubevideoid\x18\x06\x20\x01(\tR\x0eyoutubevideoid\
    \x12!\n\x0cpreview_type\x18\x07\x20\x01(\rR\x0bpreviewType\x12-\n\x12ext\
    ernal_reference\x18\x08\x20\x01(\tR\x11externalReference\x1al\n\x05Child\
    \x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\x12\
    \x1c\n\tsortorder\x18\x02\x20\x01(\rR\tsortorder\x12\x1b\n\tfile_type\
    \x18\x03\x20\x01(\rR\x08fileType\x1a/\n\x05KVTag\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \x1aZ\n\x08VoteData\x12\x14\n\x05score\x18\x01\x20\x01(\x02R\x05score\
    \x12\x19\n\x08votes_up\x18\x02\x20\x01(\rR\x07votesUp\x12\x1d\n\nvotes_d\
    own\x18\x03\x20\x01(\rR\tvotesDown\x1a\xbe\x02\n\x0bForSaleData\x12\x1e\
    \n\x0bis_for_sale\x18\x01\x20\x01(\x08R\tisForSale\x12%\n\x0eprice_categ\
    ory\x18\x02\x20\x01(\rR\rpriceCategory\x12J\n\x07estatus\x18\x03\x20\x01\
    (\x0e2\x1c.EPublishedFileForSaleStatus:\x12k_PFFSS_NotForSaleR\x07estatu\
    s\x120\n\x14price_category_floor\x18\x04\x20\x01(\rR\x12priceCategoryFlo\
    or\x129\n\x1aprice_is_pay_what_you_want\x18\x05\x20\x01(\x08R\x15priceIs\
    PayWhatYouWant\x12/\n\x13discount_percentage\x18\x06\x20\x01(\rR\x12disc\
    ountPercentage\x1a]\n\rPlaytimeStats\x12)\n\x10playtime_seconds\x18\x01\
    \x20\x01(\x04R\x0fplaytimeSeconds\x12!\n\x0cnum_sessions\x18\x02\x20\x01\
    (\x04R\x0bnumSessions\"o\n\"CPublishedFile_GetDetails_Response\x12I\n\
    \x14publishedfiledetails\x18\x01\x20\x03(\x0b2\x15.PublishedFileDetailsR\
    \x14publishedfiledetails\"\xb8\x03\n\"CPublishedFile_GetItemInfo_Request\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\x11last_time_up\
    dated\x18\x02\x20\x01(\rR\x0flastTimeUpdated\x12W\n\x0eworkshop_items\
    \x18\x03\x20\x03(\x0b20.CPublishedFile_GetItemInfo_Request.WorkshopItemR\
    \rworkshopItems\x1a\xf5\x01\n\x0cWorkshopItem\x12*\n\x11published_file_i\
    d\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\x0ctime_updated\x18\
    \x02\x20\x01(\rR\x0btimeUpdated\x12\x95\x01\n\x10desired_revision\x18\
    \x03\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPublishedFileRevisi\
    on_DefaultR\x0fdesiredRevisionB/\x82\xb5\x18+Return\x20the\x20data\x20fo\
    r\x20the\x20specified\x20revision.\"\xe4\x02\n#CPublishedFile_GetItemInf\
    o_Response\x12\x1f\n\x0bupdate_time\x18\x01\x20\x01(\rR\nupdateTime\x12\
    \\\n\x0eworkshop_items\x18\x02\x20\x03(\x0b25.CPublishedFile_GetItemInfo\
    _Response.WorkshopItemInfoR\rworkshopItems\x12#\n\rprivate_items\x18\x03\
    \x20\x03(\x06R\x0cprivateItems\x1a\x98\x01\n\x10WorkshopItemInfo\x12*\n\
    \x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\
    \x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\x12\x1f\n\x0bmanifes\
    t_id\x18\x03\x20\x01(\x06R\nmanifestId\x12\x14\n\x05flags\x18\x04\x20\
    \x01(\rR\x05flags\"\x96\x18\n#CPublishedFile_GetUserFiles_Request\x12S\n\
    \x07steamid\x18\x01\x20\x01(\x06R\x07steamidB9\x82\xb5\x185Steam\x20ID\
    \x20of\x20the\x20user\x20whose\x20files\x20are\x20being\x20requested.\
    \x12M\n\x05appid\x18\x02\x20\x01(\rR\x05appidB7\x82\xb5\x183App\x20Id\
    \x20of\x20the\x20app\x20that\x20the\x20files\x20were\x20published\x20to.\
    \x12@\n\x04page\x18\x04\x20\x01(\r:\x011R\x04pageB)\x82\xb5\x18%(Optiona\
    l)\x20Starting\x20page\x20for\x20results.\x12\\\n\nnumperpage\x18\x05\
    \x20\x01(\r:\x011R\nnumperpageB9\x82\xb5\x185(Optional)\x20The\x20number\
    \x20of\x20results,\x20per\x20page\x20to\x20return.\x12I\n\x04type\x18\
    \x06\x20\x01(\t:\x07myfilesR\x04typeB,\x82\xb5\x18((Optional)\x20Type\
    \x20of\x20files\x20to\x20be\x20returned.\x12e\n\nsortmethod\x18\x07\x20\
    \x01(\t:\x0blastupdatedR\nsortmethodB8\x82\xb5\x184(Optional)\x20Sorting\
    \x20method\x20to\x20use\x20on\x20returned\x20values.\x12D\n\x07privacy\
    \x18\t\x20\x01(\rR\x07privacyB*\x82\xb5\x18&(optional)\x20Filter\x20by\
    \x20privacy\x20settings.\x12v\n\x0crequiredtags\x18\n\x20\x03(\tR\x0creq\
    uiredtagsBR\x82\xb5\x18N(Optional)\x20Tags\x20that\x20must\x20be\x20pres\
    ent\x20on\x20a\x20published\x20file\x20to\x20satisfy\x20the\x20query.\
    \x12z\n\x0cexcludedtags\x18\x0b\x20\x03(\tR\x0cexcludedtagsBV\x82\xb5\
    \x18R(Optional)\x20Tags\x20that\x20must\x20NOT\x20be\x20present\x20on\
    \x20a\x20published\x20file\x20to\x20satisfy\x20the\x20query.\x12~\n\x10r\
    equired_kv_tags\x18\x1e\x20\x03(\x0b2*.CPublishedFile_GetUserFiles_Reque\
    st.KVTagR\x0erequiredKvTagsB(\x82\xb5\x18$Required\x20key-value\x20tags\
    \x20to\x20match\x20on.\x12G\n\x08filetype\x18\x0e\x20\x01(\rR\x08filetyp\
    eB+\x82\xb5\x18'(Optional)\x20File\x20type\x20to\x20match\x20files\x20to\
    .\x12o\n\rcreator_appid\x18\x0f\x20\x01(\rR\x0ccreatorAppidBJ\x82\xb5\
    \x18FApp\x20Id\x20of\x20the\x20app\x20that\x20published\x20the\x20files,\
    \x20only\x20matched\x20if\x20specified.\x12]\n\x14match_cloud_filename\
    \x18\x10\x20\x01(\tR\x12matchCloudFilenameB+\x82\xb5\x18'Match\x20this\
    \x20cloud\x20filename\x20if\x20specified.\x12~\n\x15cache_max_age_second\
    s\x18\x1b\x20\x01(\r:\x010R\x12cacheMaxAgeSecondsBH\x82\xb5\x18DAllow\
    \x20stale\x20data\x20to\x20be\x20returned\x20for\x20the\x20specified\x20\
    number\x20of\x20seconds.\x12_\n\x08language\x18\x1d\x20\x01(\x05:\x010R\
    \x08languageB@\x82\xb5\x18<Specifies\x20the\x20localized\x20text\x20to\
    \x20return.\x20Defaults\x20to\x20English.\x12\xae\x01\n\ttaggroups\x18\"\
    \x20\x03(\x0b2-.CPublishedFile_GetUserFiles_Request.TagGroupR\ttaggroups\
    Ba\x82\xb5\x18](Optional)\x20At\x20least\x20one\x20of\x20the\x20tags\x20\
    must\x20be\x20present\x20on\x20a\x20published\x20file\x20to\x20satisfy\
    \x20the\x20query.\x12t\n\ttotalonly\x18\x11\x20\x01(\x08R\ttotalonlyBV\
    \x82\xb5\x18R(Optional)\x20If\x20true,\x20only\x20return\x20the\x20total\
    \x20number\x20of\x20files\x20that\x20satisfy\x20this\x20query.\x12w\n\
    \x08ids_only\x18\x12\x20\x01(\x08R\x07idsOnlyB\\\x82\xb5\x18X(Optional)\
    \x20If\x20true,\x20only\x20return\x20the\x20published\x20file\x20ids\x20\
    of\x20files\x20that\x20satisfy\x20this\x20query.\x12D\n\x10return_vote_d\
    ata\x18\x13\x20\x01(\x08:\x04trueR\x0ereturnVoteDataB\x14\x82\xb5\x18\
    \x10Return\x20vote\x20data\x12D\n\x0breturn_tags\x18\x14\x20\x01(\x08R\n\
    returnTagsB#\x82\xb5\x18\x1fReturn\x20tags\x20in\x20the\x20file\x20detai\
    ls\x12Y\n\x0ereturn_kv_tags\x18\x15\x20\x01(\x08:\x04trueR\x0creturnKvTa\
    gsB-\x82\xb5\x18)Return\x20key-value\x20tags\x20in\x20the\x20file\x20det\
    ails\x12g\n\x0freturn_previews\x18\x16\x20\x01(\x08R\x0ereturnPreviewsB>\
    \x82\xb5\x18:Return\x20preview\x20image\x20and\x20video\x20details\x20in\
    \x20the\x20file\x20details\x12V\n\x0freturn_children\x18\x17\x20\x01(\
    \x08R\x0ereturnChildrenB-\x82\xb5\x18)Return\x20child\x20item\x20ids\x20\
    in\x20the\x20file\x20details\x12\x84\x01\n\x18return_short_description\
    \x18\x18\x20\x01(\x08:\x04trueR\x16returnShortDescriptionBD\x82\xb5\x18@\
    Populate\x20the\x20short_description\x20field\x20instead\x20of\x20file_d\
    escription\x12^\n\x14return_for_sale_data\x18\x1a\x20\x01(\x08R\x11retur\
    nForSaleDataB-\x82\xb5\x18)Return\x20pricing\x20information,\x20if\x20ap\
    plicable\x12O\n\x0freturn_metadata\x18\x1c\x20\x01(\x08:\x05falseR\x0ere\
    turnMetadataB\x1f\x82\xb5\x18\x1bPopulate\x20the\x20metadata\x20field\
    \x12|\n\x15return_playtime_stats\x18\x1f\x20\x01(\rR\x13returnPlaytimeSt\
    atsBH\x82\xb5\x18DReturn\x20playtime\x20stats\x20for\x20the\x20specified\
    \x20number\x20of\x20days\x20before\x20today.\x12^\n\x18strip_description\
    _bbcode\x18\x20\x20\x01(\x08R\x16stripDescriptionBbcodeB$\x82\xb5\x18\
    \x20Strips\x20BBCode\x20from\x20descriptions.\x12\x95\x01\n\x10desired_r\
    evision\x18!\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPublishedFi\
    leRevision_DefaultR\x0fdesiredRevisionB/\x82\xb5\x18+Return\x20the\x20da\
    ta\x20for\x20the\x20specified\x20revision.\x1a/\n\x05KVTag\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value\x1a\x1e\n\x08TagGroup\x12\x12\n\x04tags\x18\x01\x20\x03(\tR\
    \x04tags\"\xd1\x02\n$CPublishedFile_GetUserFiles_Response\x12\x14\n\x05t\
    otal\x18\x01\x20\x01(\rR\x05total\x12\x1e\n\nstartindex\x18\x02\x20\x01(\
    \rR\nstartindex\x12I\n\x14publishedfiledetails\x18\x03\x20\x03(\x0b2\x15\
    .PublishedFileDetailsR\x14publishedfiledetails\x12=\n\x04apps\x18\x04\
    \x20\x03(\x0b2).CPublishedFile_GetUserFiles_Response.AppR\x04apps\x1ai\n\
    \x03App\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04nam\
    e\x18\x02\x20\x01(\tR\x04name\x12\x1e\n\nshortcutid\x18\x03\x20\x01(\rR\
    \nshortcutid\x12\x18\n\x07private\x18\x04\x20\x01(\x08R\x07private\"\xd9\
    \x02\n1CPublishedFile_AreFilesInSubscriptionList_Request\x12\x14\n\x05ap\
    pid\x18\x01\x20\x01(\rR\x05appid\x12*\n\x10publishedfileids\x18\x02\x20\
    \x03(\x06R\x10publishedfileids\x120\n\x08listtype\x18\x03\x20\x01(\rR\
    \x08listtypeB\x14\x82\xb5\x18\x10See\x20EUCMListType\x12F\n\x08filetype\
    \x18\x04\x20\x01(\rR\x08filetypeB*\x82\xb5\x18&See\x20EPublishedFileInfo\
    MatchingFileType\x12h\n\x10workshopfiletype\x18\x05\x20\x01(\rR\x10works\
    hopfiletypeB<\x82\xb5\x188See\x20EWorkshopFileType.\x20\x20If\x20specifi\
    ed,\x20overrides\x20filetype\"\xd2\x01\n2CPublishedFile_AreFilesInSubscr\
    iptionList_Response\x12P\n\x05files\x18\x01\x20\x03(\x0b2:.CPublishedFil\
    e_AreFilesInSubscriptionList_Response.InListR\x05files\x1aJ\n\x06InList\
    \x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x06R\x0fpublishedfileid\x12\
    \x16\n\x06inlist\x18\x02\x20\x01(\x08R\x06inlist\"\x87\x07\n\x1dCPublish\
    edFile_Update_Request\x12@\n\x05appid\x18\x01\x20\x01(\rR\x05appidB*\x82\
    \xb5\x18&App\x20Id\x20this\x20published\x20file\x20belongs\x20to.\x12]\n\
    \x0fpublishedfileid\x18\x02\x20\x01(\x06R\x0fpublishedfileidB3\x82\xb5\
    \x18/Published\x20file\x20id\x20of\x20the\x20file\x20we'd\x20like\x20upd\
    ate.\x12A\n\x05title\x18\x03\x20\x01(\tR\x05titleB+\x82\xb5\x18'(Optiona\
    l)\x20Title\x20of\x20the\x20published\x20file.\x12\\\n\x10file_descripti\
    on\x18\x04\x20\x01(\tR\x0ffileDescriptionB1\x82\xb5\x18-(Optional)\x20De\
    scription\x20of\x20the\x20published\x20file.\x12P\n\nvisibility\x18\x05\
    \x20\x01(\rR\nvisibilityB0\x82\xb5\x18,(Optional)\x20Visibility\x20of\
    \x20the\x20published\x20file.\x12F\n\x04tags\x18\x06\x20\x03(\tR\x04tags\
    B2\x82\xb5\x18.(Optional)\x20Set\x20of\x20tags\x20for\x20the\x20publishe\
    d\x20file.\x12K\n\x08filename\x18\x07\x20\x01(\tR\x08filenameB/\x82\xb5\
    \x18+(Optional)\x20Filename\x20for\x20the\x20published\x20file.\x12b\n\
    \x10preview_filename\x18\x08\x20\x01(\tR\x0fpreviewFilenameB7\x82\xb5\
    \x183(Optional)\x20Preview\x20filename\x20for\x20the\x20published\x20fil\
    e.\x12j\n\x0bimage_width\x18\x0f\x20\x01(\rR\nimageWidthBI\x82\xb5\x18E(\
    Optional)\x20If\x20this\x20is\x20an\x20image\x20file,\x20you\x20can\x20s\
    pecify\x20the\x20image\x20width.\x12m\n\x0cimage_height\x18\x10\x20\x01(\
    \rR\x0bimageHeightBJ\x82\xb5\x18F(Optional)\x20If\x20this\x20is\x20an\
    \x20image\x20file,\x20you\x20can\x20specify\x20the\x20image\x20height.\"\
    \x20\n\x1eCPublishedFile_Update_Response\"\xde\x01\n,CPublishedFile_GetC\
    hangeHistoryEntry_Request\x12t\n\x0fpublishedfileid\x18\x01\x20\x01(\x06\
    R\x0fpublishedfileidBJ\x82\xb5\x18FPublished\x20file\x20id\x20of\x20the\
    \x20file\x20we'd\x20like\x20to\x20get\x20the\x20change\x20history\x20for\
    .\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x1a\n\x08langu\
    age\x18\x03\x20\x01(\x05R\x08language\"z\n-CPublishedFile_GetChangeHisto\
    ryEntry_Response\x12-\n\x12change_description\x18\x01\x20\x01(\tR\x11cha\
    ngeDescription\x12\x1a\n\x08language\x18\x02\x20\x01(\x05R\x08language\"\
    \xd7\x02\n'CPublishedFile_GetChangeHistory_Request\x12t\n\x0fpublishedfi\
    leid\x18\x01\x20\x01(\x06R\x0fpublishedfileidBJ\x82\xb5\x18FPublished\
    \x20file\x20id\x20of\x20the\x20file\x20we'd\x20like\x20to\x20get\x20the\
    \x20change\x20history\x20for.\x12K\n\ntotal_only\x18\x02\x20\x01(\x08R\t\
    totalOnlyB,\x82\xb5\x18(Return\x20the\x20total\x20number\x20of\x20change\
    s\x20only.\x12\x1e\n\nstartindex\x18\x03\x20\x01(\rR\nstartindex\x12\x14\
    \n\x05count\x18\x04\x20\x01(\rR\x05count\x123\n\x08language\x18\x05\x20\
    \x01(\x05:\x010R\x08languageB\x14\x82\xb5\x18\x10Desired\x20language\"\
    \x85\x02\n(CPublishedFile_GetChangeHistory_Response\x12M\n\x07changes\
    \x18\x01\x20\x03(\x0b23.CPublishedFile_GetChangeHistory_Response.ChangeL\
    ogR\x07changes\x12\x14\n\x05total\x18\x02\x20\x01(\rR\x05total\x1at\n\tC\
    hangeLog\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\rR\ttimestamp\x12-\n\x12c\
    hange_description\x18\x02\x20\x01(\tR\x11changeDescription\x12\x1a\n\x08\
    language\x18\x03\x20\x01(\x05R\x08language\"\xaf\x06\n)CPublishedFile_Re\
    freshVotingQueue_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12T\n\x12matching_file_type\x18\x02\x20\x01(\rR\x10matchingFileTypeB&\
    \x82\xb5\x18\"EPublishedFileInfoMatchingFileType\x12r\n\x04tags\x18\x03\
    \x20\x03(\tR\x04tagsB^\x82\xb5\x18ZInclude\x20files\x20that\x20have\x20a\
    ll\x20the\x20tags\x20or\x20any\x20of\x20the\x20tags\x20if\x20match_all_t\
    ags\x20is\x20set\x20to\x20false.\x12\xa3\x01\n\x0ematch_all_tags\x18\x04\
    \x20\x01(\x08:\x04trueR\x0cmatchAllTagsBw\x82\xb5\x18sIf\x20true,\x20the\
    n\x20files\x20must\x20have\x20all\x20the\x20tags\x20specified.\x20\x20If\
    \x20false,\x20then\x20must\x20have\x20at\x20least\x20one\x20of\x20the\
    \x20tags\x20specified.\x12W\n\rexcluded_tags\x18\x05\x20\x03(\tR\x0cexcl\
    udedTagsB2\x82\xb5\x18.Exclude\x20any\x20files\x20that\x20have\x20any\
    \x20of\x20these\x20tags.\x12|\n\x12desired_queue_size\x18\x06\x20\x01(\r\
    R\x10desiredQueueSizeBN\x82\xb5\x18JDesired\x20number\x20of\x20items\x20\
    in\x20the\x20voting\x20queue.\x20\x20May\x20be\x20clamped\x20by\x20the\
    \x20server\x12\xa4\x01\n\x10desired_revision\x18\x08\x20\x01(\x0e2\x17.E\
    PublishedFileRevision:\x20k_EPublishedFileRevision_DefaultR\x0fdesiredRe\
    visionB>\x82\xb5\x18:Filter\x20to\x20items\x20that\x20have\x20data\x20fo\
    r\x20the\x20specified\x20revision.\",\n*CPublishedFile_RefreshVotingQueu\
    e_Response\"\xd9\x1e\n!CPublishedFile_QueryFiles_Request\x12W\n\nquery_t\
    ype\x18\x01\x20\x01(\rR\tqueryTypeB8\x82\xb5\x184enumeration\x20EPublish\
    edFileQueryType\x20in\x20clientenums.h\x12$\n\x04page\x18\x02\x20\x01(\r\
    R\x04pageB\x10\x82\xb5\x18\x0cCurrent\x20page\x12\xf0\x01\n\x06cursor\
    \x18'\x20\x01(\tR\x06cursorB\xd7\x01\x82\xb5\x18\xd2\x01Cursor\x20to\x20\
    paginate\x20through\x20the\x20results\x20(set\x20to\x20'*'\x20for\x20the\
    \x20first\x20request).\x20\x20Prefer\x20this\x20over\x20using\x20the\x20\
    page\x20parameter,\x20as\x20it\x20will\x20allow\x20you\x20to\x20do\x20de\
    ep\x20pagination.\x20\x20When\x20used,\x20the\x20page\x20parameter\x20wi\
    ll\x20be\x20ignored.\x12\\\n\nnumperpage\x18\x03\x20\x01(\r:\x011R\nnump\
    erpageB9\x82\xb5\x185(Optional)\x20The\x20number\x20of\x20results,\x20pe\
    r\x20page\x20to\x20return.\x12C\n\rcreator_appid\x18\x04\x20\x01(\rR\x0c\
    creatorAppidB\x1e\x82\xb5\x18\x1aApp\x20that\x20created\x20the\x20files\
    \x125\n\x05appid\x18\x05\x20\x01(\rR\x05appidB\x1f\x82\xb5\x18\x1bApp\
    \x20that\x20consumes\x20the\x20files\x12\\\n\x0crequiredtags\x18\x06\x20\
    \x03(\tR\x0crequiredtagsB8\x82\xb5\x184Tags\x20to\x20match\x20on.\x20See\
    \x20match_all_tags\x20parameter\x20below\x12z\n\x0cexcludedtags\x18\x07\
    \x20\x03(\tR\x0cexcludedtagsBV\x82\xb5\x18R(Optional)\x20Tags\x20that\
    \x20must\x20NOT\x20be\x20present\x20on\x20a\x20published\x20file\x20to\
    \x20satisfy\x20the\x20query.\x12\x98\x01\n\x0ematch_all_tags\x18\x08\x20\
    \x01(\x08:\x04trueR\x0cmatchAllTagsBl\x82\xb5\x18hIf\x20true,\x20then\
    \x20items\x20must\x20have\x20all\x20the\x20tags\x20specified,\x20otherwi\
    se\x20they\x20must\x20have\x20at\x20least\x20one\x20of\x20the\x20tags.\
    \x12`\n\x0erequired_flags\x18\t\x20\x03(\tR\rrequiredFlagsB9\x82\xb5\x18\
    5Required\x20flags\x20that\x20must\x20be\x20set\x20on\x20any\x20returned\
    \x20items\x12Y\n\romitted_flags\x18\n\x20\x03(\tR\x0comittedFlagsB4\x82\
    \xb5\x180Flags\x20that\x20must\x20not\x20be\x20set\x20on\x20any\x20retur\
    ned\x20items\x12U\n\x0bsearch_text\x18\x0b\x20\x01(\tR\nsearchTextB4\x82\
    \xb5\x180Text\x20to\x20match\x20in\x20the\x20item's\x20title\x20or\x20de\
    scription\x12B\n\x08filetype\x18\x0c\x20\x01(\rR\x08filetypeB&\x82\xb5\
    \x18\"EPublishedFileInfoMatchingFileType\x12f\n\x15child_publishedfileid\
    \x18\r\x20\x01(\x06R\x14childPublishedfileidB1\x82\xb5\x18-Find\x20all\
    \x20items\x20that\x20reference\x20the\x20given\x20item.\x12\x88\x01\n\
    \x04days\x18\x0e\x20\x01(\rR\x04daysBt\x82\xb5\x18pIf\x20query_type\x20i\
    s\x20k_PublishedFileQueryType_RankedByTrend,\x20then\x20this\x20is\x20th\
    e\x20number\x20of\x20days\x20to\x20get\x20votes\x20for\x20[1,7].\x12\xc8\
    \x01\n\x19include_recent_votes_only\x18\x0f\x20\x01(\x08R\x16includeRece\
    ntVotesOnlyB\x8c\x01\x82\xb5\x18\x87\x01If\x20query_type\x20is\x20k_Publ\
    ishedFileQueryType_RankedByTrend,\x20then\x20limit\x20result\x20set\x20j\
    ust\x20to\x20items\x20that\x20have\x20votes\x20within\x20the\x20day\x20r\
    ange\x20given\x12~\n\x15cache_max_age_seconds\x18\x1f\x20\x01(\r:\x010R\
    \x12cacheMaxAgeSecondsBH\x82\xb5\x18DAllow\x20stale\x20data\x20to\x20be\
    \x20returned\x20for\x20the\x20specified\x20number\x20of\x20seconds.\x12j\
    \n\x08language\x18!\x20\x01(\x05:\x010R\x08languageBK\x82\xb5\x18GLangua\
    ge\x20to\x20search\x20in\x20and\x20also\x20what\x20gets\x20returned.\x20\
    Defaults\x20to\x20English.\x12|\n\x10required_kv_tags\x18\"\x20\x03(\x0b\
    2(.CPublishedFile_QueryFiles_Request.KVTagR\x0erequiredKvTagsB(\x82\xb5\
    \x18$Required\x20key-value\x20tags\x20to\x20match\x20on.\x12\xac\x01\n\t\
    taggroups\x18*\x20\x03(\x0b2+.CPublishedFile_QueryFiles_Request.TagGroup\
    R\ttaggroupsBa\x82\xb5\x18](Optional)\x20At\x20least\x20one\x20of\x20the\
    \x20tags\x20must\x20be\x20present\x20on\x20a\x20published\x20file\x20to\
    \x20satisfy\x20the\x20query.\x12t\n\ttotalonly\x18\x10\x20\x01(\x08R\tto\
    talonlyBV\x82\xb5\x18R(Optional)\x20If\x20true,\x20only\x20return\x20the\
    \x20total\x20number\x20of\x20files\x20that\x20satisfy\x20this\x20query.\
    \x12w\n\x08ids_only\x18#\x20\x01(\x08R\x07idsOnlyB\\\x82\xb5\x18X(Option\
    al)\x20If\x20true,\x20only\x20return\x20the\x20published\x20file\x20ids\
    \x20of\x20files\x20that\x20satisfy\x20this\x20query.\x12>\n\x10return_vo\
    te_data\x18\x11\x20\x01(\x08R\x0ereturnVoteDataB\x14\x82\xb5\x18\x10Retu\
    rn\x20vote\x20data\x12D\n\x0breturn_tags\x18\x12\x20\x01(\x08R\nreturnTa\
    gsB#\x82\xb5\x18\x1fReturn\x20tags\x20in\x20the\x20file\x20details\x12S\
    \n\x0ereturn_kv_tags\x18\x13\x20\x01(\x08R\x0creturnKvTagsB-\x82\xb5\x18\
    )Return\x20key-value\x20tags\x20in\x20the\x20file\x20details\x12g\n\x0fr\
    eturn_previews\x18\x14\x20\x01(\x08R\x0ereturnPreviewsB>\x82\xb5\x18:Ret\
    urn\x20preview\x20image\x20and\x20video\x20details\x20in\x20the\x20file\
    \x20details\x12V\n\x0freturn_children\x18\x15\x20\x01(\x08R\x0ereturnChi\
    ldrenB-\x82\xb5\x18)Return\x20child\x20item\x20ids\x20in\x20the\x20file\
    \x20details\x12~\n\x18return_short_description\x18\x16\x20\x01(\x08R\x16\
    returnShortDescriptionBD\x82\xb5\x18@Populate\x20the\x20short_descriptio\
    n\x20field\x20instead\x20of\x20file_description\x12^\n\x14return_for_sal\
    e_data\x18\x1e\x20\x01(\x08R\x11returnForSaleDataB-\x82\xb5\x18)Return\
    \x20pricing\x20information,\x20if\x20applicable\x12I\n\x0freturn_metadat\
    a\x18\x20\x20\x01(\x08:\x05falseR\x0ereturnMetadataB\x19\x82\xb5\x18\x15\
    Populate\x20the\x20metadata\x12|\n\x15return_playtime_stats\x18$\x20\x01\
    (\rR\x13returnPlaytimeStatsBH\x82\xb5\x18DReturn\x20playtime\x20stats\
    \x20for\x20the\x20specified\x20number\x20of\x20days\x20before\x20today.\
    \x12\xc6\x01\n\x0ereturn_details\x18%\x20\x01(\x08R\rreturnDetailsB\x9e\
    \x01\x82\xb5\x18\x99\x01By\x20default,\x20if\x20none\x20of\x20the\x20oth\
    er\x20'return_*'\x20fields\x20are\x20set,\x20only\x20some\x20voting\x20d\
    etails\x20are\x20returned.\x20Set\x20this\x20to\x20true\x20to\x20return\
    \x20the\x20default\x20set\x20of\x20details.\x12^\n\x18strip_description_\
    bbcode\x18&\x20\x01(\x08R\x16stripDescriptionBbcodeB$\x82\xb5\x18\x20Str\
    ips\x20BBCode\x20from\x20descriptions.\x12\x95\x01\n\x10desired_revision\
    \x18(\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPublishedFileRevis\
    ion_DefaultR\x0fdesiredRevisionB/\x82\xb5\x18+Return\x20the\x20data\x20f\
    or\x20the\x20specified\x20revision.\x1a/\n\x05KVTag\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \x1a\x1e\n\x08TagGroup\x12\x12\n\x04tags\x18\x01\x20\x03(\tR\x04tags\"\
    \xaf\x03\n\"CPublishedFile_QueryFiles_Response\x12[\n\x05total\x18\x01\
    \x20\x01(\rR\x05totalBE\x82\xb5\x18ANumber\x20of\x20matches\x20found,\
    \x20not\x20necessarily\x20number\x20of\x20items\x20returned\x12\xa3\x01\
    \n\x14publishedfiledetails\x18\x02\x20\x03(\x0b2\x15.PublishedFileDetail\
    sR\x14publishedfiledetailsBX\x82\xb5\x18TEach\x20file\x20details\x20will\
    \x20be\x20populated,\x20depending\x20on\x20what\x20return\x20values\x20w\
    ere\x20requested.\x12\x85\x01\n\x0bnext_cursor\x18\x03\x20\x01(\tR\nnext\
    CursorBd\x82\xb5\x18`If\x20a\x20paging\x20cursor\x20was\x20used,\x20then\
    \x20this\x20will\x20be\x20the\x20next\x20cursor\x20to\x20use\x20for\x20p\
    aging\x20through\x20results\"\x8f\x01\n)CPublishedFile_AddAppRelationshi\
    p_Request\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfi\
    leid\x12\x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12\"\n\x0crelation\
    ship\x18\x03\x20\x01(\rR\x0crelationship\",\n*CPublishedFile_AddAppRelat\
    ionship_Response\"\x92\x01\n,CPublishedFile_RemoveAppRelationship_Reques\
    t\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\x12\
    \x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12\"\n\x0crelationship\x18\
    \x03\x20\x01(\rR\x0crelationship\"/\n-CPublishedFile_RemoveAppRelationsh\
    ip_Response\"V\n*CPublishedFile_GetAppRelationships_Request\x12(\n\x0fpu\
    blishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\"\xe5\x01\n+CPubl\
    ishedFile_GetAppRelationships_Response\x12i\n\x11app_relationships\x18\
    \x03\x20\x03(\x0b2<.CPublishedFile_GetAppRelationships_Response.AppRelat\
    ionshipR\x10appRelationships\x1aK\n\x0fAppRelationship\x12\x14\n\x05appi\
    d\x18\x01\x20\x01(\rR\x05appid\x12\"\n\x0crelationship\x18\x02\x20\x01(\
    \rR\x0crelationship\"p\n,CPublishedFile_StartPlaytimeTracking_Request\
    \x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12*\n\x10publishedfile\
    ids\x18\x02\x20\x03(\x04R\x10publishedfileids\"/\n-CPublishedFile_StartP\
    laytimeTracking_Response\"o\n+CPublishedFile_StopPlaytimeTracking_Reques\
    t\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12*\n\x10publishedfil\
    eids\x18\x02\x20\x03(\x04R\x10publishedfileids\".\n,CPublishedFile_StopP\
    laytimeTracking_Response\"Q\n9CPublishedFile_StopPlaytimeTrackingForAllA\
    ppItems_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"<\n:CPu\
    blishedFile_StopPlaytimeTrackingForAllAppItems_Response\"\xc0\x02\n6CPub\
    lishedFile_SetPlaytimeForControllerConfigs_Request\x12\x14\n\x05appid\
    \x18\x01\x20\x01(\rR\x05appid\x12\x85\x01\n\x17controller_config_usage\
    \x18\x02\x20\x03(\x0b2M.CPublishedFile_SetPlaytimeForControllerConfigs_R\
    equest.ControllerConfigUsageR\x15controllerConfigUsage\x1ah\n\x15Control\
    lerConfigUsage\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublis\
    hedfileid\x12%\n\x0eseconds_active\x18\x02\x20\x01(\x02R\rsecondsActive\
    \"9\n7CPublishedFile_SetPlaytimeForControllerConfigs_Response\"\x80\x01\
    \n\x1fCPublishedFile_AddChild_Request\x12(\n\x0fpublishedfileid\x18\x01\
    \x20\x01(\x04R\x0fpublishedfileid\x123\n\x15child_publishedfileid\x18\
    \x02\x20\x01(\x04R\x14childPublishedfileid\"\"\n\x20CPublishedFile_AddCh\
    ild_Response\"\x83\x01\n\"CPublishedFile_RemoveChild_Request\x12(\n\x0fp\
    ublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\x123\n\x15child_\
    publishedfileid\x18\x02\x20\x01(\x04R\x14childPublishedfileid\"%\n#CPubl\
    ishedFile_RemoveChild_Response\"W\n)CPublishedFile_GetUserVoteSummary_Re\
    quest\x12*\n\x10publishedfileids\x18\x01\x20\x03(\x06R\x10publishedfilei\
    ds\"\x97\x02\n*CPublishedFile_GetUserVoteSummary_Response\x12U\n\tsummar\
    ies\x18\x01\x20\x03(\x0b27.CPublishedFile_GetUserVoteSummary_Response.Vo\
    teSummaryR\tsummaries\x1a\x91\x01\n\x0bVoteSummary\x12(\n\x0fpublishedfi\
    leid\x18\x01\x20\x01(\x06R\x0fpublishedfileid\x12\x19\n\x08vote_for\x18\
    \x02\x20\x01(\x08R\x07voteFor\x12!\n\x0cvote_against\x18\x03\x20\x01(\
    \x08R\x0bvoteAgainst\x12\x1a\n\x08reported\x18\x04\x20\x01(\x08R\x08repo\
    rted\"\xbf\x06\n*CPublishedFile_FileSubscribed_Notification\x12Q\n\x11pu\
    blished_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileIdB%\x82\xb5\x18!P\
    ublishedFileID_t\x20for\x20the\x20content\x12\x15\n\x06app_id\x18\x02\
    \x20\x01(\rR\x05appId\x12H\n\rfile_hcontent\x18\x03\x20\x01(\x06R\x0cfil\
    eHcontentB#\x82\xb5\x18\x1fUGC\x20file\x20handle\x20or\x20manifest\x20GI\
    D\x12\x1b\n\tfile_size\x18\x04\x20\x01(\rR\x08fileSize\x12)\n\x10rtime_s\
    ubscribed\x18\x05\x20\x01(\rR\x0frtimeSubscribed\x12^\n\x10is_depot_cont\
    ent\x18\x06\x20\x01(\x08R\x0eisDepotContentB4\x82\xb5\x180True\x20if\x20\
    workshop\x20item\x20is\x20delivered\x20via\x20Steampipe\x12B\n\rrtime_up\
    dated\x18\x07\x20\x01(\rR\x0crtimeUpdatedB\x1d\x82\xb5\x18\x19Last\x20ti\
    me\x20content\x20updated\x12\x8d\x01\n\trevisions\x18\x08\x20\x03(\x0b28\
    .CPublishedFile_FileSubscribed_Notification.RevisionDataR\trevisionsB5\
    \x82\xb5\x181Data\x20for\x20each\x20of\x20the\x20revisions\x20that\x20th\
    is\x20item\x20has\x1a\xe0\x01\n\x0cRevisionData\x12U\n\x08revision\x18\
    \x01\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPublishedFileRevisi\
    on_DefaultR\x08revision\x125\n\rfile_hcontent\x18\x02\x20\x01(\x06R\x0cf\
    ileHcontentB\x10\x82\xb5\x18\x0cManifest\x20GID\x12B\n\rrtime_updated\
    \x18\x03\x20\x01(\rR\x0crtimeUpdatedB\x1d\x82\xb5\x18\x19Last\x20time\
    \x20content\x20updated\"\x98\x01\n,CPublishedFile_FileUnsubscribed_Notif\
    ication\x12Q\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFi\
    leIdB%\x82\xb5\x18!PublishedFileID_t\x20for\x20the\x20content\x12\x15\n\
    \x06app_id\x18\x02\x20\x01(\rR\x05appId\"\x9a\x01\n.CPublishedFile_FileD\
    eleted_Client_Notification\x12Q\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileIdB%\x82\xb5\x18!PublishedFileID_t\x20for\x20the\
    \x20content\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId*\xab\x02\n\
    \x16EPublishedFileRevision\x12$\n\x20k_EPublishedFileRevision_Default\
    \x10\0\x12#\n\x1fk_EPublishedFileRevision_Latest\x10\x01\x12-\n)k_EPubli\
    shedFileRevision_ApprovedSnapshot\x10\x02\x123\n/k_EPublishedFileRevisio\
    n_ApprovedSnapshot_China\x10\x03\x12-\n)k_EPublishedFileRevision_Rejecte\
    dSnapshot\x10\x04\x123\n/k_EPublishedFileRevision_RejectedSnapshot_China\
    \x10\x05*\xc8\x01\n\x1bEPublishedFileForSaleStatus\x12\x16\n\x12k_PFFSS_\
    NotForSale\x10\0\x12\x1b\n\x17k_PFFSS_PendingApproval\x10\x01\x12\x1b\n\
    \x17k_PFFSS_ApprovedForSale\x10\x02\x12\x1b\n\x17k_PFFSS_RejectedForSale\
    \x10\x03\x12\x1b\n\x17k_PFFSS_NoLongerForSale\x10\x04\x12\x1d\n\x19k_PFF\
    SS_TentativeApproval\x10\x052\xd7\x1e\n\rPublishedFile\x12\x81\x01\n\tSu\
    bscribe\x12!.CPublishedFile_Subscribe_Request\x1a\".CPublishedFile_Subsc\
    ribe_Response\"-\x82\xb5\x18)Subscribes\x20the\x20user\x20to\x20the\x20p\
    ublished\x20file\x12\x8b\x01\n\x0bUnsubscribe\x12#.CPublishedFile_Unsubs\
    cribe_Request\x1a$.CPublishedFile_Unsubscribe_Response\"1\x82\xb5\x18-Un\
    subscribes\x20the\x20user\x20from\x20the\x20published\x20file\x12\x96\
    \x01\n\x0cCanSubscribe\x12$.CPublishedFile_CanSubscribe_Request\x1a%.CPu\
    blishedFile_CanSubscribe_Response\"9\x82\xb5\x185Check\x20if\x20the\x20u\
    ser\x20can\x20subscribe\x20to\x20the\x20published\x20file\x12\x80\x01\n\
    \x07Publish\x12\x1f.CPublishedFile_Publish_Request\x1a\x20.CPublishedFil\
    e_Publish_Response\"2\x82\xb5\x18.Publishes\x20a\x20clouded\x20user\x20f\
    ile\x20to\x20the\x20Workshop.\x12\x90\x01\n\nGetDetails\x12\".CPublished\
    File_GetDetails_Request\x1a#.CPublishedFile_GetDetails_Response\"9\x82\
    \xb5\x185Retrieves\x20information\x20about\x20a\x20set\x20of\x20publishe\
    d\x20files.\x12\x93\x01\n\x0bGetItemInfo\x12#.CPublishedFile_GetItemInfo\
    _Request\x1a$.CPublishedFile_GetItemInfo_Response\"9\x82\xb5\x185Retriev\
    es\x20information\x20about\x20a\x20set\x20of\x20published\x20files.\x12\
    \x85\x01\n\x0cGetUserFiles\x12$.CPublishedFile_GetUserFiles_Request\x1a%\
    .CPublishedFile_GetUserFiles_Response\"(\x82\xb5\x18$Retrieves\x20files\
    \x20published\x20by\x20a\x20user.\x12\xd5\x01\n\x1aAreFilesInSubscriptio\
    nList\x122.CPublishedFile_AreFilesInSubscriptionList_Request\x1a3.CPubli\
    shedFile_AreFilesInSubscriptionList_Response\"N\x82\xb5\x18JDetermines\
    \x20which\x20files\x20in\x20the\x20given\x20list\x20are\x20in\x20a\x20us\
    er's\x20subscription\x20list\x12z\n\x06Update\x12\x1e.CPublishedFile_Upd\
    ate_Request\x1a\x1f.CPublishedFile_Update_Response\"/\x82\xb5\x18+Update\
    s\x20information\x20about\x20a\x20published\x20file.\x12\xc0\x01\n\x15Ge\
    tChangeHistoryEntry\x12-.CPublishedFile_GetChangeHistoryEntry_Request\
    \x1a..CPublishedFile_GetChangeHistoryEntry_Response\"H\x82\xb5\x18DRetur\
    ns\x20data\x20on\x20a\x20specific\x20change\x20history\x20entry\x20for\
    \x20a\x20published\x20file\x12\xa4\x01\n\x10GetChangeHistory\x12(.CPubli\
    shedFile_GetChangeHistory_Request\x1a).CPublishedFile_GetChangeHistory_R\
    esponse\";\x82\xb5\x187Returns\x20data\x20on\x20the\x20change\x20history\
    \x20for\x20a\x20published\x20file\x12\x98\x01\n\x12RefreshVotingQueue\
    \x12*.CPublishedFile_RefreshVotingQueue_Request\x1a+.CPublishedFile_Refr\
    eshVotingQueue_Response\")\x82\xb5\x18%Refresh\x20the\x20voting\x20queue\
    \x20for\x20the\x20user\x12\x86\x01\n\nQueryFiles\x12\".CPublishedFile_Qu\
    eryFiles_Request\x1a#.CPublishedFile_QueryFiles_Response\"/\x82\xb5\x18+\
    Performs\x20a\x20search\x20query\x20for\x20published\x20files\x12\xb3\
    \x01\n\x12AddAppRelationship\x12*.CPublishedFile_AddAppRelationship_Requ\
    est\x1a+.CPublishedFile_AddAppRelationship_Response\"D\x82\xb5\x18@Adds\
    \x20a\x20relationship\x20between\x20the\x20published\x20file\x20and\x20t\
    he\x20given\x20app\x12\xbe\x01\n\x15RemoveAppRelationship\x12-.CPublishe\
    dFile_RemoveAppRelationship_Request\x1a..CPublishedFile_RemoveAppRelatio\
    nship_Response\"F\x82\xb5\x18BRemove\x20a\x20relationship\x20between\x20\
    the\x20published\x20file\x20and\x20the\x20given\x20app\x12\xb3\x01\n\x13\
    GetAppRelationships\x12+.CPublishedFile_GetAppRelationships_Request\x1a,\
    .CPublishedFile_GetAppRelationships_Response\"A\x82\xb5\x18=Returns\x20t\
    he\x20list\x20of\x20app\x20relationships\x20for\x20this\x20published\x20\
    file\x12\xb3\x01\n\x15StartPlaytimeTracking\x12-.CPublishedFile_StartPla\
    ytimeTracking_Request\x1a..CPublishedFile_StartPlaytimeTracking_Response\
    \";\x82\xb5\x187Start\x20usage\x20tracking\x20for\x20a\x20given\x20set\
    \x20of\x20published\x20files\x12\xb0\x01\n\x14StopPlaytimeTracking\x12,.\
    CPublishedFile_StopPlaytimeTracking_Request\x1a-.CPublishedFile_StopPlay\
    timeTracking_Response\";\x82\xb5\x187Stops\x20usage\x20tracking\x20for\
    \x20a\x20given\x20set\x20of\x20published\x20files\x12\xed\x01\n\"StopPla\
    ytimeTrackingForAllAppItems\x12:.CPublishedFile_StopPlaytimeTrackingForA\
    llAppItems_Request\x1a;.CPublishedFile_StopPlaytimeTrackingForAllAppItem\
    s_Response\"N\x82\xb5\x18JStops\x20usage\x20tracking\x20for\x20all\x20it\
    ems\x20currently\x20tracked\x20for\x20the\x20specified\x20app\x12\x98\
    \x02\n\x1fSetPlaytimeForControllerConfigs\x127.CPublishedFile_SetPlaytim\
    eForControllerConfigs_Request\x1a8.CPublishedFile_SetPlaytimeForControll\
    erConfigs_Response\"\x81\x01\x82\xb5\x18}Stops\x20usage\x20tracking\x20a\
    ll\x20controller\x20configs\x20for\x20the\x20given\x20app\x20and\x20set\
    \x20the\x20usage\x20time\x20for\x20the\x20for\x20the\x20given\x20control\
    ler\x20configs\x12\x8f\x01\n\x08AddChild\x12\x20.CPublishedFile_AddChild\
    _Request\x1a!.CPublishedFile_AddChild_Response\">\x82\xb5\x18:Adds\x20a\
    \x20parent->child\x20relationship\x20between\x20the\x20given\x20items.\
    \x12\x99\x01\n\x0bRemoveChild\x12#.CPublishedFile_RemoveChild_Request\
    \x1a$.CPublishedFile_RemoveChild_Response\"?\x82\xb5\x18;Removes\x20pare\
    nt->child\x20relationship\x20between\x20the\x20given\x20items.\x12\x88\
    \x01\n\x12GetUserVoteSummary\x12*.CPublishedFile_GetUserVoteSummary_Requ\
    est\x1a+.CPublishedFile_GetUserVoteSummary_Response\"\x19\x82\xb5\x18\
    \x15Get\x20user\x20vote\x20summary\x1a+\x82\xb5\x18'A\x20service\x20to\
    \x20access\x20published\x20file\x20data2\x8d\x04\n\x13PublishedFileClien\
    t\x12\x93\x01\n\x14NotifyFileSubscribed\x12+.CPublishedFile_FileSubscrib\
    ed_Notification\x1a\x0b.NoResponse\"A\x82\xb5\x18=Notification\x20from\
    \x20the\x20server\x20when\x20a\x20user\x20subscribes\x20to\x20a\x20file\
    \x12\x9b\x01\n\x16NotifyFileUnsubscribed\x12-.CPublishedFile_FileUnsubsc\
    ribed_Notification\x1a\x0b.NoResponse\"E\x82\xb5\x18ANotification\x20fro\
    m\x20the\x20server\x20when\x20a\x20user\x20unsubscribes\x20from\x20a\x20\
    file\x12\x94\x01\n\x11NotifyFileDeleted\x12/.CPublishedFile_FileDeleted_\
    Client_Notification\x1a\x0b.NoResponse\"A\x82\xb5\x18=Notification\x20fr\
    om\x20the\x20server\x20when\x20a\x20published\x20file\x20is\x20deleted\
    \x1a+\xc0\xb5\x18\x02\x82\xb5\x18#Published\x20file\x20client\x20notific\
    ationsB\x03\x80\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
