// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_player.steamclient.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetMutualFriendsForIncomingInvites_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn default() -> &'a CPlayer_GetMutualFriendsForIncomingInvites_Request {
        <CPlayer_GetMutualFriendsForIncomingInvites_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMutualFriendsForIncomingInvites_Request {
    pub fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Request {
        CPlayer_GetMutualFriendsForIncomingInvites_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetMutualFriendsForIncomingInvites_Request>(
                    "CPlayer_GetMutualFriendsForIncomingInvites_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetMutualFriendsForIncomingInvites_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetMutualFriendsForIncomingInvites_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetMutualFriendsForIncomingInvites_Request,
        };
        unsafe {
            instance.get(CPlayer_GetMutualFriendsForIncomingInvites_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_IncomingInviteMutualFriendList {
    // message fields
    steamid: ::std::option::Option<u64>,
    mutual_friend_account_ids: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IncomingInviteMutualFriendList {
    fn default() -> &'a CPlayer_IncomingInviteMutualFriendList {
        <CPlayer_IncomingInviteMutualFriendList as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IncomingInviteMutualFriendList {
    pub fn new() -> CPlayer_IncomingInviteMutualFriendList {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // repeated uint32 mutual_friend_account_ids = 2;


    pub fn get_mutual_friend_account_ids(&self) -> &[u32] {
        &self.mutual_friend_account_ids
    }
    pub fn clear_mutual_friend_account_ids(&mut self) {
        self.mutual_friend_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_mutual_friend_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.mutual_friend_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mutual_friend_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mutual_friend_account_ids
    }

    // Take field
    pub fn take_mutual_friend_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mutual_friend_account_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPlayer_IncomingInviteMutualFriendList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mutual_friend_account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        for value in &self.mutual_friend_account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        for v in &self.mutual_friend_account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IncomingInviteMutualFriendList {
        CPlayer_IncomingInviteMutualFriendList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPlayer_IncomingInviteMutualFriendList| { &m.steamid },
                    |m: &mut CPlayer_IncomingInviteMutualFriendList| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mutual_friend_account_ids",
                    |m: &CPlayer_IncomingInviteMutualFriendList| { &m.mutual_friend_account_ids },
                    |m: &mut CPlayer_IncomingInviteMutualFriendList| { &mut m.mutual_friend_account_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_IncomingInviteMutualFriendList>(
                    "CPlayer_IncomingInviteMutualFriendList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_IncomingInviteMutualFriendList {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_IncomingInviteMutualFriendList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_IncomingInviteMutualFriendList,
        };
        unsafe {
            instance.get(CPlayer_IncomingInviteMutualFriendList::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_IncomingInviteMutualFriendList {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.mutual_friend_account_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IncomingInviteMutualFriendList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IncomingInviteMutualFriendList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetMutualFriendsForIncomingInvites_Response {
    // message fields
    incoming_invite_mutual_friends_lists: ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn default() -> &'a CPlayer_GetMutualFriendsForIncomingInvites_Response {
        <CPlayer_GetMutualFriendsForIncomingInvites_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMutualFriendsForIncomingInvites_Response {
    pub fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_IncomingInviteMutualFriendList incoming_invite_mutual_friends_lists = 1;


    pub fn get_incoming_invite_mutual_friends_lists(&self) -> &[CPlayer_IncomingInviteMutualFriendList] {
        &self.incoming_invite_mutual_friends_lists
    }
    pub fn clear_incoming_invite_mutual_friends_lists(&mut self) {
        self.incoming_invite_mutual_friends_lists.clear();
    }

    // Param is passed by value, moved
    pub fn set_incoming_invite_mutual_friends_lists(&mut self, v: ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList>) {
        self.incoming_invite_mutual_friends_lists = v;
    }

    // Mutable pointer to the field.
    pub fn mut_incoming_invite_mutual_friends_lists(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList> {
        &mut self.incoming_invite_mutual_friends_lists
    }

    // Take field
    pub fn take_incoming_invite_mutual_friends_lists(&mut self) -> ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList> {
        ::std::mem::replace(&mut self.incoming_invite_mutual_friends_lists, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.incoming_invite_mutual_friends_lists {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.incoming_invite_mutual_friends_lists)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.incoming_invite_mutual_friends_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.incoming_invite_mutual_friends_lists {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Response {
        CPlayer_GetMutualFriendsForIncomingInvites_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_IncomingInviteMutualFriendList>>(
                    "incoming_invite_mutual_friends_lists",
                    |m: &CPlayer_GetMutualFriendsForIncomingInvites_Response| { &m.incoming_invite_mutual_friends_lists },
                    |m: &mut CPlayer_GetMutualFriendsForIncomingInvites_Response| { &mut m.incoming_invite_mutual_friends_lists },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetMutualFriendsForIncomingInvites_Response>(
                    "CPlayer_GetMutualFriendsForIncomingInvites_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetMutualFriendsForIncomingInvites_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetMutualFriendsForIncomingInvites_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetMutualFriendsForIncomingInvites_Response,
        };
        unsafe {
            instance.get(CPlayer_GetMutualFriendsForIncomingInvites_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn clear(&mut self) {
        self.incoming_invite_mutual_friends_lists.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Request {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Request {
        <CPlayer_GetFriendsGameplayInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Request {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Request {
        CPlayer_GetFriendsGameplayInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPlayer_GetFriendsGameplayInfo_Request| { &m.appid },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Request| { &mut m.appid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsGameplayInfo_Request>(
                    "CPlayer_GetFriendsGameplayInfo_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsGameplayInfo_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsGameplayInfo_Request,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsGameplayInfo_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Response {
    // message fields
    your_info: ::protobuf::SingularPtrField<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo>,
    in_game: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    played_recently: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    played_ever: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    owns: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    in_wishlist: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Response {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Response {
        <CPlayer_GetFriendsGameplayInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Response {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CPlayer_GetFriendsGameplayInfo_Response.OwnGameplayInfo your_info = 1;


    pub fn get_your_info(&self) -> &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        self.your_info.as_ref().unwrap_or_else(|| CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo::default_instance())
    }
    pub fn clear_your_info(&mut self) {
        self.your_info.clear();
    }

    pub fn has_your_info(&self) -> bool {
        self.your_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_info(&mut self, v: CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo) {
        self.your_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_your_info(&mut self) -> &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        if self.your_info.is_none() {
            self.your_info.set_default();
        }
        self.your_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_your_info(&mut self) -> CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        self.your_info.take().unwrap_or_else(|| CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo in_game = 2;


    pub fn get_in_game(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.in_game
    }
    pub fn clear_in_game(&mut self) {
        self.in_game.clear();
    }

    // Param is passed by value, moved
    pub fn set_in_game(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.in_game = v;
    }

    // Mutable pointer to the field.
    pub fn mut_in_game(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.in_game
    }

    // Take field
    pub fn take_in_game(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.in_game, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo played_recently = 3;


    pub fn get_played_recently(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.played_recently
    }
    pub fn clear_played_recently(&mut self) {
        self.played_recently.clear();
    }

    // Param is passed by value, moved
    pub fn set_played_recently(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.played_recently = v;
    }

    // Mutable pointer to the field.
    pub fn mut_played_recently(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.played_recently
    }

    // Take field
    pub fn take_played_recently(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.played_recently, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo played_ever = 4;


    pub fn get_played_ever(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.played_ever
    }
    pub fn clear_played_ever(&mut self) {
        self.played_ever.clear();
    }

    // Param is passed by value, moved
    pub fn set_played_ever(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.played_ever = v;
    }

    // Mutable pointer to the field.
    pub fn mut_played_ever(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.played_ever
    }

    // Take field
    pub fn take_played_ever(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.played_ever, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo owns = 5;


    pub fn get_owns(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.owns
    }
    pub fn clear_owns(&mut self) {
        self.owns.clear();
    }

    // Param is passed by value, moved
    pub fn set_owns(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.owns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owns(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.owns
    }

    // Take field
    pub fn take_owns(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.owns, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo in_wishlist = 6;


    pub fn get_in_wishlist(&self) -> &[CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo] {
        &self.in_wishlist
    }
    pub fn clear_in_wishlist(&mut self) {
        self.in_wishlist.clear();
    }

    // Param is passed by value, moved
    pub fn set_in_wishlist(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>) {
        self.in_wishlist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_in_wishlist(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        &mut self.in_wishlist
    }

    // Take field
    pub fn take_in_wishlist(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> {
        ::std::mem::replace(&mut self.in_wishlist, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.your_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_game {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.played_recently {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.played_ever {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owns {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_wishlist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.your_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.in_game)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.played_recently)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.played_ever)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.owns)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.in_wishlist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.your_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.in_game {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.played_recently {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.played_ever {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.owns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.in_wishlist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.your_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.in_game {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.played_recently {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.played_ever {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.owns {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.in_wishlist {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Response {
        CPlayer_GetFriendsGameplayInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo>>(
                    "your_info",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.your_info },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.your_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                    "in_game",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.in_game },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.in_game },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                    "played_recently",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.played_recently },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.played_recently },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                    "played_ever",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.played_ever },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.played_ever },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                    "owns",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.owns },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.owns },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>>(
                    "in_wishlist",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.in_wishlist },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.in_wishlist },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsGameplayInfo_Response>(
                    "CPlayer_GetFriendsGameplayInfo_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsGameplayInfo_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsGameplayInfo_Response,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsGameplayInfo_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Response {
    fn clear(&mut self) {
        self.your_info.clear();
        self.in_game.clear();
        self.played_recently.clear();
        self.played_ever.clear();
        self.owns.clear();
        self.in_wishlist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    // message fields
    steamid: ::std::option::Option<u64>,
    minutes_played: ::std::option::Option<u32>,
    minutes_played_forever: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        <CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played = 2;


    pub fn get_minutes_played(&self) -> u32 {
        self.minutes_played.unwrap_or(0)
    }
    pub fn clear_minutes_played(&mut self) {
        self.minutes_played = ::std::option::Option::None;
    }

    pub fn has_minutes_played(&self) -> bool {
        self.minutes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played(&mut self, v: u32) {
        self.minutes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_forever = 3;


    pub fn get_minutes_played_forever(&self) -> u32 {
        self.minutes_played_forever.unwrap_or(0)
    }
    pub fn clear_minutes_played_forever(&mut self) {
        self.minutes_played_forever = ::std::option::Option::None;
    }

    pub fn has_minutes_played_forever(&self) -> bool {
        self.minutes_played_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_forever(&mut self, v: u32) {
        self.minutes_played_forever = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_forever = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.minutes_played {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_forever {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.minutes_played {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minutes_played_forever {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &m.steamid },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minutes_played",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &m.minutes_played },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &mut m.minutes_played },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minutes_played_forever",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &m.minutes_played_forever },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo| { &mut m.minutes_played_forever },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo>(
                    "CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.minutes_played = ::std::option::Option::None;
        self.minutes_played_forever = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    // message fields
    steamid: ::std::option::Option<u64>,
    minutes_played: ::std::option::Option<u32>,
    minutes_played_forever: ::std::option::Option<u32>,
    in_wishlist: ::std::option::Option<bool>,
    owned: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        <CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played = 2;


    pub fn get_minutes_played(&self) -> u32 {
        self.minutes_played.unwrap_or(0)
    }
    pub fn clear_minutes_played(&mut self) {
        self.minutes_played = ::std::option::Option::None;
    }

    pub fn has_minutes_played(&self) -> bool {
        self.minutes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played(&mut self, v: u32) {
        self.minutes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_forever = 3;


    pub fn get_minutes_played_forever(&self) -> u32 {
        self.minutes_played_forever.unwrap_or(0)
    }
    pub fn clear_minutes_played_forever(&mut self) {
        self.minutes_played_forever = ::std::option::Option::None;
    }

    pub fn has_minutes_played_forever(&self) -> bool {
        self.minutes_played_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_forever(&mut self, v: u32) {
        self.minutes_played_forever = ::std::option::Option::Some(v);
    }

    // optional bool in_wishlist = 4;


    pub fn get_in_wishlist(&self) -> bool {
        self.in_wishlist.unwrap_or(false)
    }
    pub fn clear_in_wishlist(&mut self) {
        self.in_wishlist = ::std::option::Option::None;
    }

    pub fn has_in_wishlist(&self) -> bool {
        self.in_wishlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_wishlist(&mut self, v: bool) {
        self.in_wishlist = ::std::option::Option::Some(v);
    }

    // optional bool owned = 5;


    pub fn get_owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }
    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_forever = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_wishlist = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.minutes_played {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_forever {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_wishlist {
            my_size += 2;
        }
        if let Some(v) = self.owned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.minutes_played {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minutes_played_forever {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_wishlist {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.owned {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.steamid },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minutes_played",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.minutes_played },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.minutes_played },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minutes_played_forever",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.minutes_played_forever },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.minutes_played_forever },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "in_wishlist",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.in_wishlist },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.in_wishlist },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "owned",
                    |m: &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &m.owned },
                    |m: &mut CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo| { &mut m.owned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo>(
                    "CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.minutes_played = ::std::option::Option::None;
        self.minutes_played_forever = ::std::option::Option::None;
        self.in_wishlist = ::std::option::Option::None;
        self.owned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Request {
    // message fields
    news_language: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Request {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Request {
        <CPlayer_GetFriendsAppsActivity_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Request {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Request {
        ::std::default::Default::default()
    }

    // optional string news_language = 1;


    pub fn get_news_language(&self) -> &str {
        match self.news_language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_news_language(&mut self) {
        self.news_language.clear();
    }

    pub fn has_news_language(&self) -> bool {
        self.news_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_news_language(&mut self, v: ::std::string::String) {
        self.news_language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_news_language(&mut self) -> &mut ::std::string::String {
        if self.news_language.is_none() {
            self.news_language.set_default();
        }
        self.news_language.as_mut().unwrap()
    }

    // Take field
    pub fn take_news_language(&mut self) -> ::std::string::String {
        self.news_language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.news_language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.news_language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.news_language.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Request {
        CPlayer_GetFriendsAppsActivity_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "news_language",
                    |m: &CPlayer_GetFriendsAppsActivity_Request| { &m.news_language },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Request| { &mut m.news_language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsAppsActivity_Request>(
                    "CPlayer_GetFriendsAppsActivity_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsAppsActivity_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsAppsActivity_Request,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsAppsActivity_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Request {
    fn clear(&mut self) {
        self.news_language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Response {
    // message fields
    trending: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    recent_purchases: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    unowned: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    popular: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    dont_forget: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    being_discussed: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    new_to_group: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    returned_to_group: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>,
    active_friend_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Response {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Response {
        <CPlayer_GetFriendsAppsActivity_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Response {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo trending = 1;


    pub fn get_trending(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.trending
    }
    pub fn clear_trending(&mut self) {
        self.trending.clear();
    }

    // Param is passed by value, moved
    pub fn set_trending(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.trending = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trending(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.trending
    }

    // Take field
    pub fn take_trending(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.trending, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo recent_purchases = 2;


    pub fn get_recent_purchases(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.recent_purchases
    }
    pub fn clear_recent_purchases(&mut self) {
        self.recent_purchases.clear();
    }

    // Param is passed by value, moved
    pub fn set_recent_purchases(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.recent_purchases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recent_purchases(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.recent_purchases
    }

    // Take field
    pub fn take_recent_purchases(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.recent_purchases, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo unowned = 3;


    pub fn get_unowned(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.unowned
    }
    pub fn clear_unowned(&mut self) {
        self.unowned.clear();
    }

    // Param is passed by value, moved
    pub fn set_unowned(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.unowned = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unowned(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.unowned
    }

    // Take field
    pub fn take_unowned(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.unowned, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo popular = 4;


    pub fn get_popular(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.popular
    }
    pub fn clear_popular(&mut self) {
        self.popular.clear();
    }

    // Param is passed by value, moved
    pub fn set_popular(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.popular = v;
    }

    // Mutable pointer to the field.
    pub fn mut_popular(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.popular
    }

    // Take field
    pub fn take_popular(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.popular, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo dont_forget = 5;


    pub fn get_dont_forget(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.dont_forget
    }
    pub fn clear_dont_forget(&mut self) {
        self.dont_forget.clear();
    }

    // Param is passed by value, moved
    pub fn set_dont_forget(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.dont_forget = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dont_forget(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.dont_forget
    }

    // Take field
    pub fn take_dont_forget(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.dont_forget, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo being_discussed = 6;


    pub fn get_being_discussed(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.being_discussed
    }
    pub fn clear_being_discussed(&mut self) {
        self.being_discussed.clear();
    }

    // Param is passed by value, moved
    pub fn set_being_discussed(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.being_discussed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_being_discussed(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.being_discussed
    }

    // Take field
    pub fn take_being_discussed(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.being_discussed, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo new_to_group = 7;


    pub fn get_new_to_group(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.new_to_group
    }
    pub fn clear_new_to_group(&mut self) {
        self.new_to_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_to_group(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.new_to_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_to_group(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.new_to_group
    }

    // Take field
    pub fn take_new_to_group(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.new_to_group, ::protobuf::RepeatedField::new())
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo returned_to_group = 8;


    pub fn get_returned_to_group(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo] {
        &self.returned_to_group
    }
    pub fn clear_returned_to_group(&mut self) {
        self.returned_to_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_returned_to_group(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>) {
        self.returned_to_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_returned_to_group(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        &mut self.returned_to_group
    }

    // Take field
    pub fn take_returned_to_group(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> {
        ::std::mem::replace(&mut self.returned_to_group, ::protobuf::RepeatedField::new())
    }

    // optional uint32 active_friend_count = 9;


    pub fn get_active_friend_count(&self) -> u32 {
        self.active_friend_count.unwrap_or(0u32)
    }
    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.trending {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recent_purchases {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unowned {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.popular {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dont_forget {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.being_discussed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_to_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.returned_to_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trending)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.recent_purchases)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unowned)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.popular)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dont_forget)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.being_discussed)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.new_to_group)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.returned_to_group)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_friend_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trending {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.recent_purchases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unowned {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.popular {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dont_forget {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.being_discussed {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.new_to_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.returned_to_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.active_friend_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trending {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.recent_purchases {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.unowned {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.popular {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dont_forget {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.being_discussed {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.new_to_group {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.returned_to_group {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.active_friend_count {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Response {
        CPlayer_GetFriendsAppsActivity_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "trending",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.trending },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.trending },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "recent_purchases",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.recent_purchases },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.recent_purchases },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "unowned",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.unowned },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.unowned },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "popular",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.popular },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.popular },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "dont_forget",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.dont_forget },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.dont_forget },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "being_discussed",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.being_discussed },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.being_discussed },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "new_to_group",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.new_to_group },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.new_to_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>>(
                    "returned_to_group",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.returned_to_group },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.returned_to_group },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_friend_count",
                    |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.active_friend_count },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.active_friend_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsAppsActivity_Response>(
                    "CPlayer_GetFriendsAppsActivity_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsAppsActivity_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsAppsActivity_Response,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsAppsActivity_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Response {
    fn clear(&mut self) {
        self.trending.clear();
        self.recent_purchases.clear();
        self.unowned.clear();
        self.popular.clear();
        self.dont_forget.clear();
        self.being_discussed.clear();
        self.new_to_group.clear();
        self.returned_to_group.clear();
        self.active_friend_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    // message fields
    steamid: ::std::option::Option<u64>,
    minutes_played_this_week: ::std::option::Option<u32>,
    minutes_played_two_weeks: ::std::option::Option<u32>,
    minutes_played_forever: ::std::option::Option<u32>,
    event_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        <CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_this_week = 2;


    pub fn get_minutes_played_this_week(&self) -> u32 {
        self.minutes_played_this_week.unwrap_or(0)
    }
    pub fn clear_minutes_played_this_week(&mut self) {
        self.minutes_played_this_week = ::std::option::Option::None;
    }

    pub fn has_minutes_played_this_week(&self) -> bool {
        self.minutes_played_this_week.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_this_week(&mut self, v: u32) {
        self.minutes_played_this_week = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_two_weeks = 3;


    pub fn get_minutes_played_two_weeks(&self) -> u32 {
        self.minutes_played_two_weeks.unwrap_or(0)
    }
    pub fn clear_minutes_played_two_weeks(&mut self) {
        self.minutes_played_two_weeks = ::std::option::Option::None;
    }

    pub fn has_minutes_played_two_weeks(&self) -> bool {
        self.minutes_played_two_weeks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_two_weeks(&mut self, v: u32) {
        self.minutes_played_two_weeks = ::std::option::Option::Some(v);
    }

    // optional uint32 minutes_played_forever = 4;


    pub fn get_minutes_played_forever(&self) -> u32 {
        self.minutes_played_forever.unwrap_or(0)
    }
    pub fn clear_minutes_played_forever(&mut self) {
        self.minutes_played_forever = ::std::option::Option::None;
    }

    pub fn has_minutes_played_forever(&self) -> bool {
        self.minutes_played_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_played_forever(&mut self, v: u32) {
        self.minutes_played_forever = ::std::option::Option::Some(v);
    }

    // optional uint32 event_count = 5;


    pub fn get_event_count(&self) -> u32 {
        self.event_count.unwrap_or(0)
    }
    pub fn clear_event_count(&mut self) {
        self.event_count = ::std::option::Option::None;
    }

    pub fn has_event_count(&self) -> bool {
        self.event_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_count(&mut self, v: u32) {
        self.event_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_this_week = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_two_weeks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minutes_played_forever = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.minutes_played_this_week {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_two_weeks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minutes_played_forever {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.minutes_played_this_week {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.minutes_played_two_weeks {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.minutes_played_forever {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_count {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.steamid },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minutes_played_this_week",
                    |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.minutes_played_this_week },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.minutes_played_this_week },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minutes_played_two_weeks",
                    |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.minutes_played_two_weeks },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.minutes_played_two_weeks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minutes_played_forever",
                    |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.minutes_played_forever },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.minutes_played_forever },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_count",
                    |m: &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &m.event_count },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime| { &mut m.event_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>(
                    "CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.minutes_played_this_week = ::std::option::Option::None;
        self.minutes_played_two_weeks = ::std::option::Option::None;
        self.minutes_played_forever = ::std::option::Option::None;
        self.event_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    // message fields
    appid: ::std::option::Option<u32>,
    friends: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        <CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated .CPlayer_GetFriendsAppsActivity_Response.FriendPlayTime friends = 2;


    pub fn get_friends(&self) -> &[CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime] {
        &self.friends
    }
    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &m.appid },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime>>(
                    "friends",
                    |m: &CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &m.friends },
                    |m: &mut CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo| { &mut m.friends },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo>(
                    "CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo,
        };
        unsafe {
            instance.get(CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetGameBadgeLevels_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Request {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Request {
        <CPlayer_GetGameBadgeLevels_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Request {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Request {
        CPlayer_GetGameBadgeLevels_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPlayer_GetGameBadgeLevels_Request| { &m.appid },
                    |m: &mut CPlayer_GetGameBadgeLevels_Request| { &mut m.appid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetGameBadgeLevels_Request>(
                    "CPlayer_GetGameBadgeLevels_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetGameBadgeLevels_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetGameBadgeLevels_Request,
        };
        unsafe {
            instance.get(CPlayer_GetGameBadgeLevels_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetGameBadgeLevels_Response {
    // message fields
    player_level: ::std::option::Option<u32>,
    badges: ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Response {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Response {
        <CPlayer_GetGameBadgeLevels_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Response {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Response {
        ::std::default::Default::default()
    }

    // optional uint32 player_level = 1;


    pub fn get_player_level(&self) -> u32 {
        self.player_level.unwrap_or(0)
    }
    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: u32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // repeated .CPlayer_GetGameBadgeLevels_Response.Badge badges = 2;


    pub fn get_badges(&self) -> &[CPlayer_GetGameBadgeLevels_Response_Badge] {
        &self.badges
    }
    pub fn clear_badges(&mut self) {
        self.badges.clear();
    }

    // Param is passed by value, moved
    pub fn set_badges(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge>) {
        self.badges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_badges(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge> {
        &mut self.badges
    }

    // Take field
    pub fn take_badges(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetGameBadgeLevels_Response_Badge> {
        ::std::mem::replace(&mut self.badges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.badges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.player_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.badges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.badges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.badges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Response {
        CPlayer_GetGameBadgeLevels_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "player_level",
                    |m: &CPlayer_GetGameBadgeLevels_Response| { &m.player_level },
                    |m: &mut CPlayer_GetGameBadgeLevels_Response| { &mut m.player_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetGameBadgeLevels_Response_Badge>>(
                    "badges",
                    |m: &CPlayer_GetGameBadgeLevels_Response| { &m.badges },
                    |m: &mut CPlayer_GetGameBadgeLevels_Response| { &mut m.badges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetGameBadgeLevels_Response>(
                    "CPlayer_GetGameBadgeLevels_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetGameBadgeLevels_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetGameBadgeLevels_Response,
        };
        unsafe {
            instance.get(CPlayer_GetGameBadgeLevels_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Response {
    fn clear(&mut self) {
        self.player_level = ::std::option::Option::None;
        self.badges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetGameBadgeLevels_Response_Badge {
    // message fields
    level: ::std::option::Option<i32>,
    series: ::std::option::Option<i32>,
    border_color: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Response_Badge {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Response_Badge {
        <CPlayer_GetGameBadgeLevels_Response_Badge as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Response_Badge {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Response_Badge {
        ::std::default::Default::default()
    }

    // optional int32 level = 1;


    pub fn get_level(&self) -> i32 {
        self.level.unwrap_or(0)
    }
    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional int32 series = 2;


    pub fn get_series(&self) -> i32 {
        self.series.unwrap_or(0)
    }
    pub fn clear_series(&mut self) {
        self.series = ::std::option::Option::None;
    }

    pub fn has_series(&self) -> bool {
        self.series.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: i32) {
        self.series = ::std::option::Option::Some(v);
    }

    // optional uint32 border_color = 3;


    pub fn get_border_color(&self) -> u32 {
        self.border_color.unwrap_or(0)
    }
    pub fn clear_border_color(&mut self) {
        self.border_color = ::std::option::Option::None;
    }

    pub fn has_border_color(&self) -> bool {
        self.border_color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_border_color(&mut self, v: u32) {
        self.border_color = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.series = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.border_color = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.series {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.border_color {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.level {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.series {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.border_color {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Response_Badge {
        CPlayer_GetGameBadgeLevels_Response_Badge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "level",
                    |m: &CPlayer_GetGameBadgeLevels_Response_Badge| { &m.level },
                    |m: &mut CPlayer_GetGameBadgeLevels_Response_Badge| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "series",
                    |m: &CPlayer_GetGameBadgeLevels_Response_Badge| { &m.series },
                    |m: &mut CPlayer_GetGameBadgeLevels_Response_Badge| { &mut m.series },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "border_color",
                    |m: &CPlayer_GetGameBadgeLevels_Response_Badge| { &m.border_color },
                    |m: &mut CPlayer_GetGameBadgeLevels_Response_Badge| { &mut m.border_color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetGameBadgeLevels_Response_Badge>(
                    "CPlayer_GetGameBadgeLevels_Response_Badge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Response_Badge {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetGameBadgeLevels_Response_Badge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetGameBadgeLevels_Response_Badge,
        };
        unsafe {
            instance.get(CPlayer_GetGameBadgeLevels_Response_Badge::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn clear(&mut self) {
        self.level = ::std::option::Option::None;
        self.series = ::std::option::Option::None;
        self.border_color = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Response_Badge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetEmoticonList_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Request {
    fn default() -> &'a CPlayer_GetEmoticonList_Request {
        <CPlayer_GetEmoticonList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Request {
    pub fn new() -> CPlayer_GetEmoticonList_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Request {
        CPlayer_GetEmoticonList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetEmoticonList_Request>(
                    "CPlayer_GetEmoticonList_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetEmoticonList_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetEmoticonList_Request,
        };
        unsafe {
            instance.get(CPlayer_GetEmoticonList_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetEmoticonList_Response {
    // message fields
    emoticons: ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Response {
    fn default() -> &'a CPlayer_GetEmoticonList_Response {
        <CPlayer_GetEmoticonList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Response {
    pub fn new() -> CPlayer_GetEmoticonList_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetEmoticonList_Response.Emoticon emoticons = 1;


    pub fn get_emoticons(&self) -> &[CPlayer_GetEmoticonList_Response_Emoticon] {
        &self.emoticons
    }
    pub fn clear_emoticons(&mut self) {
        self.emoticons.clear();
    }

    // Param is passed by value, moved
    pub fn set_emoticons(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon>) {
        self.emoticons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_emoticons(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon> {
        &mut self.emoticons
    }

    // Take field
    pub fn take_emoticons(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetEmoticonList_Response_Emoticon> {
        ::std::mem::replace(&mut self.emoticons, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.emoticons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.emoticons)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.emoticons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.emoticons {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Response {
        CPlayer_GetEmoticonList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetEmoticonList_Response_Emoticon>>(
                    "emoticons",
                    |m: &CPlayer_GetEmoticonList_Response| { &m.emoticons },
                    |m: &mut CPlayer_GetEmoticonList_Response| { &mut m.emoticons },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetEmoticonList_Response>(
                    "CPlayer_GetEmoticonList_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetEmoticonList_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetEmoticonList_Response,
        };
        unsafe {
            instance.get(CPlayer_GetEmoticonList_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Response {
    fn clear(&mut self) {
        self.emoticons.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetEmoticonList_Response_Emoticon {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    count: ::std::option::Option<i32>,
    time_last_used: ::std::option::Option<u32>,
    use_count: ::std::option::Option<u32>,
    time_received: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Response_Emoticon {
    fn default() -> &'a CPlayer_GetEmoticonList_Response_Emoticon {
        <CPlayer_GetEmoticonList_Response_Emoticon as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Response_Emoticon {
    pub fn new() -> CPlayer_GetEmoticonList_Response_Emoticon {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_used = 3;


    pub fn get_time_last_used(&self) -> u32 {
        self.time_last_used.unwrap_or(0)
    }
    pub fn clear_time_last_used(&mut self) {
        self.time_last_used = ::std::option::Option::None;
    }

    pub fn has_time_last_used(&self) -> bool {
        self.time_last_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_used(&mut self, v: u32) {
        self.time_last_used = ::std::option::Option::Some(v);
    }

    // optional uint32 use_count = 4;


    pub fn get_use_count(&self) -> u32 {
        self.use_count.unwrap_or(0)
    }
    pub fn clear_use_count(&mut self) {
        self.use_count = ::std::option::Option::None;
    }

    pub fn has_use_count(&self) -> bool {
        self.use_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_count(&mut self, v: u32) {
        self.use_count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_received = 5;


    pub fn get_time_received(&self) -> u32 {
        self.time_received.unwrap_or(0)
    }
    pub fn clear_time_received(&mut self) {
        self.time_received = ::std::option::Option::None;
    }

    pub fn has_time_received(&self) -> bool {
        self.time_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_received(&mut self, v: u32) {
        self.time_received = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Response_Emoticon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_used = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.use_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_received = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_used {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_received {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.time_last_used {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.use_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.time_received {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Response_Emoticon {
        CPlayer_GetEmoticonList_Response_Emoticon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.name },
                    |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.count },
                    |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_used",
                    |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.time_last_used },
                    |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.time_last_used },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "use_count",
                    |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.use_count },
                    |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.use_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_received",
                    |m: &CPlayer_GetEmoticonList_Response_Emoticon| { &m.time_received },
                    |m: &mut CPlayer_GetEmoticonList_Response_Emoticon| { &mut m.time_received },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetEmoticonList_Response_Emoticon>(
                    "CPlayer_GetEmoticonList_Response_Emoticon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Response_Emoticon {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetEmoticonList_Response_Emoticon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetEmoticonList_Response_Emoticon,
        };
        unsafe {
            instance.get(CPlayer_GetEmoticonList_Response_Emoticon::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Response_Emoticon {
    fn clear(&mut self) {
        self.name.clear();
        self.count = ::std::option::Option::None;
        self.time_last_used = ::std::option::Option::None;
        self.use_count = ::std::option::Option::None;
        self.time_received = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Response_Emoticon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Response_Emoticon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PostStatusToFriends_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PostStatusToFriends_Request {
    fn default() -> &'a CPlayer_PostStatusToFriends_Request {
        <CPlayer_PostStatusToFriends_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PostStatusToFriends_Request {
    pub fn new() -> CPlayer_PostStatusToFriends_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 2;


    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_PostStatusToFriends_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.status_text.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PostStatusToFriends_Request {
        CPlayer_PostStatusToFriends_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPlayer_PostStatusToFriends_Request| { &m.appid },
                    |m: &mut CPlayer_PostStatusToFriends_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status_text",
                    |m: &CPlayer_PostStatusToFriends_Request| { &m.status_text },
                    |m: &mut CPlayer_PostStatusToFriends_Request| { &mut m.status_text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PostStatusToFriends_Request>(
                    "CPlayer_PostStatusToFriends_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_PostStatusToFriends_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_PostStatusToFriends_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_PostStatusToFriends_Request,
        };
        unsafe {
            instance.get(CPlayer_PostStatusToFriends_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_PostStatusToFriends_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.status_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PostStatusToFriends_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PostStatusToFriends_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PostStatusToFriends_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PostStatusToFriends_Response {
    fn default() -> &'a CPlayer_PostStatusToFriends_Response {
        <CPlayer_PostStatusToFriends_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PostStatusToFriends_Response {
    pub fn new() -> CPlayer_PostStatusToFriends_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_PostStatusToFriends_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PostStatusToFriends_Response {
        CPlayer_PostStatusToFriends_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PostStatusToFriends_Response>(
                    "CPlayer_PostStatusToFriends_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_PostStatusToFriends_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_PostStatusToFriends_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_PostStatusToFriends_Response,
        };
        unsafe {
            instance.get(CPlayer_PostStatusToFriends_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_PostStatusToFriends_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PostStatusToFriends_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PostStatusToFriends_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPostedStatus_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    postid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPostedStatus_Request {
    fn default() -> &'a CPlayer_GetPostedStatus_Request {
        <CPlayer_GetPostedStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPostedStatus_Request {
    pub fn new() -> CPlayer_GetPostedStatus_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 postid = 2;


    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }
    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetPostedStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.postid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPostedStatus_Request {
        CPlayer_GetPostedStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "steamid",
                    |m: &CPlayer_GetPostedStatus_Request| { &m.steamid },
                    |m: &mut CPlayer_GetPostedStatus_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "postid",
                    |m: &CPlayer_GetPostedStatus_Request| { &m.postid },
                    |m: &mut CPlayer_GetPostedStatus_Request| { &mut m.postid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPostedStatus_Request>(
                    "CPlayer_GetPostedStatus_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetPostedStatus_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetPostedStatus_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetPostedStatus_Request,
        };
        unsafe {
            instance.get(CPlayer_GetPostedStatus_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetPostedStatus_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.postid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPostedStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPostedStatus_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPostedStatus_Response {
    // message fields
    accountid: ::std::option::Option<u32>,
    postid: ::std::option::Option<u64>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    deleted: ::std::option::Option<bool>,
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPostedStatus_Response {
    fn default() -> &'a CPlayer_GetPostedStatus_Response {
        <CPlayer_GetPostedStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPostedStatus_Response {
    pub fn new() -> CPlayer_GetPostedStatus_Response {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 postid = 2;


    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }
    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;


    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool deleted = 4;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 5;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetPostedStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.postid {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.status_text.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPostedStatus_Response {
        CPlayer_GetPostedStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CPlayer_GetPostedStatus_Response| { &m.accountid },
                    |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "postid",
                    |m: &CPlayer_GetPostedStatus_Response| { &m.postid },
                    |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.postid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status_text",
                    |m: &CPlayer_GetPostedStatus_Response| { &m.status_text },
                    |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.status_text },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "deleted",
                    |m: &CPlayer_GetPostedStatus_Response| { &m.deleted },
                    |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.deleted },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPlayer_GetPostedStatus_Response| { &m.appid },
                    |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.appid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPostedStatus_Response>(
                    "CPlayer_GetPostedStatus_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetPostedStatus_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetPostedStatus_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetPostedStatus_Response,
        };
        unsafe {
            instance.get(CPlayer_GetPostedStatus_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetPostedStatus_Response {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.postid = ::std::option::Option::None;
        self.status_text.clear();
        self.deleted = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPostedStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPostedStatus_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_DeletePostedStatus_Request {
    // message fields
    postid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_DeletePostedStatus_Request {
    fn default() -> &'a CPlayer_DeletePostedStatus_Request {
        <CPlayer_DeletePostedStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_DeletePostedStatus_Request {
    pub fn new() -> CPlayer_DeletePostedStatus_Request {
        ::std::default::Default::default()
    }

    // optional uint64 postid = 1;


    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }
    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_DeletePostedStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.postid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.postid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_DeletePostedStatus_Request {
        CPlayer_DeletePostedStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "postid",
                    |m: &CPlayer_DeletePostedStatus_Request| { &m.postid },
                    |m: &mut CPlayer_DeletePostedStatus_Request| { &mut m.postid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_DeletePostedStatus_Request>(
                    "CPlayer_DeletePostedStatus_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_DeletePostedStatus_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_DeletePostedStatus_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_DeletePostedStatus_Request,
        };
        unsafe {
            instance.get(CPlayer_DeletePostedStatus_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_DeletePostedStatus_Request {
    fn clear(&mut self) {
        self.postid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_DeletePostedStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_DeletePostedStatus_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_DeletePostedStatus_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_DeletePostedStatus_Response {
    fn default() -> &'a CPlayer_DeletePostedStatus_Response {
        <CPlayer_DeletePostedStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_DeletePostedStatus_Response {
    pub fn new() -> CPlayer_DeletePostedStatus_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_DeletePostedStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_DeletePostedStatus_Response {
        CPlayer_DeletePostedStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_DeletePostedStatus_Response>(
                    "CPlayer_DeletePostedStatus_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_DeletePostedStatus_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_DeletePostedStatus_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_DeletePostedStatus_Response,
        };
        unsafe {
            instance.get(CPlayer_DeletePostedStatus_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_DeletePostedStatus_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_DeletePostedStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_DeletePostedStatus_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetLastPlayedTimes_Request {
    // message fields
    min_last_played: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Request {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Request {
        <CPlayer_GetLastPlayedTimes_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Request {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Request {
        ::std::default::Default::default()
    }

    // optional uint32 min_last_played = 1;


    pub fn get_min_last_played(&self) -> u32 {
        self.min_last_played.unwrap_or(0)
    }
    pub fn clear_min_last_played(&mut self) {
        self.min_last_played = ::std::option::Option::None;
    }

    pub fn has_min_last_played(&self) -> bool {
        self.min_last_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_last_played(&mut self, v: u32) {
        self.min_last_played = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min_last_played = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.min_last_played {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.min_last_played {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Request {
        CPlayer_GetLastPlayedTimes_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "min_last_played",
                    |m: &CPlayer_GetLastPlayedTimes_Request| { &m.min_last_played },
                    |m: &mut CPlayer_GetLastPlayedTimes_Request| { &mut m.min_last_played },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetLastPlayedTimes_Request>(
                    "CPlayer_GetLastPlayedTimes_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetLastPlayedTimes_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetLastPlayedTimes_Request,
        };
        unsafe {
            instance.get(CPlayer_GetLastPlayedTimes_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Request {
    fn clear(&mut self) {
        self.min_last_played = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetLastPlayedTimes_Response {
    // message fields
    games: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Response {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Response {
        <CPlayer_GetLastPlayedTimes_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Response {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetLastPlayedTimes_Response.Game games = 1;


    pub fn get_games(&self) -> &[CPlayer_GetLastPlayedTimes_Response_Game] {
        &self.games
    }
    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Response {
        CPlayer_GetLastPlayedTimes_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetLastPlayedTimes_Response_Game>>(
                    "games",
                    |m: &CPlayer_GetLastPlayedTimes_Response| { &m.games },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response| { &mut m.games },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetLastPlayedTimes_Response>(
                    "CPlayer_GetLastPlayedTimes_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetLastPlayedTimes_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetLastPlayedTimes_Response,
        };
        unsafe {
            instance.get(CPlayer_GetLastPlayedTimes_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Response {
    fn clear(&mut self) {
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetLastPlayedTimes_Response_Game {
    // message fields
    appid: ::std::option::Option<i32>,
    last_playtime: ::std::option::Option<u32>,
    playtime_2weeks: ::std::option::Option<i32>,
    playtime_forever: ::std::option::Option<i32>,
    first_playtime: ::std::option::Option<u32>,
    playtime_windows_forever: ::std::option::Option<i32>,
    playtime_mac_forever: ::std::option::Option<i32>,
    playtime_linux_forever: ::std::option::Option<i32>,
    first_windows_playtime: ::std::option::Option<u32>,
    first_mac_playtime: ::std::option::Option<u32>,
    first_linux_playtime: ::std::option::Option<u32>,
    last_windows_playtime: ::std::option::Option<u32>,
    last_mac_playtime: ::std::option::Option<u32>,
    last_linux_playtime: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Response_Game {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Response_Game {
        <CPlayer_GetLastPlayedTimes_Response_Game as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Response_Game {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Response_Game {
        ::std::default::Default::default()
    }

    // optional int32 appid = 1;


    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 last_playtime = 2;


    pub fn get_last_playtime(&self) -> u32 {
        self.last_playtime.unwrap_or(0)
    }
    pub fn clear_last_playtime(&mut self) {
        self.last_playtime = ::std::option::Option::None;
    }

    pub fn has_last_playtime(&self) -> bool {
        self.last_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_playtime(&mut self, v: u32) {
        self.last_playtime = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_2weeks = 3;


    pub fn get_playtime_2weeks(&self) -> i32 {
        self.playtime_2weeks.unwrap_or(0)
    }
    pub fn clear_playtime_2weeks(&mut self) {
        self.playtime_2weeks = ::std::option::Option::None;
    }

    pub fn has_playtime_2weeks(&self) -> bool {
        self.playtime_2weeks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_2weeks(&mut self, v: i32) {
        self.playtime_2weeks = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_forever = 4;


    pub fn get_playtime_forever(&self) -> i32 {
        self.playtime_forever.unwrap_or(0)
    }
    pub fn clear_playtime_forever(&mut self) {
        self.playtime_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_forever(&self) -> bool {
        self.playtime_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_forever(&mut self, v: i32) {
        self.playtime_forever = ::std::option::Option::Some(v);
    }

    // optional uint32 first_playtime = 5;


    pub fn get_first_playtime(&self) -> u32 {
        self.first_playtime.unwrap_or(0)
    }
    pub fn clear_first_playtime(&mut self) {
        self.first_playtime = ::std::option::Option::None;
    }

    pub fn has_first_playtime(&self) -> bool {
        self.first_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_playtime(&mut self, v: u32) {
        self.first_playtime = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_windows_forever = 6;


    pub fn get_playtime_windows_forever(&self) -> i32 {
        self.playtime_windows_forever.unwrap_or(0)
    }
    pub fn clear_playtime_windows_forever(&mut self) {
        self.playtime_windows_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_windows_forever(&self) -> bool {
        self.playtime_windows_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_windows_forever(&mut self, v: i32) {
        self.playtime_windows_forever = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_mac_forever = 7;


    pub fn get_playtime_mac_forever(&self) -> i32 {
        self.playtime_mac_forever.unwrap_or(0)
    }
    pub fn clear_playtime_mac_forever(&mut self) {
        self.playtime_mac_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_mac_forever(&self) -> bool {
        self.playtime_mac_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_mac_forever(&mut self, v: i32) {
        self.playtime_mac_forever = ::std::option::Option::Some(v);
    }

    // optional int32 playtime_linux_forever = 8;


    pub fn get_playtime_linux_forever(&self) -> i32 {
        self.playtime_linux_forever.unwrap_or(0)
    }
    pub fn clear_playtime_linux_forever(&mut self) {
        self.playtime_linux_forever = ::std::option::Option::None;
    }

    pub fn has_playtime_linux_forever(&self) -> bool {
        self.playtime_linux_forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_linux_forever(&mut self, v: i32) {
        self.playtime_linux_forever = ::std::option::Option::Some(v);
    }

    // optional uint32 first_windows_playtime = 9;


    pub fn get_first_windows_playtime(&self) -> u32 {
        self.first_windows_playtime.unwrap_or(0)
    }
    pub fn clear_first_windows_playtime(&mut self) {
        self.first_windows_playtime = ::std::option::Option::None;
    }

    pub fn has_first_windows_playtime(&self) -> bool {
        self.first_windows_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_windows_playtime(&mut self, v: u32) {
        self.first_windows_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 first_mac_playtime = 10;


    pub fn get_first_mac_playtime(&self) -> u32 {
        self.first_mac_playtime.unwrap_or(0)
    }
    pub fn clear_first_mac_playtime(&mut self) {
        self.first_mac_playtime = ::std::option::Option::None;
    }

    pub fn has_first_mac_playtime(&self) -> bool {
        self.first_mac_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_mac_playtime(&mut self, v: u32) {
        self.first_mac_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 first_linux_playtime = 11;


    pub fn get_first_linux_playtime(&self) -> u32 {
        self.first_linux_playtime.unwrap_or(0)
    }
    pub fn clear_first_linux_playtime(&mut self) {
        self.first_linux_playtime = ::std::option::Option::None;
    }

    pub fn has_first_linux_playtime(&self) -> bool {
        self.first_linux_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_linux_playtime(&mut self, v: u32) {
        self.first_linux_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 last_windows_playtime = 12;


    pub fn get_last_windows_playtime(&self) -> u32 {
        self.last_windows_playtime.unwrap_or(0)
    }
    pub fn clear_last_windows_playtime(&mut self) {
        self.last_windows_playtime = ::std::option::Option::None;
    }

    pub fn has_last_windows_playtime(&self) -> bool {
        self.last_windows_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_windows_playtime(&mut self, v: u32) {
        self.last_windows_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 last_mac_playtime = 13;


    pub fn get_last_mac_playtime(&self) -> u32 {
        self.last_mac_playtime.unwrap_or(0)
    }
    pub fn clear_last_mac_playtime(&mut self) {
        self.last_mac_playtime = ::std::option::Option::None;
    }

    pub fn has_last_mac_playtime(&self) -> bool {
        self.last_mac_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_mac_playtime(&mut self, v: u32) {
        self.last_mac_playtime = ::std::option::Option::Some(v);
    }

    // optional uint32 last_linux_playtime = 14;


    pub fn get_last_linux_playtime(&self) -> u32 {
        self.last_linux_playtime.unwrap_or(0)
    }
    pub fn clear_last_linux_playtime(&mut self) {
        self.last_linux_playtime = ::std::option::Option::None;
    }

    pub fn has_last_linux_playtime(&self) -> bool {
        self.last_linux_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_linux_playtime(&mut self, v: u32) {
        self.last_linux_playtime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Response_Game {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_playtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_2weeks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_forever = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_playtime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_windows_forever = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_mac_forever = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playtime_linux_forever = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_windows_playtime = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_mac_playtime = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_linux_playtime = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_windows_playtime = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_mac_playtime = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_linux_playtime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_playtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_2weeks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_forever {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_playtime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_windows_forever {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_mac_forever {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.playtime_linux_forever {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_windows_playtime {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_mac_playtime {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_linux_playtime {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_windows_playtime {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_mac_playtime {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_linux_playtime {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.last_playtime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.playtime_2weeks {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.playtime_forever {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.first_playtime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.playtime_windows_forever {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.playtime_mac_forever {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.playtime_linux_forever {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.first_windows_playtime {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.first_mac_playtime {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.first_linux_playtime {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.last_windows_playtime {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.last_mac_playtime {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.last_linux_playtime {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Response_Game {
        CPlayer_GetLastPlayedTimes_Response_Game::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "appid",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.appid },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "playtime_2weeks",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_2weeks },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_2weeks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "playtime_forever",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_forever },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_forever },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "playtime_windows_forever",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_windows_forever },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_windows_forever },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "playtime_mac_forever",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_mac_forever },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_mac_forever },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "playtime_linux_forever",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.playtime_linux_forever },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.playtime_linux_forever },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_windows_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_windows_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_windows_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_mac_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_mac_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_mac_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "first_linux_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.first_linux_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.first_linux_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_windows_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_windows_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_windows_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_mac_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_mac_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_mac_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_linux_playtime",
                    |m: &CPlayer_GetLastPlayedTimes_Response_Game| { &m.last_linux_playtime },
                    |m: &mut CPlayer_GetLastPlayedTimes_Response_Game| { &mut m.last_linux_playtime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetLastPlayedTimes_Response_Game>(
                    "CPlayer_GetLastPlayedTimes_Response_Game",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Response_Game {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetLastPlayedTimes_Response_Game> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetLastPlayedTimes_Response_Game,
        };
        unsafe {
            instance.get(CPlayer_GetLastPlayedTimes_Response_Game::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Response_Game {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.last_playtime = ::std::option::Option::None;
        self.playtime_2weeks = ::std::option::Option::None;
        self.playtime_forever = ::std::option::Option::None;
        self.first_playtime = ::std::option::Option::None;
        self.playtime_windows_forever = ::std::option::Option::None;
        self.playtime_mac_forever = ::std::option::Option::None;
        self.playtime_linux_forever = ::std::option::Option::None;
        self.first_windows_playtime = ::std::option::Option::None;
        self.first_mac_playtime = ::std::option::Option::None;
        self.first_linux_playtime = ::std::option::Option::None;
        self.last_windows_playtime = ::std::option::Option::None;
        self.last_mac_playtime = ::std::option::Option::None;
        self.last_linux_playtime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Response_Game {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Response_Game {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AcceptSSA_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AcceptSSA_Request {
    fn default() -> &'a CPlayer_AcceptSSA_Request {
        <CPlayer_AcceptSSA_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AcceptSSA_Request {
    pub fn new() -> CPlayer_AcceptSSA_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_AcceptSSA_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AcceptSSA_Request {
        CPlayer_AcceptSSA_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AcceptSSA_Request>(
                    "CPlayer_AcceptSSA_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_AcceptSSA_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_AcceptSSA_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_AcceptSSA_Request,
        };
        unsafe {
            instance.get(CPlayer_AcceptSSA_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_AcceptSSA_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AcceptSSA_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AcceptSSA_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AcceptSSA_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AcceptSSA_Response {
    fn default() -> &'a CPlayer_AcceptSSA_Response {
        <CPlayer_AcceptSSA_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AcceptSSA_Response {
    pub fn new() -> CPlayer_AcceptSSA_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_AcceptSSA_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AcceptSSA_Response {
        CPlayer_AcceptSSA_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AcceptSSA_Response>(
                    "CPlayer_AcceptSSA_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_AcceptSSA_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_AcceptSSA_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_AcceptSSA_Response,
        };
        unsafe {
            instance.get(CPlayer_AcceptSSA_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_AcceptSSA_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AcceptSSA_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AcceptSSA_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNicknameList_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Request {
    fn default() -> &'a CPlayer_GetNicknameList_Request {
        <CPlayer_GetNicknameList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Request {
    pub fn new() -> CPlayer_GetNicknameList_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Request {
        CPlayer_GetNicknameList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNicknameList_Request>(
                    "CPlayer_GetNicknameList_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetNicknameList_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetNicknameList_Request,
        };
        unsafe {
            instance.get(CPlayer_GetNicknameList_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNicknameList_Response {
    // message fields
    nicknames: ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Response {
    fn default() -> &'a CPlayer_GetNicknameList_Response {
        <CPlayer_GetNicknameList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Response {
    pub fn new() -> CPlayer_GetNicknameList_Response {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetNicknameList_Response.PlayerNickname nicknames = 1;


    pub fn get_nicknames(&self) -> &[CPlayer_GetNicknameList_Response_PlayerNickname] {
        &self.nicknames
    }
    pub fn clear_nicknames(&mut self) {
        self.nicknames.clear();
    }

    // Param is passed by value, moved
    pub fn set_nicknames(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname>) {
        self.nicknames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nicknames(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname> {
        &mut self.nicknames
    }

    // Take field
    pub fn take_nicknames(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetNicknameList_Response_PlayerNickname> {
        ::std::mem::replace(&mut self.nicknames, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.nicknames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nicknames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nicknames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nicknames {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Response {
        CPlayer_GetNicknameList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetNicknameList_Response_PlayerNickname>>(
                    "nicknames",
                    |m: &CPlayer_GetNicknameList_Response| { &m.nicknames },
                    |m: &mut CPlayer_GetNicknameList_Response| { &mut m.nicknames },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNicknameList_Response>(
                    "CPlayer_GetNicknameList_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetNicknameList_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetNicknameList_Response,
        };
        unsafe {
            instance.get(CPlayer_GetNicknameList_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Response {
    fn clear(&mut self) {
        self.nicknames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNicknameList_Response_PlayerNickname {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Response_PlayerNickname {
    fn default() -> &'a CPlayer_GetNicknameList_Response_PlayerNickname {
        <CPlayer_GetNicknameList_Response_PlayerNickname as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Response_PlayerNickname {
    pub fn new() -> CPlayer_GetNicknameList_Response_PlayerNickname {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Response_PlayerNickname {
        CPlayer_GetNicknameList_Response_PlayerNickname::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "accountid",
                    |m: &CPlayer_GetNicknameList_Response_PlayerNickname| { &m.accountid },
                    |m: &mut CPlayer_GetNicknameList_Response_PlayerNickname| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nickname",
                    |m: &CPlayer_GetNicknameList_Response_PlayerNickname| { &m.nickname },
                    |m: &mut CPlayer_GetNicknameList_Response_PlayerNickname| { &mut m.nickname },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNicknameList_Response_PlayerNickname>(
                    "CPlayer_GetNicknameList_Response_PlayerNickname",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Response_PlayerNickname {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetNicknameList_Response_PlayerNickname> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetNicknameList_Response_PlayerNickname,
        };
        unsafe {
            instance.get(CPlayer_GetNicknameList_Response_PlayerNickname::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Response_PlayerNickname {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPerFriendPreferences_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPerFriendPreferences_Request {
    fn default() -> &'a CPlayer_GetPerFriendPreferences_Request {
        <CPlayer_GetPerFriendPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPerFriendPreferences_Request {
    pub fn new() -> CPlayer_GetPerFriendPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPerFriendPreferences_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPerFriendPreferences_Request {
        CPlayer_GetPerFriendPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPerFriendPreferences_Request>(
                    "CPlayer_GetPerFriendPreferences_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetPerFriendPreferences_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetPerFriendPreferences_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetPerFriendPreferences_Request,
        };
        unsafe {
            instance.get(CPlayer_GetPerFriendPreferences_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetPerFriendPreferences_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPerFriendPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPerFriendPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PerFriendPreferences {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    notifications_showingame: ::std::option::Option<ENotificationSetting>,
    notifications_showonline: ::std::option::Option<ENotificationSetting>,
    notifications_showmessages: ::std::option::Option<ENotificationSetting>,
    sounds_showingame: ::std::option::Option<ENotificationSetting>,
    sounds_showonline: ::std::option::Option<ENotificationSetting>,
    sounds_showmessages: ::std::option::Option<ENotificationSetting>,
    notifications_sendmobile: ::std::option::Option<ENotificationSetting>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerFriendPreferences {
    fn default() -> &'a PerFriendPreferences {
        <PerFriendPreferences as ::protobuf::Message>::default_instance()
    }
}

impl PerFriendPreferences {
    pub fn new() -> PerFriendPreferences {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ENotificationSetting notifications_showingame = 3;


    pub fn get_notifications_showingame(&self) -> ENotificationSetting {
        self.notifications_showingame.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_showingame(&mut self) {
        self.notifications_showingame = ::std::option::Option::None;
    }

    pub fn has_notifications_showingame(&self) -> bool {
        self.notifications_showingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showingame(&mut self, v: ENotificationSetting) {
        self.notifications_showingame = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting notifications_showonline = 4;


    pub fn get_notifications_showonline(&self) -> ENotificationSetting {
        self.notifications_showonline.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_showonline(&mut self) {
        self.notifications_showonline = ::std::option::Option::None;
    }

    pub fn has_notifications_showonline(&self) -> bool {
        self.notifications_showonline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showonline(&mut self, v: ENotificationSetting) {
        self.notifications_showonline = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting notifications_showmessages = 5;


    pub fn get_notifications_showmessages(&self) -> ENotificationSetting {
        self.notifications_showmessages.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_showmessages(&mut self) {
        self.notifications_showmessages = ::std::option::Option::None;
    }

    pub fn has_notifications_showmessages(&self) -> bool {
        self.notifications_showmessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showmessages(&mut self, v: ENotificationSetting) {
        self.notifications_showmessages = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting sounds_showingame = 6;


    pub fn get_sounds_showingame(&self) -> ENotificationSetting {
        self.sounds_showingame.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_sounds_showingame(&mut self) {
        self.sounds_showingame = ::std::option::Option::None;
    }

    pub fn has_sounds_showingame(&self) -> bool {
        self.sounds_showingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showingame(&mut self, v: ENotificationSetting) {
        self.sounds_showingame = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting sounds_showonline = 7;


    pub fn get_sounds_showonline(&self) -> ENotificationSetting {
        self.sounds_showonline.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_sounds_showonline(&mut self) {
        self.sounds_showonline = ::std::option::Option::None;
    }

    pub fn has_sounds_showonline(&self) -> bool {
        self.sounds_showonline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showonline(&mut self, v: ENotificationSetting) {
        self.sounds_showonline = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting sounds_showmessages = 8;


    pub fn get_sounds_showmessages(&self) -> ENotificationSetting {
        self.sounds_showmessages.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_sounds_showmessages(&mut self) {
        self.sounds_showmessages = ::std::option::Option::None;
    }

    pub fn has_sounds_showmessages(&self) -> bool {
        self.sounds_showmessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showmessages(&mut self, v: ENotificationSetting) {
        self.sounds_showmessages = ::std::option::Option::Some(v);
    }

    // optional .ENotificationSetting notifications_sendmobile = 9;


    pub fn get_notifications_sendmobile(&self) -> ENotificationSetting {
        self.notifications_sendmobile.unwrap_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault)
    }
    pub fn clear_notifications_sendmobile(&mut self) {
        self.notifications_sendmobile = ::std::option::Option::None;
    }

    pub fn has_notifications_sendmobile(&self) -> bool {
        self.notifications_sendmobile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_sendmobile(&mut self, v: ENotificationSetting) {
        self.notifications_sendmobile = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PerFriendPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_showingame, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_showonline, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_showmessages, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sounds_showingame, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sounds_showonline, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.sounds_showmessages, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.notifications_sendmobile, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.notifications_showingame {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.notifications_showonline {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.notifications_showmessages {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.sounds_showingame {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.sounds_showonline {
            my_size += ::protobuf::rt::enum_size(7, v);
        }
        if let Some(v) = self.sounds_showmessages {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.notifications_sendmobile {
            my_size += ::protobuf::rt::enum_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.notifications_showingame {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.notifications_showonline {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.notifications_showmessages {
            os.write_enum(5, v.value())?;
        }
        if let Some(v) = self.sounds_showingame {
            os.write_enum(6, v.value())?;
        }
        if let Some(v) = self.sounds_showonline {
            os.write_enum(7, v.value())?;
        }
        if let Some(v) = self.sounds_showmessages {
            os.write_enum(8, v.value())?;
        }
        if let Some(v) = self.notifications_sendmobile {
            os.write_enum(9, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerFriendPreferences {
        PerFriendPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "accountid",
                    |m: &PerFriendPreferences| { &m.accountid },
                    |m: &mut PerFriendPreferences| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nickname",
                    |m: &PerFriendPreferences| { &m.nickname },
                    |m: &mut PerFriendPreferences| { &mut m.nickname },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                    "notifications_showingame",
                    |m: &PerFriendPreferences| { &m.notifications_showingame },
                    |m: &mut PerFriendPreferences| { &mut m.notifications_showingame },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                    "notifications_showonline",
                    |m: &PerFriendPreferences| { &m.notifications_showonline },
                    |m: &mut PerFriendPreferences| { &mut m.notifications_showonline },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                    "notifications_showmessages",
                    |m: &PerFriendPreferences| { &m.notifications_showmessages },
                    |m: &mut PerFriendPreferences| { &mut m.notifications_showmessages },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                    "sounds_showingame",
                    |m: &PerFriendPreferences| { &m.sounds_showingame },
                    |m: &mut PerFriendPreferences| { &mut m.sounds_showingame },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                    "sounds_showonline",
                    |m: &PerFriendPreferences| { &m.sounds_showonline },
                    |m: &mut PerFriendPreferences| { &mut m.sounds_showonline },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                    "sounds_showmessages",
                    |m: &PerFriendPreferences| { &m.sounds_showmessages },
                    |m: &mut PerFriendPreferences| { &mut m.sounds_showmessages },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENotificationSetting>>(
                    "notifications_sendmobile",
                    |m: &PerFriendPreferences| { &m.notifications_sendmobile },
                    |m: &mut PerFriendPreferences| { &mut m.notifications_sendmobile },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PerFriendPreferences>(
                    "PerFriendPreferences",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PerFriendPreferences {
        static mut instance: ::protobuf::lazy::Lazy<PerFriendPreferences> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PerFriendPreferences,
        };
        unsafe {
            instance.get(PerFriendPreferences::new)
        }
    }
}

impl ::protobuf::Clear for PerFriendPreferences {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.notifications_showingame = ::std::option::Option::None;
        self.notifications_showonline = ::std::option::Option::None;
        self.notifications_showmessages = ::std::option::Option::None;
        self.sounds_showingame = ::std::option::Option::None;
        self.sounds_showonline = ::std::option::Option::None;
        self.sounds_showmessages = ::std::option::Option::None;
        self.notifications_sendmobile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerFriendPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerFriendPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPerFriendPreferences_Response {
    // message fields
    preferences: ::protobuf::RepeatedField<PerFriendPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPerFriendPreferences_Response {
    fn default() -> &'a CPlayer_GetPerFriendPreferences_Response {
        <CPlayer_GetPerFriendPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPerFriendPreferences_Response {
    pub fn new() -> CPlayer_GetPerFriendPreferences_Response {
        ::std::default::Default::default()
    }

    // repeated .PerFriendPreferences preferences = 1;


    pub fn get_preferences(&self) -> &[PerFriendPreferences] {
        &self.preferences
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: ::protobuf::RepeatedField<PerFriendPreferences>) {
        self.preferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferences(&mut self) -> &mut ::protobuf::RepeatedField<PerFriendPreferences> {
        &mut self.preferences
    }

    // Take field
    pub fn take_preferences(&mut self) -> ::protobuf::RepeatedField<PerFriendPreferences> {
        ::std::mem::replace(&mut self.preferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_GetPerFriendPreferences_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.preferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.preferences {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPerFriendPreferences_Response {
        CPlayer_GetPerFriendPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerFriendPreferences>>(
                    "preferences",
                    |m: &CPlayer_GetPerFriendPreferences_Response| { &m.preferences },
                    |m: &mut CPlayer_GetPerFriendPreferences_Response| { &mut m.preferences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPerFriendPreferences_Response>(
                    "CPlayer_GetPerFriendPreferences_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetPerFriendPreferences_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetPerFriendPreferences_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetPerFriendPreferences_Response,
        };
        unsafe {
            instance.get(CPlayer_GetPerFriendPreferences_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetPerFriendPreferences_Response {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPerFriendPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPerFriendPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetPerFriendPreferences_Request {
    // message fields
    preferences: ::protobuf::SingularPtrField<PerFriendPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetPerFriendPreferences_Request {
    fn default() -> &'a CPlayer_SetPerFriendPreferences_Request {
        <CPlayer_SetPerFriendPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetPerFriendPreferences_Request {
    pub fn new() -> CPlayer_SetPerFriendPreferences_Request {
        ::std::default::Default::default()
    }

    // optional .PerFriendPreferences preferences = 1;


    pub fn get_preferences(&self) -> &PerFriendPreferences {
        self.preferences.as_ref().unwrap_or_else(|| PerFriendPreferences::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: PerFriendPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut PerFriendPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> PerFriendPreferences {
        self.preferences.take().unwrap_or_else(|| PerFriendPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_SetPerFriendPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetPerFriendPreferences_Request {
        CPlayer_SetPerFriendPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerFriendPreferences>>(
                    "preferences",
                    |m: &CPlayer_SetPerFriendPreferences_Request| { &m.preferences },
                    |m: &mut CPlayer_SetPerFriendPreferences_Request| { &mut m.preferences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetPerFriendPreferences_Request>(
                    "CPlayer_SetPerFriendPreferences_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_SetPerFriendPreferences_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_SetPerFriendPreferences_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_SetPerFriendPreferences_Request,
        };
        unsafe {
            instance.get(CPlayer_SetPerFriendPreferences_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_SetPerFriendPreferences_Request {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetPerFriendPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetPerFriendPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetPerFriendPreferences_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetPerFriendPreferences_Response {
    fn default() -> &'a CPlayer_SetPerFriendPreferences_Response {
        <CPlayer_SetPerFriendPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetPerFriendPreferences_Response {
    pub fn new() -> CPlayer_SetPerFriendPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetPerFriendPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetPerFriendPreferences_Response {
        CPlayer_SetPerFriendPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetPerFriendPreferences_Response>(
                    "CPlayer_SetPerFriendPreferences_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_SetPerFriendPreferences_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_SetPerFriendPreferences_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_SetPerFriendPreferences_Response,
        };
        unsafe {
            instance.get(CPlayer_SetPerFriendPreferences_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_SetPerFriendPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetPerFriendPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetPerFriendPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AddFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AddFriend_Request {
    fn default() -> &'a CPlayer_AddFriend_Request {
        <CPlayer_AddFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AddFriend_Request {
    pub fn new() -> CPlayer_AddFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_AddFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AddFriend_Request {
        CPlayer_AddFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPlayer_AddFriend_Request| { &m.steamid },
                    |m: &mut CPlayer_AddFriend_Request| { &mut m.steamid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AddFriend_Request>(
                    "CPlayer_AddFriend_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_AddFriend_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_AddFriend_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_AddFriend_Request,
        };
        unsafe {
            instance.get(CPlayer_AddFriend_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_AddFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AddFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AddFriend_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_AddFriend_Response {
    // message fields
    invite_sent: ::std::option::Option<bool>,
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AddFriend_Response {
    fn default() -> &'a CPlayer_AddFriend_Response {
        <CPlayer_AddFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AddFriend_Response {
    pub fn new() -> CPlayer_AddFriend_Response {
        ::std::default::Default::default()
    }

    // optional bool invite_sent = 1;


    pub fn get_invite_sent(&self) -> bool {
        self.invite_sent.unwrap_or(false)
    }
    pub fn clear_invite_sent(&mut self) {
        self.invite_sent = ::std::option::Option::None;
    }

    pub fn has_invite_sent(&self) -> bool {
        self.invite_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_sent(&mut self, v: bool) {
        self.invite_sent = ::std::option::Option::Some(v);
    }

    // optional uint32 friend_relationship = 2;


    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }
    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_AddFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invite_sent = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friend_relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.invite_sent {
            my_size += 2;
        }
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.invite_sent {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.friend_relationship {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AddFriend_Response {
        CPlayer_AddFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "invite_sent",
                    |m: &CPlayer_AddFriend_Response| { &m.invite_sent },
                    |m: &mut CPlayer_AddFriend_Response| { &mut m.invite_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "friend_relationship",
                    |m: &CPlayer_AddFriend_Response| { &m.friend_relationship },
                    |m: &mut CPlayer_AddFriend_Response| { &mut m.friend_relationship },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AddFriend_Response>(
                    "CPlayer_AddFriend_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_AddFriend_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_AddFriend_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_AddFriend_Response,
        };
        unsafe {
            instance.get(CPlayer_AddFriend_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_AddFriend_Response {
    fn clear(&mut self) {
        self.invite_sent = ::std::option::Option::None;
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AddFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AddFriend_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_RemoveFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_RemoveFriend_Request {
    fn default() -> &'a CPlayer_RemoveFriend_Request {
        <CPlayer_RemoveFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_RemoveFriend_Request {
    pub fn new() -> CPlayer_RemoveFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_RemoveFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_RemoveFriend_Request {
        CPlayer_RemoveFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPlayer_RemoveFriend_Request| { &m.steamid },
                    |m: &mut CPlayer_RemoveFriend_Request| { &mut m.steamid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_RemoveFriend_Request>(
                    "CPlayer_RemoveFriend_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_RemoveFriend_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_RemoveFriend_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_RemoveFriend_Request,
        };
        unsafe {
            instance.get(CPlayer_RemoveFriend_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_RemoveFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_RemoveFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_RemoveFriend_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_RemoveFriend_Response {
    // message fields
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_RemoveFriend_Response {
    fn default() -> &'a CPlayer_RemoveFriend_Response {
        <CPlayer_RemoveFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_RemoveFriend_Response {
    pub fn new() -> CPlayer_RemoveFriend_Response {
        ::std::default::Default::default()
    }

    // optional uint32 friend_relationship = 1;


    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }
    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_RemoveFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friend_relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_relationship {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_RemoveFriend_Response {
        CPlayer_RemoveFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "friend_relationship",
                    |m: &CPlayer_RemoveFriend_Response| { &m.friend_relationship },
                    |m: &mut CPlayer_RemoveFriend_Response| { &mut m.friend_relationship },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_RemoveFriend_Response>(
                    "CPlayer_RemoveFriend_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_RemoveFriend_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_RemoveFriend_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_RemoveFriend_Response,
        };
        unsafe {
            instance.get(CPlayer_RemoveFriend_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_RemoveFriend_Response {
    fn clear(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_RemoveFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_RemoveFriend_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_IgnoreFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    unignore: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IgnoreFriend_Request {
    fn default() -> &'a CPlayer_IgnoreFriend_Request {
        <CPlayer_IgnoreFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IgnoreFriend_Request {
    pub fn new() -> CPlayer_IgnoreFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool unignore = 2;


    pub fn get_unignore(&self) -> bool {
        self.unignore.unwrap_or(false)
    }
    pub fn clear_unignore(&mut self) {
        self.unignore = ::std::option::Option::None;
    }

    pub fn has_unignore(&self) -> bool {
        self.unignore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unignore(&mut self, v: bool) {
        self.unignore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_IgnoreFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unignore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.unignore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unignore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IgnoreFriend_Request {
        CPlayer_IgnoreFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPlayer_IgnoreFriend_Request| { &m.steamid },
                    |m: &mut CPlayer_IgnoreFriend_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unignore",
                    |m: &CPlayer_IgnoreFriend_Request| { &m.unignore },
                    |m: &mut CPlayer_IgnoreFriend_Request| { &mut m.unignore },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_IgnoreFriend_Request>(
                    "CPlayer_IgnoreFriend_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_IgnoreFriend_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_IgnoreFriend_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_IgnoreFriend_Request,
        };
        unsafe {
            instance.get(CPlayer_IgnoreFriend_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_IgnoreFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unignore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IgnoreFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IgnoreFriend_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_IgnoreFriend_Response {
    // message fields
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IgnoreFriend_Response {
    fn default() -> &'a CPlayer_IgnoreFriend_Response {
        <CPlayer_IgnoreFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IgnoreFriend_Response {
    pub fn new() -> CPlayer_IgnoreFriend_Response {
        ::std::default::Default::default()
    }

    // optional uint32 friend_relationship = 1;


    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }
    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_IgnoreFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.friend_relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_relationship {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IgnoreFriend_Response {
        CPlayer_IgnoreFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "friend_relationship",
                    |m: &CPlayer_IgnoreFriend_Response| { &m.friend_relationship },
                    |m: &mut CPlayer_IgnoreFriend_Response| { &mut m.friend_relationship },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_IgnoreFriend_Response>(
                    "CPlayer_IgnoreFriend_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_IgnoreFriend_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_IgnoreFriend_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_IgnoreFriend_Response,
        };
        unsafe {
            instance.get(CPlayer_IgnoreFriend_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_IgnoreFriend_Response {
    fn clear(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IgnoreFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IgnoreFriend_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetCommunityPreferences_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetCommunityPreferences_Request {
    fn default() -> &'a CPlayer_GetCommunityPreferences_Request {
        <CPlayer_GetCommunityPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetCommunityPreferences_Request {
    pub fn new() -> CPlayer_GetCommunityPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetCommunityPreferences_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetCommunityPreferences_Request {
        CPlayer_GetCommunityPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetCommunityPreferences_Request>(
                    "CPlayer_GetCommunityPreferences_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetCommunityPreferences_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetCommunityPreferences_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetCommunityPreferences_Request,
        };
        unsafe {
            instance.get(CPlayer_GetCommunityPreferences_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetCommunityPreferences_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetCommunityPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetCommunityPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_CommunityPreferences {
    // message fields
    hide_adult_content_violence: ::std::option::Option<bool>,
    hide_adult_content_sex: ::std::option::Option<bool>,
    parenthesize_nicknames: ::std::option::Option<bool>,
    timestamp_updated: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_CommunityPreferences {
    fn default() -> &'a CPlayer_CommunityPreferences {
        <CPlayer_CommunityPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_CommunityPreferences {
    pub fn new() -> CPlayer_CommunityPreferences {
        ::std::default::Default::default()
    }

    // optional bool hide_adult_content_violence = 1;


    pub fn get_hide_adult_content_violence(&self) -> bool {
        self.hide_adult_content_violence.unwrap_or(true)
    }
    pub fn clear_hide_adult_content_violence(&mut self) {
        self.hide_adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_hide_adult_content_violence(&self) -> bool {
        self.hide_adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_adult_content_violence(&mut self, v: bool) {
        self.hide_adult_content_violence = ::std::option::Option::Some(v);
    }

    // optional bool hide_adult_content_sex = 2;


    pub fn get_hide_adult_content_sex(&self) -> bool {
        self.hide_adult_content_sex.unwrap_or(true)
    }
    pub fn clear_hide_adult_content_sex(&mut self) {
        self.hide_adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_hide_adult_content_sex(&self) -> bool {
        self.hide_adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_adult_content_sex(&mut self, v: bool) {
        self.hide_adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional bool parenthesize_nicknames = 4;


    pub fn get_parenthesize_nicknames(&self) -> bool {
        self.parenthesize_nicknames.unwrap_or(false)
    }
    pub fn clear_parenthesize_nicknames(&mut self) {
        self.parenthesize_nicknames = ::std::option::Option::None;
    }

    pub fn has_parenthesize_nicknames(&self) -> bool {
        self.parenthesize_nicknames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parenthesize_nicknames(&mut self, v: bool) {
        self.parenthesize_nicknames = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 3;


    pub fn get_timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }
    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_CommunityPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_adult_content_violence = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_adult_content_sex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.parenthesize_nicknames = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp_updated = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hide_adult_content_violence {
            my_size += 2;
        }
        if let Some(v) = self.hide_adult_content_sex {
            my_size += 2;
        }
        if let Some(v) = self.parenthesize_nicknames {
            my_size += 2;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hide_adult_content_violence {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.hide_adult_content_sex {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.parenthesize_nicknames {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_CommunityPreferences {
        CPlayer_CommunityPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hide_adult_content_violence",
                    |m: &CPlayer_CommunityPreferences| { &m.hide_adult_content_violence },
                    |m: &mut CPlayer_CommunityPreferences| { &mut m.hide_adult_content_violence },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hide_adult_content_sex",
                    |m: &CPlayer_CommunityPreferences| { &m.hide_adult_content_sex },
                    |m: &mut CPlayer_CommunityPreferences| { &mut m.hide_adult_content_sex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "parenthesize_nicknames",
                    |m: &CPlayer_CommunityPreferences| { &m.parenthesize_nicknames },
                    |m: &mut CPlayer_CommunityPreferences| { &mut m.parenthesize_nicknames },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp_updated",
                    |m: &CPlayer_CommunityPreferences| { &m.timestamp_updated },
                    |m: &mut CPlayer_CommunityPreferences| { &mut m.timestamp_updated },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_CommunityPreferences>(
                    "CPlayer_CommunityPreferences",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_CommunityPreferences {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_CommunityPreferences> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_CommunityPreferences,
        };
        unsafe {
            instance.get(CPlayer_CommunityPreferences::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_CommunityPreferences {
    fn clear(&mut self) {
        self.hide_adult_content_violence = ::std::option::Option::None;
        self.hide_adult_content_sex = ::std::option::Option::None;
        self.parenthesize_nicknames = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_CommunityPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_CommunityPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetCommunityPreferences_Response {
    // message fields
    preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetCommunityPreferences_Response {
    fn default() -> &'a CPlayer_GetCommunityPreferences_Response {
        <CPlayer_GetCommunityPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetCommunityPreferences_Response {
    pub fn new() -> CPlayer_GetCommunityPreferences_Response {
        ::std::default::Default::default()
    }

    // optional .CPlayer_CommunityPreferences preferences = 1;


    pub fn get_preferences(&self) -> &CPlayer_CommunityPreferences {
        self.preferences.as_ref().unwrap_or_else(|| CPlayer_CommunityPreferences::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CPlayer_CommunityPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CPlayer_CommunityPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CPlayer_CommunityPreferences {
        self.preferences.take().unwrap_or_else(|| CPlayer_CommunityPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_GetCommunityPreferences_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetCommunityPreferences_Response {
        CPlayer_GetCommunityPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>>(
                    "preferences",
                    |m: &CPlayer_GetCommunityPreferences_Response| { &m.preferences },
                    |m: &mut CPlayer_GetCommunityPreferences_Response| { &mut m.preferences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetCommunityPreferences_Response>(
                    "CPlayer_GetCommunityPreferences_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetCommunityPreferences_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetCommunityPreferences_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetCommunityPreferences_Response,
        };
        unsafe {
            instance.get(CPlayer_GetCommunityPreferences_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetCommunityPreferences_Response {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetCommunityPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetCommunityPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetCommunityPreferences_Request {
    // message fields
    preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetCommunityPreferences_Request {
    fn default() -> &'a CPlayer_SetCommunityPreferences_Request {
        <CPlayer_SetCommunityPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetCommunityPreferences_Request {
    pub fn new() -> CPlayer_SetCommunityPreferences_Request {
        ::std::default::Default::default()
    }

    // optional .CPlayer_CommunityPreferences preferences = 1;


    pub fn get_preferences(&self) -> &CPlayer_CommunityPreferences {
        self.preferences.as_ref().unwrap_or_else(|| CPlayer_CommunityPreferences::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CPlayer_CommunityPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CPlayer_CommunityPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CPlayer_CommunityPreferences {
        self.preferences.take().unwrap_or_else(|| CPlayer_CommunityPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_SetCommunityPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetCommunityPreferences_Request {
        CPlayer_SetCommunityPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>>(
                    "preferences",
                    |m: &CPlayer_SetCommunityPreferences_Request| { &m.preferences },
                    |m: &mut CPlayer_SetCommunityPreferences_Request| { &mut m.preferences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetCommunityPreferences_Request>(
                    "CPlayer_SetCommunityPreferences_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_SetCommunityPreferences_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_SetCommunityPreferences_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_SetCommunityPreferences_Request,
        };
        unsafe {
            instance.get(CPlayer_SetCommunityPreferences_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_SetCommunityPreferences_Request {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetCommunityPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetCommunityPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_SetCommunityPreferences_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetCommunityPreferences_Response {
    fn default() -> &'a CPlayer_SetCommunityPreferences_Response {
        <CPlayer_SetCommunityPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetCommunityPreferences_Response {
    pub fn new() -> CPlayer_SetCommunityPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetCommunityPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetCommunityPreferences_Response {
        CPlayer_SetCommunityPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetCommunityPreferences_Response>(
                    "CPlayer_SetCommunityPreferences_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_SetCommunityPreferences_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_SetCommunityPreferences_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_SetCommunityPreferences_Response,
        };
        unsafe {
            instance.get(CPlayer_SetCommunityPreferences_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_SetCommunityPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetCommunityPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetCommunityPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNewSteamAnnouncementState_Request {
    // message fields
    language: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNewSteamAnnouncementState_Request {
    fn default() -> &'a CPlayer_GetNewSteamAnnouncementState_Request {
        <CPlayer_GetNewSteamAnnouncementState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNewSteamAnnouncementState_Request {
    pub fn new() -> CPlayer_GetNewSteamAnnouncementState_Request {
        ::std::default::Default::default()
    }

    // optional int32 language = 1;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetNewSteamAnnouncementState_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.language {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNewSteamAnnouncementState_Request {
        CPlayer_GetNewSteamAnnouncementState_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPlayer_GetNewSteamAnnouncementState_Request| { &m.language },
                    |m: &mut CPlayer_GetNewSteamAnnouncementState_Request| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNewSteamAnnouncementState_Request>(
                    "CPlayer_GetNewSteamAnnouncementState_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetNewSteamAnnouncementState_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetNewSteamAnnouncementState_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetNewSteamAnnouncementState_Request,
        };
        unsafe {
            instance.get(CPlayer_GetNewSteamAnnouncementState_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetNewSteamAnnouncementState_Request {
    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNewSteamAnnouncementState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNewSteamAnnouncementState_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetNewSteamAnnouncementState_Response {
    // message fields
    state: ::std::option::Option<i32>,
    announcement_headline: ::protobuf::SingularField<::std::string::String>,
    announcement_url: ::protobuf::SingularField<::std::string::String>,
    time_posted: ::std::option::Option<u32>,
    announcement_gid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNewSteamAnnouncementState_Response {
    fn default() -> &'a CPlayer_GetNewSteamAnnouncementState_Response {
        <CPlayer_GetNewSteamAnnouncementState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNewSteamAnnouncementState_Response {
    pub fn new() -> CPlayer_GetNewSteamAnnouncementState_Response {
        ::std::default::Default::default()
    }

    // optional int32 state = 1;


    pub fn get_state(&self) -> i32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string announcement_headline = 2;


    pub fn get_announcement_headline(&self) -> &str {
        match self.announcement_headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_headline(&mut self) {
        self.announcement_headline.clear();
    }

    pub fn has_announcement_headline(&self) -> bool {
        self.announcement_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_headline(&mut self, v: ::std::string::String) {
        self.announcement_headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_headline(&mut self) -> &mut ::std::string::String {
        if self.announcement_headline.is_none() {
            self.announcement_headline.set_default();
        }
        self.announcement_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_headline(&mut self) -> ::std::string::String {
        self.announcement_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement_url = 3;


    pub fn get_announcement_url(&self) -> &str {
        match self.announcement_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_url(&mut self) {
        self.announcement_url.clear();
    }

    pub fn has_announcement_url(&self) -> bool {
        self.announcement_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_url(&mut self, v: ::std::string::String) {
        self.announcement_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_url(&mut self) -> &mut ::std::string::String {
        if self.announcement_url.is_none() {
            self.announcement_url.set_default();
        }
        self.announcement_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_url(&mut self) -> ::std::string::String {
        self.announcement_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_posted = 4;


    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }
    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }

    // optional uint64 announcement_gid = 5;


    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }
    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetNewSteamAnnouncementState_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_headline)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_posted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.announcement_gid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNewSteamAnnouncementState_Response {
        CPlayer_GetNewSteamAnnouncementState_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "state",
                    |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.state },
                    |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "announcement_headline",
                    |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_headline },
                    |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_headline },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "announcement_url",
                    |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_url },
                    |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_posted",
                    |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.time_posted },
                    |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.time_posted },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "announcement_gid",
                    |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_gid },
                    |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_gid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNewSteamAnnouncementState_Response>(
                    "CPlayer_GetNewSteamAnnouncementState_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetNewSteamAnnouncementState_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetNewSteamAnnouncementState_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetNewSteamAnnouncementState_Response,
        };
        unsafe {
            instance.get(CPlayer_GetNewSteamAnnouncementState_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetNewSteamAnnouncementState_Response {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.announcement_headline.clear();
        self.announcement_url.clear();
        self.time_posted = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNewSteamAnnouncementState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNewSteamAnnouncementState_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_UpdateSteamAnnouncementLastRead_Request {
    // message fields
    announcement_gid: ::std::option::Option<u64>,
    time_posted: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn default() -> &'a CPlayer_UpdateSteamAnnouncementLastRead_Request {
        <CPlayer_UpdateSteamAnnouncementLastRead_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_UpdateSteamAnnouncementLastRead_Request {
    pub fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Request {
        ::std::default::Default::default()
    }

    // optional uint64 announcement_gid = 1;


    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }
    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 time_posted = 2;


    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }
    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.announcement_gid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_posted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.announcement_gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Request {
        CPlayer_UpdateSteamAnnouncementLastRead_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "announcement_gid",
                    |m: &CPlayer_UpdateSteamAnnouncementLastRead_Request| { &m.announcement_gid },
                    |m: &mut CPlayer_UpdateSteamAnnouncementLastRead_Request| { &mut m.announcement_gid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_posted",
                    |m: &CPlayer_UpdateSteamAnnouncementLastRead_Request| { &m.time_posted },
                    |m: &mut CPlayer_UpdateSteamAnnouncementLastRead_Request| { &mut m.time_posted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_UpdateSteamAnnouncementLastRead_Request>(
                    "CPlayer_UpdateSteamAnnouncementLastRead_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_UpdateSteamAnnouncementLastRead_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_UpdateSteamAnnouncementLastRead_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_UpdateSteamAnnouncementLastRead_Request,
        };
        unsafe {
            instance.get(CPlayer_UpdateSteamAnnouncementLastRead_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn clear(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
        self.time_posted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_UpdateSteamAnnouncementLastRead_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn default() -> &'a CPlayer_UpdateSteamAnnouncementLastRead_Response {
        <CPlayer_UpdateSteamAnnouncementLastRead_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_UpdateSteamAnnouncementLastRead_Response {
    pub fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Response {
        CPlayer_UpdateSteamAnnouncementLastRead_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_UpdateSteamAnnouncementLastRead_Response>(
                    "CPlayer_UpdateSteamAnnouncementLastRead_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_UpdateSteamAnnouncementLastRead_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_UpdateSteamAnnouncementLastRead_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_UpdateSteamAnnouncementLastRead_Response,
        };
        unsafe {
            instance.get(CPlayer_UpdateSteamAnnouncementLastRead_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPrivacySettings_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPrivacySettings_Request {
    fn default() -> &'a CPlayer_GetPrivacySettings_Request {
        <CPlayer_GetPrivacySettings_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPrivacySettings_Request {
    pub fn new() -> CPlayer_GetPrivacySettings_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPrivacySettings_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPrivacySettings_Request {
        CPlayer_GetPrivacySettings_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPrivacySettings_Request>(
                    "CPlayer_GetPrivacySettings_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetPrivacySettings_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetPrivacySettings_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetPrivacySettings_Request,
        };
        unsafe {
            instance.get(CPlayer_GetPrivacySettings_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetPrivacySettings_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPrivacySettings_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPrivacySettings_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPrivacySettings {
    // message fields
    privacy_state: ::std::option::Option<i32>,
    privacy_state_inventory: ::std::option::Option<i32>,
    privacy_state_gifts: ::std::option::Option<i32>,
    privacy_state_ownedgames: ::std::option::Option<i32>,
    privacy_state_playtime: ::std::option::Option<i32>,
    privacy_state_friendslist: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPrivacySettings {
    fn default() -> &'a CPrivacySettings {
        <CPrivacySettings as ::protobuf::Message>::default_instance()
    }
}

impl CPrivacySettings {
    pub fn new() -> CPrivacySettings {
        ::std::default::Default::default()
    }

    // optional int32 privacy_state = 1;


    pub fn get_privacy_state(&self) -> i32 {
        self.privacy_state.unwrap_or(0)
    }
    pub fn clear_privacy_state(&mut self) {
        self.privacy_state = ::std::option::Option::None;
    }

    pub fn has_privacy_state(&self) -> bool {
        self.privacy_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state(&mut self, v: i32) {
        self.privacy_state = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_inventory = 2;


    pub fn get_privacy_state_inventory(&self) -> i32 {
        self.privacy_state_inventory.unwrap_or(0)
    }
    pub fn clear_privacy_state_inventory(&mut self) {
        self.privacy_state_inventory = ::std::option::Option::None;
    }

    pub fn has_privacy_state_inventory(&self) -> bool {
        self.privacy_state_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_inventory(&mut self, v: i32) {
        self.privacy_state_inventory = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_gifts = 3;


    pub fn get_privacy_state_gifts(&self) -> i32 {
        self.privacy_state_gifts.unwrap_or(0)
    }
    pub fn clear_privacy_state_gifts(&mut self) {
        self.privacy_state_gifts = ::std::option::Option::None;
    }

    pub fn has_privacy_state_gifts(&self) -> bool {
        self.privacy_state_gifts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_gifts(&mut self, v: i32) {
        self.privacy_state_gifts = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_ownedgames = 4;


    pub fn get_privacy_state_ownedgames(&self) -> i32 {
        self.privacy_state_ownedgames.unwrap_or(0)
    }
    pub fn clear_privacy_state_ownedgames(&mut self) {
        self.privacy_state_ownedgames = ::std::option::Option::None;
    }

    pub fn has_privacy_state_ownedgames(&self) -> bool {
        self.privacy_state_ownedgames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_ownedgames(&mut self, v: i32) {
        self.privacy_state_ownedgames = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_playtime = 5;


    pub fn get_privacy_state_playtime(&self) -> i32 {
        self.privacy_state_playtime.unwrap_or(0)
    }
    pub fn clear_privacy_state_playtime(&mut self) {
        self.privacy_state_playtime = ::std::option::Option::None;
    }

    pub fn has_privacy_state_playtime(&self) -> bool {
        self.privacy_state_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_playtime(&mut self, v: i32) {
        self.privacy_state_playtime = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_friendslist = 6;


    pub fn get_privacy_state_friendslist(&self) -> i32 {
        self.privacy_state_friendslist.unwrap_or(0)
    }
    pub fn clear_privacy_state_friendslist(&mut self) {
        self.privacy_state_friendslist = ::std::option::Option::None;
    }

    pub fn has_privacy_state_friendslist(&self) -> bool {
        self.privacy_state_friendslist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_friendslist(&mut self, v: i32) {
        self.privacy_state_friendslist = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPrivacySettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_inventory = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_gifts = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_ownedgames = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_playtime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.privacy_state_friendslist = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.privacy_state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_inventory {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_gifts {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_ownedgames {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_playtime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_friendslist {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.privacy_state {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.privacy_state_inventory {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.privacy_state_gifts {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.privacy_state_ownedgames {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.privacy_state_playtime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.privacy_state_friendslist {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPrivacySettings {
        CPrivacySettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "privacy_state",
                    |m: &CPrivacySettings| { &m.privacy_state },
                    |m: &mut CPrivacySettings| { &mut m.privacy_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "privacy_state_inventory",
                    |m: &CPrivacySettings| { &m.privacy_state_inventory },
                    |m: &mut CPrivacySettings| { &mut m.privacy_state_inventory },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "privacy_state_gifts",
                    |m: &CPrivacySettings| { &m.privacy_state_gifts },
                    |m: &mut CPrivacySettings| { &mut m.privacy_state_gifts },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "privacy_state_ownedgames",
                    |m: &CPrivacySettings| { &m.privacy_state_ownedgames },
                    |m: &mut CPrivacySettings| { &mut m.privacy_state_ownedgames },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "privacy_state_playtime",
                    |m: &CPrivacySettings| { &m.privacy_state_playtime },
                    |m: &mut CPrivacySettings| { &mut m.privacy_state_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "privacy_state_friendslist",
                    |m: &CPrivacySettings| { &m.privacy_state_friendslist },
                    |m: &mut CPrivacySettings| { &mut m.privacy_state_friendslist },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPrivacySettings>(
                    "CPrivacySettings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPrivacySettings {
        static mut instance: ::protobuf::lazy::Lazy<CPrivacySettings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPrivacySettings,
        };
        unsafe {
            instance.get(CPrivacySettings::new)
        }
    }
}

impl ::protobuf::Clear for CPrivacySettings {
    fn clear(&mut self) {
        self.privacy_state = ::std::option::Option::None;
        self.privacy_state_inventory = ::std::option::Option::None;
        self.privacy_state_gifts = ::std::option::Option::None;
        self.privacy_state_ownedgames = ::std::option::Option::None;
        self.privacy_state_playtime = ::std::option::Option::None;
        self.privacy_state_friendslist = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPrivacySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPrivacySettings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetPrivacySettings_Response {
    // message fields
    privacy_settings: ::protobuf::SingularPtrField<CPrivacySettings>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPrivacySettings_Response {
    fn default() -> &'a CPlayer_GetPrivacySettings_Response {
        <CPlayer_GetPrivacySettings_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPrivacySettings_Response {
    pub fn new() -> CPlayer_GetPrivacySettings_Response {
        ::std::default::Default::default()
    }

    // optional .CPrivacySettings privacy_settings = 1;


    pub fn get_privacy_settings(&self) -> &CPrivacySettings {
        self.privacy_settings.as_ref().unwrap_or_else(|| CPrivacySettings::default_instance())
    }
    pub fn clear_privacy_settings(&mut self) {
        self.privacy_settings.clear();
    }

    pub fn has_privacy_settings(&self) -> bool {
        self.privacy_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_settings(&mut self, v: CPrivacySettings) {
        self.privacy_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privacy_settings(&mut self) -> &mut CPrivacySettings {
        if self.privacy_settings.is_none() {
            self.privacy_settings.set_default();
        }
        self.privacy_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_privacy_settings(&mut self) -> CPrivacySettings {
        self.privacy_settings.take().unwrap_or_else(|| CPrivacySettings::new())
    }
}

impl ::protobuf::Message for CPlayer_GetPrivacySettings_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.privacy_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.privacy_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.privacy_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.privacy_settings.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPrivacySettings_Response {
        CPlayer_GetPrivacySettings_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPrivacySettings>>(
                    "privacy_settings",
                    |m: &CPlayer_GetPrivacySettings_Response| { &m.privacy_settings },
                    |m: &mut CPlayer_GetPrivacySettings_Response| { &mut m.privacy_settings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPrivacySettings_Response>(
                    "CPlayer_GetPrivacySettings_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetPrivacySettings_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetPrivacySettings_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetPrivacySettings_Response,
        };
        unsafe {
            instance.get(CPlayer_GetPrivacySettings_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetPrivacySettings_Response {
    fn clear(&mut self) {
        self.privacy_settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPrivacySettings_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPrivacySettings_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetDurationControl_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetDurationControl_Request {
    fn default() -> &'a CPlayer_GetDurationControl_Request {
        <CPlayer_GetDurationControl_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetDurationControl_Request {
    pub fn new() -> CPlayer_GetDurationControl_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetDurationControl_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetDurationControl_Request {
        CPlayer_GetDurationControl_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPlayer_GetDurationControl_Request| { &m.appid },
                    |m: &mut CPlayer_GetDurationControl_Request| { &mut m.appid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetDurationControl_Request>(
                    "CPlayer_GetDurationControl_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetDurationControl_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetDurationControl_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetDurationControl_Request,
        };
        unsafe {
            instance.get(CPlayer_GetDurationControl_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetDurationControl_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetDurationControl_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetDurationControl_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_GetDurationControl_Response {
    // message fields
    is_enabled: ::std::option::Option<bool>,
    seconds: ::std::option::Option<i32>,
    seconds_today: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetDurationControl_Response {
    fn default() -> &'a CPlayer_GetDurationControl_Response {
        <CPlayer_GetDurationControl_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetDurationControl_Response {
    pub fn new() -> CPlayer_GetDurationControl_Response {
        ::std::default::Default::default()
    }

    // optional bool is_enabled = 1;


    pub fn get_is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }
    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 seconds = 2;


    pub fn get_seconds(&self) -> i32 {
        self.seconds.unwrap_or(0)
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_today = 3;


    pub fn get_seconds_today(&self) -> i32 {
        self.seconds_today.unwrap_or(0)
    }
    pub fn clear_seconds_today(&mut self) {
        self.seconds_today = ::std::option::Option::None;
    }

    pub fn has_seconds_today(&self) -> bool {
        self.seconds_today.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_today(&mut self, v: i32) {
        self.seconds_today = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetDurationControl_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_enabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_today = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_enabled {
            my_size += 2;
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_today {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.seconds_today {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetDurationControl_Response {
        CPlayer_GetDurationControl_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_enabled",
                    |m: &CPlayer_GetDurationControl_Response| { &m.is_enabled },
                    |m: &mut CPlayer_GetDurationControl_Response| { &mut m.is_enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seconds",
                    |m: &CPlayer_GetDurationControl_Response| { &m.seconds },
                    |m: &mut CPlayer_GetDurationControl_Response| { &mut m.seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seconds_today",
                    |m: &CPlayer_GetDurationControl_Response| { &m.seconds_today },
                    |m: &mut CPlayer_GetDurationControl_Response| { &mut m.seconds_today },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetDurationControl_Response>(
                    "CPlayer_GetDurationControl_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_GetDurationControl_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_GetDurationControl_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_GetDurationControl_Response,
        };
        unsafe {
            instance.get(CPlayer_GetDurationControl_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_GetDurationControl_Response {
    fn clear(&mut self) {
        self.is_enabled = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.seconds_today = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetDurationControl_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetDurationControl_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_LastPlayedTimes_Notification {
    // message fields
    games: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_LastPlayedTimes_Notification {
    fn default() -> &'a CPlayer_LastPlayedTimes_Notification {
        <CPlayer_LastPlayedTimes_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_LastPlayedTimes_Notification {
    pub fn new() -> CPlayer_LastPlayedTimes_Notification {
        ::std::default::Default::default()
    }

    // repeated .CPlayer_GetLastPlayedTimes_Response.Game games = 1;


    pub fn get_games(&self) -> &[CPlayer_GetLastPlayedTimes_Response_Game] {
        &self.games
    }
    pub fn clear_games(&mut self) {
        self.games.clear();
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game>) {
        self.games = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games(&mut self) -> &mut ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        &mut self.games
    }

    // Take field
    pub fn take_games(&mut self) -> ::protobuf::RepeatedField<CPlayer_GetLastPlayedTimes_Response_Game> {
        ::std::mem::replace(&mut self.games, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPlayer_LastPlayedTimes_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_LastPlayedTimes_Notification {
        CPlayer_LastPlayedTimes_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_GetLastPlayedTimes_Response_Game>>(
                    "games",
                    |m: &CPlayer_LastPlayedTimes_Notification| { &m.games },
                    |m: &mut CPlayer_LastPlayedTimes_Notification| { &mut m.games },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_LastPlayedTimes_Notification>(
                    "CPlayer_LastPlayedTimes_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_LastPlayedTimes_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_LastPlayedTimes_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_LastPlayedTimes_Notification,
        };
        unsafe {
            instance.get(CPlayer_LastPlayedTimes_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_LastPlayedTimes_Notification {
    fn clear(&mut self) {
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_LastPlayedTimes_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_LastPlayedTimes_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_FriendNicknameChanged_Notification {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    is_echo_to_self: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_FriendNicknameChanged_Notification {
    fn default() -> &'a CPlayer_FriendNicknameChanged_Notification {
        <CPlayer_FriendNicknameChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_FriendNicknameChanged_Notification {
    pub fn new() -> CPlayer_FriendNicknameChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_echo_to_self = 3;


    pub fn get_is_echo_to_self(&self) -> bool {
        self.is_echo_to_self.unwrap_or(false)
    }
    pub fn clear_is_echo_to_self(&mut self) {
        self.is_echo_to_self = ::std::option::Option::None;
    }

    pub fn has_is_echo_to_self(&self) -> bool {
        self.is_echo_to_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_echo_to_self(&mut self, v: bool) {
        self.is_echo_to_self = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_FriendNicknameChanged_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_echo_to_self = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_echo_to_self {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.is_echo_to_self {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_FriendNicknameChanged_Notification {
        CPlayer_FriendNicknameChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "accountid",
                    |m: &CPlayer_FriendNicknameChanged_Notification| { &m.accountid },
                    |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nickname",
                    |m: &CPlayer_FriendNicknameChanged_Notification| { &m.nickname },
                    |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.nickname },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_echo_to_self",
                    |m: &CPlayer_FriendNicknameChanged_Notification| { &m.is_echo_to_self },
                    |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.is_echo_to_self },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_FriendNicknameChanged_Notification>(
                    "CPlayer_FriendNicknameChanged_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_FriendNicknameChanged_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_FriendNicknameChanged_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_FriendNicknameChanged_Notification,
        };
        unsafe {
            instance.get(CPlayer_FriendNicknameChanged_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_FriendNicknameChanged_Notification {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.is_echo_to_self = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_FriendNicknameChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_FriendNicknameChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_NewSteamAnnouncementState_Notification {
    // message fields
    state: ::std::option::Option<i32>,
    announcement_headline: ::protobuf::SingularField<::std::string::String>,
    announcement_url: ::protobuf::SingularField<::std::string::String>,
    time_posted: ::std::option::Option<u32>,
    announcement_gid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_NewSteamAnnouncementState_Notification {
    fn default() -> &'a CPlayer_NewSteamAnnouncementState_Notification {
        <CPlayer_NewSteamAnnouncementState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_NewSteamAnnouncementState_Notification {
    pub fn new() -> CPlayer_NewSteamAnnouncementState_Notification {
        ::std::default::Default::default()
    }

    // optional int32 state = 1;


    pub fn get_state(&self) -> i32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string announcement_headline = 2;


    pub fn get_announcement_headline(&self) -> &str {
        match self.announcement_headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_headline(&mut self) {
        self.announcement_headline.clear();
    }

    pub fn has_announcement_headline(&self) -> bool {
        self.announcement_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_headline(&mut self, v: ::std::string::String) {
        self.announcement_headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_headline(&mut self) -> &mut ::std::string::String {
        if self.announcement_headline.is_none() {
            self.announcement_headline.set_default();
        }
        self.announcement_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_headline(&mut self) -> ::std::string::String {
        self.announcement_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement_url = 3;


    pub fn get_announcement_url(&self) -> &str {
        match self.announcement_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_announcement_url(&mut self) {
        self.announcement_url.clear();
    }

    pub fn has_announcement_url(&self) -> bool {
        self.announcement_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_url(&mut self, v: ::std::string::String) {
        self.announcement_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_url(&mut self) -> &mut ::std::string::String {
        if self.announcement_url.is_none() {
            self.announcement_url.set_default();
        }
        self.announcement_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_url(&mut self) -> ::std::string::String {
        self.announcement_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_posted = 4;


    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }
    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }

    // optional uint64 announcement_gid = 5;


    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }
    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_NewSteamAnnouncementState_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_headline)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_posted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.announcement_gid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.announcement_headline.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.announcement_url.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_NewSteamAnnouncementState_Notification {
        CPlayer_NewSteamAnnouncementState_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "state",
                    |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.state },
                    |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "announcement_headline",
                    |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_headline },
                    |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_headline },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "announcement_url",
                    |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_url },
                    |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_posted",
                    |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.time_posted },
                    |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.time_posted },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "announcement_gid",
                    |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_gid },
                    |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_gid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_NewSteamAnnouncementState_Notification>(
                    "CPlayer_NewSteamAnnouncementState_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_NewSteamAnnouncementState_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_NewSteamAnnouncementState_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_NewSteamAnnouncementState_Notification,
        };
        unsafe {
            instance.get(CPlayer_NewSteamAnnouncementState_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_NewSteamAnnouncementState_Notification {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.announcement_headline.clear();
        self.announcement_url.clear();
        self.time_posted = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_NewSteamAnnouncementState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_NewSteamAnnouncementState_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_CommunityPreferencesChanged_Notification {
    // message fields
    preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_CommunityPreferencesChanged_Notification {
    fn default() -> &'a CPlayer_CommunityPreferencesChanged_Notification {
        <CPlayer_CommunityPreferencesChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_CommunityPreferencesChanged_Notification {
    pub fn new() -> CPlayer_CommunityPreferencesChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .CPlayer_CommunityPreferences preferences = 1;


    pub fn get_preferences(&self) -> &CPlayer_CommunityPreferences {
        self.preferences.as_ref().unwrap_or_else(|| CPlayer_CommunityPreferences::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: CPlayer_CommunityPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut CPlayer_CommunityPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> CPlayer_CommunityPreferences {
        self.preferences.take().unwrap_or_else(|| CPlayer_CommunityPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_CommunityPreferencesChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_CommunityPreferencesChanged_Notification {
        CPlayer_CommunityPreferencesChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>>(
                    "preferences",
                    |m: &CPlayer_CommunityPreferencesChanged_Notification| { &m.preferences },
                    |m: &mut CPlayer_CommunityPreferencesChanged_Notification| { &mut m.preferences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_CommunityPreferencesChanged_Notification>(
                    "CPlayer_CommunityPreferencesChanged_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_CommunityPreferencesChanged_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_CommunityPreferencesChanged_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_CommunityPreferencesChanged_Notification,
        };
        unsafe {
            instance.get(CPlayer_CommunityPreferencesChanged_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_CommunityPreferencesChanged_Notification {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_CommunityPreferencesChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_CommunityPreferencesChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PerFriendPreferencesChanged_Notification {
    // message fields
    accountid: ::std::option::Option<u32>,
    preferences: ::protobuf::SingularPtrField<PerFriendPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PerFriendPreferencesChanged_Notification {
    fn default() -> &'a CPlayer_PerFriendPreferencesChanged_Notification {
        <CPlayer_PerFriendPreferencesChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PerFriendPreferencesChanged_Notification {
    pub fn new() -> CPlayer_PerFriendPreferencesChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .PerFriendPreferences preferences = 2;


    pub fn get_preferences(&self) -> &PerFriendPreferences {
        self.preferences.as_ref().unwrap_or_else(|| PerFriendPreferences::default_instance())
    }
    pub fn clear_preferences(&mut self) {
        self.preferences.clear();
    }

    pub fn has_preferences(&self) -> bool {
        self.preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferences(&mut self, v: PerFriendPreferences) {
        self.preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferences(&mut self) -> &mut PerFriendPreferences {
        if self.preferences.is_none() {
            self.preferences.set_default();
        }
        self.preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferences(&mut self) -> PerFriendPreferences {
        self.preferences.take().unwrap_or_else(|| PerFriendPreferences::new())
    }
}

impl ::protobuf::Message for CPlayer_PerFriendPreferencesChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(ref v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.preferences.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PerFriendPreferencesChanged_Notification {
        CPlayer_PerFriendPreferencesChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "accountid",
                    |m: &CPlayer_PerFriendPreferencesChanged_Notification| { &m.accountid },
                    |m: &mut CPlayer_PerFriendPreferencesChanged_Notification| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PerFriendPreferences>>(
                    "preferences",
                    |m: &CPlayer_PerFriendPreferencesChanged_Notification| { &m.preferences },
                    |m: &mut CPlayer_PerFriendPreferencesChanged_Notification| { &mut m.preferences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PerFriendPreferencesChanged_Notification>(
                    "CPlayer_PerFriendPreferencesChanged_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_PerFriendPreferencesChanged_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_PerFriendPreferencesChanged_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_PerFriendPreferencesChanged_Notification,
        };
        unsafe {
            instance.get(CPlayer_PerFriendPreferencesChanged_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_PerFriendPreferencesChanged_Notification {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PerFriendPreferencesChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PerFriendPreferencesChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPlayer_PrivacySettingsChanged_Notification {
    // message fields
    privacy_settings: ::protobuf::SingularPtrField<CPrivacySettings>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PrivacySettingsChanged_Notification {
    fn default() -> &'a CPlayer_PrivacySettingsChanged_Notification {
        <CPlayer_PrivacySettingsChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PrivacySettingsChanged_Notification {
    pub fn new() -> CPlayer_PrivacySettingsChanged_Notification {
        ::std::default::Default::default()
    }

    // optional .CPrivacySettings privacy_settings = 1;


    pub fn get_privacy_settings(&self) -> &CPrivacySettings {
        self.privacy_settings.as_ref().unwrap_or_else(|| CPrivacySettings::default_instance())
    }
    pub fn clear_privacy_settings(&mut self) {
        self.privacy_settings.clear();
    }

    pub fn has_privacy_settings(&self) -> bool {
        self.privacy_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_settings(&mut self, v: CPrivacySettings) {
        self.privacy_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privacy_settings(&mut self) -> &mut CPrivacySettings {
        if self.privacy_settings.is_none() {
            self.privacy_settings.set_default();
        }
        self.privacy_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_privacy_settings(&mut self) -> CPrivacySettings {
        self.privacy_settings.take().unwrap_or_else(|| CPrivacySettings::new())
    }
}

impl ::protobuf::Message for CPlayer_PrivacySettingsChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.privacy_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.privacy_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.privacy_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.privacy_settings.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PrivacySettingsChanged_Notification {
        CPlayer_PrivacySettingsChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPrivacySettings>>(
                    "privacy_settings",
                    |m: &CPlayer_PrivacySettingsChanged_Notification| { &m.privacy_settings },
                    |m: &mut CPlayer_PrivacySettingsChanged_Notification| { &mut m.privacy_settings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PrivacySettingsChanged_Notification>(
                    "CPlayer_PrivacySettingsChanged_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPlayer_PrivacySettingsChanged_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPlayer_PrivacySettingsChanged_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPlayer_PrivacySettingsChanged_Notification,
        };
        unsafe {
            instance.get(CPlayer_PrivacySettingsChanged_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPlayer_PrivacySettingsChanged_Notification {
    fn clear(&mut self) {
        self.privacy_settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PrivacySettingsChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PrivacySettingsChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ENotificationSetting {
    k_ENotificationSettingNotifyUseDefault = 0,
    k_ENotificationSettingAlways = 1,
    k_ENotificationSettingNever = 2,
}

impl ::protobuf::ProtobufEnum for ENotificationSetting {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENotificationSetting> {
        match value {
            0 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            1 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingAlways),
            2 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingNever),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ENotificationSetting] = &[
            ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ENotificationSetting::k_ENotificationSettingAlways,
            ENotificationSetting::k_ENotificationSettingNever,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ENotificationSetting", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ENotificationSetting {
}

impl ::std::default::Default for ENotificationSetting {
    fn default() -> Self {
        ENotificationSetting::k_ENotificationSettingNotifyUseDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for ENotificationSetting {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&steammessages_player.steamclient.proto\x1a,steammessages_unified_base\
    .steamclient.proto\"4\n2CPlayer_GetMutualFriendsForIncomingInvites_Reque\
    st\"}\n&CPlayer_IncomingInviteMutualFriendList\x12\x18\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamid\x129\n\x19mutual_friend_account_ids\x18\
    \x02\x20\x03(\rR\x16mutualFriendAccountIds\"\xae\x01\n3CPlayer_GetMutual\
    FriendsForIncomingInvites_Response\x12w\n$incoming_invite_mutual_friends\
    _lists\x18\x01\x20\x03(\x0b2'.CPlayer_IncomingInviteMutualFriendListR\
    \x20incomingInviteMutualFriendsLists\">\n&CPlayer_GetFriendsGameplayInfo\
    _Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\x9f\x07\n'CPl\
    ayer_GetFriendsGameplayInfo_Response\x12U\n\tyour_info\x18\x01\x20\x01(\
    \x0b28.CPlayer_GetFriendsGameplayInfo_Response.OwnGameplayInfoR\x08yourI\
    nfo\x12U\n\x07in_game\x18\x02\x20\x03(\x0b2<.CPlayer_GetFriendsGameplayI\
    nfo_Response.FriendsGameplayInfoR\x06inGame\x12e\n\x0fplayed_recently\
    \x18\x03\x20\x03(\x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsG\
    ameplayInfoR\x0eplayedRecently\x12]\n\x0bplayed_ever\x18\x04\x20\x03(\
    \x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfoR\npla\
    yedEver\x12P\n\x04owns\x18\x05\x20\x03(\x0b2<.CPlayer_GetFriendsGameplay\
    Info_Response.FriendsGameplayInfoR\x04owns\x12]\n\x0bin_wishlist\x18\x06\
    \x20\x03(\x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayI\
    nfoR\ninWishlist\x1a\x8c\x01\n\x13FriendsGameplayInfo\x12\x18\n\x07steam\
    id\x18\x01\x20\x01(\x06R\x07steamid\x12%\n\x0eminutes_played\x18\x02\x20\
    \x01(\rR\rminutesPlayed\x124\n\x16minutes_played_forever\x18\x03\x20\x01\
    (\rR\x14minutesPlayedForever\x1a\xbf\x01\n\x0fOwnGameplayInfo\x12\x18\n\
    \x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12%\n\x0eminutes_played\
    \x18\x02\x20\x01(\rR\rminutesPlayed\x124\n\x16minutes_played_forever\x18\
    \x03\x20\x01(\rR\x14minutesPlayedForever\x12\x1f\n\x0bin_wishlist\x18\
    \x04\x20\x01(\x08R\ninWishlist\x12\x14\n\x05owned\x18\x05\x20\x01(\x08R\
    \x05owned\"\xa2\x01\n&CPlayer_GetFriendsAppsActivity_Request\x12x\n\rnew\
    s_language\x18\x01\x20\x01(\tR\x0cnewsLanguageBS\x82\xb5\x18OLanguage\
    \x20for\x20which\x20to\x20query\x20about\x20news\x20items\x20(for\x20the\
    \x20being_discussed\x20results).\"\xcc\x13\n'CPlayer_GetFriendsAppsActiv\
    ity_Response\x12\xc2\x01\n\x08trending\x18\x01\x20\x03(\x0b27.CPlayer_Ge\
    tFriendsAppsActivity_Response.AppFriendsInfoR\x08trendingBm\x82\xb5\x18i\
    Apps\x20that\x20friends\x20have\x20played\x20more\x20this\x20week\x20tha\
    n\x20last,\x20with\x20list\x20of\x20friends\x20who've\x20played\x20more\
    \x20this\x20week\x12\xc5\x01\n\x10recent_purchases\x18\x02\x20\x03(\x0b2\
    7.CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\x0frecentPurch\
    asesBa\x82\xb5\x18]Apps\x20friends\x20have\x20played\x20in\x20the\x20pas\
    t\x20two\x20weeks\x20for\x20which\x20the\x20user\x20recently\x20acquired\
    \x20a\x20license\x12\xa7\x01\n\x07unowned\x18\x03\x20\x03(\x0b27.CPlayer\
    _GetFriendsAppsActivity_Response.AppFriendsInfoR\x07unownedBT\x82\xb5\
    \x18PApps\x20friends\x20have\x20played\x20in\x20the\x20past\x20two\x20we\
    eks\x20for\x20which\x20the\x20user\x20has\x20no\x20license\x12\xb8\x01\n\
    \x07popular\x18\x04\x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_Respon\
    se.AppFriendsInfoR\x07popularBe\x82\xb5\x18aApps\x20friends\x20have\x20p\
    layed\x20in\x20the\x20past\x20two\x20weeks,\x20for\x20which\x20the\x20us\
    er\x20has\x20a\x20license,\x20sorted\x20by\x20count\x12\xd2\x01\n\x0bdon\
    t_forget\x18\x05\x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_Response.\
    AppFriendsInfoR\ndontForgetBx\x82\xb5\x18tApps\x20friends\x20have\x20pla\
    yed\x20in\x20the\x20past\x20two\x20weeks\x20which\x20the\x20user\x20has\
    \x20neither\x20purchased\x20nor\x20played\x20in\x20the\x20past\x20two\
    \x20weeks\x12\xb9\x01\n\x0fbeing_discussed\x18\x06\x20\x03(\x0b27.CPlaye\
    r_GetFriendsAppsActivity_Response.AppFriendsInfoR\x0ebeingDiscussedBW\
    \x82\xb5\x18SOwned\x20apps\x20that\x20friends\x20have\x20posted\x20statu\
    s\x20or\x20screenshots\x20for\x20in\x20the\x20past\x20two\x20weeks\x12\
    \xa0\x01\n\x0cnew_to_group\x18\x07\x20\x03(\x0b27.CPlayer_GetFriendsApps\
    Activity_Response.AppFriendsInfoR\nnewToGroupBE\x82\xb5\x18AOwned\x20app\
    s\x20that\x20none\x20of\x20your\x20friends\x20had\x20played\x20prior\x20\
    to\x202\x20weeks.\x12\xaa\x01\n\x11returned_to_group\x18\x08\x20\x03(\
    \x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\x0freturn\
    edToGroupBE\x82\xb5\x18AOwned\x20apps\x20that\x20friends\x20hadn't\x20pl\
    ayed\x20for\x20a\x20while,\x20but\x20are\x20again.\x12y\n\x13active_frie\
    nd_count\x18\t\x20\x01(\r:\x010R\x11activeFriendCountBF\x82\xb5\x18BNumb\
    er\x20of\x20friends\x20with\x20non-trivial\x20activity\x20in\x20the\x20p\
    ast\x20two\x20weeks.\x1a\xd4\x04\n\x0eFriendPlayTime\x12\x18\n\x07steami\
    d\x18\x01\x20\x01(\x06R\x07steamid\x12\x8a\x01\n\x18minutes_played_this_\
    week\x18\x02\x20\x01(\rR\x15minutesPlayedThisWeekBQ\x82\xb5\x18MMinutes\
    \x20this\x20friend\x20played\x20the\x20game\x20(from\x20the\x20enclosing\
    \x20structure)\x20this\x20week.\x12\x94\x01\n\x18minutes_played_two_week\
    s\x18\x03\x20\x01(\rR\x15minutesPlayedTwoWeeksB[\x82\xb5\x18WMinutes\x20\
    this\x20friend\x20played\x20the\x20game\x20(from\x20the\x20enclosing\x20\
    structure)\x20in\x20the\x20past\x202\x20weeks.\x12\x86\x01\n\x16minutes_\
    played_forever\x18\x04\x20\x01(\rR\x14minutesPlayedForeverBP\x82\xb5\x18\
    LMinutes\x20this\x20friend\x20played\x20the\x20game\x20(from\x20the\x20e\
    nclosing\x20structure)\x20all\x20time.\x12{\n\x0bevent_count\x18\x05\x20\
    \x01(\rR\neventCountBZ\x82\xb5\x18VNumber\x20of\x20events\x20involving\
    \x20this\x20user\x20&\x20app.\x20(Only\x20set\x20for\x20results\x20in\
    \x20being_discussed.)\x1a\xfb\x01\n\x0eAppFriendsInfo\x12\x14\n\x05appid\
    \x18\x01\x20\x01(\rR\x05appid\x12\xd2\x01\n\x07friends\x18\x02\x20\x03(\
    \x0b27.CPlayer_GetFriendsAppsActivity_Response.FriendPlayTimeR\x07friend\
    sB\x7f\x82\xb5\x18{Friends\x20(w/\x20playtime)\x20that\x20meet\x20a\x20s\
    pecific\x20criteria\x20--\x20e.g.\x20for\x20trending,\x20only\x20include\
    s\x20friends\x20w/\x20more\x20playtime\x20this\x20week.\":\n\"CPlayer_Ge\
    tGameBadgeLevels_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \"\xe6\x01\n#CPlayer_GetGameBadgeLevels_Response\x12!\n\x0cplayer_level\
    \x18\x01\x20\x01(\rR\x0bplayerLevel\x12B\n\x06badges\x18\x02\x20\x03(\
    \x0b2*.CPlayer_GetGameBadgeLevels_Response.BadgeR\x06badges\x1aX\n\x05Ba\
    dge\x12\x14\n\x05level\x18\x01\x20\x01(\x05R\x05level\x12\x16\n\x06serie\
    s\x18\x02\x20\x01(\x05R\x06series\x12!\n\x0cborder_color\x18\x03\x20\x01\
    (\rR\x0bborderColor\"!\n\x1fCPlayer_GetEmoticonList_Request\"\x8b\x02\n\
    \x20CPlayer_GetEmoticonList_Response\x12H\n\temoticons\x18\x01\x20\x03(\
    \x0b2*.CPlayer_GetEmoticonList_Response.EmoticonR\temoticons\x1a\x9c\x01\
    \n\x08Emoticon\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\
    \x05count\x18\x02\x20\x01(\x05R\x05count\x12$\n\x0etime_last_used\x18\
    \x03\x20\x01(\rR\x0ctimeLastUsed\x12\x1b\n\tuse_count\x18\x04\x20\x01(\r\
    R\x08useCount\x12#\n\rtime_received\x18\x05\x20\x01(\rR\x0ctimeReceived\
    \"\\\n#CPlayer_PostStatusToFriends_Request\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\x12\x1f\n\x0bstatus_text\x18\x02\x20\x01(\tR\nstat\
    usText\"&\n$CPlayer_PostStatusToFriends_Response\"v\n\x1fCPlayer_GetPost\
    edStatus_Request\x12;\n\x07steamid\x18\x01\x20\x01(\x04R\x07steamidB!\
    \x82\xb5\x18\x1dThe\x20player\x20we're\x20asking\x20about\x12\x16\n\x06p\
    ostid\x18\x02\x20\x01(\x04R\x06postid\"\xa9\x01\n\x20CPlayer_GetPostedSt\
    atus_Response\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\
    \x16\n\x06postid\x18\x02\x20\x01(\x04R\x06postid\x12\x1f\n\x0bstatus_tex\
    t\x18\x03\x20\x01(\tR\nstatusText\x12\x18\n\x07deleted\x18\x04\x20\x01(\
    \x08R\x07deleted\x12\x14\n\x05appid\x18\x05\x20\x01(\rR\x05appid\"<\n\"C\
    Player_DeletePostedStatus_Request\x12\x16\n\x06postid\x18\x01\x20\x01(\
    \x04R\x06postid\"%\n#CPlayer_DeletePostedStatus_Response\"\x91\x01\n\"CP\
    layer_GetLastPlayedTimes_Request\x12k\n\x0fmin_last_played\x18\x01\x20\
    \x01(\rR\rminLastPlayedBC\x82\xb5\x18?The\x20most\x20recent\x20last-play\
    ed\x20time\x20the\x20client\x20already\x20knows\x20about\"\xed\x05\n#CPl\
    ayer_GetLastPlayedTimes_Response\x12?\n\x05games\x18\x01\x20\x03(\x0b2).\
    CPlayer_GetLastPlayedTimes_Response.GameR\x05games\x1a\x84\x05\n\x04Game\
    \x12\x14\n\x05appid\x18\x01\x20\x01(\x05R\x05appid\x12#\n\rlast_playtime\
    \x18\x02\x20\x01(\rR\x0clastPlaytime\x12'\n\x0fplaytime_2weeks\x18\x03\
    \x20\x01(\x05R\x0eplaytime2weeks\x12)\n\x10playtime_forever\x18\x04\x20\
    \x01(\x05R\x0fplaytimeForever\x12%\n\x0efirst_playtime\x18\x05\x20\x01(\
    \rR\rfirstPlaytime\x128\n\x18playtime_windows_forever\x18\x06\x20\x01(\
    \x05R\x16playtimeWindowsForever\x120\n\x14playtime_mac_forever\x18\x07\
    \x20\x01(\x05R\x12playtimeMacForever\x124\n\x16playtime_linux_forever\
    \x18\x08\x20\x01(\x05R\x14playtimeLinuxForever\x124\n\x16first_windows_p\
    laytime\x18\t\x20\x01(\rR\x14firstWindowsPlaytime\x12,\n\x12first_mac_pl\
    aytime\x18\n\x20\x01(\rR\x10firstMacPlaytime\x120\n\x14first_linux_playt\
    ime\x18\x0b\x20\x01(\rR\x12firstLinuxPlaytime\x122\n\x15last_windows_pla\
    ytime\x18\x0c\x20\x01(\rR\x13lastWindowsPlaytime\x12*\n\x11last_mac_play\
    time\x18\r\x20\x01(\rR\x0flastMacPlaytime\x12.\n\x13last_linux_playtime\
    \x18\x0e\x20\x01(\rR\x11lastLinuxPlaytime\"\x1b\n\x19CPlayer_AcceptSSA_R\
    equest\"\x1c\n\x1aCPlayer_AcceptSSA_Response\"!\n\x1fCPlayer_GetNickname\
    List_Request\"\xbe\x01\n\x20CPlayer_GetNicknameList_Response\x12N\n\tnic\
    knames\x18\x01\x20\x03(\x0b20.CPlayer_GetNicknameList_Response.PlayerNic\
    knameR\tnicknames\x1aJ\n\x0ePlayerNickname\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\x07R\taccountid\x12\x1a\n\x08nickname\x18\x02\x20\x01(\tR\x08n\
    ickname\")\n'CPlayer_GetPerFriendPreferences_Request\"\x84\x07\n\x14PerF\
    riendPreferences\x12\x1c\n\taccountid\x18\x01\x20\x01(\x07R\taccountid\
    \x12\x1a\n\x08nickname\x18\x02\x20\x01(\tR\x08nickname\x12x\n\x18notific\
    ations_showingame\x18\x03\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENot\
    ificationSettingNotifyUseDefaultR\x17notificationsShowingame\x12x\n\x18n\
    otifications_showonline\x18\x04\x20\x01(\x0e2\x15.ENotificationSetting:&\
    k_ENotificationSettingNotifyUseDefaultR\x17notificationsShowonline\x12|\
    \n\x1anotifications_showmessages\x18\x05\x20\x01(\x0e2\x15.ENotification\
    Setting:&k_ENotificationSettingNotifyUseDefaultR\x19notificationsShowmes\
    sages\x12j\n\x11sounds_showingame\x18\x06\x20\x01(\x0e2\x15.ENotificatio\
    nSetting:&k_ENotificationSettingNotifyUseDefaultR\x10soundsShowingame\
    \x12j\n\x11sounds_showonline\x18\x07\x20\x01(\x0e2\x15.ENotificationSett\
    ing:&k_ENotificationSettingNotifyUseDefaultR\x10soundsShowonline\x12n\n\
    \x13sounds_showmessages\x18\x08\x20\x01(\x0e2\x15.ENotificationSetting:&\
    k_ENotificationSettingNotifyUseDefaultR\x12soundsShowmessages\x12x\n\x18\
    notifications_sendmobile\x18\t\x20\x01(\x0e2\x15.ENotificationSetting:&k\
    _ENotificationSettingNotifyUseDefaultR\x17notificationsSendmobile\"c\n(C\
    Player_GetPerFriendPreferences_Response\x127\n\x0bpreferences\x18\x01\
    \x20\x03(\x0b2\x15.PerFriendPreferencesR\x0bpreferences\"b\n'CPlayer_Set\
    PerFriendPreferences_Request\x127\n\x0bpreferences\x18\x01\x20\x01(\x0b2\
    \x15.PerFriendPreferencesR\x0bpreferences\"*\n(CPlayer_SetPerFriendPrefe\
    rences_Response\"l\n\x19CPlayer_AddFriend_Request\x12O\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamidB5\x82\xb5\x181Steam\x20ID\x20of\x20user\
    \x20to\x20whom\x20to\x20send\x20a\x20friend\x20invite.\"\x96\x02\n\x1aCP\
    layer_AddFriend_Response\x12[\n\x0binvite_sent\x18\x01\x20\x01(\x08R\nin\
    viteSentB:\x82\xb5\x186True\x20if\x20the\x20operation\x20was\x20successf\
    ul,\x20false\x20otherwise.\x12\x9a\x01\n\x13friend_relationship\x18\x02\
    \x20\x01(\rR\x12friendRelationshipBi\x82\xb5\x18ethe\x20resulting\x20rel\
    ationship.\x20\x20Depending\x20on\x20state,\x20may\x20move\x20directly\
    \x20to\x20friends\x20rather\x20than\x20invite\x20sent\"[\n\x1cCPlayer_Re\
    moveFriend_Request\x12;\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamidB!\
    \x82\xb5\x18\x1dSteam\x20ID\x20of\x20friend\x20to\x20remove.\"p\n\x1dCPl\
    ayer_RemoveFriend_Response\x12O\n\x13friend_relationship\x18\x01\x20\x01\
    (\rR\x12friendRelationshipB\x1e\x82\xb5\x18\x1athe\x20resulting\x20relat\
    ionship\"\x92\x01\n\x1cCPlayer_IgnoreFriend_Request\x12\x18\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamid\x12X\n\x08unignore\x18\x02\x20\x01(\
    \x08R\x08unignoreB<\x82\xb5\x188If\x20set,\x20remove\x20from\x20ignore/b\
    lock\x20list\x20instead\x20of\x20adding\x20\"p\n\x1dCPlayer_IgnoreFriend\
    _Response\x12O\n\x13friend_relationship\x18\x01\x20\x01(\rR\x12friendRel\
    ationshipB\x1e\x82\xb5\x18\x1athe\x20resulting\x20relationship\")\n'CPla\
    yer_GetCommunityPreferences_Request\"\x89\x02\n\x1cCPlayer_CommunityPref\
    erences\x12C\n\x1bhide_adult_content_violence\x18\x01\x20\x01(\x08:\x04t\
    rueR\x18hideAdultContentViolence\x129\n\x16hide_adult_content_sex\x18\
    \x02\x20\x01(\x08:\x04trueR\x13hideAdultContentSex\x12<\n\x16parenthesiz\
    e_nicknames\x18\x04\x20\x01(\x08:\x05falseR\x15parenthesizeNicknames\x12\
    +\n\x11timestamp_updated\x18\x03\x20\x01(\rR\x10timestampUpdated\"k\n(CP\
    layer_GetCommunityPreferences_Response\x12?\n\x0bpreferences\x18\x01\x20\
    \x01(\x0b2\x1d.CPlayer_CommunityPreferencesR\x0bpreferences\"j\n'CPlayer\
    _SetCommunityPreferences_Request\x12?\n\x0bpreferences\x18\x01\x20\x01(\
    \x0b2\x1d.CPlayer_CommunityPreferencesR\x0bpreferences\"*\n(CPlayer_SetC\
    ommunityPreferences_Response\"J\n,CPlayer_GetNewSteamAnnouncementState_R\
    equest\x12\x1a\n\x08language\x18\x01\x20\x01(\x05R\x08language\"\xf1\x01\
    \n-CPlayer_GetNewSteamAnnouncementState_Response\x12\x14\n\x05state\x18\
    \x01\x20\x01(\x05R\x05state\x123\n\x15announcement_headline\x18\x02\x20\
    \x01(\tR\x14announcementHeadline\x12)\n\x10announcement_url\x18\x03\x20\
    \x01(\tR\x0fannouncementUrl\x12\x1f\n\x0btime_posted\x18\x04\x20\x01(\rR\
    \ntimePosted\x12)\n\x10announcement_gid\x18\x05\x20\x01(\x04R\x0fannounc\
    ementGid\"}\n/CPlayer_UpdateSteamAnnouncementLastRead_Request\x12)\n\x10\
    announcement_gid\x18\x01\x20\x01(\x04R\x0fannouncementGid\x12\x1f\n\x0bt\
    ime_posted\x18\x02\x20\x01(\rR\ntimePosted\"2\n0CPlayer_UpdateSteamAnnou\
    ncementLastRead_Response\"$\n\"CPlayer_GetPrivacySettings_Request\"\xcb\
    \x02\n\x10CPrivacySettings\x12#\n\rprivacy_state\x18\x01\x20\x01(\x05R\
    \x0cprivacyState\x126\n\x17privacy_state_inventory\x18\x02\x20\x01(\x05R\
    \x15privacyStateInventory\x12.\n\x13privacy_state_gifts\x18\x03\x20\x01(\
    \x05R\x11privacyStateGifts\x128\n\x18privacy_state_ownedgames\x18\x04\
    \x20\x01(\x05R\x16privacyStateOwnedgames\x124\n\x16privacy_state_playtim\
    e\x18\x05\x20\x01(\x05R\x14privacyStatePlaytime\x12:\n\x19privacy_state_\
    friendslist\x18\x06\x20\x01(\x05R\x17privacyStateFriendslist\"c\n#CPlaye\
    r_GetPrivacySettings_Response\x12<\n\x10privacy_settings\x18\x01\x20\x01\
    (\x0b2\x11.CPrivacySettingsR\x0fprivacySettings\":\n\"CPlayer_GetDuratio\
    nControl_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\x83\
    \x01\n#CPlayer_GetDurationControl_Response\x12\x1d\n\nis_enabled\x18\x01\
    \x20\x01(\x08R\tisEnabled\x12\x18\n\x07seconds\x18\x02\x20\x01(\x05R\x07\
    seconds\x12#\n\rseconds_today\x18\x03\x20\x01(\x05R\x0csecondsToday\"g\n\
    $CPlayer_LastPlayedTimes_Notification\x12?\n\x05games\x18\x01\x20\x03(\
    \x0b2).CPlayer_GetLastPlayedTimes_Response.GameR\x05games\"\x8d\x01\n*CP\
    layer_FriendNicknameChanged_Notification\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\x07R\taccountid\x12\x1a\n\x08nickname\x18\x02\x20\x01(\tR\x08n\
    ickname\x12%\n\x0fis_echo_to_self\x18\x03\x20\x01(\x08R\x0cisEchoToSelf\
    \"\xf2\x01\n.CPlayer_NewSteamAnnouncementState_Notification\x12\x14\n\
    \x05state\x18\x01\x20\x01(\x05R\x05state\x123\n\x15announcement_headline\
    \x18\x02\x20\x01(\tR\x14announcementHeadline\x12)\n\x10announcement_url\
    \x18\x03\x20\x01(\tR\x0fannouncementUrl\x12\x1f\n\x0btime_posted\x18\x04\
    \x20\x01(\rR\ntimePosted\x12)\n\x10announcement_gid\x18\x05\x20\x01(\x04\
    R\x0fannouncementGid\"s\n0CPlayer_CommunityPreferencesChanged_Notificati\
    on\x12?\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x1d.CPlayer_CommunityPref\
    erencesR\x0bpreferences\"\x89\x01\n0CPlayer_PerFriendPreferencesChanged_\
    Notification\x12\x1c\n\taccountid\x18\x01\x20\x01(\x07R\taccountid\x127\
    \n\x0bpreferences\x18\x02\x20\x01(\x0b2\x15.PerFriendPreferencesR\x0bpre\
    ferences\"k\n+CPlayer_PrivacySettingsChanged_Notification\x12<\n\x10priv\
    acy_settings\x18\x01\x20\x01(\x0b2\x11.CPrivacySettingsR\x0fprivacySetti\
    ngs*\x85\x01\n\x14ENotificationSetting\x12*\n&k_ENotificationSettingNoti\
    fyUseDefault\x10\0\x12\x20\n\x1ck_ENotificationSettingAlways\x10\x01\x12\
    \x1f\n\x1bk_ENotificationSettingNever\x10\x022\xb8\x1c\n\x06Player\x12\
    \xef\x01\n\"GetMutualFriendsForIncomingInvites\x123.CPlayer_GetMutualFri\
    endsForIncomingInvites_Request\x1a4.CPlayer_GetMutualFriendsForIncomingI\
    nvites_Response\"^\x82\xb5\x18ZGet\x20me\x20the\x20mutual\x20friends\x20\
    for\x20each\x20of\x20my\x20pending\x20incoming\x20invites\x20(individual\
    s\x20and\x20clans).\x12\xb8\x01\n\x16GetFriendsGameplayInfo\x12'.CPlayer\
    _GetFriendsGameplayInfo_Request\x1a(.CPlayer_GetFriendsGameplayInfo_Resp\
    onse\"K\x82\xb5\x18GGet\x20a\x20list\x20of\x20friends\x20who\x20are\x20p\
    laying,\x20have\x20played,\x20own,\x20or\x20want\x20a\x20game\x12\xae\
    \x01\n\x16GetFriendsAppsActivity\x12'.CPlayer_GetFriendsAppsActivity_Req\
    uest\x1a(.CPlayer_GetFriendsAppsActivity_Response\"A\x82\xb5\x18=Get\x20\
    lists\x20of\x20apps\x20friends\x20are\x20active\x20in,\x20in\x20a\x20var\
    iety\x20of\x20ways\x12\xb6\x01\n\x12GetGameBadgeLevels\x12#.CPlayer_GetG\
    ameBadgeLevels_Request\x1a$.CPlayer_GetGameBadgeLevels_Response\"U\x82\
    \xb5\x18QReturns\x20the\x20Steam\x20Level\x20of\x20a\x20user,\x20the\x20\
    Badge\x20level\x20for\x20the\x20game,\x20and\x20if\x20it's\x20foil\x12\
    \x91\x01\n\x0fGetEmoticonList\x12\x20.CPlayer_GetEmoticonList_Request\
    \x1a!.CPlayer_GetEmoticonList_Response\"9\x82\xb5\x185Gets\x20a\x20list\
    \x20of\x20the\x20emoticons\x20a\x20user\x20has\x20with\x20metadata\x12\
    \x91\x01\n\x13PostStatusToFriends\x12$.CPlayer_PostStatusToFriends_Reque\
    st\x1a%.CPlayer_PostStatusToFriends_Response\"-\x82\xb5\x18)Posts\x20cus\
    tom\x20status\x20text\x20into\x20the\x20blotter\x12\x86\x01\n\x0fGetPost\
    edStatus\x12\x20.CPlayer_GetPostedStatus_Request\x1a!.CPlayer_GetPostedS\
    tatus_Response\".\x82\xb5\x18*Gets\x20a\x20posted\x20status\x20text\x20f\
    or\x20a\x20user\x20by\x20id\x12\x92\x01\n\x12DeletePostedStatus\x12#.CPl\
    ayer_DeletePostedStatus_Request\x1a$.CPlayer_DeletePostedStatus_Response\
    \"1\x82\xb5\x18-Deletes\x20a\x20posted\x20status\x20text\x20for\x20a\x20\
    user\x20by\x20id\x12\x95\x01\n\x18ClientGetLastPlayedTimes\x12#.CPlayer_\
    GetLastPlayedTimes_Request\x1a$.CPlayer_GetLastPlayedTimes_Response\".\
    \x82\xb5\x18*Gets\x20the\x20last-played\x20times\x20for\x20the\x20accoun\
    t\x12c\n\tAcceptSSA\x12\x1a.CPlayer_AcceptSSA_Request\x1a\x1b.CPlayer_Ac\
    ceptSSA_Response\"\x1d\x82\xb5\x18\x19User\x20is\x20accepting\x20the\x20\
    SSA\x12\x94\x01\n\x0fGetNicknameList\x12\x20.CPlayer_GetNicknameList_Req\
    uest\x1a!.CPlayer_GetNicknameList_Response\"<\x82\xb5\x188Gets\x20the\
    \x20list\x20of\x20nicknames\x20this\x20user\x20has\x20for\x20other\x20us\
    ers\x12\xbd\x01\n\x17GetPerFriendPreferences\x12(.CPlayer_GetPerFriendPr\
    eferences_Request\x1a).CPlayer_GetPerFriendPreferences_Response\"M\x82\
    \xb5\x18IGets\x20the\x20list\x20of\x20per-friend\x20preferences\x20this\
    \x20user\x20has\x20set\x20for\x20other\x20users\x12\xb7\x01\n\x17SetPerF\
    riendPreferences\x12(.CPlayer_SetPerFriendPreferences_Request\x1a).CPlay\
    er_SetPerFriendPreferences_Response\"G\x82\xb5\x18CSets\x20the\x20logged\
    \x20in\x20user's\x20per-friend\x20preferences\x20for\x20the\x20given\x20\
    user\x12s\n\tAddFriend\x12\x1a.CPlayer_AddFriend_Request\x1a\x1b.CPlayer\
    _AddFriend_Response\"-\x82\xb5\x18)Invites\x20another\x20Steam\x20user\
    \x20to\x20be\x20a\x20friend\x12\x82\x01\n\x0cRemoveFriend\x12\x1d.CPlaye\
    r_RemoveFriend_Request\x1a\x1e.CPlayer_RemoveFriend_Response\"3\x82\xb5\
    \x18/Removes\x20a\x20friend\x20or\x20ignores\x20a\x20friend\x20suggestio\
    n\x12\xa6\x01\n\x0cIgnoreFriend\x12\x1d.CPlayer_IgnoreFriend_Request\x1a\
    \x1e.CPlayer_IgnoreFriend_Response\"W\x82\xb5\x18SBlocks\x20or\x20unbloc\
    ks\x20communication\x20with\x20the\x20user.\x20\x20Despite\x20name,\x20c\
    an\x20be\x20a\x20non-friend.\x12\x9e\x01\n\x17GetCommunityPreferences\
    \x12(.CPlayer_GetCommunityPreferences_Request\x1a).CPlayer_GetCommunityP\
    references_Response\".\x82\xb5\x18*Returns\x20the\x20player's\x20communi\
    ty\x20preferences\x12\x9b\x01\n\x17SetCommunityPreferences\x12(.CPlayer_\
    SetCommunityPreferences_Request\x1a).CPlayer_SetCommunityPreferences_Res\
    ponse\"+\x82\xb5\x18'Sets\x20the\x20player's\x20community\x20preferences\
    \x12\xde\x01\n\x1cGetNewSteamAnnouncementState\x12-.CPlayer_GetNewSteamA\
    nnouncementState_Request\x1a..CPlayer_GetNewSteamAnnouncementState_Respo\
    nse\"_\x82\xb5\x18[Calculates\x20and\x20returns\x20what\x20to\x20display\
    \x20for\x20UI\x20that\x20renders\x20new\x20steam\x20announcement\x20avai\
    lable\x12\xbc\x01\n\x1fUpdateSteamAnnouncementLastRead\x120.CPlayer_Upda\
    teSteamAnnouncementLastRead_Request\x1a1.CPlayer_UpdateSteamAnnouncement\
    LastRead_Response\"4\x82\xb5\x180Marks\x20latest\x20announcement\x20time\
    stamp\x20read\x20by\x20user\x12\x82\x01\n\x12GetPrivacySettings\x12#.CPl\
    ayer_GetPrivacySettings_Request\x1a$.CPlayer_GetPrivacySettings_Response\
    \"!\x82\xb5\x18\x1dGet\x20current\x20privacy\x20settings.\x12\x8c\x01\n\
    \x12GetDurationControl\x12#.CPlayer_GetDurationControl_Request\x1a$.CPla\
    yer_GetDurationControl_Response\"+\x82\xb5\x18'Get\x20gameplay\x20durati\
    on\x20control\x20settings.\x1a-\x82\xb5\x18)A\x20service\x20for\x20acces\
    sing\x20Steam\x20player\x20data2\xa3\x08\n\x0cPlayerClient\x12\x8c\x01\n\
    \x15NotifyLastPlayedTimes\x12%.CPlayer_LastPlayedTimes_Notification\x1a\
    \x0b.NoResponse\"?\x82\xb5\x18;Notification\x20from\x20server\x20to\x20c\
    lient\x20of\x20more\x20recent\x20play\x20time\x12\xa4\x01\n\x1bNotifyFri\
    endNicknameChanged\x12+.CPlayer_FriendNicknameChanged_Notification\x1a\
    \x0b.NoResponse\"K\x82\xb5\x18GNotification\x20from\x20server\x20to\x20c\
    lient\x20that\x20a\x20friend's\x20nickname\x20has\x20changed\x12\xa4\x01\
    \n\x1fNotifyNewSteamAnnouncementState\x12/.CPlayer_NewSteamAnnouncementS\
    tate_Notification\x1a\x0b.NoResponse\"C\x82\xb5\x18?Notifies\x20client\
    \x20of\x20changes\x20to\x20steam\x20announcement\x20state\x20for\x20user\
    \x12\xb9\x01\n!NotifyCommunityPreferencesChanged\x121.CPlayer_CommunityP\
    referencesChanged_Notification\x1a\x0b.NoResponse\"T\x82\xb5\x18PNotific\
    ation\x20from\x20server\x20to\x20client\x20that\x20their\x20community\
    \x20preferences\x20have\x20changed\x12\xaa\x01\n!NotifyPerFriendPreferen\
    cesChanged\x121.CPlayer_PerFriendPreferencesChanged_Notification\x1a\x0b\
    .NoResponse\"E\x82\xb5\x18ANotification\x20from\x20server\x20that\x20per\
    -friend\x20preferences\x20have\x20changed\x12\x9c\x01\n#NotifyPrivacyPri\
    vacySettingsChanged\x12,.CPlayer_PrivacySettingsChanged_Notification\x1a\
    \x0b.NoResponse\":\x82\xb5\x186Notification\x20from\x20server\x20that\
    \x20privacy\x20settings\x20changed\x1a.\x82\xb5\x18&Steam\x20player\x20d\
    ata\x20client\x20notifications\xc0\xb5\x18\x02B\x03\x80\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
