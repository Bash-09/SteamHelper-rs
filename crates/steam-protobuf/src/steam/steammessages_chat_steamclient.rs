// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_chat.steamclient.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChat_RequestFriendPersonaStates_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Request {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Request {
        <CChat_RequestFriendPersonaStates_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Request {
    pub fn new() -> CChat_RequestFriendPersonaStates_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChat_RequestFriendPersonaStates_Request {
        CChat_RequestFriendPersonaStates_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChat_RequestFriendPersonaStates_Request>(
                    "CChat_RequestFriendPersonaStates_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChat_RequestFriendPersonaStates_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChat_RequestFriendPersonaStates_Request,
        };
        unsafe {
            instance.get(CChat_RequestFriendPersonaStates_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChat_RequestFriendPersonaStates_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChat_RequestFriendPersonaStates_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChat_RequestFriendPersonaStates_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Response {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Response {
        <CChat_RequestFriendPersonaStates_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Response {
    pub fn new() -> CChat_RequestFriendPersonaStates_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChat_RequestFriendPersonaStates_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChat_RequestFriendPersonaStates_Response {
        CChat_RequestFriendPersonaStates_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChat_RequestFriendPersonaStates_Response>(
                    "CChat_RequestFriendPersonaStates_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChat_RequestFriendPersonaStates_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChat_RequestFriendPersonaStates_Response,
        };
        unsafe {
            instance.get(CChat_RequestFriendPersonaStates_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChat_RequestFriendPersonaStates_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChat_RequestFriendPersonaStates_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateChatRoomGroup_Request {
    // message fields
    steamid_partner: ::std::option::Option<u64>,
    steamid_invited: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    steamid_invitees: ::std::vec::Vec<u64>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Request {
        <CChatRoom_CreateChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Request {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_partner = 1;


    pub fn get_steamid_partner(&self) -> u64 {
        self.steamid_partner.unwrap_or(0)
    }
    pub fn clear_steamid_partner(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
    }

    pub fn has_steamid_partner(&self) -> bool {
        self.steamid_partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_partner(&mut self, v: u64) {
        self.steamid_partner = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_invited = 2;


    pub fn get_steamid_invited(&self) -> u64 {
        self.steamid_invited.unwrap_or(0)
    }
    pub fn clear_steamid_invited(&mut self) {
        self.steamid_invited = ::std::option::Option::None;
    }

    pub fn has_steamid_invited(&self) -> bool {
        self.steamid_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invited(&mut self, v: u64) {
        self.steamid_invited = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed64 steamid_invitees = 4;


    pub fn get_steamid_invitees(&self) -> &[u64] {
        &self.steamid_invitees
    }
    pub fn clear_steamid_invitees(&mut self) {
        self.steamid_invitees.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitees(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_invitees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_invitees(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_invitees
    }

    // Take field
    pub fn take_steamid_invitees(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_invitees, ::std::vec::Vec::new())
    }

    // optional uint32 watching_broadcast_accountid = 6;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 7;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_partner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_invited = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_invitees)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_partner {
            my_size += 9;
        }
        if let Some(v) = self.steamid_invited {
            my_size += 9;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += 9 * self.steamid_invitees.len() as u32;
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_partner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steamid_invited {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.steamid_invitees {
            os.write_fixed64(4, *v)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        CChatRoom_CreateChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_partner",
                    |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_partner },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_partner },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_invited",
                    |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invited },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invited },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.name },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_invitees",
                    |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invitees },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invitees },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "watching_broadcast_accountid",
                    |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_accountid },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "watching_broadcast_channel_id",
                    |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_channel_id },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_channel_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateChatRoomGroup_Request>(
                    "CChatRoom_CreateChatRoomGroup_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateChatRoomGroup_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateChatRoomGroup_Request,
        };
        unsafe {
            instance.get(CChatRoom_CreateChatRoomGroup_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoomGroup_Request {
    fn clear(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
        self.steamid_invited = ::std::option::Option::None;
        self.name.clear();
        self.steamid_invitees.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRole {
    // message fields
    role_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRole {
    fn default() -> &'a CChatRole {
        <CChatRole as ::protobuf::Message>::default_instance()
    }
}

impl CChatRole {
    pub fn new() -> CChatRole {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 3;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRole {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRole {
        CChatRole::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRole| { &m.role_id },
                    |m: &mut CChatRole| { &mut m.role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRole| { &m.name },
                    |m: &mut CChatRole| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ordinal",
                    |m: &CChatRole| { &m.ordinal },
                    |m: &mut CChatRole| { &mut m.ordinal },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRole>(
                    "CChatRole",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRole {
        static mut instance: ::protobuf::lazy::Lazy<CChatRole> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRole,
        };
        unsafe {
            instance.get(CChatRole::new)
        }
    }
}

impl ::protobuf::Clear for CChatRole {
    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.name.clear();
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRole {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoleActions {
    // message fields
    role_id: ::std::option::Option<u64>,
    can_create_rename_delete_channel: ::std::option::Option<bool>,
    can_kick: ::std::option::Option<bool>,
    can_ban: ::std::option::Option<bool>,
    can_invite: ::std::option::Option<bool>,
    can_change_tagline_avatar_name: ::std::option::Option<bool>,
    can_chat: ::std::option::Option<bool>,
    can_view_history: ::std::option::Option<bool>,
    can_change_group_roles: ::std::option::Option<bool>,
    can_change_user_roles: ::std::option::Option<bool>,
    can_mention_all: ::std::option::Option<bool>,
    can_set_watching_broadcast: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoleActions {
    fn default() -> &'a CChatRoleActions {
        <CChatRoleActions as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoleActions {
    pub fn new() -> CChatRoleActions {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional bool can_create_rename_delete_channel = 2;


    pub fn get_can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.unwrap_or(false)
    }
    pub fn clear_can_create_rename_delete_channel(&mut self) {
        self.can_create_rename_delete_channel = ::std::option::Option::None;
    }

    pub fn has_can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_create_rename_delete_channel(&mut self, v: bool) {
        self.can_create_rename_delete_channel = ::std::option::Option::Some(v);
    }

    // optional bool can_kick = 3;


    pub fn get_can_kick(&self) -> bool {
        self.can_kick.unwrap_or(false)
    }
    pub fn clear_can_kick(&mut self) {
        self.can_kick = ::std::option::Option::None;
    }

    pub fn has_can_kick(&self) -> bool {
        self.can_kick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_kick(&mut self, v: bool) {
        self.can_kick = ::std::option::Option::Some(v);
    }

    // optional bool can_ban = 4;


    pub fn get_can_ban(&self) -> bool {
        self.can_ban.unwrap_or(false)
    }
    pub fn clear_can_ban(&mut self) {
        self.can_ban = ::std::option::Option::None;
    }

    pub fn has_can_ban(&self) -> bool {
        self.can_ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_ban(&mut self, v: bool) {
        self.can_ban = ::std::option::Option::Some(v);
    }

    // optional bool can_invite = 5;


    pub fn get_can_invite(&self) -> bool {
        self.can_invite.unwrap_or(false)
    }
    pub fn clear_can_invite(&mut self) {
        self.can_invite = ::std::option::Option::None;
    }

    pub fn has_can_invite(&self) -> bool {
        self.can_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_invite(&mut self, v: bool) {
        self.can_invite = ::std::option::Option::Some(v);
    }

    // optional bool can_change_tagline_avatar_name = 6;


    pub fn get_can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.unwrap_or(false)
    }
    pub fn clear_can_change_tagline_avatar_name(&mut self) {
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
    }

    pub fn has_can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_tagline_avatar_name(&mut self, v: bool) {
        self.can_change_tagline_avatar_name = ::std::option::Option::Some(v);
    }

    // optional bool can_chat = 7;


    pub fn get_can_chat(&self) -> bool {
        self.can_chat.unwrap_or(false)
    }
    pub fn clear_can_chat(&mut self) {
        self.can_chat = ::std::option::Option::None;
    }

    pub fn has_can_chat(&self) -> bool {
        self.can_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_chat(&mut self, v: bool) {
        self.can_chat = ::std::option::Option::Some(v);
    }

    // optional bool can_view_history = 8;


    pub fn get_can_view_history(&self) -> bool {
        self.can_view_history.unwrap_or(false)
    }
    pub fn clear_can_view_history(&mut self) {
        self.can_view_history = ::std::option::Option::None;
    }

    pub fn has_can_view_history(&self) -> bool {
        self.can_view_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_view_history(&mut self, v: bool) {
        self.can_view_history = ::std::option::Option::Some(v);
    }

    // optional bool can_change_group_roles = 9;


    pub fn get_can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.unwrap_or(false)
    }
    pub fn clear_can_change_group_roles(&mut self) {
        self.can_change_group_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_group_roles(&mut self, v: bool) {
        self.can_change_group_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_change_user_roles = 10;


    pub fn get_can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.unwrap_or(false)
    }
    pub fn clear_can_change_user_roles(&mut self) {
        self.can_change_user_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_user_roles(&mut self, v: bool) {
        self.can_change_user_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_mention_all = 11;


    pub fn get_can_mention_all(&self) -> bool {
        self.can_mention_all.unwrap_or(false)
    }
    pub fn clear_can_mention_all(&mut self) {
        self.can_mention_all = ::std::option::Option::None;
    }

    pub fn has_can_mention_all(&self) -> bool {
        self.can_mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_mention_all(&mut self, v: bool) {
        self.can_mention_all = ::std::option::Option::Some(v);
    }

    // optional bool can_set_watching_broadcast = 12;


    pub fn get_can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.unwrap_or(false)
    }
    pub fn clear_can_set_watching_broadcast(&mut self) {
        self.can_set_watching_broadcast = ::std::option::Option::None;
    }

    pub fn has_can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_set_watching_broadcast(&mut self, v: bool) {
        self.can_set_watching_broadcast = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoleActions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_create_rename_delete_channel = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_kick = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_ban = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_invite = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_change_tagline_avatar_name = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_chat = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_view_history = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_change_group_roles = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_change_user_roles = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_mention_all = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_set_watching_broadcast = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            my_size += 2;
        }
        if let Some(v) = self.can_kick {
            my_size += 2;
        }
        if let Some(v) = self.can_ban {
            my_size += 2;
        }
        if let Some(v) = self.can_invite {
            my_size += 2;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            my_size += 2;
        }
        if let Some(v) = self.can_chat {
            my_size += 2;
        }
        if let Some(v) = self.can_view_history {
            my_size += 2;
        }
        if let Some(v) = self.can_change_group_roles {
            my_size += 2;
        }
        if let Some(v) = self.can_change_user_roles {
            my_size += 2;
        }
        if let Some(v) = self.can_mention_all {
            my_size += 2;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.can_kick {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.can_ban {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_invite {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.can_chat {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.can_view_history {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.can_change_group_roles {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.can_change_user_roles {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.can_mention_all {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoleActions {
        CChatRoleActions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoleActions| { &m.role_id },
                    |m: &mut CChatRoleActions| { &mut m.role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_create_rename_delete_channel",
                    |m: &CChatRoleActions| { &m.can_create_rename_delete_channel },
                    |m: &mut CChatRoleActions| { &mut m.can_create_rename_delete_channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_kick",
                    |m: &CChatRoleActions| { &m.can_kick },
                    |m: &mut CChatRoleActions| { &mut m.can_kick },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_ban",
                    |m: &CChatRoleActions| { &m.can_ban },
                    |m: &mut CChatRoleActions| { &mut m.can_ban },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_invite",
                    |m: &CChatRoleActions| { &m.can_invite },
                    |m: &mut CChatRoleActions| { &mut m.can_invite },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_change_tagline_avatar_name",
                    |m: &CChatRoleActions| { &m.can_change_tagline_avatar_name },
                    |m: &mut CChatRoleActions| { &mut m.can_change_tagline_avatar_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_chat",
                    |m: &CChatRoleActions| { &m.can_chat },
                    |m: &mut CChatRoleActions| { &mut m.can_chat },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_view_history",
                    |m: &CChatRoleActions| { &m.can_view_history },
                    |m: &mut CChatRoleActions| { &mut m.can_view_history },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_change_group_roles",
                    |m: &CChatRoleActions| { &m.can_change_group_roles },
                    |m: &mut CChatRoleActions| { &mut m.can_change_group_roles },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_change_user_roles",
                    |m: &CChatRoleActions| { &m.can_change_user_roles },
                    |m: &mut CChatRoleActions| { &mut m.can_change_user_roles },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_mention_all",
                    |m: &CChatRoleActions| { &m.can_mention_all },
                    |m: &mut CChatRoleActions| { &mut m.can_mention_all },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_set_watching_broadcast",
                    |m: &CChatRoleActions| { &m.can_set_watching_broadcast },
                    |m: &mut CChatRoleActions| { &mut m.can_set_watching_broadcast },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoleActions>(
                    "CChatRoleActions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoleActions {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoleActions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoleActions,
        };
        unsafe {
            instance.get(CChatRoleActions::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoleActions {
    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.can_create_rename_delete_channel = ::std::option::Option::None;
        self.can_kick = ::std::option::Option::None;
        self.can_ban = ::std::option::Option::None;
        self.can_invite = ::std::option::Option::None;
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
        self.can_chat = ::std::option::Option::None;
        self.can_view_history = ::std::option::Option::None;
        self.can_change_group_roles = ::std::option::Option::None;
        self.can_change_user_roles = ::std::option::Option::None;
        self.can_mention_all = ::std::option::Option::None;
        self.can_set_watching_broadcast = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoleActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoleActions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatPartyBeacon {
    // message fields
    app_id: ::std::option::Option<u32>,
    steamid_owner: ::std::option::Option<u64>,
    beacon_id: ::std::option::Option<u64>,
    game_metadata: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatPartyBeacon {
    fn default() -> &'a CChatPartyBeacon {
        <CChatPartyBeacon as ::protobuf::Message>::default_instance()
    }
}

impl CChatPartyBeacon {
    pub fn new() -> CChatPartyBeacon {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_owner = 2;


    pub fn get_steamid_owner(&self) -> u64 {
        self.steamid_owner.unwrap_or(0)
    }
    pub fn clear_steamid_owner(&mut self) {
        self.steamid_owner = ::std::option::Option::None;
    }

    pub fn has_steamid_owner(&self) -> bool {
        self.steamid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_owner(&mut self, v: u64) {
        self.steamid_owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 beacon_id = 3;


    pub fn get_beacon_id(&self) -> u64 {
        self.beacon_id.unwrap_or(0)
    }
    pub fn clear_beacon_id(&mut self) {
        self.beacon_id = ::std::option::Option::None;
    }

    pub fn has_beacon_id(&self) -> bool {
        self.beacon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_id(&mut self, v: u64) {
        self.beacon_id = ::std::option::Option::Some(v);
    }

    // optional string game_metadata = 4;


    pub fn get_game_metadata(&self) -> &str {
        match self.game_metadata.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_metadata(&mut self) {
        self.game_metadata.clear();
    }

    pub fn has_game_metadata(&self) -> bool {
        self.game_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_metadata(&mut self, v: ::std::string::String) {
        self.game_metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_metadata(&mut self) -> &mut ::std::string::String {
        if self.game_metadata.is_none() {
            self.game_metadata.set_default();
        }
        self.game_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_metadata(&mut self) -> ::std::string::String {
        self.game_metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatPartyBeacon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_owner = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.beacon_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_owner {
            my_size += 9;
        }
        if let Some(v) = self.beacon_id {
            my_size += 9;
        }
        if let Some(ref v) = self.game_metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid_owner {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.beacon_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.game_metadata.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatPartyBeacon {
        CChatPartyBeacon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "app_id",
                    |m: &CChatPartyBeacon| { &m.app_id },
                    |m: &mut CChatPartyBeacon| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_owner",
                    |m: &CChatPartyBeacon| { &m.steamid_owner },
                    |m: &mut CChatPartyBeacon| { &mut m.steamid_owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "beacon_id",
                    |m: &CChatPartyBeacon| { &m.beacon_id },
                    |m: &mut CChatPartyBeacon| { &mut m.beacon_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_metadata",
                    |m: &CChatPartyBeacon| { &m.game_metadata },
                    |m: &mut CChatPartyBeacon| { &mut m.game_metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatPartyBeacon>(
                    "CChatPartyBeacon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatPartyBeacon {
        static mut instance: ::protobuf::lazy::Lazy<CChatPartyBeacon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatPartyBeacon,
        };
        unsafe {
            instance.get(CChatPartyBeacon::new)
        }
    }
}

impl ::protobuf::Clear for CChatPartyBeacon {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steamid_owner = ::std::option::Option::None;
        self.beacon_id = ::std::option::Option::None;
        self.game_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatPartyBeacon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatPartyBeacon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoomGroupHeaderState {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    clanid: ::std::option::Option<u32>,
    accountid_owner: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    tagline: ::protobuf::SingularField<::std::string::String>,
    avatar_sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    default_role_id: ::std::option::Option<u64>,
    roles: ::protobuf::RepeatedField<CChatRole>,
    role_actions: ::protobuf::RepeatedField<CChatRoleActions>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    party_beacons: ::protobuf::RepeatedField<CChatPartyBeacon>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupHeaderState {
    fn default() -> &'a CChatRoomGroupHeaderState {
        <CChatRoomGroupHeaderState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupHeaderState {
    pub fn new() -> CChatRoomGroupHeaderState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;


    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 clanid = 13;


    pub fn get_clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }
    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_owner = 14;


    pub fn get_accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }
    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 21;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string tagline = 15;


    pub fn get_tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagline(&mut self) {
        self.tagline.clear();
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline.set_default();
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes avatar_sha = 16;


    pub fn get_avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha.clear();
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha.set_default();
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 default_role_id = 17;


    pub fn get_default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }
    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRole roles = 18;


    pub fn get_roles(&self) -> &[CChatRole] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<CChatRole>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<CChatRole> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<CChatRole> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }

    // repeated .CChatRoleActions role_actions = 19;


    pub fn get_role_actions(&self) -> &[CChatRoleActions] {
        &self.role_actions
    }
    pub fn clear_role_actions(&mut self) {
        self.role_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_actions(&mut self, v: ::protobuf::RepeatedField<CChatRoleActions>) {
        self.role_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_actions(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoleActions> {
        &mut self.role_actions
    }

    // Take field
    pub fn take_role_actions(&mut self) -> ::protobuf::RepeatedField<CChatRoleActions> {
        ::std::mem::replace(&mut self.role_actions, ::protobuf::RepeatedField::new())
    }

    // optional uint32 watching_broadcast_accountid = 20;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // repeated .CChatPartyBeacon party_beacons = 22;


    pub fn get_party_beacons(&self) -> &[CChatPartyBeacon] {
        &self.party_beacons
    }
    pub fn clear_party_beacons(&mut self) {
        self.party_beacons.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_beacons(&mut self, v: ::protobuf::RepeatedField<CChatPartyBeacon>) {
        self.party_beacons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_beacons(&mut self) -> &mut ::protobuf::RepeatedField<CChatPartyBeacon> {
        &mut self.party_beacons
    }

    // Take field
    pub fn take_party_beacons(&mut self) -> ::protobuf::RepeatedField<CChatPartyBeacon> {
        ::std::mem::replace(&mut self.party_beacons, ::protobuf::RepeatedField::new())
    }

    // optional uint64 watching_broadcast_channel_id = 23;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomGroupHeaderState {
    fn is_initialized(&self) -> bool {
        for v in &self.roles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.role_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.party_beacons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clanid = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_owner = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagline)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.avatar_sha)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_role_id = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roles)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_actions)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.party_beacons)?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(21, v)?;
        }
        if let Some(ref v) = self.tagline.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            os.write_bytes(16, &v)?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(17, v)?;
        }
        for v in &self.roles {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.role_actions {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(20, v)?;
        }
        for v in &self.party_beacons {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(23, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomGroupHeaderState {
        CChatRoomGroupHeaderState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoomGroupHeaderState| { &m.chat_group_id },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chat_name",
                    |m: &CChatRoomGroupHeaderState| { &m.chat_name },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "clanid",
                    |m: &CChatRoomGroupHeaderState| { &m.clanid },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.clanid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid_owner",
                    |m: &CChatRoomGroupHeaderState| { &m.accountid_owner },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.accountid_owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CChatRoomGroupHeaderState| { &m.appid },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tagline",
                    |m: &CChatRoomGroupHeaderState| { &m.tagline },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.tagline },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "avatar_sha",
                    |m: &CChatRoomGroupHeaderState| { &m.avatar_sha },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.avatar_sha },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "default_role_id",
                    |m: &CChatRoomGroupHeaderState| { &m.default_role_id },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.default_role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRole>>(
                    "roles",
                    |m: &CChatRoomGroupHeaderState| { &m.roles },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.roles },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                    "role_actions",
                    |m: &CChatRoomGroupHeaderState| { &m.role_actions },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.role_actions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "watching_broadcast_accountid",
                    |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_accountid },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatPartyBeacon>>(
                    "party_beacons",
                    |m: &CChatRoomGroupHeaderState| { &m.party_beacons },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.party_beacons },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "watching_broadcast_channel_id",
                    |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_channel_id },
                    |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_channel_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoomGroupHeaderState>(
                    "CChatRoomGroupHeaderState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoomGroupHeaderState {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoomGroupHeaderState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoomGroupHeaderState,
        };
        unsafe {
            instance.get(CChatRoomGroupHeaderState::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoomGroupHeaderState {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_name.clear();
        self.clanid = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.tagline.clear();
        self.avatar_sha.clear();
        self.default_role_id = ::std::option::Option::None;
        self.roles.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomGroupHeaderState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupHeaderState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoomMember {
    // message fields
    accountid: ::std::option::Option<u32>,
    state: ::std::option::Option<EChatRoomJoinState>,
    rank: ::std::option::Option<EChatRoomGroupRank>,
    time_kick_expire: ::std::option::Option<u32>,
    role_ids: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomMember {
    fn default() -> &'a CChatRoomMember {
        <CChatRoomMember as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomMember {
    pub fn new() -> CChatRoomMember {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomJoinState state = 3;


    pub fn get_state(&self) -> EChatRoomJoinState {
        self.state.unwrap_or(EChatRoomJoinState::k_EChatRoomJoinState_Default)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EChatRoomJoinState) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomGroupRank rank = 4;


    pub fn get_rank(&self) -> EChatRoomGroupRank {
        self.rank.unwrap_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 time_kick_expire = 6;


    pub fn get_time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }
    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // repeated uint64 role_ids = 7;


    pub fn get_role_ids(&self) -> &[u64] {
        &self.role_ids
    }
    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoomMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.rank, 4, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_kick_expire = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.role_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.rank {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(6, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomMember {
        CChatRoomMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CChatRoomMember| { &m.accountid },
                    |m: &mut CChatRoomMember| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomJoinState>>(
                    "state",
                    |m: &CChatRoomMember| { &m.state },
                    |m: &mut CChatRoomMember| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomGroupRank>>(
                    "rank",
                    |m: &CChatRoomMember| { &m.rank },
                    |m: &mut CChatRoomMember| { &mut m.rank },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_kick_expire",
                    |m: &CChatRoomMember| { &m.time_kick_expire },
                    |m: &mut CChatRoomMember| { &mut m.time_kick_expire },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_ids",
                    |m: &CChatRoomMember| { &m.role_ids },
                    |m: &mut CChatRoomMember| { &mut m.role_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoomMember>(
                    "CChatRoomMember",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoomMember {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoomMember> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoomMember,
        };
        unsafe {
            instance.get(CChatRoomMember::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoomMember {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.time_kick_expire = ::std::option::Option::None;
        self.role_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomMember {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoomState {
    // message fields
    chat_id: ::std::option::Option<u64>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    voice_allowed: ::std::option::Option<bool>,
    members_in_voice: ::std::vec::Vec<u32>,
    time_last_message: ::std::option::Option<u32>,
    sort_order: ::std::option::Option<u32>,
    last_message: ::protobuf::SingularField<::std::string::String>,
    accountid_last_message: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomState {
    fn default() -> &'a CChatRoomState {
        <CChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomState {
    pub fn new() -> CChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;


    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool voice_allowed = 3;


    pub fn get_voice_allowed(&self) -> bool {
        self.voice_allowed.unwrap_or(false)
    }
    pub fn clear_voice_allowed(&mut self) {
        self.voice_allowed = ::std::option::Option::None;
    }

    pub fn has_voice_allowed(&self) -> bool {
        self.voice_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_allowed(&mut self, v: bool) {
        self.voice_allowed = ::std::option::Option::Some(v);
    }

    // repeated uint32 members_in_voice = 4;


    pub fn get_members_in_voice(&self) -> &[u32] {
        &self.members_in_voice
    }
    pub fn clear_members_in_voice(&mut self) {
        self.members_in_voice.clear();
    }

    // Param is passed by value, moved
    pub fn set_members_in_voice(&mut self, v: ::std::vec::Vec<u32>) {
        self.members_in_voice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members_in_voice(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.members_in_voice
    }

    // Take field
    pub fn take_members_in_voice(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.members_in_voice, ::std::vec::Vec::new())
    }

    // optional uint32 time_last_message = 5;


    pub fn get_time_last_message(&self) -> u32 {
        self.time_last_message.unwrap_or(0)
    }
    pub fn clear_time_last_message(&mut self) {
        self.time_last_message = ::std::option::Option::None;
    }

    pub fn has_time_last_message(&self) -> bool {
        self.time_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_message(&mut self, v: u32) {
        self.time_last_message = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 6;


    pub fn get_sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }
    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }

    // optional string last_message = 7;


    pub fn get_last_message(&self) -> &str {
        match self.last_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_last_message(&mut self) {
        self.last_message.clear();
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: ::std::string::String) {
        self.last_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message(&mut self) -> &mut ::std::string::String {
        if self.last_message.is_none() {
            self.last_message.set_default();
        }
        self.last_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message(&mut self) -> ::std::string::String {
        self.last_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_last_message = 8;


    pub fn get_accountid_last_message(&self) -> u32 {
        self.accountid_last_message.unwrap_or(0)
    }
    pub fn clear_accountid_last_message(&mut self) {
        self.accountid_last_message = ::std::option::Option::None;
    }

    pub fn has_accountid_last_message(&self) -> bool {
        self.accountid_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_last_message(&mut self, v: u32) {
        self.accountid_last_message = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_allowed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.members_in_voice)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_message = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sort_order = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.last_message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_last_message = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.voice_allowed {
            my_size += 2;
        }
        for value in &self.members_in_voice {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.time_last_message {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sort_order {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.last_message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.accountid_last_message {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.voice_allowed {
            os.write_bool(3, v)?;
        }
        for v in &self.members_in_voice {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.time_last_message {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.last_message.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.accountid_last_message {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomState {
        CChatRoomState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoomState| { &m.chat_id },
                    |m: &mut CChatRoomState| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chat_name",
                    |m: &CChatRoomState| { &m.chat_name },
                    |m: &mut CChatRoomState| { &mut m.chat_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "voice_allowed",
                    |m: &CChatRoomState| { &m.voice_allowed },
                    |m: &mut CChatRoomState| { &mut m.voice_allowed },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "members_in_voice",
                    |m: &CChatRoomState| { &m.members_in_voice },
                    |m: &mut CChatRoomState| { &mut m.members_in_voice },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_message",
                    |m: &CChatRoomState| { &m.time_last_message },
                    |m: &mut CChatRoomState| { &mut m.time_last_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sort_order",
                    |m: &CChatRoomState| { &m.sort_order },
                    |m: &mut CChatRoomState| { &mut m.sort_order },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "last_message",
                    |m: &CChatRoomState| { &m.last_message },
                    |m: &mut CChatRoomState| { &mut m.last_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid_last_message",
                    |m: &CChatRoomState| { &m.accountid_last_message },
                    |m: &mut CChatRoomState| { &mut m.accountid_last_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoomState>(
                    "CChatRoomState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoomState {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoomState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoomState,
        };
        unsafe {
            instance.get(CChatRoomState::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoomState {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_name.clear();
        self.voice_allowed = ::std::option::Option::None;
        self.members_in_voice.clear();
        self.time_last_message = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.last_message.clear();
        self.accountid_last_message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoomGroupState {
    // message fields
    header_state: ::protobuf::SingularPtrField<CChatRoomGroupHeaderState>,
    members: ::protobuf::RepeatedField<CChatRoomMember>,
    default_chat_id: ::std::option::Option<u64>,
    chat_rooms: ::protobuf::RepeatedField<CChatRoomState>,
    kicked: ::protobuf::RepeatedField<CChatRoomMember>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupState {
    fn default() -> &'a CChatRoomGroupState {
        <CChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupState {
    pub fn new() -> CChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupHeaderState header_state = 1;


    pub fn get_header_state(&self) -> &CChatRoomGroupHeaderState {
        self.header_state.as_ref().unwrap_or_else(|| CChatRoomGroupHeaderState::default_instance())
    }
    pub fn clear_header_state(&mut self) {
        self.header_state.clear();
    }

    pub fn has_header_state(&self) -> bool {
        self.header_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_state(&mut self, v: CChatRoomGroupHeaderState) {
        self.header_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_state(&mut self) -> &mut CChatRoomGroupHeaderState {
        if self.header_state.is_none() {
            self.header_state.set_default();
        }
        self.header_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_state(&mut self) -> CChatRoomGroupHeaderState {
        self.header_state.take().unwrap_or_else(|| CChatRoomGroupHeaderState::new())
    }

    // repeated .CChatRoomMember members = 2;


    pub fn get_members(&self) -> &[CChatRoomMember] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CChatRoomMember>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomMember> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CChatRoomMember> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional uint64 default_chat_id = 4;


    pub fn get_default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }
    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 5;


    pub fn get_chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }
    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::protobuf::RepeatedField<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::protobuf::RepeatedField<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::protobuf::RepeatedField::new())
    }

    // repeated .CChatRoomMember kicked = 7;


    pub fn get_kicked(&self) -> &[CChatRoomMember] {
        &self.kicked
    }
    pub fn clear_kicked(&mut self) {
        self.kicked.clear();
    }

    // Param is passed by value, moved
    pub fn set_kicked(&mut self, v: ::protobuf::RepeatedField<CChatRoomMember>) {
        self.kicked = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kicked(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomMember> {
        &mut self.kicked
    }

    // Take field
    pub fn take_kicked(&mut self) -> ::protobuf::RepeatedField<CChatRoomMember> {
        ::std::mem::replace(&mut self.kicked, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoomGroupState {
    fn is_initialized(&self) -> bool {
        for v in &self.header_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chat_rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kicked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header_state)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_chat_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_rooms)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kicked)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.kicked {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.default_chat_id {
            os.write_uint64(4, v)?;
        }
        for v in &self.chat_rooms {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.kicked {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomGroupState {
        CChatRoomGroupState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupHeaderState>>(
                    "header_state",
                    |m: &CChatRoomGroupState| { &m.header_state },
                    |m: &mut CChatRoomGroupState| { &mut m.header_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMember>>(
                    "members",
                    |m: &CChatRoomGroupState| { &m.members },
                    |m: &mut CChatRoomGroupState| { &mut m.members },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "default_chat_id",
                    |m: &CChatRoomGroupState| { &m.default_chat_id },
                    |m: &mut CChatRoomGroupState| { &mut m.default_chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                    "chat_rooms",
                    |m: &CChatRoomGroupState| { &m.chat_rooms },
                    |m: &mut CChatRoomGroupState| { &mut m.chat_rooms },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMember>>(
                    "kicked",
                    |m: &CChatRoomGroupState| { &m.kicked },
                    |m: &mut CChatRoomGroupState| { &mut m.kicked },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoomGroupState>(
                    "CChatRoomGroupState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoomGroupState {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoomGroupState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoomGroupState,
        };
        unsafe {
            instance.get(CChatRoomGroupState::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoomGroupState {
    fn clear(&mut self) {
        self.header_state.clear();
        self.members.clear();
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.kicked.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CUserChatRoomState {
    // message fields
    chat_id: ::std::option::Option<u64>,
    time_joined: ::std::option::Option<u32>,
    time_last_ack: ::std::option::Option<u32>,
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    time_last_mention: ::std::option::Option<u32>,
    unread_indicator_muted: ::std::option::Option<bool>,
    time_first_unread: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomState {
    fn default() -> &'a CUserChatRoomState {
        <CUserChatRoomState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomState {
    pub fn new() -> CUserChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;


    pub fn get_time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }
    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_ack = 3;


    pub fn get_time_last_ack(&self) -> u32 {
        self.time_last_ack.unwrap_or(0)
    }
    pub fn clear_time_last_ack(&mut self) {
        self.time_last_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_ack(&self) -> bool {
        self.time_last_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_ack(&mut self, v: u32) {
        self.time_last_ack = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_mention = 6;


    pub fn get_time_last_mention(&self) -> u32 {
        self.time_last_mention.unwrap_or(0)
    }
    pub fn clear_time_last_mention(&mut self) {
        self.time_last_mention = ::std::option::Option::None;
    }

    pub fn has_time_last_mention(&self) -> bool {
        self.time_last_mention.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_mention(&mut self, v: u32) {
        self.time_last_mention = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_unread = 8;


    pub fn get_time_first_unread(&self) -> u32 {
        self.time_first_unread.unwrap_or(0)
    }
    pub fn clear_time_first_unread(&mut self) {
        self.time_first_unread = ::std::option::Option::None;
    }

    pub fn has_time_first_unread(&self) -> bool {
        self.time_first_unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_unread(&mut self, v: u32) {
        self.time_first_unread = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CUserChatRoomState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_joined = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_ack = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_mention = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_first_unread = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_ack {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.time_last_mention {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        if let Some(v) = self.time_first_unread {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_ack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, v.value())?;
        }
        if let Some(v) = self.time_last_mention {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.time_first_unread {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CUserChatRoomState {
        CUserChatRoomState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CUserChatRoomState| { &m.chat_id },
                    |m: &mut CUserChatRoomState| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_joined",
                    |m: &CUserChatRoomState| { &m.time_joined },
                    |m: &mut CUserChatRoomState| { &mut m.time_joined },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_ack",
                    |m: &CUserChatRoomState| { &m.time_last_ack },
                    |m: &mut CUserChatRoomState| { &mut m.time_last_ack },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "desktop_notification_level",
                    |m: &CUserChatRoomState| { &m.desktop_notification_level },
                    |m: &mut CUserChatRoomState| { &mut m.desktop_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "mobile_notification_level",
                    |m: &CUserChatRoomState| { &m.mobile_notification_level },
                    |m: &mut CUserChatRoomState| { &mut m.mobile_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_mention",
                    |m: &CUserChatRoomState| { &m.time_last_mention },
                    |m: &mut CUserChatRoomState| { &mut m.time_last_mention },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unread_indicator_muted",
                    |m: &CUserChatRoomState| { &m.unread_indicator_muted },
                    |m: &mut CUserChatRoomState| { &mut m.unread_indicator_muted },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_first_unread",
                    |m: &CUserChatRoomState| { &m.time_first_unread },
                    |m: &mut CUserChatRoomState| { &mut m.time_first_unread },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CUserChatRoomState>(
                    "CUserChatRoomState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CUserChatRoomState {
        static mut instance: ::protobuf::lazy::Lazy<CUserChatRoomState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CUserChatRoomState,
        };
        unsafe {
            instance.get(CUserChatRoomState::new)
        }
    }
}

impl ::protobuf::Clear for CUserChatRoomState {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.time_last_ack = ::std::option::Option::None;
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_mention = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.time_first_unread = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CUserChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserChatRoomState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CUserChatRoomGroupState {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    time_joined: ::std::option::Option<u32>,
    user_chat_room_state: ::protobuf::RepeatedField<CUserChatRoomState>,
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    time_last_group_ack: ::std::option::Option<u32>,
    unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomGroupState {
    fn default() -> &'a CUserChatRoomGroupState {
        <CUserChatRoomGroupState as ::protobuf::Message>::default_instance()
    }
}

impl CUserChatRoomGroupState {
    pub fn new() -> CUserChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;


    pub fn get_time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }
    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // repeated .CUserChatRoomState user_chat_room_state = 3;


    pub fn get_user_chat_room_state(&self) -> &[CUserChatRoomState] {
        &self.user_chat_room_state
    }
    pub fn clear_user_chat_room_state(&mut self) {
        self.user_chat_room_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_chat_room_state(&mut self, v: ::protobuf::RepeatedField<CUserChatRoomState>) {
        self.user_chat_room_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_chat_room_state(&mut self) -> &mut ::protobuf::RepeatedField<CUserChatRoomState> {
        &mut self.user_chat_room_state
    }

    // Take field
    pub fn take_user_chat_room_state(&mut self) -> ::protobuf::RepeatedField<CUserChatRoomState> {
        ::std::mem::replace(&mut self.user_chat_room_state, ::protobuf::RepeatedField::new())
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_group_ack = 6;


    pub fn get_time_last_group_ack(&self) -> u32 {
        self.time_last_group_ack.unwrap_or(0)
    }
    pub fn clear_time_last_group_ack(&mut self) {
        self.time_last_group_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_group_ack(&self) -> bool {
        self.time_last_group_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_group_ack(&mut self, v: u32) {
        self.time_last_group_ack = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CUserChatRoomGroupState {
    fn is_initialized(&self) -> bool {
        for v in &self.user_chat_room_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_joined = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_chat_room_state)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_group_ack = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_joined {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_chat_room_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        if let Some(v) = self.time_last_group_ack {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        for v in &self.user_chat_room_state {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, v.value())?;
        }
        if let Some(v) = self.time_last_group_ack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CUserChatRoomGroupState {
        CUserChatRoomGroupState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CUserChatRoomGroupState| { &m.chat_group_id },
                    |m: &mut CUserChatRoomGroupState| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_joined",
                    |m: &CUserChatRoomGroupState| { &m.time_joined },
                    |m: &mut CUserChatRoomGroupState| { &mut m.time_joined },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomState>>(
                    "user_chat_room_state",
                    |m: &CUserChatRoomGroupState| { &m.user_chat_room_state },
                    |m: &mut CUserChatRoomGroupState| { &mut m.user_chat_room_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "desktop_notification_level",
                    |m: &CUserChatRoomGroupState| { &m.desktop_notification_level },
                    |m: &mut CUserChatRoomGroupState| { &mut m.desktop_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "mobile_notification_level",
                    |m: &CUserChatRoomGroupState| { &m.mobile_notification_level },
                    |m: &mut CUserChatRoomGroupState| { &mut m.mobile_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_last_group_ack",
                    |m: &CUserChatRoomGroupState| { &m.time_last_group_ack },
                    |m: &mut CUserChatRoomGroupState| { &mut m.time_last_group_ack },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unread_indicator_muted",
                    |m: &CUserChatRoomGroupState| { &m.unread_indicator_muted },
                    |m: &mut CUserChatRoomGroupState| { &mut m.unread_indicator_muted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CUserChatRoomGroupState>(
                    "CUserChatRoomGroupState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CUserChatRoomGroupState {
        static mut instance: ::protobuf::lazy::Lazy<CUserChatRoomGroupState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CUserChatRoomGroupState,
        };
        unsafe {
            instance.get(CUserChatRoomGroupState::new)
        }
    }
}

impl ::protobuf::Clear for CUserChatRoomGroupState {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.user_chat_room_state.clear();
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_group_ack = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CUserChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserChatRoomGroupState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateChatRoomGroup_Response {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    state: ::protobuf::SingularPtrField<CChatRoomGroupState>,
    user_chat_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Response {
        <CChatRoom_CreateChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Response {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomGroupState state = 2;


    pub fn get_state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| CChatRoomGroupState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }

    // optional .CUserChatRoomGroupState user_chat_state = 3;


    pub fn get_user_chat_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_state.as_ref().unwrap_or_else(|| CUserChatRoomGroupState::default_instance())
    }
    pub fn clear_user_chat_state(&mut self) {
        self.user_chat_state.clear();
    }

    pub fn has_user_chat_state(&self) -> bool {
        self.user_chat_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_state.is_none() {
            self.user_chat_state.set_default();
        }
        self.user_chat_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_chat_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        CChatRoom_CreateChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.chat_group_id },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                    "state",
                    |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.state },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                    "user_chat_state",
                    |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.user_chat_state },
                    |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.user_chat_state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateChatRoomGroup_Response>(
                    "CChatRoom_CreateChatRoomGroup_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateChatRoomGroup_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateChatRoomGroup_Response,
        };
        unsafe {
            instance.get(CChatRoom_CreateChatRoomGroup_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoomGroup_Response {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.state.clear();
        self.user_chat_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SaveChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Request {
        <CChatRoom_SaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        CChatRoom_SaveChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.name },
                    |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SaveChatRoomGroup_Request>(
                    "CChatRoom_SaveChatRoomGroup_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SaveChatRoomGroup_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SaveChatRoomGroup_Request,
        };
        unsafe {
            instance.get(CChatRoom_SaveChatRoomGroup_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SaveChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SaveChatRoomGroup_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Response {
        <CChatRoom_SaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SaveChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        CChatRoom_SaveChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SaveChatRoomGroup_Response>(
                    "CChatRoom_SaveChatRoomGroup_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SaveChatRoomGroup_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SaveChatRoomGroup_Response,
        };
        unsafe {
            instance.get(CChatRoom_SaveChatRoomGroup_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SaveChatRoomGroup_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RenameChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Request {
        <CChatRoom_RenameChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Request {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        CChatRoom_RenameChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.name },
                    |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RenameChatRoomGroup_Request>(
                    "CChatRoom_RenameChatRoomGroup_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RenameChatRoomGroup_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RenameChatRoomGroup_Request,
        };
        unsafe {
            instance.get(CChatRoom_RenameChatRoomGroup_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RenameChatRoomGroup_Response {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Response {
        <CChatRoom_RenameChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Response {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        CChatRoom_RenameChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_RenameChatRoomGroup_Response| { &m.name },
                    |m: &mut CChatRoom_RenameChatRoomGroup_Response| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RenameChatRoomGroup_Response>(
                    "CChatRoom_RenameChatRoomGroup_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RenameChatRoomGroup_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RenameChatRoomGroup_Response,
        };
        unsafe {
            instance.get(CChatRoom_RenameChatRoomGroup_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoomGroup_Response {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetChatRoomGroupTagline_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    tagline: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Request {
        <CChatRoom_SetChatRoomGroupTagline_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string tagline = 2;


    pub fn get_tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagline(&mut self) {
        self.tagline.clear();
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline.set_default();
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagline)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.tagline.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        CChatRoom_SetChatRoomGroupTagline_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tagline",
                    |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.tagline },
                    |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.tagline },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetChatRoomGroupTagline_Request>(
                    "CChatRoom_SetChatRoomGroupTagline_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetChatRoomGroupTagline_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetChatRoomGroupTagline_Request,
        };
        unsafe {
            instance.get(CChatRoom_SetChatRoomGroupTagline_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupTagline_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.tagline.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupTagline_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetChatRoomGroupTagline_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Response {
        <CChatRoom_SetChatRoomGroupTagline_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupTagline_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        CChatRoom_SetChatRoomGroupTagline_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetChatRoomGroupTagline_Response>(
                    "CChatRoom_SetChatRoomGroupTagline_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetChatRoomGroupTagline_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetChatRoomGroupTagline_Response,
        };
        unsafe {
            instance.get(CChatRoom_SetChatRoomGroupTagline_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupTagline_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupTagline_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetChatRoomGroupAvatar_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    avatar_sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Request {
        <CChatRoom_SetChatRoomGroupAvatar_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional bytes avatar_sha = 2;


    pub fn get_avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha.clear();
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_sha.is_none() {
            self.avatar_sha.set_default();
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.avatar_sha)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.avatar_sha.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        CChatRoom_SetChatRoomGroupAvatar_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "avatar_sha",
                    |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.avatar_sha },
                    |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.avatar_sha },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetChatRoomGroupAvatar_Request>(
                    "CChatRoom_SetChatRoomGroupAvatar_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetChatRoomGroupAvatar_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetChatRoomGroupAvatar_Request,
        };
        unsafe {
            instance.get(CChatRoom_SetChatRoomGroupAvatar_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.avatar_sha.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetChatRoomGroupAvatar_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Response {
        <CChatRoom_SetChatRoomGroupAvatar_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        CChatRoom_SetChatRoomGroupAvatar_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetChatRoomGroupAvatar_Response>(
                    "CChatRoom_SetChatRoomGroupAvatar_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetChatRoomGroupAvatar_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetChatRoomGroupAvatar_Response,
        };
        unsafe {
            instance.get(CChatRoom_SetChatRoomGroupAvatar_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 2;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 3;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "watching_broadcast_accountid",
                    |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_accountid },
                    |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "watching_broadcast_channel_id",
                    |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_channel_id },
                    |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_channel_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Request>(
                    "CChatRoom_SetChatRoomGroupWatchingBroadcast_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetChatRoomGroupWatchingBroadcast_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetChatRoomGroupWatchingBroadcast_Request,
        };
        unsafe {
            instance.get(CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Response>(
                    "CChatRoom_SetChatRoomGroupWatchingBroadcast_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetChatRoomGroupWatchingBroadcast_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetChatRoomGroupWatchingBroadcast_Response,
        };
        unsafe {
            instance.get(CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_MuteUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    expiration: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Request {
    fn default() -> &'a CChatRoom_MuteUser_Request {
        <CChatRoom_MuteUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Request {
    pub fn new() -> CChatRoom_MuteUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;


    pub fn get_expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }
    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_MuteUser_Request {
        CChatRoom_MuteUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_MuteUser_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_MuteUser_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_MuteUser_Request| { &m.steamid },
                    |m: &mut CChatRoom_MuteUser_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "expiration",
                    |m: &CChatRoom_MuteUser_Request| { &m.expiration },
                    |m: &mut CChatRoom_MuteUser_Request| { &mut m.expiration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_MuteUser_Request>(
                    "CChatRoom_MuteUser_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_MuteUser_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_MuteUser_Request,
        };
        unsafe {
            instance.get(CChatRoom_MuteUser_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_MuteUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_MuteUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MuteUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_MuteUser_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Response {
    fn default() -> &'a CChatRoom_MuteUser_Response {
        <CChatRoom_MuteUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Response {
    pub fn new() -> CChatRoom_MuteUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_MuteUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_MuteUser_Response {
        CChatRoom_MuteUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_MuteUser_Response>(
                    "CChatRoom_MuteUser_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_MuteUser_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_MuteUser_Response,
        };
        unsafe {
            instance.get(CChatRoom_MuteUser_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_MuteUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_MuteUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MuteUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_KickUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    expiration: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Request {
    fn default() -> &'a CChatRoom_KickUser_Request {
        <CChatRoom_KickUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Request {
    pub fn new() -> CChatRoom_KickUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;


    pub fn get_expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }
    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_KickUser_Request {
        CChatRoom_KickUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_KickUser_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_KickUser_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_KickUser_Request| { &m.steamid },
                    |m: &mut CChatRoom_KickUser_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "expiration",
                    |m: &CChatRoom_KickUser_Request| { &m.expiration },
                    |m: &mut CChatRoom_KickUser_Request| { &mut m.expiration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_KickUser_Request>(
                    "CChatRoom_KickUser_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_KickUser_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_KickUser_Request,
        };
        unsafe {
            instance.get(CChatRoom_KickUser_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_KickUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_KickUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_KickUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_KickUser_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Response {
    fn default() -> &'a CChatRoom_KickUser_Response {
        <CChatRoom_KickUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Response {
    pub fn new() -> CChatRoom_KickUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_KickUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_KickUser_Response {
        CChatRoom_KickUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_KickUser_Response>(
                    "CChatRoom_KickUser_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_KickUser_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_KickUser_Response,
        };
        unsafe {
            instance.get(CChatRoom_KickUser_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_KickUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_KickUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_KickUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetUserBanState_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    ban_state: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Request {
    fn default() -> &'a CChatRoom_SetUserBanState_Request {
        <CChatRoom_SetUserBanState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Request {
    pub fn new() -> CChatRoom_SetUserBanState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool ban_state = 3;


    pub fn get_ban_state(&self) -> bool {
        self.ban_state.unwrap_or(false)
    }
    pub fn clear_ban_state(&mut self) {
        self.ban_state = ::std::option::Option::None;
    }

    pub fn has_ban_state(&self) -> bool {
        self.ban_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_state(&mut self, v: bool) {
        self.ban_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ban_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.ban_state {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ban_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserBanState_Request {
        CChatRoom_SetUserBanState_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_SetUserBanState_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_SetUserBanState_Request| { &m.steamid },
                    |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ban_state",
                    |m: &CChatRoom_SetUserBanState_Request| { &m.ban_state },
                    |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.ban_state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetUserBanState_Request>(
                    "CChatRoom_SetUserBanState_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetUserBanState_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetUserBanState_Request,
        };
        unsafe {
            instance.get(CChatRoom_SetUserBanState_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserBanState_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ban_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserBanState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserBanState_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetUserBanState_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Response {
    fn default() -> &'a CChatRoom_SetUserBanState_Response {
        <CChatRoom_SetUserBanState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Response {
    pub fn new() -> CChatRoom_SetUserBanState_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetUserBanState_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserBanState_Response {
        CChatRoom_SetUserBanState_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetUserBanState_Response>(
                    "CChatRoom_SetUserBanState_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetUserBanState_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetUserBanState_Response,
        };
        unsafe {
            instance.get(CChatRoom_SetUserBanState_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserBanState_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserBanState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserBanState_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RevokeInvite_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Request {
    fn default() -> &'a CChatRoom_RevokeInvite_Request {
        <CChatRoom_RevokeInvite_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Request {
    pub fn new() -> CChatRoom_RevokeInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RevokeInvite_Request {
        CChatRoom_RevokeInvite_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_RevokeInvite_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_RevokeInvite_Request| { &m.steamid },
                    |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.steamid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RevokeInvite_Request>(
                    "CChatRoom_RevokeInvite_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RevokeInvite_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RevokeInvite_Request,
        };
        unsafe {
            instance.get(CChatRoom_RevokeInvite_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RevokeInvite_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RevokeInvite_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RevokeInvite_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RevokeInvite_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Response {
    fn default() -> &'a CChatRoom_RevokeInvite_Response {
        <CChatRoom_RevokeInvite_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Response {
    pub fn new() -> CChatRoom_RevokeInvite_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RevokeInvite_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RevokeInvite_Response {
        CChatRoom_RevokeInvite_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RevokeInvite_Response>(
                    "CChatRoom_RevokeInvite_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RevokeInvite_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RevokeInvite_Response,
        };
        unsafe {
            instance.get(CChatRoom_RevokeInvite_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RevokeInvite_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RevokeInvite_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RevokeInvite_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Request {
    fn default() -> &'a CChatRoom_CreateRole_Request {
        <CChatRoom_CreateRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Request {
    pub fn new() -> CChatRoom_CreateRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateRole_Request {
        CChatRoom_CreateRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_CreateRole_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_CreateRole_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_CreateRole_Request| { &m.name },
                    |m: &mut CChatRoom_CreateRole_Request| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateRole_Request>(
                    "CChatRoom_CreateRole_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateRole_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateRole_Request,
        };
        unsafe {
            instance.get(CChatRoom_CreateRole_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateRole_Response {
    // message fields
    actions: ::protobuf::SingularPtrField<CChatRoleActions>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Response {
    fn default() -> &'a CChatRoom_CreateRole_Response {
        <CChatRoom_CreateRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Response {
    pub fn new() -> CChatRoom_CreateRole_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoleActions actions = 2;


    pub fn get_actions(&self) -> &CChatRoleActions {
        self.actions.as_ref().unwrap_or_else(|| CChatRoleActions::default_instance())
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    pub fn has_actions(&self) -> bool {
        self.actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: CChatRoleActions) {
        self.actions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut CChatRoleActions {
        if self.actions.is_none() {
            self.actions.set_default();
        }
        self.actions.as_mut().unwrap()
    }

    // Take field
    pub fn take_actions(&mut self) -> CChatRoleActions {
        self.actions.take().unwrap_or_else(|| CChatRoleActions::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateRole_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.actions.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateRole_Response {
        CChatRoom_CreateRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                    "actions",
                    |m: &CChatRoom_CreateRole_Response| { &m.actions },
                    |m: &mut CChatRoom_CreateRole_Response| { &mut m.actions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateRole_Response>(
                    "CChatRoom_CreateRole_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateRole_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateRole_Response,
        };
        unsafe {
            instance.get(CChatRoom_CreateRole_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateRole_Response {
    fn clear(&mut self) {
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetRoles_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Request {
    fn default() -> &'a CChatRoom_GetRoles_Request {
        <CChatRoom_GetRoles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Request {
    pub fn new() -> CChatRoom_GetRoles_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoles_Request {
        CChatRoom_GetRoles_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetRoles_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetRoles_Request| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetRoles_Request>(
                    "CChatRoom_GetRoles_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetRoles_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetRoles_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetRoles_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoles_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoles_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetRoles_Response {
    // message fields
    roles: ::protobuf::RepeatedField<CChatRole>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Response {
    fn default() -> &'a CChatRoom_GetRoles_Response {
        <CChatRoom_GetRoles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Response {
    pub fn new() -> CChatRoom_GetRoles_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRole roles = 1;


    pub fn get_roles(&self) -> &[CChatRole] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<CChatRole>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<CChatRole> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<CChatRole> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetRoles_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.roles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.roles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoles_Response {
        CChatRoom_GetRoles_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRole>>(
                    "roles",
                    |m: &CChatRoom_GetRoles_Response| { &m.roles },
                    |m: &mut CChatRoom_GetRoles_Response| { &mut m.roles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetRoles_Response>(
                    "CChatRoom_GetRoles_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetRoles_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetRoles_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetRoles_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoles_Response {
    fn clear(&mut self) {
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoles_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RenameRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Request {
    fn default() -> &'a CChatRoom_RenameRole_Request {
        <CChatRoom_RenameRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Request {
    pub fn new() -> CChatRoom_RenameRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameRole_Request {
        CChatRoom_RenameRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_RenameRole_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_RenameRole_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoom_RenameRole_Request| { &m.role_id },
                    |m: &mut CChatRoom_RenameRole_Request| { &mut m.role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_RenameRole_Request| { &m.name },
                    |m: &mut CChatRoom_RenameRole_Request| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RenameRole_Request>(
                    "CChatRoom_RenameRole_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RenameRole_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RenameRole_Request,
        };
        unsafe {
            instance.get(CChatRoom_RenameRole_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RenameRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RenameRole_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Response {
    fn default() -> &'a CChatRoom_RenameRole_Response {
        <CChatRoom_RenameRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Response {
    pub fn new() -> CChatRoom_RenameRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RenameRole_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameRole_Response {
        CChatRoom_RenameRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RenameRole_Response>(
                    "CChatRoom_RenameRole_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RenameRole_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RenameRole_Response,
        };
        unsafe {
            instance.get(CChatRoom_RenameRole_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RenameRole_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ReorderRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Request {
    fn default() -> &'a CChatRoom_ReorderRole_Request {
        <CChatRoom_ReorderRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Request {
    pub fn new() -> CChatRoom_ReorderRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderRole_Request {
        CChatRoom_ReorderRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_ReorderRole_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_ReorderRole_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoom_ReorderRole_Request| { &m.role_id },
                    |m: &mut CChatRoom_ReorderRole_Request| { &mut m.role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ordinal",
                    |m: &CChatRoom_ReorderRole_Request| { &m.ordinal },
                    |m: &mut CChatRoom_ReorderRole_Request| { &mut m.ordinal },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ReorderRole_Request>(
                    "CChatRoom_ReorderRole_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ReorderRole_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ReorderRole_Request,
        };
        unsafe {
            instance.get(CChatRoom_ReorderRole_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ReorderRole_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Response {
    fn default() -> &'a CChatRoom_ReorderRole_Response {
        <CChatRoom_ReorderRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Response {
    pub fn new() -> CChatRoom_ReorderRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReorderRole_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderRole_Response {
        CChatRoom_ReorderRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ReorderRole_Response>(
                    "CChatRoom_ReorderRole_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ReorderRole_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ReorderRole_Response,
        };
        unsafe {
            instance.get(CChatRoom_ReorderRole_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderRole_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteRole_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Request {
    fn default() -> &'a CChatRoom_DeleteRole_Request {
        <CChatRoom_DeleteRole_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Request {
    pub fn new() -> CChatRoom_DeleteRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRole_Request {
        CChatRoom_DeleteRole_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_DeleteRole_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_DeleteRole_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoom_DeleteRole_Request| { &m.role_id },
                    |m: &mut CChatRoom_DeleteRole_Request| { &mut m.role_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteRole_Request>(
                    "CChatRoom_DeleteRole_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteRole_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteRole_Request,
        };
        unsafe {
            instance.get(CChatRoom_DeleteRole_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRole_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRole_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteRole_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Response {
    fn default() -> &'a CChatRoom_DeleteRole_Response {
        <CChatRoom_DeleteRole_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Response {
    pub fn new() -> CChatRoom_DeleteRole_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRole_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRole_Response {
        CChatRoom_DeleteRole_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteRole_Response>(
                    "CChatRoom_DeleteRole_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteRole_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteRole_Response,
        };
        unsafe {
            instance.get(CChatRoom_DeleteRole_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRole_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRole_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetRoleActions_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Request {
    fn default() -> &'a CChatRoom_GetRoleActions_Request {
        <CChatRoom_GetRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Request {
    pub fn new() -> CChatRoom_GetRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoleActions_Request {
        CChatRoom_GetRoleActions_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetRoleActions_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoom_GetRoleActions_Request| { &m.role_id },
                    |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.role_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetRoleActions_Request>(
                    "CChatRoom_GetRoleActions_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetRoleActions_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetRoleActions_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetRoleActions_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoleActions_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoleActions_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetRoleActions_Response {
    // message fields
    actions: ::protobuf::RepeatedField<CChatRoleActions>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Response {
    fn default() -> &'a CChatRoom_GetRoleActions_Response {
        <CChatRoom_GetRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Response {
    pub fn new() -> CChatRoom_GetRoleActions_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoleActions actions = 1;


    pub fn get_actions(&self) -> &[CChatRoleActions] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<CChatRoleActions>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoleActions> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<CChatRoleActions> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetRoleActions_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRoleActions_Response {
        CChatRoom_GetRoleActions_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                    "actions",
                    |m: &CChatRoom_GetRoleActions_Response| { &m.actions },
                    |m: &mut CChatRoom_GetRoleActions_Response| { &mut m.actions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetRoleActions_Response>(
                    "CChatRoom_GetRoleActions_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetRoleActions_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetRoleActions_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetRoleActions_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetRoleActions_Response {
    fn clear(&mut self) {
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRoleActions_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ReplaceRoleActions_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    actions: ::protobuf::SingularPtrField<CChatRoleActions>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Request {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Request {
        <CChatRoom_ReplaceRoleActions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Request {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoleActions actions = 4;


    pub fn get_actions(&self) -> &CChatRoleActions {
        self.actions.as_ref().unwrap_or_else(|| CChatRoleActions::default_instance())
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    pub fn has_actions(&self) -> bool {
        self.actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: CChatRoleActions) {
        self.actions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut CChatRoleActions {
        if self.actions.is_none() {
            self.actions.set_default();
        }
        self.actions.as_mut().unwrap()
    }

    // Take field
    pub fn take_actions(&mut self) -> CChatRoleActions {
        self.actions.take().unwrap_or_else(|| CChatRoleActions::new())
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.actions.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Request {
        CChatRoom_ReplaceRoleActions_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_ReplaceRoleActions_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoom_ReplaceRoleActions_Request| { &m.role_id },
                    |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                    "actions",
                    |m: &CChatRoom_ReplaceRoleActions_Request| { &m.actions },
                    |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.actions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ReplaceRoleActions_Request>(
                    "CChatRoom_ReplaceRoleActions_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ReplaceRoleActions_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ReplaceRoleActions_Request,
        };
        unsafe {
            instance.get(CChatRoom_ReplaceRoleActions_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ReplaceRoleActions_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReplaceRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ReplaceRoleActions_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Response {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Response {
        <CChatRoom_ReplaceRoleActions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Response {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReplaceRoleActions_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Response {
        CChatRoom_ReplaceRoleActions_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ReplaceRoleActions_Response>(
                    "CChatRoom_ReplaceRoleActions_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ReplaceRoleActions_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ReplaceRoleActions_Response,
        };
        unsafe {
            instance.get(CChatRoom_ReplaceRoleActions_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ReplaceRoleActions_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReplaceRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_AddRoleToUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Request {
    fn default() -> &'a CChatRoom_AddRoleToUser_Request {
        <CChatRoom_AddRoleToUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Request {
    pub fn new() -> CChatRoom_AddRoleToUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_AddRoleToUser_Request {
        CChatRoom_AddRoleToUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_AddRoleToUser_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoom_AddRoleToUser_Request| { &m.role_id },
                    |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_AddRoleToUser_Request| { &m.steamid },
                    |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.steamid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_AddRoleToUser_Request>(
                    "CChatRoom_AddRoleToUser_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_AddRoleToUser_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_AddRoleToUser_Request,
        };
        unsafe {
            instance.get(CChatRoom_AddRoleToUser_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_AddRoleToUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_AddRoleToUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_AddRoleToUser_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Response {
    fn default() -> &'a CChatRoom_AddRoleToUser_Response {
        <CChatRoom_AddRoleToUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Response {
    pub fn new() -> CChatRoom_AddRoleToUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_AddRoleToUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_AddRoleToUser_Response {
        CChatRoom_AddRoleToUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_AddRoleToUser_Response>(
                    "CChatRoom_AddRoleToUser_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_AddRoleToUser_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_AddRoleToUser_Response,
        };
        unsafe {
            instance.get(CChatRoom_AddRoleToUser_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_AddRoleToUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_AddRoleToUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetRolesForUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Request {
    fn default() -> &'a CChatRoom_GetRolesForUser_Request {
        <CChatRoom_GetRolesForUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Request {
    pub fn new() -> CChatRoom_GetRolesForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRolesForUser_Request {
        CChatRoom_GetRolesForUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetRolesForUser_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_GetRolesForUser_Request| { &m.steamid },
                    |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.steamid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetRolesForUser_Request>(
                    "CChatRoom_GetRolesForUser_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetRolesForUser_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetRolesForUser_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetRolesForUser_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetRolesForUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRolesForUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetRolesForUser_Response {
    // message fields
    role_ids: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Response {
    fn default() -> &'a CChatRoom_GetRolesForUser_Response {
        <CChatRoom_GetRolesForUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Response {
    pub fn new() -> CChatRoom_GetRolesForUser_Response {
        ::std::default::Default::default()
    }

    // repeated uint64 role_ids = 1;


    pub fn get_role_ids(&self) -> &[u64] {
        &self.role_ids
    }
    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetRolesForUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.role_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.role_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.role_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetRolesForUser_Response {
        CChatRoom_GetRolesForUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_ids",
                    |m: &CChatRoom_GetRolesForUser_Response| { &m.role_ids },
                    |m: &mut CChatRoom_GetRolesForUser_Response| { &mut m.role_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetRolesForUser_Response>(
                    "CChatRoom_GetRolesForUser_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetRolesForUser_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetRolesForUser_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetRolesForUser_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetRolesForUser_Response {
    fn clear(&mut self) {
        self.role_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetRolesForUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteRoleFromUser_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    role_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Request {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Request {
        <CChatRoom_DeleteRoleFromUser_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Request {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;


    pub fn get_role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }
    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.role_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.role_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        CChatRoom_DeleteRoleFromUser_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_id",
                    |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.role_id },
                    |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.steamid },
                    |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.steamid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteRoleFromUser_Request>(
                    "CChatRoom_DeleteRoleFromUser_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteRoleFromUser_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteRoleFromUser_Request,
        };
        unsafe {
            instance.get(CChatRoom_DeleteRoleFromUser_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRoleFromUser_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRoleFromUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteRoleFromUser_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Response {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Response {
        <CChatRoom_DeleteRoleFromUser_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Response {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteRoleFromUser_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        CChatRoom_DeleteRoleFromUser_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteRoleFromUser_Response>(
                    "CChatRoom_DeleteRoleFromUser_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteRoleFromUser_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteRoleFromUser_Response,
        };
        unsafe {
            instance.get(CChatRoom_DeleteRoleFromUser_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteRoleFromUser_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteRoleFromUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_JoinChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    invite_code: ::protobuf::SingularField<::std::string::String>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Request {
        <CChatRoom_JoinChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        CChatRoom_JoinChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invite_code",
                    |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.invite_code },
                    |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.invite_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_id },
                    |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_JoinChatRoomGroup_Request>(
                    "CChatRoom_JoinChatRoomGroup_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_JoinChatRoomGroup_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_JoinChatRoomGroup_Request,
        };
        unsafe {
            instance.get(CChatRoom_JoinChatRoomGroup_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_JoinChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code.clear();
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_JoinChatRoomGroup_Response {
    // message fields
    state: ::protobuf::SingularPtrField<CChatRoomGroupState>,
    user_chat_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    join_chat_id: ::std::option::Option<u64>,
    time_expire: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Response {
        <CChatRoom_JoinChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupState state = 1;


    pub fn get_state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| CChatRoomGroupState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }

    // optional .CUserChatRoomGroupState user_chat_state = 3;


    pub fn get_user_chat_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_state.as_ref().unwrap_or_else(|| CUserChatRoomGroupState::default_instance())
    }
    pub fn clear_user_chat_state(&mut self) {
        self.user_chat_state.clear();
    }

    pub fn has_user_chat_state(&self) -> bool {
        self.user_chat_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_state.is_none() {
            self.user_chat_state.set_default();
        }
        self.user_chat_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional uint64 join_chat_id = 4;


    pub fn get_join_chat_id(&self) -> u64 {
        self.join_chat_id.unwrap_or(0)
    }
    pub fn clear_join_chat_id(&mut self) {
        self.join_chat_id = ::std::option::Option::None;
    }

    pub fn has_join_chat_id(&self) -> bool {
        self.join_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_chat_id(&mut self, v: u64) {
        self.join_chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expire = 5;


    pub fn get_time_expire(&self) -> u32 {
        self.time_expire.unwrap_or(0)
    }
    pub fn clear_time_expire(&mut self) {
        self.time_expire = ::std::option::Option::None;
    }

    pub fn has_time_expire(&self) -> bool {
        self.time_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expire(&mut self, v: u32) {
        self.time_expire = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_chat_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_state)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.join_chat_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_expire = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.join_chat_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_expire {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_chat_state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.join_chat_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.time_expire {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        CChatRoom_JoinChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                    "state",
                    |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.state },
                    |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                    "user_chat_state",
                    |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.user_chat_state },
                    |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.user_chat_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "join_chat_id",
                    |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.join_chat_id },
                    |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.join_chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_expire",
                    |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.time_expire },
                    |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.time_expire },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_JoinChatRoomGroup_Response>(
                    "CChatRoom_JoinChatRoomGroup_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_JoinChatRoomGroup_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_JoinChatRoomGroup_Response,
        };
        unsafe {
            instance.get(CChatRoom_JoinChatRoomGroup_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_JoinChatRoomGroup_Response {
    fn clear(&mut self) {
        self.state.clear();
        self.user_chat_state.clear();
        self.join_chat_id = ::std::option::Option::None;
        self.time_expire = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    steamid: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    skip_friendsui_check: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
        <CChatRoom_InviteFriendToChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Request {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional bool skip_friendsui_check = 4;


    pub fn get_skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.unwrap_or(false)
    }
    pub fn clear_skip_friendsui_check(&mut self) {
        self.skip_friendsui_check = ::std::option::Option::None;
    }

    pub fn has_skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_friendsui_check(&mut self, v: bool) {
        self.skip_friendsui_check = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.skip_friendsui_check = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skip_friendsui_check {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.skip_friendsui_check {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        CChatRoom_InviteFriendToChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.steamid },
                    |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_id },
                    |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "skip_friendsui_check",
                    |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.skip_friendsui_check },
                    |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.skip_friendsui_check },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_InviteFriendToChatRoomGroup_Request>(
                    "CChatRoom_InviteFriendToChatRoomGroup_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_InviteFriendToChatRoomGroup_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_InviteFriendToChatRoomGroup_Request,
        };
        unsafe {
            instance.get(CChatRoom_InviteFriendToChatRoomGroup_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.skip_friendsui_check = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
        <CChatRoom_InviteFriendToChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Response {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        CChatRoom_InviteFriendToChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_InviteFriendToChatRoomGroup_Response>(
                    "CChatRoom_InviteFriendToChatRoomGroup_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_InviteFriendToChatRoomGroup_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_InviteFriendToChatRoomGroup_Response,
        };
        unsafe {
            instance.get(CChatRoom_InviteFriendToChatRoomGroup_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_LeaveChatRoomGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Request {
        <CChatRoom_LeaveChatRoomGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        CChatRoom_LeaveChatRoomGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_LeaveChatRoomGroup_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_LeaveChatRoomGroup_Request| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_LeaveChatRoomGroup_Request>(
                    "CChatRoom_LeaveChatRoomGroup_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_LeaveChatRoomGroup_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_LeaveChatRoomGroup_Request,
        };
        unsafe {
            instance.get(CChatRoom_LeaveChatRoomGroup_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveChatRoomGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_LeaveChatRoomGroup_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Response {
        <CChatRoom_LeaveChatRoomGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_LeaveChatRoomGroup_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        CChatRoom_LeaveChatRoomGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_LeaveChatRoomGroup_Response>(
                    "CChatRoom_LeaveChatRoomGroup_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_LeaveChatRoomGroup_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_LeaveChatRoomGroup_Response,
        };
        unsafe {
            instance.get(CChatRoom_LeaveChatRoomGroup_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveChatRoomGroup_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    allow_voice: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Request {
    fn default() -> &'a CChatRoom_CreateChatRoom_Request {
        <CChatRoom_CreateChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Request {
    pub fn new() -> CChatRoom_CreateChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_voice = 3;


    pub fn get_allow_voice(&self) -> bool {
        self.allow_voice.unwrap_or(false)
    }
    pub fn clear_allow_voice(&mut self) {
        self.allow_voice = ::std::option::Option::None;
    }

    pub fn has_allow_voice(&self) -> bool {
        self.allow_voice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_voice(&mut self, v: bool) {
        self.allow_voice = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_voice = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.allow_voice {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.allow_voice {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoom_Request {
        CChatRoom_CreateChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_CreateChatRoom_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_CreateChatRoom_Request| { &m.name },
                    |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allow_voice",
                    |m: &CChatRoom_CreateChatRoom_Request| { &m.allow_voice },
                    |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.allow_voice },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateChatRoom_Request>(
                    "CChatRoom_CreateChatRoom_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateChatRoom_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateChatRoom_Request,
        };
        unsafe {
            instance.get(CChatRoom_CreateChatRoom_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name.clear();
        self.allow_voice = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateChatRoom_Response {
    // message fields
    chat_room: ::protobuf::SingularPtrField<CChatRoomState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Response {
    fn default() -> &'a CChatRoom_CreateChatRoom_Response {
        <CChatRoom_CreateChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Response {
    pub fn new() -> CChatRoom_CreateChatRoom_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomState chat_room = 1;


    pub fn get_chat_room(&self) -> &CChatRoomState {
        self.chat_room.as_ref().unwrap_or_else(|| CChatRoomState::default_instance())
    }
    pub fn clear_chat_room(&mut self) {
        self.chat_room.clear();
    }

    pub fn has_chat_room(&self) -> bool {
        self.chat_room.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room(&mut self, v: CChatRoomState) {
        self.chat_room = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_room(&mut self) -> &mut CChatRoomState {
        if self.chat_room.is_none() {
            self.chat_room.set_default();
        }
        self.chat_room.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_room(&mut self) -> CChatRoomState {
        self.chat_room.take().unwrap_or_else(|| CChatRoomState::new())
    }
}

impl ::protobuf::Message for CChatRoom_CreateChatRoom_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_room {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chat_room)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chat_room.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chat_room.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateChatRoom_Response {
        CChatRoom_CreateChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                    "chat_room",
                    |m: &CChatRoom_CreateChatRoom_Response| { &m.chat_room },
                    |m: &mut CChatRoom_CreateChatRoom_Response| { &mut m.chat_room },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateChatRoom_Response>(
                    "CChatRoom_CreateChatRoom_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateChatRoom_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateChatRoom_Response,
        };
        unsafe {
            instance.get(CChatRoom_CreateChatRoom_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateChatRoom_Response {
    fn clear(&mut self) {
        self.chat_room.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Request {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Request {
        <CChatRoom_DeleteChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Request {
    pub fn new() -> CChatRoom_DeleteChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatRoom_Request {
        CChatRoom_DeleteChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_id },
                    |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteChatRoom_Request>(
                    "CChatRoom_DeleteChatRoom_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteChatRoom_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteChatRoom_Request,
        };
        unsafe {
            instance.get(CChatRoom_DeleteChatRoom_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteChatRoom_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Response {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Response {
        <CChatRoom_DeleteChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Response {
    pub fn new() -> CChatRoom_DeleteChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatRoom_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatRoom_Response {
        CChatRoom_DeleteChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteChatRoom_Response>(
                    "CChatRoom_DeleteChatRoom_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteChatRoom_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteChatRoom_Response,
        };
        unsafe {
            instance.get(CChatRoom_DeleteChatRoom_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatRoom_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RenameChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Request {
    fn default() -> &'a CChatRoom_RenameChatRoom_Request {
        <CChatRoom_RenameChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Request {
    pub fn new() -> CChatRoom_RenameChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoom_Request {
        CChatRoom_RenameChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_id },
                    |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CChatRoom_RenameChatRoom_Request| { &m.name },
                    |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RenameChatRoom_Request>(
                    "CChatRoom_RenameChatRoom_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RenameChatRoom_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RenameChatRoom_Request,
        };
        unsafe {
            instance.get(CChatRoom_RenameChatRoom_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_RenameChatRoom_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Response {
    fn default() -> &'a CChatRoom_RenameChatRoom_Response {
        <CChatRoom_RenameChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Response {
    pub fn new() -> CChatRoom_RenameChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_RenameChatRoom_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_RenameChatRoom_Response {
        CChatRoom_RenameChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_RenameChatRoom_Response>(
                    "CChatRoom_RenameChatRoom_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_RenameChatRoom_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_RenameChatRoom_Response,
        };
        unsafe {
            instance.get(CChatRoom_RenameChatRoom_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_RenameChatRoom_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_RenameChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ReorderChatRoom_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    move_after_chat_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Request {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Request {
        <CChatRoom_ReorderChatRoom_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Request {
    pub fn new() -> CChatRoom_ReorderChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 move_after_chat_id = 3;


    pub fn get_move_after_chat_id(&self) -> u64 {
        self.move_after_chat_id.unwrap_or(0)
    }
    pub fn clear_move_after_chat_id(&mut self) {
        self.move_after_chat_id = ::std::option::Option::None;
    }

    pub fn has_move_after_chat_id(&self) -> bool {
        self.move_after_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_after_chat_id(&mut self, v: u64) {
        self.move_after_chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.move_after_chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.move_after_chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.move_after_chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderChatRoom_Request {
        CChatRoom_ReorderChatRoom_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_id },
                    |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "move_after_chat_id",
                    |m: &CChatRoom_ReorderChatRoom_Request| { &m.move_after_chat_id },
                    |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.move_after_chat_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ReorderChatRoom_Request>(
                    "CChatRoom_ReorderChatRoom_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ReorderChatRoom_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ReorderChatRoom_Request,
        };
        unsafe {
            instance.get(CChatRoom_ReorderChatRoom_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderChatRoom_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.move_after_chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ReorderChatRoom_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Response {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Response {
        <CChatRoom_ReorderChatRoom_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Response {
    pub fn new() -> CChatRoom_ReorderChatRoom_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_ReorderChatRoom_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ReorderChatRoom_Response {
        CChatRoom_ReorderChatRoom_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ReorderChatRoom_Response>(
                    "CChatRoom_ReorderChatRoom_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ReorderChatRoom_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ReorderChatRoom_Response,
        };
        unsafe {
            instance.get(CChatRoom_ReorderChatRoom_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ReorderChatRoom_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ReorderChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SendChatMessage_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Request {
    fn default() -> &'a CChatRoom_SendChatMessage_Request {
        <CChatRoom_SendChatMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Request {
    pub fn new() -> CChatRoom_SendChatMessage_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SendChatMessage_Request {
        CChatRoom_SendChatMessage_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_SendChatMessage_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_SendChatMessage_Request| { &m.chat_id },
                    |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CChatRoom_SendChatMessage_Request| { &m.message },
                    |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SendChatMessage_Request>(
                    "CChatRoom_SendChatMessage_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SendChatMessage_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SendChatMessage_Request,
        };
        unsafe {
            instance.get(CChatRoom_SendChatMessage_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SendChatMessage_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SendChatMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SendChatMessage_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SendChatMessage_Response {
    // message fields
    modified_message: ::protobuf::SingularField<::std::string::String>,
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Response {
    fn default() -> &'a CChatRoom_SendChatMessage_Response {
        <CChatRoom_SendChatMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Response {
    pub fn new() -> CChatRoom_SendChatMessage_Response {
        ::std::default::Default::default()
    }

    // optional string modified_message = 1;


    pub fn get_modified_message(&self) -> &str {
        match self.modified_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_modified_message(&mut self) {
        self.modified_message.clear();
    }

    pub fn has_modified_message(&self) -> bool {
        self.modified_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_message(&mut self, v: ::std::string::String) {
        self.modified_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_message(&mut self) -> &mut ::std::string::String {
        if self.modified_message.is_none() {
            self.modified_message.set_default();
        }
        self.modified_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_message(&mut self) -> ::std::string::String {
        self.modified_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_timestamp = 2;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SendChatMessage_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.modified_message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.modified_message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.modified_message.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SendChatMessage_Response {
        CChatRoom_SendChatMessage_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "modified_message",
                    |m: &CChatRoom_SendChatMessage_Response| { &m.modified_message },
                    |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.modified_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_timestamp",
                    |m: &CChatRoom_SendChatMessage_Response| { &m.server_timestamp },
                    |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.server_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ordinal",
                    |m: &CChatRoom_SendChatMessage_Response| { &m.ordinal },
                    |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.ordinal },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SendChatMessage_Response>(
                    "CChatRoom_SendChatMessage_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SendChatMessage_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SendChatMessage_Response,
        };
        unsafe {
            instance.get(CChatRoom_SendChatMessage_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SendChatMessage_Response {
    fn clear(&mut self) {
        self.modified_message.clear();
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SendChatMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SendChatMessage_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_JoinVoiceChat_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Request {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Request {
        <CChatRoom_JoinVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Request {
    pub fn new() -> CChatRoom_JoinVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinVoiceChat_Request {
        CChatRoom_JoinVoiceChat_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_id },
                    |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_JoinVoiceChat_Request>(
                    "CChatRoom_JoinVoiceChat_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_JoinVoiceChat_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_JoinVoiceChat_Request,
        };
        unsafe {
            instance.get(CChatRoom_JoinVoiceChat_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_JoinVoiceChat_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_JoinVoiceChat_Response {
    // message fields
    voice_chatid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Response {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Response {
        <CChatRoom_JoinVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Response {
    pub fn new() -> CChatRoom_JoinVoiceChat_Response {
        ::std::default::Default::default()
    }

    // optional uint64 voice_chatid = 1;


    pub fn get_voice_chatid(&self) -> u64 {
        self.voice_chatid.unwrap_or(0)
    }
    pub fn clear_voice_chatid(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
    }

    pub fn has_voice_chatid(&self) -> bool {
        self.voice_chatid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chatid(&mut self, v: u64) {
        self.voice_chatid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_JoinVoiceChat_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.voice_chatid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.voice_chatid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.voice_chatid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_JoinVoiceChat_Response {
        CChatRoom_JoinVoiceChat_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "voice_chatid",
                    |m: &CChatRoom_JoinVoiceChat_Response| { &m.voice_chatid },
                    |m: &mut CChatRoom_JoinVoiceChat_Response| { &mut m.voice_chatid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_JoinVoiceChat_Response>(
                    "CChatRoom_JoinVoiceChat_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_JoinVoiceChat_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_JoinVoiceChat_Response,
        };
        unsafe {
            instance.get(CChatRoom_JoinVoiceChat_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_JoinVoiceChat_Response {
    fn clear(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_JoinVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_LeaveVoiceChat_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Request {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Request {
        <CChatRoom_LeaveVoiceChat_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Request {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Request {
        CChatRoom_LeaveVoiceChat_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_id },
                    |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_LeaveVoiceChat_Request>(
                    "CChatRoom_LeaveVoiceChat_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_LeaveVoiceChat_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_LeaveVoiceChat_Request,
        };
        unsafe {
            instance.get(CChatRoom_LeaveVoiceChat_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveVoiceChat_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_LeaveVoiceChat_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Response {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Response {
        <CChatRoom_LeaveVoiceChat_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Response {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_LeaveVoiceChat_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Response {
        CChatRoom_LeaveVoiceChat_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_LeaveVoiceChat_Response>(
                    "CChatRoom_LeaveVoiceChat_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_LeaveVoiceChat_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_LeaveVoiceChat_Response,
        };
        unsafe {
            instance.get(CChatRoom_LeaveVoiceChat_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_LeaveVoiceChat_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_LeaveVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetMessageHistory_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    last_time: ::std::option::Option<u32>,
    last_ordinal: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    start_ordinal: ::std::option::Option<u32>,
    max_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Request {
    fn default() -> &'a CChatRoom_GetMessageHistory_Request {
        <CChatRoom_GetMessageHistory_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Request {
    pub fn new() -> CChatRoom_GetMessageHistory_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time = 3;


    pub fn get_last_time(&self) -> u32 {
        self.last_time.unwrap_or(0)
    }
    pub fn clear_last_time(&mut self) {
        self.last_time = ::std::option::Option::None;
    }

    pub fn has_last_time(&self) -> bool {
        self.last_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time(&mut self, v: u32) {
        self.last_time = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ordinal = 4;


    pub fn get_last_ordinal(&self) -> u32 {
        self.last_ordinal.unwrap_or(0)
    }
    pub fn clear_last_ordinal(&mut self) {
        self.last_ordinal = ::std::option::Option::None;
    }

    pub fn has_last_ordinal(&self) -> bool {
        self.last_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ordinal(&mut self, v: u32) {
        self.last_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 5;


    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 start_ordinal = 6;


    pub fn get_start_ordinal(&self) -> u32 {
        self.start_ordinal.unwrap_or(0)
    }
    pub fn clear_start_ordinal(&mut self) {
        self.start_ordinal = ::std::option::Option::None;
    }

    pub fn has_start_ordinal(&self) -> bool {
        self.start_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_ordinal(&mut self, v: u32) {
        self.start_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 max_count = 7;


    pub fn get_max_count(&self) -> u32 {
        self.max_count.unwrap_or(0)
    }
    pub fn clear_max_count(&mut self) {
        self.max_count = ::std::option::Option::None;
    }

    pub fn has_max_count(&self) -> bool {
        self.max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: u32) {
        self.max_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_ordinal = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_ordinal = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_ordinal {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_count {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.last_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.start_ordinal {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_count {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageHistory_Request {
        CChatRoom_GetMessageHistory_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_id },
                    |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_time",
                    |m: &CChatRoom_GetMessageHistory_Request| { &m.last_time },
                    |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_ordinal",
                    |m: &CChatRoom_GetMessageHistory_Request| { &m.last_ordinal },
                    |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_ordinal },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_time",
                    |m: &CChatRoom_GetMessageHistory_Request| { &m.start_time },
                    |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "start_ordinal",
                    |m: &CChatRoom_GetMessageHistory_Request| { &m.start_ordinal },
                    |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_ordinal },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_count",
                    |m: &CChatRoom_GetMessageHistory_Request| { &m.max_count },
                    |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.max_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetMessageHistory_Request>(
                    "CChatRoom_GetMessageHistory_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetMessageHistory_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetMessageHistory_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetMessageHistory_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageHistory_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.last_time = ::std::option::Option::None;
        self.last_ordinal = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.start_ordinal = ::std::option::Option::None;
        self.max_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageHistory_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ServerMessage {
    // message fields
    message: ::std::option::Option<EChatRoomServerMessage>,
    string_param: ::protobuf::SingularField<::std::string::String>,
    accountid_param: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerMessage {
    fn default() -> &'a ServerMessage {
        <ServerMessage as ::protobuf::Message>::default_instance()
    }
}

impl ServerMessage {
    pub fn new() -> ServerMessage {
        ::std::default::Default::default()
    }

    // optional .EChatRoomServerMessage message = 1;


    pub fn get_message(&self) -> EChatRoomServerMessage {
        self.message.unwrap_or(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid)
    }
    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: EChatRoomServerMessage) {
        self.message = ::std::option::Option::Some(v);
    }

    // optional string string_param = 2;


    pub fn get_string_param(&self) -> &str {
        match self.string_param.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_string_param(&mut self) {
        self.string_param.clear();
    }

    pub fn has_string_param(&self) -> bool {
        self.string_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param(&mut self, v: ::std::string::String) {
        self.string_param = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param(&mut self) -> &mut ::std::string::String {
        if self.string_param.is_none() {
            self.string_param.set_default();
        }
        self.string_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param(&mut self) -> ::std::string::String {
        self.string_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_param = 3;


    pub fn get_accountid_param(&self) -> u32 {
        self.accountid_param.unwrap_or(0)
    }
    pub fn clear_accountid_param(&mut self) {
        self.accountid_param = ::std::option::Option::None;
    }

    pub fn has_accountid_param(&self) -> bool {
        self.accountid_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_param(&mut self, v: u32) {
        self.accountid_param = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.message, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_param)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_param = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.message {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.string_param.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.accountid_param {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.string_param.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.accountid_param {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerMessage {
        ServerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomServerMessage>>(
                    "message",
                    |m: &ServerMessage| { &m.message },
                    |m: &mut ServerMessage| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string_param",
                    |m: &ServerMessage| { &m.string_param },
                    |m: &mut ServerMessage| { &mut m.string_param },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid_param",
                    |m: &ServerMessage| { &m.accountid_param },
                    |m: &mut ServerMessage| { &mut m.accountid_param },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerMessage>(
                    "ServerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerMessage {
        static mut instance: ::protobuf::lazy::Lazy<ServerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerMessage,
        };
        unsafe {
            instance.get(ServerMessage::new)
        }
    }
}

impl ::protobuf::Clear for ServerMessage {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.string_param.clear();
        self.accountid_param = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetMessageHistory_Response {
    // message fields
    messages: ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage>,
    more_available: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response {
        <CChatRoom_GetMessageHistory_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response {
    pub fn new() -> CChatRoom_GetMessageHistory_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetMessageHistory_Response.ChatMessage messages = 1;


    pub fn get_messages(&self) -> &[CChatRoom_GetMessageHistory_Response_ChatMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CChatRoom_GetMessageHistory_Response_ChatMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }

    // optional bool more_available = 4;


    pub fn get_more_available(&self) -> bool {
        self.more_available.unwrap_or(false)
    }
    pub fn clear_more_available(&mut self) {
        self.more_available = ::std::option::Option::None;
    }

    pub fn has_more_available(&self) -> bool {
        self.more_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_more_available(&mut self, v: bool) {
        self.more_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.more_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.more_available {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.more_available {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageHistory_Response {
        CChatRoom_GetMessageHistory_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetMessageHistory_Response_ChatMessage>>(
                    "messages",
                    |m: &CChatRoom_GetMessageHistory_Response| { &m.messages },
                    |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.messages },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "more_available",
                    |m: &CChatRoom_GetMessageHistory_Response| { &m.more_available },
                    |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.more_available },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetMessageHistory_Response>(
                    "CChatRoom_GetMessageHistory_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetMessageHistory_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetMessageHistory_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetMessageHistory_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageHistory_Response {
    fn clear(&mut self) {
        self.messages.clear();
        self.more_available = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageHistory_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetMessageHistory_Response_ChatMessage {
    // message fields
    sender: ::std::option::Option<u32>,
    server_timestamp: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    ordinal: ::std::option::Option<u32>,
    server_message: ::protobuf::SingularPtrField<ServerMessage>,
    deleted: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response_ChatMessage {
        <CChatRoom_GetMessageHistory_Response_ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response_ChatMessage {
    pub fn new() -> CChatRoom_GetMessageHistory_Response_ChatMessage {
        ::std::default::Default::default()
    }

    // optional uint32 sender = 1;


    pub fn get_sender(&self) -> u32 {
        self.sender.unwrap_or(0)
    }
    pub fn clear_sender(&mut self) {
        self.sender = ::std::option::Option::None;
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: u32) {
        self.sender = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 2;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 4;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .ServerMessage server_message = 5;


    pub fn get_server_message(&self) -> &ServerMessage {
        self.server_message.as_ref().unwrap_or_else(|| ServerMessage::default_instance())
    }
    pub fn clear_server_message(&mut self) {
        self.server_message.clear();
    }

    pub fn has_server_message(&self) -> bool {
        self.server_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_message(&mut self, v: ServerMessage) {
        self.server_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_message(&mut self) -> &mut ServerMessage {
        if self.server_message.is_none() {
            self.server_message.set_default();
        }
        self.server_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_message(&mut self) -> ServerMessage {
        self.server_message.take().unwrap_or_else(|| ServerMessage::new())
    }

    // optional bool deleted = 6;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.server_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sender = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_message)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sender {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sender {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.server_message.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMessageHistory_Response_ChatMessage {
        CChatRoom_GetMessageHistory_Response_ChatMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sender",
                    |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.sender },
                    |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_timestamp",
                    |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.server_timestamp },
                    |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.server_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.message },
                    |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ordinal",
                    |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.ordinal },
                    |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.ordinal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerMessage>>(
                    "server_message",
                    |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.server_message },
                    |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.server_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "deleted",
                    |m: &CChatRoom_GetMessageHistory_Response_ChatMessage| { &m.deleted },
                    |m: &mut CChatRoom_GetMessageHistory_Response_ChatMessage| { &mut m.deleted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetMessageHistory_Response_ChatMessage>(
                    "CChatRoom_GetMessageHistory_Response_ChatMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response_ChatMessage {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetMessageHistory_Response_ChatMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetMessageHistory_Response_ChatMessage,
        };
        unsafe {
            instance.get(CChatRoom_GetMessageHistory_Response_ChatMessage::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn clear(&mut self) {
        self.sender = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.message.clear();
        self.ordinal = ::std::option::Option::None;
        self.server_message.clear();
        self.deleted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Response_ChatMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetMyChatRoomGroups_Request {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Request {
        <CChatRoom_GetMyChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Request {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        CChatRoom_GetMyChatRoomGroups_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetMyChatRoomGroups_Request>(
                    "CChatRoom_GetMyChatRoomGroups_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetMyChatRoomGroups_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetMyChatRoomGroups_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetMyChatRoomGroups_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetMyChatRoomGroups_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMyChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetChatRoomGroupSummary_Response {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_group_name: ::protobuf::SingularField<::std::string::String>,
    active_member_count: ::std::option::Option<u32>,
    active_voice_member_count: ::std::option::Option<u32>,
    default_chat_id: ::std::option::Option<u64>,
    chat_rooms: ::protobuf::RepeatedField<CChatRoomState>,
    clanid: ::std::option::Option<u32>,
    chat_group_tagline: ::protobuf::SingularField<::std::string::String>,
    accountid_owner: ::std::option::Option<u32>,
    top_members: ::std::vec::Vec<u32>,
    chat_group_avatar_sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rank: ::std::option::Option<EChatRoomGroupRank>,
    default_role_id: ::std::option::Option<u64>,
    role_ids: ::std::vec::Vec<u64>,
    role_actions: ::protobuf::RepeatedField<CChatRoleActions>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    party_beacons: ::protobuf::RepeatedField<CChatPartyBeacon>,
    watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Response {
        <CChatRoom_GetChatRoomGroupSummary_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_group_name = 2;


    pub fn get_chat_group_name(&self) -> &str {
        match self.chat_group_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_group_name(&mut self) {
        self.chat_group_name.clear();
    }

    pub fn has_chat_group_name(&self) -> bool {
        self.chat_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_name(&mut self, v: ::std::string::String) {
        self.chat_group_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_name(&mut self) -> &mut ::std::string::String {
        if self.chat_group_name.is_none() {
            self.chat_group_name.set_default();
        }
        self.chat_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_name(&mut self) -> ::std::string::String {
        self.chat_group_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_member_count = 3;


    pub fn get_active_member_count(&self) -> u32 {
        self.active_member_count.unwrap_or(0)
    }
    pub fn clear_active_member_count(&mut self) {
        self.active_member_count = ::std::option::Option::None;
    }

    pub fn has_active_member_count(&self) -> bool {
        self.active_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_member_count(&mut self, v: u32) {
        self.active_member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_voice_member_count = 4;


    pub fn get_active_voice_member_count(&self) -> u32 {
        self.active_voice_member_count.unwrap_or(0)
    }
    pub fn clear_active_voice_member_count(&mut self) {
        self.active_voice_member_count = ::std::option::Option::None;
    }

    pub fn has_active_voice_member_count(&self) -> bool {
        self.active_voice_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_voice_member_count(&mut self, v: u32) {
        self.active_voice_member_count = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 5;


    pub fn get_default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }
    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 6;


    pub fn get_chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }
    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::protobuf::RepeatedField<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::protobuf::RepeatedField<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::protobuf::RepeatedField::new())
    }

    // optional uint32 clanid = 7;


    pub fn get_clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }
    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional string chat_group_tagline = 8;


    pub fn get_chat_group_tagline(&self) -> &str {
        match self.chat_group_tagline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_group_tagline(&mut self) {
        self.chat_group_tagline.clear();
    }

    pub fn has_chat_group_tagline(&self) -> bool {
        self.chat_group_tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_tagline(&mut self, v: ::std::string::String) {
        self.chat_group_tagline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_tagline(&mut self) -> &mut ::std::string::String {
        if self.chat_group_tagline.is_none() {
            self.chat_group_tagline.set_default();
        }
        self.chat_group_tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_tagline(&mut self) -> ::std::string::String {
        self.chat_group_tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_owner = 9;


    pub fn get_accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }
    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // repeated uint32 top_members = 10;


    pub fn get_top_members(&self) -> &[u32] {
        &self.top_members
    }
    pub fn clear_top_members(&mut self) {
        self.top_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_top_members(&mut self, v: ::std::vec::Vec<u32>) {
        self.top_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_top_members(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.top_members
    }

    // Take field
    pub fn take_top_members(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.top_members, ::std::vec::Vec::new())
    }

    // optional bytes chat_group_avatar_sha = 11;


    pub fn get_chat_group_avatar_sha(&self) -> &[u8] {
        match self.chat_group_avatar_sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_chat_group_avatar_sha(&mut self) {
        self.chat_group_avatar_sha.clear();
    }

    pub fn has_chat_group_avatar_sha(&self) -> bool {
        self.chat_group_avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_avatar_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.chat_group_avatar_sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_avatar_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chat_group_avatar_sha.is_none() {
            self.chat_group_avatar_sha.set_default();
        }
        self.chat_group_avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_avatar_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.chat_group_avatar_sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EChatRoomGroupRank rank = 12;


    pub fn get_rank(&self) -> EChatRoomGroupRank {
        self.rank.unwrap_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint64 default_role_id = 13;


    pub fn get_default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }
    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // repeated uint64 role_ids = 14;


    pub fn get_role_ids(&self) -> &[u64] {
        &self.role_ids
    }
    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }

    // repeated .CChatRoleActions role_actions = 15;


    pub fn get_role_actions(&self) -> &[CChatRoleActions] {
        &self.role_actions
    }
    pub fn clear_role_actions(&mut self) {
        self.role_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_actions(&mut self, v: ::protobuf::RepeatedField<CChatRoleActions>) {
        self.role_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_actions(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoleActions> {
        &mut self.role_actions
    }

    // Take field
    pub fn take_role_actions(&mut self) -> ::protobuf::RepeatedField<CChatRoleActions> {
        ::std::mem::replace(&mut self.role_actions, ::protobuf::RepeatedField::new())
    }

    // optional uint32 watching_broadcast_accountid = 16;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 17;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated .CChatPartyBeacon party_beacons = 18;


    pub fn get_party_beacons(&self) -> &[CChatPartyBeacon] {
        &self.party_beacons
    }
    pub fn clear_party_beacons(&mut self) {
        self.party_beacons.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_beacons(&mut self, v: ::protobuf::RepeatedField<CChatPartyBeacon>) {
        self.party_beacons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_beacons(&mut self) -> &mut ::protobuf::RepeatedField<CChatPartyBeacon> {
        &mut self.party_beacons
    }

    // Take field
    pub fn take_party_beacons(&mut self) -> ::protobuf::RepeatedField<CChatPartyBeacon> {
        ::std::mem::replace(&mut self.party_beacons, ::protobuf::RepeatedField::new())
    }

    // optional uint64 watching_broadcast_channel_id = 19;


    pub fn get_watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.role_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.party_beacons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_group_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_member_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_voice_member_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_chat_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_rooms)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clanid = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_group_tagline)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_owner = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.top_members)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.chat_group_avatar_sha)?;
                },
                12 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.rank, 12, &mut self.unknown_fields)?
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_role_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.role_ids)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.role_actions)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.party_beacons)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.active_member_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_voice_member_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_group_tagline.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.top_members {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.chat_group_avatar_sha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::enum_size(12, v);
        }
        if let Some(v) = self.default_role_id {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.role_ids {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_group_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.active_member_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_voice_member_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.chat_rooms {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.clanid {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.chat_group_tagline.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(9, v)?;
        }
        for v in &self.top_members {
            os.write_uint32(10, *v)?;
        };
        if let Some(ref v) = self.chat_group_avatar_sha.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(v) = self.rank {
            os.write_enum(12, v.value())?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(14, *v)?;
        };
        for v in &self.role_actions {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(17, v)?;
        }
        for v in &self.party_beacons {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        CChatRoom_GetChatRoomGroupSummary_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chat_group_name",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_name },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_member_count",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_member_count },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_member_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_voice_member_count",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_voice_member_count },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_voice_member_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "default_chat_id",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_chat_id },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                    "chat_rooms",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_rooms },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_rooms },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "clanid",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.clanid },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.clanid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chat_group_tagline",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_tagline },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_tagline },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid_owner",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.accountid_owner },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.accountid_owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "top_members",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.top_members },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.top_members },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "chat_group_avatar_sha",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_avatar_sha },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_avatar_sha },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomGroupRank>>(
                    "rank",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.rank },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.rank },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "default_role_id",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_role_id },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_role_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "role_ids",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_ids },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoleActions>>(
                    "role_actions",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_actions },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_actions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "watching_broadcast_accountid",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_accountid },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.appid },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatPartyBeacon>>(
                    "party_beacons",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.party_beacons },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.party_beacons },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "watching_broadcast_channel_id",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_channel_id },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_channel_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetChatRoomGroupSummary_Response>(
                    "CChatRoom_GetChatRoomGroupSummary_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetChatRoomGroupSummary_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetChatRoomGroupSummary_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetChatRoomGroupSummary_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupSummary_Response {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_name.clear();
        self.active_member_count = ::std::option::Option::None;
        self.active_voice_member_count = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.clanid = ::std::option::Option::None;
        self.chat_group_tagline.clear();
        self.accountid_owner = ::std::option::Option::None;
        self.top_members.clear();
        self.chat_group_avatar_sha.clear();
        self.rank = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.role_ids.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupSummary_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoomSummaryPair {
    // message fields
    user_chat_group_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomSummaryPair {
    fn default() -> &'a CChatRoomSummaryPair {
        <CChatRoomSummaryPair as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomSummaryPair {
    pub fn new() -> CChatRoomSummaryPair {
        ::std::default::Default::default()
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 1;


    pub fn get_user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| CUserChatRoomGroupState::default_instance())
    }
    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_group_state.is_none() {
            self.user_chat_group_state.set_default();
        }
        self.user_chat_group_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 2;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }
}

impl ::protobuf::Message for CChatRoomSummaryPair {
    fn is_initialized(&self) -> bool {
        for v in &self.user_chat_group_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_group_state)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomSummaryPair {
        CChatRoomSummaryPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                    "user_chat_group_state",
                    |m: &CChatRoomSummaryPair| { &m.user_chat_group_state },
                    |m: &mut CChatRoomSummaryPair| { &mut m.user_chat_group_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                    "group_summary",
                    |m: &CChatRoomSummaryPair| { &m.group_summary },
                    |m: &mut CChatRoomSummaryPair| { &mut m.group_summary },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoomSummaryPair>(
                    "CChatRoomSummaryPair",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoomSummaryPair {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoomSummaryPair> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoomSummaryPair,
        };
        unsafe {
            instance.get(CChatRoomSummaryPair::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoomSummaryPair {
    fn clear(&mut self) {
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomSummaryPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomSummaryPair {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetMyChatRoomGroups_Response {
    // message fields
    chat_room_groups: ::protobuf::RepeatedField<CChatRoomSummaryPair>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Response {
        <CChatRoom_GetMyChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Response {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomSummaryPair chat_room_groups = 1;


    pub fn get_chat_room_groups(&self) -> &[CChatRoomSummaryPair] {
        &self.chat_room_groups
    }
    pub fn clear_chat_room_groups(&mut self) {
        self.chat_room_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_room_groups(&mut self, v: ::protobuf::RepeatedField<CChatRoomSummaryPair>) {
        self.chat_room_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_room_groups(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomSummaryPair> {
        &mut self.chat_room_groups
    }

    // Take field
    pub fn take_chat_room_groups(&mut self) -> ::protobuf::RepeatedField<CChatRoomSummaryPair> {
        ::std::mem::replace(&mut self.chat_room_groups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetMyChatRoomGroups_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_room_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_room_groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chat_room_groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chat_room_groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        CChatRoom_GetMyChatRoomGroups_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomSummaryPair>>(
                    "chat_room_groups",
                    |m: &CChatRoom_GetMyChatRoomGroups_Response| { &m.chat_room_groups },
                    |m: &mut CChatRoom_GetMyChatRoomGroups_Response| { &mut m.chat_room_groups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetMyChatRoomGroups_Response>(
                    "CChatRoom_GetMyChatRoomGroups_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetMyChatRoomGroups_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetMyChatRoomGroups_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetMyChatRoomGroups_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetMyChatRoomGroups_Response {
    fn clear(&mut self) {
        self.chat_room_groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetMyChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetChatRoomGroupState_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Request {
        <CChatRoom_GetChatRoomGroupState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        CChatRoom_GetChatRoomGroupState_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetChatRoomGroupState_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetChatRoomGroupState_Request| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetChatRoomGroupState_Request>(
                    "CChatRoom_GetChatRoomGroupState_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetChatRoomGroupState_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetChatRoomGroupState_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetChatRoomGroupState_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupState_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetChatRoomGroupState_Response {
    // message fields
    state: ::protobuf::SingularPtrField<CChatRoomGroupState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Response {
        <CChatRoom_GetChatRoomGroupState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupState state = 1;


    pub fn get_state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| CChatRoomGroupState::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupState_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        CChatRoom_GetChatRoomGroupState_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                    "state",
                    |m: &CChatRoom_GetChatRoomGroupState_Response| { &m.state },
                    |m: &mut CChatRoom_GetChatRoomGroupState_Response| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetChatRoomGroupState_Response>(
                    "CChatRoom_GetChatRoomGroupState_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetChatRoomGroupState_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetChatRoomGroupState_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetChatRoomGroupState_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupState_Response {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetChatRoomGroupSummary_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Request {
        <CChatRoom_GetChatRoomGroupSummary_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetChatRoomGroupSummary_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        CChatRoom_GetChatRoomGroupSummary_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetChatRoomGroupSummary_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetChatRoomGroupSummary_Request| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetChatRoomGroupSummary_Request>(
                    "CChatRoom_GetChatRoomGroupSummary_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetChatRoomGroupSummary_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetChatRoomGroupSummary_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetChatRoomGroupSummary_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetChatRoomGroupSummary_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetChatRoomGroupSummary_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_AckChatMessage_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AckChatMessage_Notification {
    fn default() -> &'a CChatRoom_AckChatMessage_Notification {
        <CChatRoom_AckChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_AckChatMessage_Notification {
    pub fn new() -> CChatRoom_AckChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_AckChatMessage_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_AckChatMessage_Notification {
        CChatRoom_AckChatMessage_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_group_id },
                    |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_id },
                    |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &CChatRoom_AckChatMessage_Notification| { &m.timestamp },
                    |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_AckChatMessage_Notification>(
                    "CChatRoom_AckChatMessage_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_AckChatMessage_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_AckChatMessage_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_AckChatMessage_Notification,
        };
        unsafe {
            instance.get(CChatRoom_AckChatMessage_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_AckChatMessage_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_AckChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_AckChatMessage_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateInviteLink_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    seconds_valid: ::std::option::Option<u32>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Request {
    fn default() -> &'a CChatRoom_CreateInviteLink_Request {
        <CChatRoom_CreateInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Request {
    pub fn new() -> CChatRoom_CreateInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_valid = 2;


    pub fn get_seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }
    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_valid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateInviteLink_Request {
        CChatRoom_CreateInviteLink_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seconds_valid",
                    |m: &CChatRoom_CreateInviteLink_Request| { &m.seconds_valid },
                    |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.seconds_valid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_id },
                    |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateInviteLink_Request>(
                    "CChatRoom_CreateInviteLink_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateInviteLink_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateInviteLink_Request,
        };
        unsafe {
            instance.get(CChatRoom_CreateInviteLink_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateInviteLink_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_CreateInviteLink_Response {
    // message fields
    invite_code: ::protobuf::SingularField<::std::string::String>,
    seconds_valid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Response {
    fn default() -> &'a CChatRoom_CreateInviteLink_Response {
        <CChatRoom_CreateInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Response {
    pub fn new() -> CChatRoom_CreateInviteLink_Response {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seconds_valid = 2;


    pub fn get_seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }
    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_CreateInviteLink_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_valid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_CreateInviteLink_Response {
        CChatRoom_CreateInviteLink_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invite_code",
                    |m: &CChatRoom_CreateInviteLink_Response| { &m.invite_code },
                    |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.invite_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "seconds_valid",
                    |m: &CChatRoom_CreateInviteLink_Response| { &m.seconds_valid },
                    |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.seconds_valid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_CreateInviteLink_Response>(
                    "CChatRoom_CreateInviteLink_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_CreateInviteLink_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_CreateInviteLink_Response,
        };
        unsafe {
            instance.get(CChatRoom_CreateInviteLink_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_CreateInviteLink_Response {
    fn clear(&mut self) {
        self.invite_code.clear();
        self.seconds_valid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_CreateInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteLinkInfo_Request {
    // message fields
    invite_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Request {
        <CChatRoom_GetInviteLinkInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Request {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        CChatRoom_GetInviteLinkInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invite_code",
                    |m: &CChatRoom_GetInviteLinkInfo_Request| { &m.invite_code },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Request| { &mut m.invite_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteLinkInfo_Request>(
                    "CChatRoom_GetInviteLinkInfo_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteLinkInfo_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteLinkInfo_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteLinkInfo_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinkInfo_Request {
    fn clear(&mut self) {
        self.invite_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinkInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteLinkInfo_Response {
    // message fields
    steamid_sender: ::std::option::Option<u64>,
    time_expires: ::std::option::Option<u32>,
    chat_id: ::std::option::Option<u64>,
    group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    user_chat_group_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    time_kick_expire: ::std::option::Option<u32>,
    banned: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Response {
        <CChatRoom_GetInviteLinkInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Response {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_sender = 3;


    pub fn get_steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }
    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 4;


    pub fn get_time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }
    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 6;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 8;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 9;


    pub fn get_user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| CUserChatRoomGroupState::default_instance())
    }
    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_group_state.is_none() {
            self.user_chat_group_state.set_default();
        }
        self.user_chat_group_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional uint32 time_kick_expire = 10;


    pub fn get_time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }
    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 11;


    pub fn get_banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }
    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinkInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_chat_group_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_sender = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_expires = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_group_state)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_kick_expire = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.banned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_sender {
            my_size += 9;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.banned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        CChatRoom_GetInviteLinkInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_sender",
                    |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.steamid_sender },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.steamid_sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_expires",
                    |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_expires },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_expires },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.chat_id },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                    "group_summary",
                    |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.group_summary },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.group_summary },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                    "user_chat_group_state",
                    |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.user_chat_group_state },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.user_chat_group_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_kick_expire",
                    |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_kick_expire },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_kick_expire },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "banned",
                    |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.banned },
                    |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.banned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteLinkInfo_Response>(
                    "CChatRoom_GetInviteLinkInfo_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteLinkInfo_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteLinkInfo_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteLinkInfo_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinkInfo_Response {
    fn clear(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.group_summary.clear();
        self.user_chat_group_state.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinkInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteInfo_Request {
    // message fields
    steamid_invitee: ::std::option::Option<u64>,
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    invite_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteInfo_Request {
        <CChatRoom_GetInviteInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Request {
    pub fn new() -> CChatRoom_GetInviteInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_invitee = 1;


    pub fn get_steamid_invitee(&self) -> u64 {
        self.steamid_invitee.unwrap_or(0)
    }
    pub fn clear_steamid_invitee(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
    }

    pub fn has_steamid_invitee(&self) -> bool {
        self.steamid_invitee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitee(&mut self, v: u64) {
        self.steamid_invitee = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 4;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_invitee = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_invitee {
            my_size += 9;
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_invitee {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteInfo_Request {
        CChatRoom_GetInviteInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_invitee",
                    |m: &CChatRoom_GetInviteInfo_Request| { &m.steamid_invitee },
                    |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.steamid_invitee },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_id },
                    |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invite_code",
                    |m: &CChatRoom_GetInviteInfo_Request| { &m.invite_code },
                    |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.invite_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteInfo_Request>(
                    "CChatRoom_GetInviteInfo_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteInfo_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteInfo_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteInfo_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteInfo_Request {
    fn clear(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.invite_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteInfo_Response {
    // message fields
    group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    time_kick_expire: ::std::option::Option<u32>,
    banned: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteInfo_Response {
        <CChatRoom_GetInviteInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Response {
    pub fn new() -> CChatRoom_GetInviteInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 1;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional uint32 time_kick_expire = 2;


    pub fn get_time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }
    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 3;


    pub fn get_banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }
    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_kick_expire = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.banned = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.banned {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteInfo_Response {
        CChatRoom_GetInviteInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                    "group_summary",
                    |m: &CChatRoom_GetInviteInfo_Response| { &m.group_summary },
                    |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.group_summary },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_kick_expire",
                    |m: &CChatRoom_GetInviteInfo_Response| { &m.time_kick_expire },
                    |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.time_kick_expire },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "banned",
                    |m: &CChatRoom_GetInviteInfo_Response| { &m.banned },
                    |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.banned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteInfo_Response>(
                    "CChatRoom_GetInviteInfo_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteInfo_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteInfo_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteInfo_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteInfo_Response {
    fn clear(&mut self) {
        self.group_summary.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteLinksForGroup_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Request {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Request {
        <CChatRoom_GetInviteLinksForGroup_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Request {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        CChatRoom_GetInviteLinksForGroup_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetInviteLinksForGroup_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetInviteLinksForGroup_Request| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteLinksForGroup_Request>(
                    "CChatRoom_GetInviteLinksForGroup_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteLinksForGroup_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteLinksForGroup_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteLinksForGroup_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinksForGroup_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinksForGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteLinksForGroup_Response {
    // message fields
    invite_links: ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Response {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Response {
        <CChatRoom_GetInviteLinksForGroup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Response {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetInviteLinksForGroup_Response.LinkInfo invite_links = 1;


    pub fn get_invite_links(&self) -> &[CChatRoom_GetInviteLinksForGroup_Response_LinkInfo] {
        &self.invite_links
    }
    pub fn clear_invite_links(&mut self) {
        self.invite_links.clear();
    }

    // Param is passed by value, moved
    pub fn set_invite_links(&mut self, v: ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>) {
        self.invite_links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invite_links(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo> {
        &mut self.invite_links
    }

    // Take field
    pub fn take_invite_links(&mut self) -> ::protobuf::RepeatedField<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo> {
        ::std::mem::replace(&mut self.invite_links, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.invite_links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invite_links)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invite_links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invite_links {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        CChatRoom_GetInviteLinksForGroup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>>(
                    "invite_links",
                    |m: &CChatRoom_GetInviteLinksForGroup_Response| { &m.invite_links },
                    |m: &mut CChatRoom_GetInviteLinksForGroup_Response| { &mut m.invite_links },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteLinksForGroup_Response>(
                    "CChatRoom_GetInviteLinksForGroup_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteLinksForGroup_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteLinksForGroup_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteLinksForGroup_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinksForGroup_Response {
    fn clear(&mut self) {
        self.invite_links.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinksForGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    // message fields
    invite_code: ::protobuf::SingularField<::std::string::String>,
    steamid_creator: ::std::option::Option<u64>,
    time_expires: ::std::option::Option<u32>,
    chat_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        <CChatRoom_GetInviteLinksForGroup_Response_LinkInfo as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid_creator = 2;


    pub fn get_steamid_creator(&self) -> u64 {
        self.steamid_creator.unwrap_or(0)
    }
    pub fn clear_steamid_creator(&mut self) {
        self.steamid_creator = ::std::option::Option::None;
    }

    pub fn has_steamid_creator(&self) -> bool {
        self.steamid_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_creator(&mut self, v: u64) {
        self.steamid_creator = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 3;


    pub fn get_time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }
    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 4;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_creator = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_expires = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid_creator {
            my_size += 9;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.steamid_creator {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        CChatRoom_GetInviteLinksForGroup_Response_LinkInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invite_code",
                    |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.invite_code },
                    |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.invite_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_creator",
                    |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.steamid_creator },
                    |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.steamid_creator },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_expires",
                    |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.time_expires },
                    |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.time_expires },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &m.chat_id },
                    |m: &mut CChatRoom_GetInviteLinksForGroup_Response_LinkInfo| { &mut m.chat_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo>(
                    "CChatRoom_GetInviteLinksForGroup_Response_LinkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteLinksForGroup_Response_LinkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteLinksForGroup_Response_LinkInfo,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteLinksForGroup_Response_LinkInfo::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn clear(&mut self) {
        self.invite_code.clear();
        self.steamid_creator = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetBanList_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Request {
    fn default() -> &'a CChatRoom_GetBanList_Request {
        <CChatRoom_GetBanList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Request {
    pub fn new() -> CChatRoom_GetBanList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetBanList_Request {
        CChatRoom_GetBanList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetBanList_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetBanList_Request| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetBanList_Request>(
                    "CChatRoom_GetBanList_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetBanList_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetBanList_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetBanList_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetBanList_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetBanList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetBanList_Response {
    // message fields
    bans: ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Response {
    fn default() -> &'a CChatRoom_GetBanList_Response {
        <CChatRoom_GetBanList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Response {
    pub fn new() -> CChatRoom_GetBanList_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetBanList_Response.BanInfo bans = 1;


    pub fn get_bans(&self) -> &[CChatRoom_GetBanList_Response_BanInfo] {
        &self.bans
    }
    pub fn clear_bans(&mut self) {
        self.bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_bans(&mut self, v: ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo>) {
        self.bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bans(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo> {
        &mut self.bans
    }

    // Take field
    pub fn take_bans(&mut self) -> ::protobuf::RepeatedField<CChatRoom_GetBanList_Response_BanInfo> {
        ::std::mem::replace(&mut self.bans, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.bans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bans {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetBanList_Response {
        CChatRoom_GetBanList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetBanList_Response_BanInfo>>(
                    "bans",
                    |m: &CChatRoom_GetBanList_Response| { &m.bans },
                    |m: &mut CChatRoom_GetBanList_Response| { &mut m.bans },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetBanList_Response>(
                    "CChatRoom_GetBanList_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetBanList_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetBanList_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetBanList_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetBanList_Response {
    fn clear(&mut self) {
        self.bans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetBanList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetBanList_Response_BanInfo {
    // message fields
    accountid: ::std::option::Option<u32>,
    accountid_actor: ::std::option::Option<u32>,
    time_banned: ::std::option::Option<u32>,
    ban_reason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Response_BanInfo {
    fn default() -> &'a CChatRoom_GetBanList_Response_BanInfo {
        <CChatRoom_GetBanList_Response_BanInfo as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Response_BanInfo {
    pub fn new() -> CChatRoom_GetBanList_Response_BanInfo {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_actor = 2;


    pub fn get_accountid_actor(&self) -> u32 {
        self.accountid_actor.unwrap_or(0)
    }
    pub fn clear_accountid_actor(&mut self) {
        self.accountid_actor = ::std::option::Option::None;
    }

    pub fn has_accountid_actor(&self) -> bool {
        self.accountid_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_actor(&mut self, v: u32) {
        self.accountid_actor = ::std::option::Option::Some(v);
    }

    // optional uint32 time_banned = 3;


    pub fn get_time_banned(&self) -> u32 {
        self.time_banned.unwrap_or(0)
    }
    pub fn clear_time_banned(&mut self) {
        self.time_banned = ::std::option::Option::None;
    }

    pub fn has_time_banned(&self) -> bool {
        self.time_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_banned(&mut self, v: u32) {
        self.time_banned = ::std::option::Option::Some(v);
    }

    // optional string ban_reason = 4;


    pub fn get_ban_reason(&self) -> &str {
        match self.ban_reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ban_reason(&mut self) {
        self.ban_reason.clear();
    }

    pub fn has_ban_reason(&self) -> bool {
        self.ban_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_reason(&mut self, v: ::std::string::String) {
        self.ban_reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ban_reason(&mut self) -> &mut ::std::string::String {
        if self.ban_reason.is_none() {
            self.ban_reason.set_default();
        }
        self.ban_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_ban_reason(&mut self) -> ::std::string::String {
        self.ban_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetBanList_Response_BanInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_banned = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ban_reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_actor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_banned {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ban_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid_actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_banned {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.ban_reason.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetBanList_Response_BanInfo {
        CChatRoom_GetBanList_Response_BanInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.accountid },
                    |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid_actor",
                    |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.accountid_actor },
                    |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.accountid_actor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_banned",
                    |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.time_banned },
                    |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.time_banned },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ban_reason",
                    |m: &CChatRoom_GetBanList_Response_BanInfo| { &m.ban_reason },
                    |m: &mut CChatRoom_GetBanList_Response_BanInfo| { &mut m.ban_reason },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetBanList_Response_BanInfo>(
                    "CChatRoom_GetBanList_Response_BanInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Response_BanInfo {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetBanList_Response_BanInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetBanList_Response_BanInfo,
        };
        unsafe {
            instance.get(CChatRoom_GetBanList_Response_BanInfo::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetBanList_Response_BanInfo {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.accountid_actor = ::std::option::Option::None;
        self.time_banned = ::std::option::Option::None;
        self.ban_reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetBanList_Response_BanInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetBanList_Response_BanInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteList_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Request {
    fn default() -> &'a CChatRoom_GetInviteList_Request {
        <CChatRoom_GetInviteList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Request {
    pub fn new() -> CChatRoom_GetInviteList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteList_Request {
        CChatRoom_GetInviteList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_GetInviteList_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_GetInviteList_Request| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteList_Request>(
                    "CChatRoom_GetInviteList_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteList_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteList_Request,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteList_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteList_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoomGroupInvite {
    // message fields
    accountid: ::std::option::Option<u32>,
    accountid_actor: ::std::option::Option<u32>,
    time_invited: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupInvite {
    fn default() -> &'a CChatRoomGroupInvite {
        <CChatRoomGroupInvite as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoomGroupInvite {
    pub fn new() -> CChatRoomGroupInvite {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_actor = 2;


    pub fn get_accountid_actor(&self) -> u32 {
        self.accountid_actor.unwrap_or(0)
    }
    pub fn clear_accountid_actor(&mut self) {
        self.accountid_actor = ::std::option::Option::None;
    }

    pub fn has_accountid_actor(&self) -> bool {
        self.accountid_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_actor(&mut self, v: u32) {
        self.accountid_actor = ::std::option::Option::Some(v);
    }

    // optional uint32 time_invited = 3;


    pub fn get_time_invited(&self) -> u32 {
        self.time_invited.unwrap_or(0)
    }
    pub fn clear_time_invited(&mut self) {
        self.time_invited = ::std::option::Option::None;
    }

    pub fn has_time_invited(&self) -> bool {
        self.time_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_invited(&mut self, v: u32) {
        self.time_invited = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoomGroupInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_invited = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid_actor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_invited {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid_actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_invited {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoomGroupInvite {
        CChatRoomGroupInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid",
                    |m: &CChatRoomGroupInvite| { &m.accountid },
                    |m: &mut CChatRoomGroupInvite| { &mut m.accountid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "accountid_actor",
                    |m: &CChatRoomGroupInvite| { &m.accountid_actor },
                    |m: &mut CChatRoomGroupInvite| { &mut m.accountid_actor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_invited",
                    |m: &CChatRoomGroupInvite| { &m.time_invited },
                    |m: &mut CChatRoomGroupInvite| { &mut m.time_invited },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoomGroupInvite>(
                    "CChatRoomGroupInvite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoomGroupInvite {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoomGroupInvite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoomGroupInvite,
        };
        unsafe {
            instance.get(CChatRoomGroupInvite::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoomGroupInvite {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.accountid_actor = ::std::option::Option::None;
        self.time_invited = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoomGroupInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoomGroupInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_GetInviteList_Response {
    // message fields
    invites: ::protobuf::RepeatedField<CChatRoomGroupInvite>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Response {
    fn default() -> &'a CChatRoom_GetInviteList_Response {
        <CChatRoom_GetInviteList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Response {
    pub fn new() -> CChatRoom_GetInviteList_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomGroupInvite invites = 1;


    pub fn get_invites(&self) -> &[CChatRoomGroupInvite] {
        &self.invites
    }
    pub fn clear_invites(&mut self) {
        self.invites.clear();
    }

    // Param is passed by value, moved
    pub fn set_invites(&mut self, v: ::protobuf::RepeatedField<CChatRoomGroupInvite>) {
        self.invites = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invites(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomGroupInvite> {
        &mut self.invites
    }

    // Take field
    pub fn take_invites(&mut self) -> ::protobuf::RepeatedField<CChatRoomGroupInvite> {
        ::std::mem::replace(&mut self.invites, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_GetInviteList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.invites {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invites)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invites {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invites {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_GetInviteList_Response {
        CChatRoom_GetInviteList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupInvite>>(
                    "invites",
                    |m: &CChatRoom_GetInviteList_Response| { &m.invites },
                    |m: &mut CChatRoom_GetInviteList_Response| { &mut m.invites },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_GetInviteList_Response>(
                    "CChatRoom_GetInviteList_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_GetInviteList_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_GetInviteList_Response,
        };
        unsafe {
            instance.get(CChatRoom_GetInviteList_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_GetInviteList_Response {
    fn clear(&mut self) {
        self.invites.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_GetInviteList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_GetInviteList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteInviteLink_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    invite_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Request {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Request {
        <CChatRoom_DeleteInviteLink_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Request {
    pub fn new() -> CChatRoom_DeleteInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;


    pub fn get_invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_invite_code(&mut self) {
        self.invite_code.clear();
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code.set_default();
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.invite_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.invite_code.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteInviteLink_Request {
        CChatRoom_DeleteInviteLink_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_DeleteInviteLink_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invite_code",
                    |m: &CChatRoom_DeleteInviteLink_Request| { &m.invite_code },
                    |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.invite_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteInviteLink_Request>(
                    "CChatRoom_DeleteInviteLink_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteInviteLink_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteInviteLink_Request,
        };
        unsafe {
            instance.get(CChatRoom_DeleteInviteLink_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteInviteLink_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteInviteLink_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Response {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Response {
        <CChatRoom_DeleteInviteLink_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Response {
    pub fn new() -> CChatRoom_DeleteInviteLink_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteInviteLink_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteInviteLink_Response {
        CChatRoom_DeleteInviteLink_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteInviteLink_Response>(
                    "CChatRoom_DeleteInviteLink_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteInviteLink_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteInviteLink_Response,
        };
        unsafe {
            instance.get(CChatRoom_DeleteInviteLink_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteInviteLink_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Request {
    // message fields
    chat_group_ids: ::std::vec::Vec<u64>,
    chat_groups_data_requested: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
        <CChatRoom_SetSessionActiveChatRoomGroups_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Request {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        ::std::default::Default::default()
    }

    // repeated uint64 chat_group_ids = 1;


    pub fn get_chat_group_ids(&self) -> &[u64] {
        &self.chat_group_ids
    }
    pub fn clear_chat_group_ids(&mut self) {
        self.chat_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_group_ids
    }

    // Take field
    pub fn take_chat_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_group_ids, ::std::vec::Vec::new())
    }

    // repeated uint64 chat_groups_data_requested = 2;


    pub fn get_chat_groups_data_requested(&self) -> &[u64] {
        &self.chat_groups_data_requested
    }
    pub fn clear_chat_groups_data_requested(&mut self) {
        self.chat_groups_data_requested.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_groups_data_requested(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_groups_data_requested = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_groups_data_requested(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_groups_data_requested
    }

    // Take field
    pub fn take_chat_groups_data_requested(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_groups_data_requested, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.chat_group_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.chat_groups_data_requested)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.chat_groups_data_requested {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        for v in &self.chat_groups_data_requested {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        CChatRoom_SetSessionActiveChatRoomGroups_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_ids",
                    |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_group_ids },
                    |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_group_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_groups_data_requested",
                    |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_groups_data_requested },
                    |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_groups_data_requested },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetSessionActiveChatRoomGroups_Request>(
                    "CChatRoom_SetSessionActiveChatRoomGroups_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetSessionActiveChatRoomGroups_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetSessionActiveChatRoomGroups_Request,
        };
        unsafe {
            instance.get(CChatRoom_SetSessionActiveChatRoomGroups_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.chat_groups_data_requested.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Response {
    // message fields
    chat_states: ::protobuf::RepeatedField<CChatRoomGroupState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
        <CChatRoom_SetSessionActiveChatRoomGroups_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Response {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomGroupState chat_states = 1;


    pub fn get_chat_states(&self) -> &[CChatRoomGroupState] {
        &self.chat_states
    }
    pub fn clear_chat_states(&mut self) {
        self.chat_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_states(&mut self, v: ::protobuf::RepeatedField<CChatRoomGroupState>) {
        self.chat_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_states(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomGroupState> {
        &mut self.chat_states
    }

    // Take field
    pub fn take_chat_states(&mut self) -> ::protobuf::RepeatedField<CChatRoomGroupState> {
        ::std::mem::replace(&mut self.chat_states, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_states {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_states)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chat_states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chat_states {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        CChatRoom_SetSessionActiveChatRoomGroups_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupState>>(
                    "chat_states",
                    |m: &CChatRoom_SetSessionActiveChatRoomGroups_Response| { &m.chat_states },
                    |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Response| { &mut m.chat_states },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetSessionActiveChatRoomGroups_Response>(
                    "CChatRoom_SetSessionActiveChatRoomGroups_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetSessionActiveChatRoomGroups_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetSessionActiveChatRoomGroups_Response,
        };
        unsafe {
            instance.get(CChatRoom_SetSessionActiveChatRoomGroups_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn clear(&mut self) {
        self.chat_states.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetUserChatGroupPreferences_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_group_preferences: ::protobuf::SingularPtrField<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences>,
    chat_room_preferences: ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request {
        <CChatRoom_SetUserChatGroupPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences chat_group_preferences = 2;


    pub fn get_chat_group_preferences(&self) -> &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        self.chat_group_preferences.as_ref().unwrap_or_else(|| CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences::default_instance())
    }
    pub fn clear_chat_group_preferences(&mut self) {
        self.chat_group_preferences.clear();
    }

    pub fn has_chat_group_preferences(&self) -> bool {
        self.chat_group_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_preferences(&mut self, v: CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences) {
        self.chat_group_preferences = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_preferences(&mut self) -> &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        if self.chat_group_preferences.is_none() {
            self.chat_group_preferences.set_default();
        }
        self.chat_group_preferences.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_preferences(&mut self) -> CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        self.chat_group_preferences.take().unwrap_or_else(|| CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences::new())
    }

    // repeated .CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences chat_room_preferences = 3;


    pub fn get_chat_room_preferences(&self) -> &[CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences] {
        &self.chat_room_preferences
    }
    pub fn clear_chat_room_preferences(&mut self) {
        self.chat_room_preferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_room_preferences(&mut self, v: ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>) {
        self.chat_room_preferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_room_preferences(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences> {
        &mut self.chat_room_preferences
    }

    // Take field
    pub fn take_chat_room_preferences(&mut self) -> ::protobuf::RepeatedField<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences> {
        ::std::mem::replace(&mut self.chat_room_preferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_group_preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chat_room_preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chat_group_preferences)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_room_preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chat_group_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.chat_room_preferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.chat_group_preferences.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.chat_room_preferences {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        CChatRoom_SetUserChatGroupPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences>>(
                    "chat_group_preferences",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_preferences },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_preferences },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>>(
                    "chat_room_preferences",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_room_preferences },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_room_preferences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetUserChatGroupPreferences_Request>(
                    "CChatRoom_SetUserChatGroupPreferences_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetUserChatGroupPreferences_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetUserChatGroupPreferences_Request,
        };
        unsafe {
            instance.get(CChatRoom_SetUserChatGroupPreferences_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_preferences.clear();
        self.chat_room_preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    // message fields
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        <CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        ::std::default::Default::default()
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 1;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 2;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 3;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "desktop_notification_level",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &m.desktop_notification_level },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &mut m.desktop_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "mobile_notification_level",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &m.mobile_notification_level },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &mut m.mobile_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unread_indicator_muted",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &m.unread_indicator_muted },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences| { &mut m.unread_indicator_muted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences>(
                    "CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences,
        };
        unsafe {
            instance.get(CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn clear(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    // message fields
    chat_id: ::std::option::Option<u64>,
    desktop_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    mobile_notification_level: ::std::option::Option<EChatRoomNotificationLevel>,
    unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        <CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 2;


    pub fn get_desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        self.desktop_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 3;


    pub fn get_mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        self.mobile_notification_level.unwrap_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid)
    }
    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 4;


    pub fn get_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }
    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desktop_notification_level, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mobile_notification_level, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread_indicator_muted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desktop_notification_level {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.chat_id },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "desktop_notification_level",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.desktop_notification_level },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.desktop_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomNotificationLevel>>(
                    "mobile_notification_level",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.mobile_notification_level },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.mobile_notification_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unread_indicator_muted",
                    |m: &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &m.unread_indicator_muted },
                    |m: &mut CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences| { &mut m.unread_indicator_muted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences>(
                    "CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences,
        };
        unsafe {
            instance.get(CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_SetUserChatGroupPreferences_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Response {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Response {
        <CChatRoom_SetUserChatGroupPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Response {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_SetUserChatGroupPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        CChatRoom_SetUserChatGroupPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_SetUserChatGroupPreferences_Response>(
                    "CChatRoom_SetUserChatGroupPreferences_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_SetUserChatGroupPreferences_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_SetUserChatGroupPreferences_Response,
        };
        unsafe {
            instance.get(CChatRoom_SetUserChatGroupPreferences_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_SetUserChatGroupPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_SetUserChatGroupPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteChatMessages_Request {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    messages: ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Request {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Request {
        <CChatRoom_DeleteChatMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Request {
    pub fn new() -> CChatRoom_DeleteChatMessages_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoom_DeleteChatMessages_Request.Message messages = 3;


    pub fn get_messages(&self) -> &[CChatRoom_DeleteChatMessages_Request_Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CChatRoom_DeleteChatMessages_Request_Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatMessages_Request {
        CChatRoom_DeleteChatMessages_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_group_id },
                    |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_id },
                    |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_DeleteChatMessages_Request_Message>>(
                    "messages",
                    |m: &CChatRoom_DeleteChatMessages_Request| { &m.messages },
                    |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteChatMessages_Request>(
                    "CChatRoom_DeleteChatMessages_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Request {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteChatMessages_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteChatMessages_Request,
        };
        unsafe {
            instance.get(CChatRoom_DeleteChatMessages_Request::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatMessages_Request {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteChatMessages_Request_Message {
    // message fields
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Request_Message {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Request_Message {
        <CChatRoom_DeleteChatMessages_Request_Message as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Request_Message {
    pub fn new() -> CChatRoom_DeleteChatMessages_Request_Message {
        ::std::default::Default::default()
    }

    // optional uint32 server_timestamp = 1;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 2;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Request_Message {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatMessages_Request_Message {
        CChatRoom_DeleteChatMessages_Request_Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_timestamp",
                    |m: &CChatRoom_DeleteChatMessages_Request_Message| { &m.server_timestamp },
                    |m: &mut CChatRoom_DeleteChatMessages_Request_Message| { &mut m.server_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ordinal",
                    |m: &CChatRoom_DeleteChatMessages_Request_Message| { &m.ordinal },
                    |m: &mut CChatRoom_DeleteChatMessages_Request_Message| { &mut m.ordinal },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteChatMessages_Request_Message>(
                    "CChatRoom_DeleteChatMessages_Request_Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Request_Message {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteChatMessages_Request_Message> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteChatMessages_Request_Message,
        };
        unsafe {
            instance.get(CChatRoom_DeleteChatMessages_Request_Message::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatMessages_Request_Message {
    fn clear(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatMessages_Request_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Request_Message {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_DeleteChatMessages_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Response {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Response {
        <CChatRoom_DeleteChatMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Response {
    pub fn new() -> CChatRoom_DeleteChatMessages_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CChatRoom_DeleteChatMessages_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_DeleteChatMessages_Response {
        CChatRoom_DeleteChatMessages_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_DeleteChatMessages_Response>(
                    "CChatRoom_DeleteChatMessages_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Response {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_DeleteChatMessages_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_DeleteChatMessages_Response,
        };
        unsafe {
            instance.get(CChatRoom_DeleteChatMessages_Response::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_DeleteChatMessages_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_DeleteChatMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClanChatRooms_GetClanChatRoomInfo_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    autocreate: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Request {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Request {
        <CClanChatRooms_GetClanChatRoomInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Request {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool autocreate = 2;


    pub fn get_autocreate(&self) -> bool {
        self.autocreate.unwrap_or(true)
    }
    pub fn clear_autocreate(&mut self) {
        self.autocreate = ::std::option::Option::None;
    }

    pub fn has_autocreate(&self) -> bool {
        self.autocreate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autocreate(&mut self, v: bool) {
        self.autocreate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autocreate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.autocreate {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.autocreate {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        CClanChatRooms_GetClanChatRoomInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.steamid },
                    |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "autocreate",
                    |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.autocreate },
                    |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.autocreate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClanChatRooms_GetClanChatRoomInfo_Request>(
                    "CClanChatRooms_GetClanChatRoomInfo_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Request {
        static mut instance: ::protobuf::lazy::Lazy<CClanChatRooms_GetClanChatRoomInfo_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClanChatRooms_GetClanChatRoomInfo_Request,
        };
        unsafe {
            instance.get(CClanChatRooms_GetClanChatRoomInfo_Request::new)
        }
    }
}

impl ::protobuf::Clear for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.autocreate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClanChatRooms_GetClanChatRoomInfo_Response {
    // message fields
    chat_group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Response {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Response {
        <CClanChatRooms_GetClanChatRoomInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Response {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response chat_group_summary = 1;


    pub fn get_chat_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.chat_group_summary.as_ref().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::default_instance())
    }
    pub fn clear_chat_group_summary(&mut self) {
        self.chat_group_summary.clear();
    }

    pub fn has_chat_group_summary(&self) -> bool {
        self.chat_group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.chat_group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.chat_group_summary.is_none() {
            self.chat_group_summary.set_default();
        }
        self.chat_group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.chat_group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }
}

impl ::protobuf::Message for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chat_group_summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chat_group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chat_group_summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        CClanChatRooms_GetClanChatRoomInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                    "chat_group_summary",
                    |m: &CClanChatRooms_GetClanChatRoomInfo_Response| { &m.chat_group_summary },
                    |m: &mut CClanChatRooms_GetClanChatRoomInfo_Response| { &mut m.chat_group_summary },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClanChatRooms_GetClanChatRoomInfo_Response>(
                    "CClanChatRooms_GetClanChatRoomInfo_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Response {
        static mut instance: ::protobuf::lazy::Lazy<CClanChatRooms_GetClanChatRoomInfo_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClanChatRooms_GetClanChatRoomInfo_Response,
        };
        unsafe {
            instance.get(CClanChatRooms_GetClanChatRoomInfo_Response::new)
        }
    }
}

impl ::protobuf::Clear for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn clear(&mut self) {
        self.chat_group_summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    chat_room_private: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
        <CClanChatRooms_SetClanChatRoomPrivate_Request as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Request {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 2;


    pub fn get_chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }
    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat_room_private = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_room_private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_room_private {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        CClanChatRooms_SetClanChatRoomPrivate_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.steamid },
                    |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "chat_room_private",
                    |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.chat_room_private },
                    |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.chat_room_private },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClanChatRooms_SetClanChatRoomPrivate_Request>(
                    "CClanChatRooms_SetClanChatRoomPrivate_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Request {
        static mut instance: ::protobuf::lazy::Lazy<CClanChatRooms_SetClanChatRoomPrivate_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClanChatRooms_SetClanChatRoomPrivate_Request,
        };
        unsafe {
            instance.get(CClanChatRooms_SetClanChatRoomPrivate_Request::new)
        }
    }
}

impl ::protobuf::Clear for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_room_private = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Response {
    // message fields
    chat_room_private: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
        <CClanChatRooms_SetClanChatRoomPrivate_Response as ::protobuf::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Response {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        ::std::default::Default::default()
    }

    // optional bool chat_room_private = 1;


    pub fn get_chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }
    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat_room_private = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room_private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_room_private {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        CClanChatRooms_SetClanChatRoomPrivate_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "chat_room_private",
                    |m: &CClanChatRooms_SetClanChatRoomPrivate_Response| { &m.chat_room_private },
                    |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Response| { &mut m.chat_room_private },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClanChatRooms_SetClanChatRoomPrivate_Response>(
                    "CClanChatRooms_SetClanChatRoomPrivate_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Response {
        static mut instance: ::protobuf::lazy::Lazy<CClanChatRooms_SetClanChatRoomPrivate_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClanChatRooms_SetClanChatRoomPrivate_Response,
        };
        unsafe {
            instance.get(CClanChatRooms_SetClanChatRoomPrivate_Response::new)
        }
    }
}

impl ::protobuf::Clear for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn clear(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatMentions {
    // message fields
    mention_all: ::std::option::Option<bool>,
    mention_here: ::std::option::Option<bool>,
    mention_accountids: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatMentions {
    fn default() -> &'a CChatMentions {
        <CChatMentions as ::protobuf::Message>::default_instance()
    }
}

impl CChatMentions {
    pub fn new() -> CChatMentions {
        ::std::default::Default::default()
    }

    // optional bool mention_all = 1;


    pub fn get_mention_all(&self) -> bool {
        self.mention_all.unwrap_or(false)
    }
    pub fn clear_mention_all(&mut self) {
        self.mention_all = ::std::option::Option::None;
    }

    pub fn has_mention_all(&self) -> bool {
        self.mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_all(&mut self, v: bool) {
        self.mention_all = ::std::option::Option::Some(v);
    }

    // optional bool mention_here = 2;


    pub fn get_mention_here(&self) -> bool {
        self.mention_here.unwrap_or(false)
    }
    pub fn clear_mention_here(&mut self) {
        self.mention_here = ::std::option::Option::None;
    }

    pub fn has_mention_here(&self) -> bool {
        self.mention_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_here(&mut self, v: bool) {
        self.mention_here = ::std::option::Option::Some(v);
    }

    // repeated uint32 mention_accountids = 3;


    pub fn get_mention_accountids(&self) -> &[u32] {
        &self.mention_accountids
    }
    pub fn clear_mention_accountids(&mut self) {
        self.mention_accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_mention_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.mention_accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mention_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mention_accountids
    }

    // Take field
    pub fn take_mention_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mention_accountids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CChatMentions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mention_all = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mention_here = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mention_accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mention_all {
            my_size += 2;
        }
        if let Some(v) = self.mention_here {
            my_size += 2;
        }
        for value in &self.mention_accountids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mention_all {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.mention_here {
            os.write_bool(2, v)?;
        }
        for v in &self.mention_accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatMentions {
        CChatMentions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mention_all",
                    |m: &CChatMentions| { &m.mention_all },
                    |m: &mut CChatMentions| { &mut m.mention_all },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mention_here",
                    |m: &CChatMentions| { &m.mention_here },
                    |m: &mut CChatMentions| { &mut m.mention_here },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mention_accountids",
                    |m: &CChatMentions| { &m.mention_accountids },
                    |m: &mut CChatMentions| { &mut m.mention_accountids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatMentions>(
                    "CChatMentions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatMentions {
        static mut instance: ::protobuf::lazy::Lazy<CChatMentions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatMentions,
        };
        unsafe {
            instance.get(CChatMentions::new)
        }
    }
}

impl ::protobuf::Clear for CChatMentions {
    fn clear(&mut self) {
        self.mention_all = ::std::option::Option::None;
        self.mention_here = ::std::option::Option::None;
        self.mention_accountids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatMentions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatMentions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_IncomingChatMessage_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    steamid_sender: ::std::option::Option<u64>,
    message: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<u32>,
    mentions: ::protobuf::SingularPtrField<CChatMentions>,
    ordinal: ::std::option::Option<u32>,
    server_message: ::protobuf::SingularPtrField<ServerMessage>,
    message_no_bbcode: ::protobuf::SingularField<::std::string::String>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_IncomingChatMessage_Notification {
    fn default() -> &'a CChatRoom_IncomingChatMessage_Notification {
        <CChatRoom_IncomingChatMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_IncomingChatMessage_Notification {
    pub fn new() -> CChatRoom_IncomingChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_sender = 3;


    pub fn get_steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }
    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional string message = 4;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 timestamp = 5;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .CChatMentions mentions = 6;


    pub fn get_mentions(&self) -> &CChatMentions {
        self.mentions.as_ref().unwrap_or_else(|| CChatMentions::default_instance())
    }
    pub fn clear_mentions(&mut self) {
        self.mentions.clear();
    }

    pub fn has_mentions(&self) -> bool {
        self.mentions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mentions(&mut self, v: CChatMentions) {
        self.mentions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mentions(&mut self) -> &mut CChatMentions {
        if self.mentions.is_none() {
            self.mentions.set_default();
        }
        self.mentions.as_mut().unwrap()
    }

    // Take field
    pub fn take_mentions(&mut self) -> CChatMentions {
        self.mentions.take().unwrap_or_else(|| CChatMentions::new())
    }

    // optional uint32 ordinal = 7;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .ServerMessage server_message = 8;


    pub fn get_server_message(&self) -> &ServerMessage {
        self.server_message.as_ref().unwrap_or_else(|| ServerMessage::default_instance())
    }
    pub fn clear_server_message(&mut self) {
        self.server_message.clear();
    }

    pub fn has_server_message(&self) -> bool {
        self.server_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_message(&mut self, v: ServerMessage) {
        self.server_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_message(&mut self) -> &mut ServerMessage {
        if self.server_message.is_none() {
            self.server_message.set_default();
        }
        self.server_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_message(&mut self) -> ServerMessage {
        self.server_message.take().unwrap_or_else(|| ServerMessage::new())
    }

    // optional string message_no_bbcode = 9;


    pub fn get_message_no_bbcode(&self) -> &str {
        match self.message_no_bbcode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_no_bbcode(&mut self) {
        self.message_no_bbcode.clear();
    }

    pub fn has_message_no_bbcode(&self) -> bool {
        self.message_no_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_no_bbcode(&mut self, v: ::std::string::String) {
        self.message_no_bbcode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_no_bbcode(&mut self) -> &mut ::std::string::String {
        if self.message_no_bbcode.is_none() {
            self.message_no_bbcode.set_default();
        }
        self.message_no_bbcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_no_bbcode(&mut self) -> ::std::string::String {
        self.message_no_bbcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_name = 10;


    pub fn get_chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CChatRoom_IncomingChatMessage_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.mentions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_sender = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mentions)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_message)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_no_bbcode)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_sender {
            my_size += 9;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mentions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message_no_bbcode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.mentions.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.server_message.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message_no_bbcode.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.chat_name.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_IncomingChatMessage_Notification {
        CChatRoom_IncomingChatMessage_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_group_id },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_id },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid_sender",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.steamid_sender },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.steamid_sender },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.timestamp },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatMentions>>(
                    "mentions",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.mentions },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.mentions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ordinal",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.ordinal },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.ordinal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerMessage>>(
                    "server_message",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.server_message },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.server_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message_no_bbcode",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message_no_bbcode },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message_no_bbcode },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chat_name",
                    |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_name },
                    |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_IncomingChatMessage_Notification>(
                    "CChatRoom_IncomingChatMessage_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_IncomingChatMessage_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_IncomingChatMessage_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_IncomingChatMessage_Notification,
        };
        unsafe {
            instance.get(CChatRoom_IncomingChatMessage_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_IncomingChatMessage_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.steamid_sender = ::std::option::Option::None;
        self.message.clear();
        self.timestamp = ::std::option::Option::None;
        self.mentions.clear();
        self.ordinal = ::std::option::Option::None;
        self.server_message.clear();
        self.message_no_bbcode.clear();
        self.chat_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_IncomingChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_IncomingChatMessage_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ChatMessageModified_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    chat_id: ::std::option::Option<u64>,
    messages: ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatMessageModified_Notification {
    fn default() -> &'a CChatRoom_ChatMessageModified_Notification {
        <CChatRoom_ChatMessageModified_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatMessageModified_Notification {
    pub fn new() -> CChatRoom_ChatMessageModified_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoom_ChatMessageModified_Notification.ChatMessage messages = 3;


    pub fn get_messages(&self) -> &[CChatRoom_ChatMessageModified_Notification_ChatMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CChatRoom_ChatMessageModified_Notification_ChatMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_ChatMessageModified_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatMessageModified_Notification {
        CChatRoom_ChatMessageModified_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_group_id },
                    |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_id },
                    |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_ChatMessageModified_Notification_ChatMessage>>(
                    "messages",
                    |m: &CChatRoom_ChatMessageModified_Notification| { &m.messages },
                    |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ChatMessageModified_Notification>(
                    "CChatRoom_ChatMessageModified_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ChatMessageModified_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ChatMessageModified_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ChatMessageModified_Notification,
        };
        unsafe {
            instance.get(CChatRoom_ChatMessageModified_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ChatMessageModified_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatMessageModified_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatMessageModified_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ChatMessageModified_Notification_ChatMessage {
    // message fields
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    deleted: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn default() -> &'a CChatRoom_ChatMessageModified_Notification_ChatMessage {
        <CChatRoom_ChatMessageModified_Notification_ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatMessageModified_Notification_ChatMessage {
    pub fn new() -> CChatRoom_ChatMessageModified_Notification_ChatMessage {
        ::std::default::Default::default()
    }

    // optional uint32 server_timestamp = 1;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 2;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 3;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatMessageModified_Notification_ChatMessage {
        CChatRoom_ChatMessageModified_Notification_ChatMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "server_timestamp",
                    |m: &CChatRoom_ChatMessageModified_Notification_ChatMessage| { &m.server_timestamp },
                    |m: &mut CChatRoom_ChatMessageModified_Notification_ChatMessage| { &mut m.server_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ordinal",
                    |m: &CChatRoom_ChatMessageModified_Notification_ChatMessage| { &m.ordinal },
                    |m: &mut CChatRoom_ChatMessageModified_Notification_ChatMessage| { &mut m.ordinal },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "deleted",
                    |m: &CChatRoom_ChatMessageModified_Notification_ChatMessage| { &m.deleted },
                    |m: &mut CChatRoom_ChatMessageModified_Notification_ChatMessage| { &mut m.deleted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ChatMessageModified_Notification_ChatMessage>(
                    "CChatRoom_ChatMessageModified_Notification_ChatMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ChatMessageModified_Notification_ChatMessage {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ChatMessageModified_Notification_ChatMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ChatMessageModified_Notification_ChatMessage,
        };
        unsafe {
            instance.get(CChatRoom_ChatMessageModified_Notification_ChatMessage::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn clear(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatMessageModified_Notification_ChatMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_MemberStateChange_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    member: ::protobuf::SingularPtrField<CChatRoomMember>,
    change: ::std::option::Option<EChatRoomMemberStateChange>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MemberStateChange_Notification {
    fn default() -> &'a CChatRoom_MemberStateChange_Notification {
        <CChatRoom_MemberStateChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_MemberStateChange_Notification {
    pub fn new() -> CChatRoom_MemberStateChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomMember member = 2;


    pub fn get_member(&self) -> &CChatRoomMember {
        self.member.as_ref().unwrap_or_else(|| CChatRoomMember::default_instance())
    }
    pub fn clear_member(&mut self) {
        self.member.clear();
    }

    pub fn has_member(&self) -> bool {
        self.member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: CChatRoomMember) {
        self.member = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member(&mut self) -> &mut CChatRoomMember {
        if self.member.is_none() {
            self.member.set_default();
        }
        self.member.as_mut().unwrap()
    }

    // Take field
    pub fn take_member(&mut self) -> CChatRoomMember {
        self.member.take().unwrap_or_else(|| CChatRoomMember::new())
    }

    // optional .EChatRoomMemberStateChange change = 3;


    pub fn get_change(&self) -> EChatRoomMemberStateChange {
        self.change.unwrap_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid)
    }
    pub fn clear_change(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_change(&self) -> bool {
        self.change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: EChatRoomMemberStateChange) {
        self.change = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_MemberStateChange_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.member {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.member)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.change, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.change {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.member.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.change {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_MemberStateChange_Notification {
        CChatRoom_MemberStateChange_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_MemberStateChange_Notification| { &m.chat_group_id },
                    |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomMember>>(
                    "member",
                    |m: &CChatRoom_MemberStateChange_Notification| { &m.member },
                    |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.member },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMemberStateChange>>(
                    "change",
                    |m: &CChatRoom_MemberStateChange_Notification| { &m.change },
                    |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.change },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_MemberStateChange_Notification>(
                    "CChatRoom_MemberStateChange_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_MemberStateChange_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_MemberStateChange_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_MemberStateChange_Notification,
        };
        unsafe {
            instance.get(CChatRoom_MemberStateChange_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_MemberStateChange_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.member.clear();
        self.change = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_MemberStateChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_MemberStateChange_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ChatRoomHeaderState_Notification {
    // message fields
    header_state: ::protobuf::SingularPtrField<CChatRoomGroupHeaderState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomHeaderState_Notification {
    fn default() -> &'a CChatRoom_ChatRoomHeaderState_Notification {
        <CChatRoom_ChatRoomHeaderState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomHeaderState_Notification {
    pub fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupHeaderState header_state = 1;


    pub fn get_header_state(&self) -> &CChatRoomGroupHeaderState {
        self.header_state.as_ref().unwrap_or_else(|| CChatRoomGroupHeaderState::default_instance())
    }
    pub fn clear_header_state(&mut self) {
        self.header_state.clear();
    }

    pub fn has_header_state(&self) -> bool {
        self.header_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_state(&mut self, v: CChatRoomGroupHeaderState) {
        self.header_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_state(&mut self) -> &mut CChatRoomGroupHeaderState {
        if self.header_state.is_none() {
            self.header_state.set_default();
        }
        self.header_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_state(&mut self) -> CChatRoomGroupHeaderState {
        self.header_state.take().unwrap_or_else(|| CChatRoomGroupHeaderState::new())
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomHeaderState_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.header_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header_state.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        CChatRoom_ChatRoomHeaderState_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomGroupHeaderState>>(
                    "header_state",
                    |m: &CChatRoom_ChatRoomHeaderState_Notification| { &m.header_state },
                    |m: &mut CChatRoom_ChatRoomHeaderState_Notification| { &mut m.header_state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ChatRoomHeaderState_Notification>(
                    "CChatRoom_ChatRoomHeaderState_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomHeaderState_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ChatRoomHeaderState_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ChatRoomHeaderState_Notification,
        };
        unsafe {
            instance.get(CChatRoom_ChatRoomHeaderState_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ChatRoomHeaderState_Notification {
    fn clear(&mut self) {
        self.header_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatRoomHeaderState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatRoomHeaderState_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_ChatRoomGroupRoomsChange_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    default_chat_id: ::std::option::Option<u64>,
    chat_rooms: ::protobuf::RepeatedField<CChatRoomState>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn default() -> &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
        <CChatRoom_ChatRoomGroupRoomsChange_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomGroupRoomsChange_Notification {
    pub fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 2;


    pub fn get_default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }
    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 3;


    pub fn get_chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }
    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::protobuf::RepeatedField<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::protobuf::RepeatedField<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::protobuf::RepeatedField<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.chat_rooms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.default_chat_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chat_rooms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_chat_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.chat_rooms {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        CChatRoom_ChatRoomGroupRoomsChange_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_group_id },
                    |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "default_chat_id",
                    |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.default_chat_id },
                    |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.default_chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoomState>>(
                    "chat_rooms",
                    |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_rooms },
                    |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_rooms },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_ChatRoomGroupRoomsChange_Notification>(
                    "CChatRoom_ChatRoomGroupRoomsChange_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomGroupRoomsChange_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_ChatRoomGroupRoomsChange_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_ChatRoomGroupRoomsChange_Notification,
        };
        unsafe {
            instance.get(CChatRoom_ChatRoomGroupRoomsChange_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    // message fields
    chat_id: ::std::option::Option<u64>,
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn default() -> &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        <CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    pub fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;


    pub fn get_chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }
    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_id",
                    |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_id },
                    |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_group_id },
                    |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_group_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification>(
                    "CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification,
        };
        unsafe {
            instance.get(CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    // message fields
    chat_group_id: ::std::option::Option<u64>,
    user_chat_group_state: ::protobuf::SingularPtrField<CUserChatRoomGroupState>,
    group_summary: ::protobuf::SingularPtrField<CChatRoom_GetChatRoomGroupSummary_Response>,
    user_action: ::std::option::Option<EChatRoomMemberStateChange>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        <ChatRoomClient_NotifyChatGroupUserStateChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 2;


    pub fn get_user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| CUserChatRoomGroupState::default_instance())
    }
    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        if self.user_chat_group_state.is_none() {
            self.user_chat_group_state.set_default();
        }
        self.user_chat_group_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 3;


    pub fn get_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::default_instance())
    }
    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        if self.group_summary.is_none() {
            self.group_summary.set_default();
        }
        self.group_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional .EChatRoomMemberStateChange user_action = 4;


    pub fn get_user_action(&self) -> EChatRoomMemberStateChange {
        self.user_action.unwrap_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid)
    }
    pub fn clear_user_action(&mut self) {
        self.user_action = ::std::option::Option::None;
    }

    pub fn has_user_action(&self) -> bool {
        self.user_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_action(&mut self, v: EChatRoomMemberStateChange) {
        self.user_action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.user_chat_group_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_chat_group_state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_summary)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.user_action, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.user_action {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.user_chat_group_state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.group_summary.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.user_action {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chat_group_id",
                    |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.chat_group_id },
                    |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.chat_group_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CUserChatRoomGroupState>>(
                    "user_chat_group_state",
                    |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_chat_group_state },
                    |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_chat_group_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatRoom_GetChatRoomGroupSummary_Response>>(
                    "group_summary",
                    |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.group_summary },
                    |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.group_summary },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EChatRoomMemberStateChange>>(
                    "user_action",
                    |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_action },
                    |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChatRoomClient_NotifyChatGroupUserStateChanged_Notification>(
                    "ChatRoomClient_NotifyChatGroupUserStateChanged_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        static mut instance: ::protobuf::lazy::Lazy<ChatRoomClient_NotifyChatGroupUserStateChanged_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChatRoomClient_NotifyChatGroupUserStateChanged_Notification,
        };
        unsafe {
            instance.get(ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::new)
        }
    }
}

impl ::protobuf::Clear for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.user_action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatUsability_ClientUsabilityMetrics_Notification {
    // message fields
    metrics_run_id: ::std::option::Option<u32>,
    client_build: ::std::option::Option<u32>,
    metrics_version: ::std::option::Option<u32>,
    in_web: ::std::option::Option<bool>,
    settings: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_Settings>,
    voice_settings: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings>,
    ui_state: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_UIState>,
    metrics: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_Metrics>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification {
        <CChatUsability_ClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;


    pub fn get_metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }
    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_build = 2;


    pub fn get_client_build(&self) -> u32 {
        self.client_build.unwrap_or(0)
    }
    pub fn clear_client_build(&mut self) {
        self.client_build = ::std::option::Option::None;
    }

    pub fn has_client_build(&self) -> bool {
        self.client_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_build(&mut self, v: u32) {
        self.client_build = ::std::option::Option::Some(v);
    }

    // optional uint32 metrics_version = 3;


    pub fn get_metrics_version(&self) -> u32 {
        self.metrics_version.unwrap_or(0)
    }
    pub fn clear_metrics_version(&mut self) {
        self.metrics_version = ::std::option::Option::None;
    }

    pub fn has_metrics_version(&self) -> bool {
        self.metrics_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_version(&mut self, v: u32) {
        self.metrics_version = ::std::option::Option::Some(v);
    }

    // optional bool in_web = 4;


    pub fn get_in_web(&self) -> bool {
        self.in_web.unwrap_or(false)
    }
    pub fn clear_in_web(&mut self) {
        self.in_web = ::std::option::Option::None;
    }

    pub fn has_in_web(&self) -> bool {
        self.in_web.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_web(&mut self, v: bool) {
        self.in_web = ::std::option::Option::Some(v);
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.Settings settings = 10;


    pub fn get_settings(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        self.settings.as_ref().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_Settings::default_instance())
    }
    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    pub fn has_settings(&self) -> bool {
        self.settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_Settings) {
        self.settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        if self.settings.is_none() {
            self.settings.set_default();
        }
        self.settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_settings(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        self.settings.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_Settings::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings voice_settings = 11;


    pub fn get_voice_settings(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        self.voice_settings.as_ref().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings::default_instance())
    }
    pub fn clear_voice_settings(&mut self) {
        self.voice_settings.clear();
    }

    pub fn has_voice_settings(&self) -> bool {
        self.voice_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_settings(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings) {
        self.voice_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_settings(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        if self.voice_settings.is_none() {
            self.voice_settings.set_default();
        }
        self.voice_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_settings(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        self.voice_settings.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.UIState ui_state = 12;


    pub fn get_ui_state(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        self.ui_state.as_ref().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_UIState::default_instance())
    }
    pub fn clear_ui_state(&mut self) {
        self.ui_state.clear();
    }

    pub fn has_ui_state(&self) -> bool {
        self.ui_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_state(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_UIState) {
        self.ui_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ui_state(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        if self.ui_state.is_none() {
            self.ui_state.set_default();
        }
        self.ui_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_ui_state(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        self.ui_state.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_UIState::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.Metrics metrics = 13;


    pub fn get_metrics(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        self.metrics.as_ref().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_Metrics::default_instance())
    }
    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    pub fn has_metrics(&self) -> bool {
        self.metrics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_Metrics) {
        self.metrics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metrics(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        if self.metrics.is_none() {
            self.metrics.set_default();
        }
        self.metrics.as_mut().unwrap()
    }

    // Take field
    pub fn take_metrics(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        self.metrics.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_Metrics::new())
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.settings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voice_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ui_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metrics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.metrics_run_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_build = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.metrics_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_web = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.settings)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voice_settings)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ui_state)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_build {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.metrics_version {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_web {
            my_size += 2;
        }
        if let Some(ref v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voice_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_build {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.metrics_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_web {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.settings.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voice_settings.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ui_state.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metrics.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        CChatUsability_ClientUsabilityMetrics_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "metrics_run_id",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_run_id },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "client_build",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.client_build },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.client_build },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "metrics_version",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_version },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "in_web",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.in_web },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.in_web },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_Settings>>(
                    "settings",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.settings },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.settings },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings>>(
                    "voice_settings",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.voice_settings },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.voice_settings },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_UIState>>(
                    "ui_state",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.ui_state },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.ui_state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_Metrics>>(
                    "metrics",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatUsability_ClientUsabilityMetrics_Notification>(
                    "CChatUsability_ClientUsabilityMetrics_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatUsability_ClientUsabilityMetrics_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatUsability_ClientUsabilityMetrics_Notification,
        };
        unsafe {
            instance.get(CChatUsability_ClientUsabilityMetrics_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification {
    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.client_build = ::std::option::Option::None;
        self.metrics_version = ::std::option::Option::None;
        self.in_web = ::std::option::Option::None;
        self.settings.clear();
        self.voice_settings.clear();
        self.ui_state.clear();
        self.metrics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    // message fields
    notifications_show_ingame: ::std::option::Option<bool>,
    notifications_show_online: ::std::option::Option<bool>,
    notifications_show_message: ::std::option::Option<bool>,
    notifications_events_and_announcements: ::std::option::Option<bool>,
    sounds_play_ingame: ::std::option::Option<bool>,
    sounds_play_online: ::std::option::Option<bool>,
    sounds_play_message: ::std::option::Option<bool>,
    sounds_events_and_announcements: ::std::option::Option<bool>,
    always_new_chat_window: ::std::option::Option<bool>,
    force_alphabetic_friend_sorting: ::std::option::Option<bool>,
    chat_flash_mode: ::std::option::Option<i32>,
    remember_open_chats: ::std::option::Option<bool>,
    compact_quick_access: ::std::option::Option<bool>,
    compact_friends_list: ::std::option::Option<bool>,
    notifications_show_chat_room_notification: ::std::option::Option<bool>,
    sounds_play_chat_room_notification: ::std::option::Option<bool>,
    hide_offline_friends_in_tag_groups: ::std::option::Option<bool>,
    hide_categorized_friends: ::std::option::Option<bool>,
    categorize_in_game_friends_by_game: ::std::option::Option<bool>,
    chat_font_size: ::std::option::Option<i32>,
    use24hour_clock: ::std::option::Option<bool>,
    do_not_disturb_mode: ::std::option::Option<bool>,
    disable_embed_inlining: ::std::option::Option<bool>,
    sign_into_friends: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        <CChatUsability_ClientUsabilityMetrics_Notification_Settings as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        ::std::default::Default::default()
    }

    // optional bool notifications_show_ingame = 1;


    pub fn get_notifications_show_ingame(&self) -> bool {
        self.notifications_show_ingame.unwrap_or(false)
    }
    pub fn clear_notifications_show_ingame(&mut self) {
        self.notifications_show_ingame = ::std::option::Option::None;
    }

    pub fn has_notifications_show_ingame(&self) -> bool {
        self.notifications_show_ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_ingame(&mut self, v: bool) {
        self.notifications_show_ingame = ::std::option::Option::Some(v);
    }

    // optional bool notifications_show_online = 2;


    pub fn get_notifications_show_online(&self) -> bool {
        self.notifications_show_online.unwrap_or(false)
    }
    pub fn clear_notifications_show_online(&mut self) {
        self.notifications_show_online = ::std::option::Option::None;
    }

    pub fn has_notifications_show_online(&self) -> bool {
        self.notifications_show_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_online(&mut self, v: bool) {
        self.notifications_show_online = ::std::option::Option::Some(v);
    }

    // optional bool notifications_show_message = 3;


    pub fn get_notifications_show_message(&self) -> bool {
        self.notifications_show_message.unwrap_or(false)
    }
    pub fn clear_notifications_show_message(&mut self) {
        self.notifications_show_message = ::std::option::Option::None;
    }

    pub fn has_notifications_show_message(&self) -> bool {
        self.notifications_show_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_message(&mut self, v: bool) {
        self.notifications_show_message = ::std::option::Option::Some(v);
    }

    // optional bool notifications_events_and_announcements = 4;


    pub fn get_notifications_events_and_announcements(&self) -> bool {
        self.notifications_events_and_announcements.unwrap_or(false)
    }
    pub fn clear_notifications_events_and_announcements(&mut self) {
        self.notifications_events_and_announcements = ::std::option::Option::None;
    }

    pub fn has_notifications_events_and_announcements(&self) -> bool {
        self.notifications_events_and_announcements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_events_and_announcements(&mut self, v: bool) {
        self.notifications_events_and_announcements = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_ingame = 5;


    pub fn get_sounds_play_ingame(&self) -> bool {
        self.sounds_play_ingame.unwrap_or(false)
    }
    pub fn clear_sounds_play_ingame(&mut self) {
        self.sounds_play_ingame = ::std::option::Option::None;
    }

    pub fn has_sounds_play_ingame(&self) -> bool {
        self.sounds_play_ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_ingame(&mut self, v: bool) {
        self.sounds_play_ingame = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_online = 6;


    pub fn get_sounds_play_online(&self) -> bool {
        self.sounds_play_online.unwrap_or(false)
    }
    pub fn clear_sounds_play_online(&mut self) {
        self.sounds_play_online = ::std::option::Option::None;
    }

    pub fn has_sounds_play_online(&self) -> bool {
        self.sounds_play_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_online(&mut self, v: bool) {
        self.sounds_play_online = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_message = 7;


    pub fn get_sounds_play_message(&self) -> bool {
        self.sounds_play_message.unwrap_or(false)
    }
    pub fn clear_sounds_play_message(&mut self) {
        self.sounds_play_message = ::std::option::Option::None;
    }

    pub fn has_sounds_play_message(&self) -> bool {
        self.sounds_play_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_message(&mut self, v: bool) {
        self.sounds_play_message = ::std::option::Option::Some(v);
    }

    // optional bool sounds_events_and_announcements = 8;


    pub fn get_sounds_events_and_announcements(&self) -> bool {
        self.sounds_events_and_announcements.unwrap_or(false)
    }
    pub fn clear_sounds_events_and_announcements(&mut self) {
        self.sounds_events_and_announcements = ::std::option::Option::None;
    }

    pub fn has_sounds_events_and_announcements(&self) -> bool {
        self.sounds_events_and_announcements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_events_and_announcements(&mut self, v: bool) {
        self.sounds_events_and_announcements = ::std::option::Option::Some(v);
    }

    // optional bool always_new_chat_window = 9;


    pub fn get_always_new_chat_window(&self) -> bool {
        self.always_new_chat_window.unwrap_or(false)
    }
    pub fn clear_always_new_chat_window(&mut self) {
        self.always_new_chat_window = ::std::option::Option::None;
    }

    pub fn has_always_new_chat_window(&self) -> bool {
        self.always_new_chat_window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_always_new_chat_window(&mut self, v: bool) {
        self.always_new_chat_window = ::std::option::Option::Some(v);
    }

    // optional bool force_alphabetic_friend_sorting = 10;


    pub fn get_force_alphabetic_friend_sorting(&self) -> bool {
        self.force_alphabetic_friend_sorting.unwrap_or(false)
    }
    pub fn clear_force_alphabetic_friend_sorting(&mut self) {
        self.force_alphabetic_friend_sorting = ::std::option::Option::None;
    }

    pub fn has_force_alphabetic_friend_sorting(&self) -> bool {
        self.force_alphabetic_friend_sorting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_alphabetic_friend_sorting(&mut self, v: bool) {
        self.force_alphabetic_friend_sorting = ::std::option::Option::Some(v);
    }

    // optional int32 chat_flash_mode = 11;


    pub fn get_chat_flash_mode(&self) -> i32 {
        self.chat_flash_mode.unwrap_or(0)
    }
    pub fn clear_chat_flash_mode(&mut self) {
        self.chat_flash_mode = ::std::option::Option::None;
    }

    pub fn has_chat_flash_mode(&self) -> bool {
        self.chat_flash_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_flash_mode(&mut self, v: i32) {
        self.chat_flash_mode = ::std::option::Option::Some(v);
    }

    // optional bool remember_open_chats = 12;


    pub fn get_remember_open_chats(&self) -> bool {
        self.remember_open_chats.unwrap_or(false)
    }
    pub fn clear_remember_open_chats(&mut self) {
        self.remember_open_chats = ::std::option::Option::None;
    }

    pub fn has_remember_open_chats(&self) -> bool {
        self.remember_open_chats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remember_open_chats(&mut self, v: bool) {
        self.remember_open_chats = ::std::option::Option::Some(v);
    }

    // optional bool compact_quick_access = 13;


    pub fn get_compact_quick_access(&self) -> bool {
        self.compact_quick_access.unwrap_or(false)
    }
    pub fn clear_compact_quick_access(&mut self) {
        self.compact_quick_access = ::std::option::Option::None;
    }

    pub fn has_compact_quick_access(&self) -> bool {
        self.compact_quick_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compact_quick_access(&mut self, v: bool) {
        self.compact_quick_access = ::std::option::Option::Some(v);
    }

    // optional bool compact_friends_list = 14;


    pub fn get_compact_friends_list(&self) -> bool {
        self.compact_friends_list.unwrap_or(false)
    }
    pub fn clear_compact_friends_list(&mut self) {
        self.compact_friends_list = ::std::option::Option::None;
    }

    pub fn has_compact_friends_list(&self) -> bool {
        self.compact_friends_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compact_friends_list(&mut self, v: bool) {
        self.compact_friends_list = ::std::option::Option::Some(v);
    }

    // optional bool notifications_show_chat_room_notification = 15;


    pub fn get_notifications_show_chat_room_notification(&self) -> bool {
        self.notifications_show_chat_room_notification.unwrap_or(false)
    }
    pub fn clear_notifications_show_chat_room_notification(&mut self) {
        self.notifications_show_chat_room_notification = ::std::option::Option::None;
    }

    pub fn has_notifications_show_chat_room_notification(&self) -> bool {
        self.notifications_show_chat_room_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_show_chat_room_notification(&mut self, v: bool) {
        self.notifications_show_chat_room_notification = ::std::option::Option::Some(v);
    }

    // optional bool sounds_play_chat_room_notification = 16;


    pub fn get_sounds_play_chat_room_notification(&self) -> bool {
        self.sounds_play_chat_room_notification.unwrap_or(false)
    }
    pub fn clear_sounds_play_chat_room_notification(&mut self) {
        self.sounds_play_chat_room_notification = ::std::option::Option::None;
    }

    pub fn has_sounds_play_chat_room_notification(&self) -> bool {
        self.sounds_play_chat_room_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_play_chat_room_notification(&mut self, v: bool) {
        self.sounds_play_chat_room_notification = ::std::option::Option::Some(v);
    }

    // optional bool hide_offline_friends_in_tag_groups = 17;


    pub fn get_hide_offline_friends_in_tag_groups(&self) -> bool {
        self.hide_offline_friends_in_tag_groups.unwrap_or(false)
    }
    pub fn clear_hide_offline_friends_in_tag_groups(&mut self) {
        self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
    }

    pub fn has_hide_offline_friends_in_tag_groups(&self) -> bool {
        self.hide_offline_friends_in_tag_groups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_offline_friends_in_tag_groups(&mut self, v: bool) {
        self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(v);
    }

    // optional bool hide_categorized_friends = 18;


    pub fn get_hide_categorized_friends(&self) -> bool {
        self.hide_categorized_friends.unwrap_or(false)
    }
    pub fn clear_hide_categorized_friends(&mut self) {
        self.hide_categorized_friends = ::std::option::Option::None;
    }

    pub fn has_hide_categorized_friends(&self) -> bool {
        self.hide_categorized_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_categorized_friends(&mut self, v: bool) {
        self.hide_categorized_friends = ::std::option::Option::Some(v);
    }

    // optional bool categorize_in_game_friends_by_game = 19;


    pub fn get_categorize_in_game_friends_by_game(&self) -> bool {
        self.categorize_in_game_friends_by_game.unwrap_or(false)
    }
    pub fn clear_categorize_in_game_friends_by_game(&mut self) {
        self.categorize_in_game_friends_by_game = ::std::option::Option::None;
    }

    pub fn has_categorize_in_game_friends_by_game(&self) -> bool {
        self.categorize_in_game_friends_by_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_categorize_in_game_friends_by_game(&mut self, v: bool) {
        self.categorize_in_game_friends_by_game = ::std::option::Option::Some(v);
    }

    // optional int32 chat_font_size = 20;


    pub fn get_chat_font_size(&self) -> i32 {
        self.chat_font_size.unwrap_or(0)
    }
    pub fn clear_chat_font_size(&mut self) {
        self.chat_font_size = ::std::option::Option::None;
    }

    pub fn has_chat_font_size(&self) -> bool {
        self.chat_font_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_font_size(&mut self, v: i32) {
        self.chat_font_size = ::std::option::Option::Some(v);
    }

    // optional bool use24hour_clock = 21;


    pub fn get_use24hour_clock(&self) -> bool {
        self.use24hour_clock.unwrap_or(false)
    }
    pub fn clear_use24hour_clock(&mut self) {
        self.use24hour_clock = ::std::option::Option::None;
    }

    pub fn has_use24hour_clock(&self) -> bool {
        self.use24hour_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use24hour_clock(&mut self, v: bool) {
        self.use24hour_clock = ::std::option::Option::Some(v);
    }

    // optional bool do_not_disturb_mode = 22;


    pub fn get_do_not_disturb_mode(&self) -> bool {
        self.do_not_disturb_mode.unwrap_or(false)
    }
    pub fn clear_do_not_disturb_mode(&mut self) {
        self.do_not_disturb_mode = ::std::option::Option::None;
    }

    pub fn has_do_not_disturb_mode(&self) -> bool {
        self.do_not_disturb_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_not_disturb_mode(&mut self, v: bool) {
        self.do_not_disturb_mode = ::std::option::Option::Some(v);
    }

    // optional bool disable_embed_inlining = 23;


    pub fn get_disable_embed_inlining(&self) -> bool {
        self.disable_embed_inlining.unwrap_or(false)
    }
    pub fn clear_disable_embed_inlining(&mut self) {
        self.disable_embed_inlining = ::std::option::Option::None;
    }

    pub fn has_disable_embed_inlining(&self) -> bool {
        self.disable_embed_inlining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_embed_inlining(&mut self, v: bool) {
        self.disable_embed_inlining = ::std::option::Option::Some(v);
    }

    // optional bool sign_into_friends = 24;


    pub fn get_sign_into_friends(&self) -> bool {
        self.sign_into_friends.unwrap_or(false)
    }
    pub fn clear_sign_into_friends(&mut self) {
        self.sign_into_friends = ::std::option::Option::None;
    }

    pub fn has_sign_into_friends(&self) -> bool {
        self.sign_into_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign_into_friends(&mut self, v: bool) {
        self.sign_into_friends = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_ingame = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_online = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_message = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_events_and_announcements = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_ingame = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_online = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_message = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_events_and_announcements = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.always_new_chat_window = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_alphabetic_friend_sorting = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_flash_mode = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remember_open_chats = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compact_quick_access = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compact_friends_list = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notifications_show_chat_room_notification = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sounds_play_chat_room_notification = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide_categorized_friends = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.categorize_in_game_friends_by_game = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_font_size = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use24hour_clock = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.do_not_disturb_mode = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_embed_inlining = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sign_into_friends = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.notifications_show_ingame {
            my_size += 2;
        }
        if let Some(v) = self.notifications_show_online {
            my_size += 2;
        }
        if let Some(v) = self.notifications_show_message {
            my_size += 2;
        }
        if let Some(v) = self.notifications_events_and_announcements {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_ingame {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_online {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_message {
            my_size += 2;
        }
        if let Some(v) = self.sounds_events_and_announcements {
            my_size += 2;
        }
        if let Some(v) = self.always_new_chat_window {
            my_size += 2;
        }
        if let Some(v) = self.force_alphabetic_friend_sorting {
            my_size += 2;
        }
        if let Some(v) = self.chat_flash_mode {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remember_open_chats {
            my_size += 2;
        }
        if let Some(v) = self.compact_quick_access {
            my_size += 2;
        }
        if let Some(v) = self.compact_friends_list {
            my_size += 2;
        }
        if let Some(v) = self.notifications_show_chat_room_notification {
            my_size += 2;
        }
        if let Some(v) = self.sounds_play_chat_room_notification {
            my_size += 3;
        }
        if let Some(v) = self.hide_offline_friends_in_tag_groups {
            my_size += 3;
        }
        if let Some(v) = self.hide_categorized_friends {
            my_size += 3;
        }
        if let Some(v) = self.categorize_in_game_friends_by_game {
            my_size += 3;
        }
        if let Some(v) = self.chat_font_size {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use24hour_clock {
            my_size += 3;
        }
        if let Some(v) = self.do_not_disturb_mode {
            my_size += 3;
        }
        if let Some(v) = self.disable_embed_inlining {
            my_size += 3;
        }
        if let Some(v) = self.sign_into_friends {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.notifications_show_ingame {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.notifications_show_online {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.notifications_show_message {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.notifications_events_and_announcements {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.sounds_play_ingame {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.sounds_play_online {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.sounds_play_message {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.sounds_events_and_announcements {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.always_new_chat_window {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.force_alphabetic_friend_sorting {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.chat_flash_mode {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.remember_open_chats {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.compact_quick_access {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.compact_friends_list {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.notifications_show_chat_room_notification {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.sounds_play_chat_room_notification {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.hide_offline_friends_in_tag_groups {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.hide_categorized_friends {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.categorize_in_game_friends_by_game {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.chat_font_size {
            os.write_int32(20, v)?;
        }
        if let Some(v) = self.use24hour_clock {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.do_not_disturb_mode {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.disable_embed_inlining {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.sign_into_friends {
            os.write_bool(24, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        CChatUsability_ClientUsabilityMetrics_Notification_Settings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notifications_show_ingame",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_ingame },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_ingame },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notifications_show_online",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_online },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_online },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notifications_show_message",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_message },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notifications_events_and_announcements",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_events_and_announcements },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_events_and_announcements },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sounds_play_ingame",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_ingame },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_ingame },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sounds_play_online",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_online },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_online },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sounds_play_message",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_message },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sounds_events_and_announcements",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_events_and_announcements },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_events_and_announcements },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "always_new_chat_window",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.always_new_chat_window },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.always_new_chat_window },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force_alphabetic_friend_sorting",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.force_alphabetic_friend_sorting },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.force_alphabetic_friend_sorting },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "chat_flash_mode",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.chat_flash_mode },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.chat_flash_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remember_open_chats",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.remember_open_chats },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.remember_open_chats },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "compact_quick_access",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.compact_quick_access },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.compact_quick_access },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "compact_friends_list",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.compact_friends_list },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.compact_friends_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notifications_show_chat_room_notification",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.notifications_show_chat_room_notification },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.notifications_show_chat_room_notification },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sounds_play_chat_room_notification",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sounds_play_chat_room_notification },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sounds_play_chat_room_notification },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hide_offline_friends_in_tag_groups",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.hide_offline_friends_in_tag_groups },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.hide_offline_friends_in_tag_groups },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hide_categorized_friends",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.hide_categorized_friends },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.hide_categorized_friends },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "categorize_in_game_friends_by_game",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.categorize_in_game_friends_by_game },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.categorize_in_game_friends_by_game },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "chat_font_size",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.chat_font_size },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.chat_font_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use24hour_clock",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.use24hour_clock },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.use24hour_clock },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "do_not_disturb_mode",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.do_not_disturb_mode },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.do_not_disturb_mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disable_embed_inlining",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.disable_embed_inlining },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.disable_embed_inlining },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sign_into_friends",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &m.sign_into_friends },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Settings| { &mut m.sign_into_friends },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatUsability_ClientUsabilityMetrics_Notification_Settings>(
                    "CChatUsability_ClientUsabilityMetrics_Notification_Settings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_Settings {
        static mut instance: ::protobuf::lazy::Lazy<CChatUsability_ClientUsabilityMetrics_Notification_Settings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatUsability_ClientUsabilityMetrics_Notification_Settings,
        };
        unsafe {
            instance.get(CChatUsability_ClientUsabilityMetrics_Notification_Settings::new)
        }
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn clear(&mut self) {
        self.notifications_show_ingame = ::std::option::Option::None;
        self.notifications_show_online = ::std::option::Option::None;
        self.notifications_show_message = ::std::option::Option::None;
        self.notifications_events_and_announcements = ::std::option::Option::None;
        self.sounds_play_ingame = ::std::option::Option::None;
        self.sounds_play_online = ::std::option::Option::None;
        self.sounds_play_message = ::std::option::Option::None;
        self.sounds_events_and_announcements = ::std::option::Option::None;
        self.always_new_chat_window = ::std::option::Option::None;
        self.force_alphabetic_friend_sorting = ::std::option::Option::None;
        self.chat_flash_mode = ::std::option::Option::None;
        self.remember_open_chats = ::std::option::Option::None;
        self.compact_quick_access = ::std::option::Option::None;
        self.compact_friends_list = ::std::option::Option::None;
        self.notifications_show_chat_room_notification = ::std::option::Option::None;
        self.sounds_play_chat_room_notification = ::std::option::Option::None;
        self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
        self.hide_categorized_friends = ::std::option::Option::None;
        self.categorize_in_game_friends_by_game = ::std::option::Option::None;
        self.chat_font_size = ::std::option::Option::None;
        self.use24hour_clock = ::std::option::Option::None;
        self.do_not_disturb_mode = ::std::option::Option::None;
        self.disable_embed_inlining = ::std::option::Option::None;
        self.sign_into_friends = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_Settings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    // message fields
    voice_input_gain: ::std::option::Option<f32>,
    voice_output_gain: ::std::option::Option<f32>,
    noise_gate_level: ::std::option::Option<i32>,
    voice_use_echo_cancellation: ::std::option::Option<bool>,
    voice_use_noise_cancellation: ::std::option::Option<bool>,
    voice_use_auto_gain_control: ::std::option::Option<bool>,
    selected_non_default_mic: ::std::option::Option<bool>,
    selected_non_default_output: ::std::option::Option<bool>,
    push_to_talk_enabled: ::std::option::Option<bool>,
    push_to_mute_enabled: ::std::option::Option<bool>,
    play_ptt_sounds: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        <CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        ::std::default::Default::default()
    }

    // optional float voice_input_gain = 1;


    pub fn get_voice_input_gain(&self) -> f32 {
        self.voice_input_gain.unwrap_or(0.)
    }
    pub fn clear_voice_input_gain(&mut self) {
        self.voice_input_gain = ::std::option::Option::None;
    }

    pub fn has_voice_input_gain(&self) -> bool {
        self.voice_input_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_input_gain(&mut self, v: f32) {
        self.voice_input_gain = ::std::option::Option::Some(v);
    }

    // optional float voice_output_gain = 2;


    pub fn get_voice_output_gain(&self) -> f32 {
        self.voice_output_gain.unwrap_or(0.)
    }
    pub fn clear_voice_output_gain(&mut self) {
        self.voice_output_gain = ::std::option::Option::None;
    }

    pub fn has_voice_output_gain(&self) -> bool {
        self.voice_output_gain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_output_gain(&mut self, v: f32) {
        self.voice_output_gain = ::std::option::Option::Some(v);
    }

    // optional int32 noise_gate_level = 3;


    pub fn get_noise_gate_level(&self) -> i32 {
        self.noise_gate_level.unwrap_or(0)
    }
    pub fn clear_noise_gate_level(&mut self) {
        self.noise_gate_level = ::std::option::Option::None;
    }

    pub fn has_noise_gate_level(&self) -> bool {
        self.noise_gate_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_noise_gate_level(&mut self, v: i32) {
        self.noise_gate_level = ::std::option::Option::Some(v);
    }

    // optional bool voice_use_echo_cancellation = 4;


    pub fn get_voice_use_echo_cancellation(&self) -> bool {
        self.voice_use_echo_cancellation.unwrap_or(false)
    }
    pub fn clear_voice_use_echo_cancellation(&mut self) {
        self.voice_use_echo_cancellation = ::std::option::Option::None;
    }

    pub fn has_voice_use_echo_cancellation(&self) -> bool {
        self.voice_use_echo_cancellation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_use_echo_cancellation(&mut self, v: bool) {
        self.voice_use_echo_cancellation = ::std::option::Option::Some(v);
    }

    // optional bool voice_use_noise_cancellation = 5;


    pub fn get_voice_use_noise_cancellation(&self) -> bool {
        self.voice_use_noise_cancellation.unwrap_or(false)
    }
    pub fn clear_voice_use_noise_cancellation(&mut self) {
        self.voice_use_noise_cancellation = ::std::option::Option::None;
    }

    pub fn has_voice_use_noise_cancellation(&self) -> bool {
        self.voice_use_noise_cancellation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_use_noise_cancellation(&mut self, v: bool) {
        self.voice_use_noise_cancellation = ::std::option::Option::Some(v);
    }

    // optional bool voice_use_auto_gain_control = 6;


    pub fn get_voice_use_auto_gain_control(&self) -> bool {
        self.voice_use_auto_gain_control.unwrap_or(false)
    }
    pub fn clear_voice_use_auto_gain_control(&mut self) {
        self.voice_use_auto_gain_control = ::std::option::Option::None;
    }

    pub fn has_voice_use_auto_gain_control(&self) -> bool {
        self.voice_use_auto_gain_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_use_auto_gain_control(&mut self, v: bool) {
        self.voice_use_auto_gain_control = ::std::option::Option::Some(v);
    }

    // optional bool selected_non_default_mic = 7;


    pub fn get_selected_non_default_mic(&self) -> bool {
        self.selected_non_default_mic.unwrap_or(false)
    }
    pub fn clear_selected_non_default_mic(&mut self) {
        self.selected_non_default_mic = ::std::option::Option::None;
    }

    pub fn has_selected_non_default_mic(&self) -> bool {
        self.selected_non_default_mic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_non_default_mic(&mut self, v: bool) {
        self.selected_non_default_mic = ::std::option::Option::Some(v);
    }

    // optional bool selected_non_default_output = 8;


    pub fn get_selected_non_default_output(&self) -> bool {
        self.selected_non_default_output.unwrap_or(false)
    }
    pub fn clear_selected_non_default_output(&mut self) {
        self.selected_non_default_output = ::std::option::Option::None;
    }

    pub fn has_selected_non_default_output(&self) -> bool {
        self.selected_non_default_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_non_default_output(&mut self, v: bool) {
        self.selected_non_default_output = ::std::option::Option::Some(v);
    }

    // optional bool push_to_talk_enabled = 9;


    pub fn get_push_to_talk_enabled(&self) -> bool {
        self.push_to_talk_enabled.unwrap_or(false)
    }
    pub fn clear_push_to_talk_enabled(&mut self) {
        self.push_to_talk_enabled = ::std::option::Option::None;
    }

    pub fn has_push_to_talk_enabled(&self) -> bool {
        self.push_to_talk_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_to_talk_enabled(&mut self, v: bool) {
        self.push_to_talk_enabled = ::std::option::Option::Some(v);
    }

    // optional bool push_to_mute_enabled = 10;


    pub fn get_push_to_mute_enabled(&self) -> bool {
        self.push_to_mute_enabled.unwrap_or(false)
    }
    pub fn clear_push_to_mute_enabled(&mut self) {
        self.push_to_mute_enabled = ::std::option::Option::None;
    }

    pub fn has_push_to_mute_enabled(&self) -> bool {
        self.push_to_mute_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_to_mute_enabled(&mut self, v: bool) {
        self.push_to_mute_enabled = ::std::option::Option::Some(v);
    }

    // optional bool play_ptt_sounds = 11;


    pub fn get_play_ptt_sounds(&self) -> bool {
        self.play_ptt_sounds.unwrap_or(false)
    }
    pub fn clear_play_ptt_sounds(&mut self) {
        self.play_ptt_sounds = ::std::option::Option::None;
    }

    pub fn has_play_ptt_sounds(&self) -> bool {
        self.play_ptt_sounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_play_ptt_sounds(&mut self, v: bool) {
        self.play_ptt_sounds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.voice_input_gain = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.voice_output_gain = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.noise_gate_level = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_use_echo_cancellation = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_use_noise_cancellation = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voice_use_auto_gain_control = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selected_non_default_mic = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.selected_non_default_output = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.push_to_talk_enabled = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.push_to_mute_enabled = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.play_ptt_sounds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.voice_input_gain {
            my_size += 5;
        }
        if let Some(v) = self.voice_output_gain {
            my_size += 5;
        }
        if let Some(v) = self.noise_gate_level {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.voice_use_echo_cancellation {
            my_size += 2;
        }
        if let Some(v) = self.voice_use_noise_cancellation {
            my_size += 2;
        }
        if let Some(v) = self.voice_use_auto_gain_control {
            my_size += 2;
        }
        if let Some(v) = self.selected_non_default_mic {
            my_size += 2;
        }
        if let Some(v) = self.selected_non_default_output {
            my_size += 2;
        }
        if let Some(v) = self.push_to_talk_enabled {
            my_size += 2;
        }
        if let Some(v) = self.push_to_mute_enabled {
            my_size += 2;
        }
        if let Some(v) = self.play_ptt_sounds {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.voice_input_gain {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.voice_output_gain {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.noise_gate_level {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.voice_use_echo_cancellation {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.voice_use_noise_cancellation {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.voice_use_auto_gain_control {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.selected_non_default_mic {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.selected_non_default_output {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.push_to_talk_enabled {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.push_to_mute_enabled {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.play_ptt_sounds {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "voice_input_gain",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_input_gain },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_input_gain },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "voice_output_gain",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_output_gain },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_output_gain },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "noise_gate_level",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.noise_gate_level },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.noise_gate_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "voice_use_echo_cancellation",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_use_echo_cancellation },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_use_echo_cancellation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "voice_use_noise_cancellation",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_use_noise_cancellation },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_use_noise_cancellation },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "voice_use_auto_gain_control",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.voice_use_auto_gain_control },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.voice_use_auto_gain_control },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "selected_non_default_mic",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.selected_non_default_mic },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.selected_non_default_mic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "selected_non_default_output",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.selected_non_default_output },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.selected_non_default_output },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "push_to_talk_enabled",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.push_to_talk_enabled },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.push_to_talk_enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "push_to_mute_enabled",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.push_to_mute_enabled },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.push_to_mute_enabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "play_ptt_sounds",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &m.play_ptt_sounds },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings| { &mut m.play_ptt_sounds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings>(
                    "CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
        static mut instance: ::protobuf::lazy::Lazy<CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings,
        };
        unsafe {
            instance.get(CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings::new)
        }
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn clear(&mut self) {
        self.voice_input_gain = ::std::option::Option::None;
        self.voice_output_gain = ::std::option::Option::None;
        self.noise_gate_level = ::std::option::Option::None;
        self.voice_use_echo_cancellation = ::std::option::Option::None;
        self.voice_use_noise_cancellation = ::std::option::Option::None;
        self.voice_use_auto_gain_control = ::std::option::Option::None;
        self.selected_non_default_mic = ::std::option::Option::None;
        self.selected_non_default_output = ::std::option::Option::None;
        self.push_to_talk_enabled = ::std::option::Option::None;
        self.push_to_mute_enabled = ::std::option::Option::None;
        self.play_ptt_sounds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    // message fields
    friends_list_height: ::std::option::Option<i32>,
    friends_list_width: ::std::option::Option<i32>,
    friends_list_docked: ::std::option::Option<bool>,
    friends_list_collapsed: ::std::option::Option<bool>,
    friends_list_group_chats_height: ::std::option::Option<i32>,
    friends_list_visible: ::std::option::Option<bool>,
    chat_popups_opened: ::std::option::Option<i32>,
    group_chat_tabs_opened: ::std::option::Option<i32>,
    friend_chat_tabs_opened: ::std::option::Option<i32>,
    chat_window_width: ::std::option::Option<i32>,
    chat_window_height: ::std::option::Option<i32>,
    category_collapse: ::protobuf::SingularPtrField<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState>,
    group_chat_left_col_collapsed: ::std::option::Option<i32>,
    group_chat_right_col_collapsed: ::std::option::Option<i32>,
    in_one_on_one_voice_chat: ::std::option::Option<bool>,
    in_group_voice_chat: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        <CChatUsability_ClientUsabilityMetrics_Notification_UIState as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        ::std::default::Default::default()
    }

    // optional int32 friends_list_height = 1;


    pub fn get_friends_list_height(&self) -> i32 {
        self.friends_list_height.unwrap_or(0)
    }
    pub fn clear_friends_list_height(&mut self) {
        self.friends_list_height = ::std::option::Option::None;
    }

    pub fn has_friends_list_height(&self) -> bool {
        self.friends_list_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_height(&mut self, v: i32) {
        self.friends_list_height = ::std::option::Option::Some(v);
    }

    // optional int32 friends_list_width = 2;


    pub fn get_friends_list_width(&self) -> i32 {
        self.friends_list_width.unwrap_or(0)
    }
    pub fn clear_friends_list_width(&mut self) {
        self.friends_list_width = ::std::option::Option::None;
    }

    pub fn has_friends_list_width(&self) -> bool {
        self.friends_list_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_width(&mut self, v: i32) {
        self.friends_list_width = ::std::option::Option::Some(v);
    }

    // optional bool friends_list_docked = 3;


    pub fn get_friends_list_docked(&self) -> bool {
        self.friends_list_docked.unwrap_or(false)
    }
    pub fn clear_friends_list_docked(&mut self) {
        self.friends_list_docked = ::std::option::Option::None;
    }

    pub fn has_friends_list_docked(&self) -> bool {
        self.friends_list_docked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_docked(&mut self, v: bool) {
        self.friends_list_docked = ::std::option::Option::Some(v);
    }

    // optional bool friends_list_collapsed = 4;


    pub fn get_friends_list_collapsed(&self) -> bool {
        self.friends_list_collapsed.unwrap_or(false)
    }
    pub fn clear_friends_list_collapsed(&mut self) {
        self.friends_list_collapsed = ::std::option::Option::None;
    }

    pub fn has_friends_list_collapsed(&self) -> bool {
        self.friends_list_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_collapsed(&mut self, v: bool) {
        self.friends_list_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 friends_list_group_chats_height = 5;


    pub fn get_friends_list_group_chats_height(&self) -> i32 {
        self.friends_list_group_chats_height.unwrap_or(0)
    }
    pub fn clear_friends_list_group_chats_height(&mut self) {
        self.friends_list_group_chats_height = ::std::option::Option::None;
    }

    pub fn has_friends_list_group_chats_height(&self) -> bool {
        self.friends_list_group_chats_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_group_chats_height(&mut self, v: i32) {
        self.friends_list_group_chats_height = ::std::option::Option::Some(v);
    }

    // optional bool friends_list_visible = 6;


    pub fn get_friends_list_visible(&self) -> bool {
        self.friends_list_visible.unwrap_or(false)
    }
    pub fn clear_friends_list_visible(&mut self) {
        self.friends_list_visible = ::std::option::Option::None;
    }

    pub fn has_friends_list_visible(&self) -> bool {
        self.friends_list_visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_list_visible(&mut self, v: bool) {
        self.friends_list_visible = ::std::option::Option::Some(v);
    }

    // optional int32 chat_popups_opened = 7;


    pub fn get_chat_popups_opened(&self) -> i32 {
        self.chat_popups_opened.unwrap_or(0)
    }
    pub fn clear_chat_popups_opened(&mut self) {
        self.chat_popups_opened = ::std::option::Option::None;
    }

    pub fn has_chat_popups_opened(&self) -> bool {
        self.chat_popups_opened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_popups_opened(&mut self, v: i32) {
        self.chat_popups_opened = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_tabs_opened = 8;


    pub fn get_group_chat_tabs_opened(&self) -> i32 {
        self.group_chat_tabs_opened.unwrap_or(0)
    }
    pub fn clear_group_chat_tabs_opened(&mut self) {
        self.group_chat_tabs_opened = ::std::option::Option::None;
    }

    pub fn has_group_chat_tabs_opened(&self) -> bool {
        self.group_chat_tabs_opened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_tabs_opened(&mut self, v: i32) {
        self.group_chat_tabs_opened = ::std::option::Option::Some(v);
    }

    // optional int32 friend_chat_tabs_opened = 9;


    pub fn get_friend_chat_tabs_opened(&self) -> i32 {
        self.friend_chat_tabs_opened.unwrap_or(0)
    }
    pub fn clear_friend_chat_tabs_opened(&mut self) {
        self.friend_chat_tabs_opened = ::std::option::Option::None;
    }

    pub fn has_friend_chat_tabs_opened(&self) -> bool {
        self.friend_chat_tabs_opened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_chat_tabs_opened(&mut self, v: i32) {
        self.friend_chat_tabs_opened = ::std::option::Option::Some(v);
    }

    // optional int32 chat_window_width = 10;


    pub fn get_chat_window_width(&self) -> i32 {
        self.chat_window_width.unwrap_or(0)
    }
    pub fn clear_chat_window_width(&mut self) {
        self.chat_window_width = ::std::option::Option::None;
    }

    pub fn has_chat_window_width(&self) -> bool {
        self.chat_window_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_window_width(&mut self, v: i32) {
        self.chat_window_width = ::std::option::Option::Some(v);
    }

    // optional int32 chat_window_height = 11;


    pub fn get_chat_window_height(&self) -> i32 {
        self.chat_window_height.unwrap_or(0)
    }
    pub fn clear_chat_window_height(&mut self) {
        self.chat_window_height = ::std::option::Option::None;
    }

    pub fn has_chat_window_height(&self) -> bool {
        self.chat_window_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_window_height(&mut self, v: i32) {
        self.chat_window_height = ::std::option::Option::Some(v);
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState category_collapse = 12;


    pub fn get_category_collapse(&self) -> &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        self.category_collapse.as_ref().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState::default_instance())
    }
    pub fn clear_category_collapse(&mut self) {
        self.category_collapse.clear();
    }

    pub fn has_category_collapse(&self) -> bool {
        self.category_collapse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_collapse(&mut self, v: CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState) {
        self.category_collapse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category_collapse(&mut self) -> &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        if self.category_collapse.is_none() {
            self.category_collapse.set_default();
        }
        self.category_collapse.as_mut().unwrap()
    }

    // Take field
    pub fn take_category_collapse(&mut self) -> CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        self.category_collapse.take().unwrap_or_else(|| CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState::new())
    }

    // optional int32 group_chat_left_col_collapsed = 13;


    pub fn get_group_chat_left_col_collapsed(&self) -> i32 {
        self.group_chat_left_col_collapsed.unwrap_or(0)
    }
    pub fn clear_group_chat_left_col_collapsed(&mut self) {
        self.group_chat_left_col_collapsed = ::std::option::Option::None;
    }

    pub fn has_group_chat_left_col_collapsed(&self) -> bool {
        self.group_chat_left_col_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_left_col_collapsed(&mut self, v: i32) {
        self.group_chat_left_col_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_right_col_collapsed = 14;


    pub fn get_group_chat_right_col_collapsed(&self) -> i32 {
        self.group_chat_right_col_collapsed.unwrap_or(0)
    }
    pub fn clear_group_chat_right_col_collapsed(&mut self) {
        self.group_chat_right_col_collapsed = ::std::option::Option::None;
    }

    pub fn has_group_chat_right_col_collapsed(&self) -> bool {
        self.group_chat_right_col_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_right_col_collapsed(&mut self, v: i32) {
        self.group_chat_right_col_collapsed = ::std::option::Option::Some(v);
    }

    // optional bool in_one_on_one_voice_chat = 15;


    pub fn get_in_one_on_one_voice_chat(&self) -> bool {
        self.in_one_on_one_voice_chat.unwrap_or(false)
    }
    pub fn clear_in_one_on_one_voice_chat(&mut self) {
        self.in_one_on_one_voice_chat = ::std::option::Option::None;
    }

    pub fn has_in_one_on_one_voice_chat(&self) -> bool {
        self.in_one_on_one_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_one_on_one_voice_chat(&mut self, v: bool) {
        self.in_one_on_one_voice_chat = ::std::option::Option::Some(v);
    }

    // optional bool in_group_voice_chat = 16;


    pub fn get_in_group_voice_chat(&self) -> bool {
        self.in_group_voice_chat.unwrap_or(false)
    }
    pub fn clear_in_group_voice_chat(&mut self) {
        self.in_group_voice_chat = ::std::option::Option::None;
    }

    pub fn has_in_group_voice_chat(&self) -> bool {
        self.in_group_voice_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_group_voice_chat(&mut self, v: bool) {
        self.in_group_voice_chat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn is_initialized(&self) -> bool {
        for v in &self.category_collapse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_list_height = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_list_width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.friends_list_docked = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.friends_list_collapsed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_list_group_chats_height = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.friends_list_visible = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_popups_opened = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_tabs_opened = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friend_chat_tabs_opened = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_window_width = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_window_height = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.category_collapse)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_left_col_collapsed = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_right_col_collapsed = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_one_on_one_voice_chat = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_group_voice_chat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friends_list_height {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_list_width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_list_docked {
            my_size += 2;
        }
        if let Some(v) = self.friends_list_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.friends_list_group_chats_height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_list_visible {
            my_size += 2;
        }
        if let Some(v) = self.chat_popups_opened {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_tabs_opened {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friend_chat_tabs_opened {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_window_width {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_window_height {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.category_collapse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.group_chat_left_col_collapsed {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_right_col_collapsed {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_one_on_one_voice_chat {
            my_size += 2;
        }
        if let Some(v) = self.in_group_voice_chat {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friends_list_height {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.friends_list_width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.friends_list_docked {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.friends_list_collapsed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.friends_list_group_chats_height {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.friends_list_visible {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.chat_popups_opened {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.group_chat_tabs_opened {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.friend_chat_tabs_opened {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.chat_window_width {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.chat_window_height {
            os.write_int32(11, v)?;
        }
        if let Some(ref v) = self.category_collapse.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.group_chat_left_col_collapsed {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.group_chat_right_col_collapsed {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.in_one_on_one_voice_chat {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.in_group_voice_chat {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        CChatUsability_ClientUsabilityMetrics_Notification_UIState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_list_height",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_height },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_list_width",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_width },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "friends_list_docked",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_docked },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_docked },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "friends_list_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_collapsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_list_group_chats_height",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_group_chats_height },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_group_chats_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "friends_list_visible",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friends_list_visible },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friends_list_visible },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "chat_popups_opened",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.chat_popups_opened },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.chat_popups_opened },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "group_chat_tabs_opened",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.group_chat_tabs_opened },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.group_chat_tabs_opened },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friend_chat_tabs_opened",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.friend_chat_tabs_opened },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.friend_chat_tabs_opened },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "chat_window_width",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.chat_window_width },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.chat_window_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "chat_window_height",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.chat_window_height },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.chat_window_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState>>(
                    "category_collapse",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.category_collapse },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.category_collapse },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "group_chat_left_col_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.group_chat_left_col_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.group_chat_left_col_collapsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "group_chat_right_col_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.group_chat_right_col_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.group_chat_right_col_collapsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "in_one_on_one_voice_chat",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.in_one_on_one_voice_chat },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.in_one_on_one_voice_chat },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "in_group_voice_chat",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &m.in_group_voice_chat },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState| { &mut m.in_group_voice_chat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatUsability_ClientUsabilityMetrics_Notification_UIState>(
                    "CChatUsability_ClientUsabilityMetrics_Notification_UIState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_UIState {
        static mut instance: ::protobuf::lazy::Lazy<CChatUsability_ClientUsabilityMetrics_Notification_UIState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatUsability_ClientUsabilityMetrics_Notification_UIState,
        };
        unsafe {
            instance.get(CChatUsability_ClientUsabilityMetrics_Notification_UIState::new)
        }
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn clear(&mut self) {
        self.friends_list_height = ::std::option::Option::None;
        self.friends_list_width = ::std::option::Option::None;
        self.friends_list_docked = ::std::option::Option::None;
        self.friends_list_collapsed = ::std::option::Option::None;
        self.friends_list_group_chats_height = ::std::option::Option::None;
        self.friends_list_visible = ::std::option::Option::None;
        self.chat_popups_opened = ::std::option::Option::None;
        self.group_chat_tabs_opened = ::std::option::Option::None;
        self.friend_chat_tabs_opened = ::std::option::Option::None;
        self.chat_window_width = ::std::option::Option::None;
        self.chat_window_height = ::std::option::Option::None;
        self.category_collapse.clear();
        self.group_chat_left_col_collapsed = ::std::option::Option::None;
        self.group_chat_right_col_collapsed = ::std::option::Option::None;
        self.in_one_on_one_voice_chat = ::std::option::Option::None;
        self.in_group_voice_chat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_UIState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    // message fields
    in_game_collapsed: ::std::option::Option<bool>,
    online_collapsed: ::std::option::Option<bool>,
    offline_collapsed: ::std::option::Option<bool>,
    game_groups_collapsed: ::std::option::Option<i32>,
    categories_collapsed: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        <CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        ::std::default::Default::default()
    }

    // optional bool in_game_collapsed = 1;


    pub fn get_in_game_collapsed(&self) -> bool {
        self.in_game_collapsed.unwrap_or(false)
    }
    pub fn clear_in_game_collapsed(&mut self) {
        self.in_game_collapsed = ::std::option::Option::None;
    }

    pub fn has_in_game_collapsed(&self) -> bool {
        self.in_game_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_collapsed(&mut self, v: bool) {
        self.in_game_collapsed = ::std::option::Option::Some(v);
    }

    // optional bool online_collapsed = 2;


    pub fn get_online_collapsed(&self) -> bool {
        self.online_collapsed.unwrap_or(false)
    }
    pub fn clear_online_collapsed(&mut self) {
        self.online_collapsed = ::std::option::Option::None;
    }

    pub fn has_online_collapsed(&self) -> bool {
        self.online_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online_collapsed(&mut self, v: bool) {
        self.online_collapsed = ::std::option::Option::Some(v);
    }

    // optional bool offline_collapsed = 3;


    pub fn get_offline_collapsed(&self) -> bool {
        self.offline_collapsed.unwrap_or(false)
    }
    pub fn clear_offline_collapsed(&mut self) {
        self.offline_collapsed = ::std::option::Option::None;
    }

    pub fn has_offline_collapsed(&self) -> bool {
        self.offline_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline_collapsed(&mut self, v: bool) {
        self.offline_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 game_groups_collapsed = 4;


    pub fn get_game_groups_collapsed(&self) -> i32 {
        self.game_groups_collapsed.unwrap_or(0)
    }
    pub fn clear_game_groups_collapsed(&mut self) {
        self.game_groups_collapsed = ::std::option::Option::None;
    }

    pub fn has_game_groups_collapsed(&self) -> bool {
        self.game_groups_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_groups_collapsed(&mut self, v: i32) {
        self.game_groups_collapsed = ::std::option::Option::Some(v);
    }

    // optional int32 categories_collapsed = 5;


    pub fn get_categories_collapsed(&self) -> i32 {
        self.categories_collapsed.unwrap_or(0)
    }
    pub fn clear_categories_collapsed(&mut self) {
        self.categories_collapsed = ::std::option::Option::None;
    }

    pub fn has_categories_collapsed(&self) -> bool {
        self.categories_collapsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_categories_collapsed(&mut self, v: i32) {
        self.categories_collapsed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_game_collapsed = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.online_collapsed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.offline_collapsed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_groups_collapsed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.categories_collapsed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.in_game_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.online_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.offline_collapsed {
            my_size += 2;
        }
        if let Some(v) = self.game_groups_collapsed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.categories_collapsed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.in_game_collapsed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.online_collapsed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.offline_collapsed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.game_groups_collapsed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.categories_collapsed {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "in_game_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.in_game_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.in_game_collapsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "online_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.online_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.online_collapsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "offline_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.offline_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.offline_collapsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "game_groups_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.game_groups_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.game_groups_collapsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "categories_collapsed",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &m.categories_collapsed },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState| { &mut m.categories_collapsed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState>(
                    "CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
        static mut instance: ::protobuf::lazy::Lazy<CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState,
        };
        unsafe {
            instance.get(CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState::new)
        }
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn clear(&mut self) {
        self.in_game_collapsed = ::std::option::Option::None;
        self.online_collapsed = ::std::option::Option::None;
        self.offline_collapsed = ::std::option::Option::None;
        self.game_groups_collapsed = ::std::option::Option::None;
        self.categories_collapsed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_UIState_CategoryCollapseState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    // message fields
    friends_count: ::std::option::Option<i32>,
    friends_category_count: ::std::option::Option<i32>,
    friends_categorized_count: ::std::option::Option<i32>,
    friends_online_count: ::std::option::Option<i32>,
    friends_in_game_count: ::std::option::Option<i32>,
    friends_in_game_singleton_count: ::std::option::Option<i32>,
    game_group_count: ::std::option::Option<i32>,
    friends_favorite_count: ::std::option::Option<i32>,
    group_chat_count: ::std::option::Option<i32>,
    group_chat_favorite_count: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        <CChatUsability_ClientUsabilityMetrics_Notification_Metrics as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        ::std::default::Default::default()
    }

    // optional int32 friends_count = 1;


    pub fn get_friends_count(&self) -> i32 {
        self.friends_count.unwrap_or(0)
    }
    pub fn clear_friends_count(&mut self) {
        self.friends_count = ::std::option::Option::None;
    }

    pub fn has_friends_count(&self) -> bool {
        self.friends_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_count(&mut self, v: i32) {
        self.friends_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_category_count = 2;


    pub fn get_friends_category_count(&self) -> i32 {
        self.friends_category_count.unwrap_or(0)
    }
    pub fn clear_friends_category_count(&mut self) {
        self.friends_category_count = ::std::option::Option::None;
    }

    pub fn has_friends_category_count(&self) -> bool {
        self.friends_category_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_category_count(&mut self, v: i32) {
        self.friends_category_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_categorized_count = 3;


    pub fn get_friends_categorized_count(&self) -> i32 {
        self.friends_categorized_count.unwrap_or(0)
    }
    pub fn clear_friends_categorized_count(&mut self) {
        self.friends_categorized_count = ::std::option::Option::None;
    }

    pub fn has_friends_categorized_count(&self) -> bool {
        self.friends_categorized_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_categorized_count(&mut self, v: i32) {
        self.friends_categorized_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_online_count = 4;


    pub fn get_friends_online_count(&self) -> i32 {
        self.friends_online_count.unwrap_or(0)
    }
    pub fn clear_friends_online_count(&mut self) {
        self.friends_online_count = ::std::option::Option::None;
    }

    pub fn has_friends_online_count(&self) -> bool {
        self.friends_online_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_online_count(&mut self, v: i32) {
        self.friends_online_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_in_game_count = 5;


    pub fn get_friends_in_game_count(&self) -> i32 {
        self.friends_in_game_count.unwrap_or(0)
    }
    pub fn clear_friends_in_game_count(&mut self) {
        self.friends_in_game_count = ::std::option::Option::None;
    }

    pub fn has_friends_in_game_count(&self) -> bool {
        self.friends_in_game_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_in_game_count(&mut self, v: i32) {
        self.friends_in_game_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_in_game_singleton_count = 6;


    pub fn get_friends_in_game_singleton_count(&self) -> i32 {
        self.friends_in_game_singleton_count.unwrap_or(0)
    }
    pub fn clear_friends_in_game_singleton_count(&mut self) {
        self.friends_in_game_singleton_count = ::std::option::Option::None;
    }

    pub fn has_friends_in_game_singleton_count(&self) -> bool {
        self.friends_in_game_singleton_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_in_game_singleton_count(&mut self, v: i32) {
        self.friends_in_game_singleton_count = ::std::option::Option::Some(v);
    }

    // optional int32 game_group_count = 7;


    pub fn get_game_group_count(&self) -> i32 {
        self.game_group_count.unwrap_or(0)
    }
    pub fn clear_game_group_count(&mut self) {
        self.game_group_count = ::std::option::Option::None;
    }

    pub fn has_game_group_count(&self) -> bool {
        self.game_group_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_group_count(&mut self, v: i32) {
        self.game_group_count = ::std::option::Option::Some(v);
    }

    // optional int32 friends_favorite_count = 8;


    pub fn get_friends_favorite_count(&self) -> i32 {
        self.friends_favorite_count.unwrap_or(0)
    }
    pub fn clear_friends_favorite_count(&mut self) {
        self.friends_favorite_count = ::std::option::Option::None;
    }

    pub fn has_friends_favorite_count(&self) -> bool {
        self.friends_favorite_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_favorite_count(&mut self, v: i32) {
        self.friends_favorite_count = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_count = 9;


    pub fn get_group_chat_count(&self) -> i32 {
        self.group_chat_count.unwrap_or(0)
    }
    pub fn clear_group_chat_count(&mut self) {
        self.group_chat_count = ::std::option::Option::None;
    }

    pub fn has_group_chat_count(&self) -> bool {
        self.group_chat_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_count(&mut self, v: i32) {
        self.group_chat_count = ::std::option::Option::Some(v);
    }

    // optional int32 group_chat_favorite_count = 10;


    pub fn get_group_chat_favorite_count(&self) -> i32 {
        self.group_chat_favorite_count.unwrap_or(0)
    }
    pub fn clear_group_chat_favorite_count(&mut self) {
        self.group_chat_favorite_count = ::std::option::Option::None;
    }

    pub fn has_group_chat_favorite_count(&self) -> bool {
        self.group_chat_favorite_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chat_favorite_count(&mut self, v: i32) {
        self.group_chat_favorite_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_category_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_categorized_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_online_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_in_game_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_in_game_singleton_count = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_group_count = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.friends_favorite_count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_count = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_chat_favorite_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friends_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_category_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_categorized_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_online_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_in_game_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_in_game_singleton_count {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_group_count {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_favorite_count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.group_chat_favorite_count {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friends_count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.friends_category_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.friends_categorized_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.friends_online_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.friends_in_game_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.friends_in_game_singleton_count {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.game_group_count {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.friends_favorite_count {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.group_chat_count {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.group_chat_favorite_count {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        CChatUsability_ClientUsabilityMetrics_Notification_Metrics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_category_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_category_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_category_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_categorized_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_categorized_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_categorized_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_online_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_online_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_online_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_in_game_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_in_game_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_in_game_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_in_game_singleton_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_in_game_singleton_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_in_game_singleton_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "game_group_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.game_group_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.game_group_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "friends_favorite_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.friends_favorite_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.friends_favorite_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "group_chat_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.group_chat_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.group_chat_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "group_chat_favorite_count",
                    |m: &CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &m.group_chat_favorite_count },
                    |m: &mut CChatUsability_ClientUsabilityMetrics_Notification_Metrics| { &mut m.group_chat_favorite_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatUsability_ClientUsabilityMetrics_Notification_Metrics>(
                    "CChatUsability_ClientUsabilityMetrics_Notification_Metrics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
        static mut instance: ::protobuf::lazy::Lazy<CChatUsability_ClientUsabilityMetrics_Notification_Metrics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatUsability_ClientUsabilityMetrics_Notification_Metrics,
        };
        unsafe {
            instance.get(CChatUsability_ClientUsabilityMetrics_Notification_Metrics::new)
        }
    }
}

impl ::protobuf::Clear for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn clear(&mut self) {
        self.friends_count = ::std::option::Option::None;
        self.friends_category_count = ::std::option::Option::None;
        self.friends_categorized_count = ::std::option::Option::None;
        self.friends_online_count = ::std::option::Option::None;
        self.friends_in_game_count = ::std::option::Option::None;
        self.friends_in_game_singleton_count = ::std::option::Option::None;
        self.game_group_count = ::std::option::Option::None;
        self.friends_favorite_count = ::std::option::Option::None;
        self.group_chat_count = ::std::option::Option::None;
        self.group_chat_favorite_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CChatUsability_RequestClientUsabilityMetrics_Notification {
    // message fields
    metrics_run_id: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
        <CChatUsability_RequestClientUsabilityMetrics_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CChatUsability_RequestClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;


    pub fn get_metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }
    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.metrics_run_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        CChatUsability_RequestClientUsabilityMetrics_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "metrics_run_id",
                    |m: &CChatUsability_RequestClientUsabilityMetrics_Notification| { &m.metrics_run_id },
                    |m: &mut CChatUsability_RequestClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CChatUsability_RequestClientUsabilityMetrics_Notification>(
                    "CChatUsability_RequestClientUsabilityMetrics_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CChatUsability_RequestClientUsabilityMetrics_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CChatUsability_RequestClientUsabilityMetrics_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CChatUsability_RequestClientUsabilityMetrics_Notification,
        };
        unsafe {
            instance.get(CChatUsability_RequestClientUsabilityMetrics_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EChatRoomJoinState {
    k_EChatRoomJoinState_Default = 0,
    k_EChatRoomJoinState_None = 1,
    k_EChatRoomJoinState_Joined = 2,
    k_EChatRoomJoinState_TestInvalid = 99,
}

impl ::protobuf::ProtobufEnum for EChatRoomJoinState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomJoinState> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            1 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            2 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            99 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomJoinState] = &[
            EChatRoomJoinState::k_EChatRoomJoinState_Default,
            EChatRoomJoinState::k_EChatRoomJoinState_None,
            EChatRoomJoinState::k_EChatRoomJoinState_Joined,
            EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EChatRoomJoinState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EChatRoomJoinState {
}

impl ::std::default::Default for EChatRoomJoinState {
    fn default() -> Self {
        EChatRoomJoinState::k_EChatRoomJoinState_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomJoinState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EChatRoomGroupRank {
    k_EChatRoomGroupRank_Default = 0,
    k_EChatRoomGroupRank_Viewer = 10,
    k_EChatRoomGroupRank_Guest = 15,
    k_EChatRoomGroupRank_Member = 20,
    k_EChatRoomGroupRank_Moderator = 30,
    k_EChatRoomGroupRank_Officer = 40,
    k_EChatRoomGroupRank_Owner = 50,
    k_EChatRoomGroupRank_TestInvalid = 99,
}

impl ::protobuf::ProtobufEnum for EChatRoomGroupRank {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomGroupRank> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            10 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            15 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            20 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            30 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            40 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            50 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            99 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomGroupRank] = &[
            EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Guest,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Member,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Officer,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Owner,
            EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EChatRoomGroupRank", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EChatRoomGroupRank {
}

impl ::std::default::Default for EChatRoomGroupRank {
    fn default() -> Self {
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomGroupRank {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EChatRoomNotificationLevel {
    k_EChatroomNotificationLevel_Invalid = 0,
    k_EChatroomNotificationLevel_None = 1,
    k_EChatroomNotificationLevel_MentionMe = 2,
    k_EChatroomNotificationLevel_MentionAll = 3,
    k_EChatroomNotificationLevel_AllMessages = 4,
}

impl ::protobuf::ProtobufEnum for EChatRoomNotificationLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            1 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            2 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            3 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            4 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomNotificationLevel] = &[
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll,
            EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EChatRoomNotificationLevel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EChatRoomNotificationLevel {
}

impl ::std::default::Default for EChatRoomNotificationLevel {
    fn default() -> Self {
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomNotificationLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EChatRoomServerMessage {
    k_EChatRoomServerMsg_Invalid = 0,
    k_EChatRoomServerMsg_RenameChatRoom = 1,
    k_EChatRoomServerMsg_Joined = 2,
    k_EChatRoomServerMsg_Parted = 3,
    k_EChatRoomServerMsg_Kicked = 4,
    k_EChatRoomServerMsg_Invited = 5,
    k_EChatRoomServerMsg_InviteDismissed = 8,
    k_EChatRoomServerMsg_ChatRoomTaglineChanged = 9,
    k_EChatRoomServerMsg_ChatRoomAvatarChanged = 10,
    k_EChatRoomServerMsg_AppCustom = 11,
}

impl ::protobuf::ProtobufEnum for EChatRoomServerMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomServerMessage> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            1 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            2 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            3 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            4 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            5 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            8 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            10 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            11 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomServerMessage] = &[
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
            EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Joined,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Parted,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invited,
            EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged,
            EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EChatRoomServerMessage", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EChatRoomServerMessage {
}

impl ::std::default::Default for EChatRoomServerMessage {
    fn default() -> Self {
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomServerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EChatRoomMemberStateChange {
    k_EChatRoomMemberStateChange_Invalid = 0,
    k_EChatRoomMemberStateChange_Joined = 1,
    k_EChatRoomMemberStateChange_Parted = 2,
    k_EChatRoomMemberStateChange_Kicked = 3,
    k_EChatRoomMemberStateChange_Invited = 4,
    k_EChatRoomMemberStateChange_RankChanged = 7,
    k_EChatRoomMemberStateChange_InviteDismissed = 8,
    k_EChatRoomMemberStateChange_Muted = 9,
    k_EChatRoomMemberStateChange_Banned = 10,
    k_EChatRoomMemberStateChange_RolesChanged = 12,
}

impl ::protobuf::ProtobufEnum for EChatRoomMemberStateChange {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            2 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            3 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            4 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            7 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            8 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            10 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            12 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EChatRoomMemberStateChange] = &[
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EChatRoomMemberStateChange", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EChatRoomMemberStateChange {
}

impl ::std::default::Default for EChatRoomMemberStateChange {
    fn default() -> Self {
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EChatRoomMemberStateChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_chat.steamclient.proto\x1a,steammessages_unified_base.s\
    teamclient.proto\"*\n(CChat_RequestFriendPersonaStates_Request\"+\n)CCha\
    t_RequestFriendPersonaStates_Response\"\xbd\x02\n%CChatRoom_CreateChatRo\
    omGroup_Request\x12'\n\x0fsteamid_partner\x18\x01\x20\x01(\x06R\x0esteam\
    idPartner\x12'\n\x0fsteamid_invited\x18\x02\x20\x01(\x06R\x0esteamidInvi\
    ted\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12)\n\x10steamid_invi\
    tees\x18\x04\x20\x03(\x06R\x0fsteamidInvitees\x12@\n\x1cwatching_broadca\
    st_accountid\x18\x06\x20\x01(\rR\x1awatchingBroadcastAccountid\x12A\n\
    \x1dwatching_broadcast_channel_id\x18\x07\x20\x01(\x04R\x1awatchingBroad\
    castChannelId\"R\n\tCChatRole\x12\x17\n\x07role_id\x18\x01\x20\x01(\x04R\
    \x06roleId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x18\n\x07or\
    dinal\x18\x03\x20\x01(\rR\x07ordinal\"\x9c\x04\n\x10CChatRoleActions\x12\
    \x17\n\x07role_id\x18\x01\x20\x01(\x04R\x06roleId\x12F\n\x20can_create_r\
    ename_delete_channel\x18\x02\x20\x01(\x08R\x1ccanCreateRenameDeleteChann\
    el\x12\x19\n\x08can_kick\x18\x03\x20\x01(\x08R\x07canKick\x12\x17\n\x07c\
    an_ban\x18\x04\x20\x01(\x08R\x06canBan\x12\x1d\n\ncan_invite\x18\x05\x20\
    \x01(\x08R\tcanInvite\x12B\n\x1ecan_change_tagline_avatar_name\x18\x06\
    \x20\x01(\x08R\x1acanChangeTaglineAvatarName\x12\x19\n\x08can_chat\x18\
    \x07\x20\x01(\x08R\x07canChat\x12(\n\x10can_view_history\x18\x08\x20\x01\
    (\x08R\x0ecanViewHistory\x123\n\x16can_change_group_roles\x18\t\x20\x01(\
    \x08R\x13canChangeGroupRoles\x121\n\x15can_change_user_roles\x18\n\x20\
    \x01(\x08R\x12canChangeUserRoles\x12&\n\x0fcan_mention_all\x18\x0b\x20\
    \x01(\x08R\rcanMentionAll\x12;\n\x1acan_set_watching_broadcast\x18\x0c\
    \x20\x01(\x08R\x17canSetWatchingBroadcast\"\x90\x01\n\x10CChatPartyBeaco\
    n\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12#\n\rsteamid_owner\
    \x18\x02\x20\x01(\x06R\x0csteamidOwner\x12\x1b\n\tbeacon_id\x18\x03\x20\
    \x01(\x06R\x08beaconId\x12#\n\rgame_metadata\x18\x04\x20\x01(\tR\x0cgame\
    Metadata\"\xa9\x04\n\x19CChatRoomGroupHeaderState\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1b\n\tchat_name\x18\x02\x20\
    \x01(\tR\x08chatName\x12\x16\n\x06clanid\x18\r\x20\x01(\rR\x06clanid\x12\
    '\n\x0faccountid_owner\x18\x0e\x20\x01(\rR\x0eaccountidOwner\x12\x14\n\
    \x05appid\x18\x15\x20\x01(\rR\x05appid\x12\x18\n\x07tagline\x18\x0f\x20\
    \x01(\tR\x07tagline\x12\x1d\n\navatar_sha\x18\x10\x20\x01(\x0cR\tavatarS\
    ha\x12&\n\x0fdefault_role_id\x18\x11\x20\x01(\x04R\rdefaultRoleId\x12\
    \x20\n\x05roles\x18\x12\x20\x03(\x0b2\n.CChatRoleR\x05roles\x124\n\x0cro\
    le_actions\x18\x13\x20\x03(\x0b2\x11.CChatRoleActionsR\x0broleActions\
    \x12@\n\x1cwatching_broadcast_accountid\x18\x14\x20\x01(\rR\x1awatchingB\
    roadcastAccountid\x126\n\rparty_beacons\x18\x16\x20\x03(\x0b2\x11.CChatP\
    artyBeaconR\x0cpartyBeacons\x12A\n\x1dwatching_broadcast_channel_id\x18\
    \x17\x20\x01(\x04R\x1awatchingBroadcastChannelId\"\x84\x02\n\x0fCChatRoo\
    mMember\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12G\n\x05st\
    ate\x18\x03\x20\x01(\x0e2\x13.EChatRoomJoinState:\x1ck_EChatRoomJoinStat\
    e_DefaultR\x05state\x12E\n\x04rank\x18\x04\x20\x01(\x0e2\x13.EChatRoomGr\
    oupRank:\x1ck_EChatRoomGroupRank_DefaultR\x04rank\x12(\n\x10time_kick_ex\
    pire\x18\x06\x20\x01(\rR\x0etimeKickExpire\x12\x19\n\x08role_ids\x18\x07\
    \x20\x03(\x04R\x07roleIds\"\xb9\x02\n\x0eCChatRoomState\x12\x17\n\x07cha\
    t_id\x18\x01\x20\x01(\x04R\x06chatId\x12\x1b\n\tchat_name\x18\x02\x20\
    \x01(\tR\x08chatName\x12#\n\rvoice_allowed\x18\x03\x20\x01(\x08R\x0cvoic\
    eAllowed\x12(\n\x10members_in_voice\x18\x04\x20\x03(\rR\x0emembersInVoic\
    e\x12*\n\x11time_last_message\x18\x05\x20\x01(\rR\x0ftimeLastMessage\x12\
    \x1d\n\nsort_order\x18\x06\x20\x01(\rR\tsortOrder\x12!\n\x0clast_message\
    \x18\x07\x20\x01(\tR\x0blastMessage\x124\n\x16accountid_last_message\x18\
    \x08\x20\x01(\rR\x14accountidLastMessage\"\x82\x02\n\x13CChatRoomGroupSt\
    ate\x12=\n\x0cheader_state\x18\x01\x20\x01(\x0b2\x1a.CChatRoomGroupHeade\
    rStateR\x0bheaderState\x12*\n\x07members\x18\x02\x20\x03(\x0b2\x10.CChat\
    RoomMemberR\x07members\x12&\n\x0fdefault_chat_id\x18\x04\x20\x01(\x04R\r\
    defaultChatId\x12.\n\nchat_rooms\x18\x05\x20\x03(\x0b2\x0f.CChatRoomStat\
    eR\tchatRooms\x12(\n\x06kicked\x18\x07\x20\x03(\x0b2\x10.CChatRoomMember\
    R\x06kicked\"\x87\x04\n\x12CUserChatRoomState\x12\x17\n\x07chat_id\x18\
    \x01\x20\x01(\x04R\x06chatId\x12\x1f\n\x0btime_joined\x18\x02\x20\x01(\r\
    R\ntimeJoined\x12\"\n\rtime_last_ack\x18\x03\x20\x01(\rR\x0btimeLastAck\
    \x12\x7f\n\x1adesktop_notification_level\x18\x04\x20\x01(\x0e2\x1b.EChat\
    RoomNotificationLevel:$k_EChatroomNotificationLevel_InvalidR\x18desktopN\
    otificationLevel\x12}\n\x19mobile_notification_level\x18\x05\x20\x01(\
    \x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLevel_Inval\
    idR\x17mobileNotificationLevel\x12*\n\x11time_last_mention\x18\x06\x20\
    \x01(\rR\x0ftimeLastMention\x12;\n\x16unread_indicator_muted\x18\x07\x20\
    \x01(\x08:\x05falseR\x14unreadIndicatorMuted\x12*\n\x11time_first_unread\
    \x18\x08\x20\x01(\rR\x0ftimeFirstUnread\"\x90\x04\n\x17CUserChatRoomGrou\
    pState\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x1f\n\x0btime_joined\x18\x02\x20\x01(\rR\ntimeJoined\x12D\n\x14user_cha\
    t_room_state\x18\x03\x20\x03(\x0b2\x13.CUserChatRoomStateR\x11userChatRo\
    omState\x12\x7f\n\x1adesktop_notification_level\x18\x04\x20\x01(\x0e2\
    \x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLevel_InvalidR\
    \x18desktopNotificationLevel\x12}\n\x19mobile_notification_level\x18\x05\
    \x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLe\
    vel_InvalidR\x17mobileNotificationLevel\x12-\n\x13time_last_group_ack\
    \x18\x06\x20\x01(\rR\x10timeLastGroupAck\x12;\n\x16unread_indicator_mute\
    d\x18\x07\x20\x01(\x08:\x05falseR\x14unreadIndicatorMuted\"\xba\x01\n&CC\
    hatRoom_CreateChatRoomGroup_Response\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12*\n\x05state\x18\x02\x20\x01(\x0b2\x14.CCha\
    tRoomGroupStateR\x05state\x12@\n\x0fuser_chat_state\x18\x03\x20\x01(\x0b\
    2\x18.CUserChatRoomGroupStateR\ruserChatState\"]\n#CChatRoom_SaveChatRoo\
    mGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroup\
    Id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"&\n$CChatRoom_SaveChat\
    RoomGroup_Response\"_\n%CChatRoom_RenameChatRoomGroup_Request\x12\"\n\rc\
    hat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\"<\n&CChatRoom_RenameChatRoomGroup_Response\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"i\n)CChatRoom_SetChatRoomGro\
    upTagline_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGr\
    oupId\x12\x18\n\x07tagline\x18\x02\x20\x01(\tR\x07tagline\",\n*CChatRoom\
    _SetChatRoomGroupTagline_Response\"m\n(CChatRoom_SetChatRoomGroupAvatar_\
    Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x1d\n\navatar_sha\x18\x02\x20\x01(\x0cR\tavatarSha\"+\n)CChatRoom_SetCh\
    atRoomGroupAvatar_Response\"\xde\x01\n3CChatRoom_SetChatRoomGroupWatchin\
    gBroadcast_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatG\
    roupId\x12@\n\x1cwatching_broadcast_accountid\x18\x02\x20\x01(\rR\x1awat\
    chingBroadcastAccountid\x12A\n\x1dwatching_broadcast_channel_id\x18\x03\
    \x20\x01(\x04R\x1awatchingBroadcastChannelId\"6\n4CChatRoom_SetChatRoomG\
    roupWatchingBroadcast_Response\"z\n\x1aCChatRoom_MuteUser_Request\x12\"\
    \n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07stea\
    mid\x18\x02\x20\x01(\x06R\x07steamid\x12\x1e\n\nexpiration\x18\x03\x20\
    \x01(\x05R\nexpiration\"\x1d\n\x1bCChatRoom_MuteUser_Response\"z\n\x1aCC\
    hatRoom_KickUser_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\
    \x12\x1e\n\nexpiration\x18\x03\x20\x01(\x05R\nexpiration\"\x1d\n\x1bCCha\
    tRoom_KickUser_Response\"~\n!CChatRoom_SetUserBanState_Request\x12\"\n\r\
    chat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\
    \x18\x02\x20\x01(\x06R\x07steamid\x12\x1b\n\tban_state\x18\x03\x20\x01(\
    \x08R\x08banState\"$\n\"CChatRoom_SetUserBanState_Response\"^\n\x1eCChat\
    Room_RevokeInvite_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\"!\
    \n\x1fCChatRoom_RevokeInvite_Response\"V\n\x1cCChatRoom_CreateRole_Reque\
    st\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\"L\n\x1dCChatRoom_CreateRole_Respon\
    se\x12+\n\x07actions\x18\x02\x20\x01(\x0b2\x11.CChatRoleActionsR\x07acti\
    ons\"@\n\x1aCChatRoom_GetRoles_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\"?\n\x1bCChatRoom_GetRoles_Response\x12\
    \x20\n\x05roles\x18\x01\x20\x03(\x0b2\n.CChatRoleR\x05roles\"o\n\x1cCCha\
    tRoom_RenameRole_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"\x1f\n\x1dCChatRoom_RenameRo\
    le_Response\"v\n\x1dCChatRoom_ReorderRole_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\
    \x01(\x04R\x06roleId\x12\x18\n\x07ordinal\x18\x03\x20\x01(\rR\x07ordinal\
    \"\x20\n\x1eCChatRoom_ReorderRole_Response\"[\n\x1cCChatRoom_DeleteRole_\
    Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\"\x1f\n\x1dCChatRoom_D\
    eleteRole_Response\"_\n\x20CChatRoom_GetRoleActions_Request\x12\"\n\rcha\
    t_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\
    \x02\x20\x01(\x04R\x06roleId\"P\n!CChatRoom_GetRoleActions_Response\x12+\
    \n\x07actions\x18\x01\x20\x03(\x0b2\x11.CChatRoleActionsR\x07actions\"\
    \x90\x01\n$CChatRoom_ReplaceRoleActions_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\
    \x01(\x04R\x06roleId\x12+\n\x07actions\x18\x04\x20\x01(\x0b2\x11.CChatRo\
    leActionsR\x07actions\"'\n%CChatRoom_ReplaceRoleActions_Response\"x\n\
    \x1fCChatRoom_AddRoleToUser_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x03\x20\x01(\x04R\x06\
    roleId\x12\x18\n\x07steamid\x18\x04\x20\x01(\x06R\x07steamid\"\"\n\x20CC\
    hatRoom_AddRoleToUser_Response\"a\n!CChatRoom_GetRolesForUser_Request\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\
    \x07steamid\x18\x03\x20\x01(\x06R\x07steamid\"?\n\"CChatRoom_GetRolesFor\
    User_Response\x12\x19\n\x08role_ids\x18\x01\x20\x03(\x04R\x07roleIds\"}\
    \n$CChatRoom_DeleteRoleFromUser_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x03\x20\x01(\x04R\
    \x06roleId\x12\x18\n\x07steamid\x18\x04\x20\x01(\x06R\x07steamid\"'\n%CC\
    hatRoom_DeleteRoleFromUser_Response\"\x83\x01\n#CChatRoom_JoinChatRoomGr\
    oup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12\x1f\n\x0binvite_code\x18\x02\x20\x01(\tR\ninviteCode\x12\x17\n\x07c\
    hat_id\x18\x03\x20\x01(\x04R\x06chatId\"\xd7\x01\n$CChatRoom_JoinChatRoo\
    mGroup_Response\x12*\n\x05state\x18\x01\x20\x01(\x0b2\x14.CChatRoomGroup\
    StateR\x05state\x12@\n\x0fuser_chat_state\x18\x03\x20\x01(\x0b2\x18.CUse\
    rChatRoomGroupStateR\ruserChatState\x12\x20\n\x0cjoin_chat_id\x18\x04\
    \x20\x01(\x04R\njoinChatId\x12\x1f\n\x0btime_expire\x18\x05\x20\x01(\rR\
    \ntimeExpire\"\xb8\x01\n-CChatRoom_InviteFriendToChatRoomGroup_Request\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\
    \x07steamid\x18\x02\x20\x01(\x06R\x07steamid\x12\x17\n\x07chat_id\x18\
    \x03\x20\x01(\x04R\x06chatId\x120\n\x14skip_friendsui_check\x18\x04\x20\
    \x01(\x08R\x12skipFriendsuiCheck\"0\n.CChatRoom_InviteFriendToChatRoomGr\
    oup_Response\"J\n$CChatRoom_LeaveChatRoomGroup_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"'\n%CChatRoom_LeaveChatRoomG\
    roup_Response\"{\n\x20CChatRoom_CreateChatRoom_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x1f\n\x0ballow_voice\x18\x03\x20\x01(\x08R\nallowVo\
    ice\"Q\n!CChatRoom_CreateChatRoom_Response\x12,\n\tchat_room\x18\x01\x20\
    \x01(\x0b2\x0f.CChatRoomStateR\x08chatRoom\"_\n\x20CChatRoom_DeleteChatR\
    oom_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\"#\n!CChatRoom_Del\
    eteChatRoom_Response\"s\n\x20CChatRoom_RenameChatRoom_Request\x12\"\n\rc\
    hat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\
    \x18\x02\x20\x01(\x04R\x06chatId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\"#\n!CChatRoom_RenameChatRoom_Response\"\x8d\x01\n!CChatRoom_Re\
    orderChatRoom_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bch\
    atGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12+\n\
    \x12move_after_chat_id\x18\x03\x20\x01(\x04R\x0fmoveAfterChatId\"$\n\"CC\
    hatRoom_ReorderChatRoom_Response\"z\n!CChatRoom_SendChatMessage_Request\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\
    \x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\x18\n\x07message\x18\x03\
    \x20\x01(\tR\x07message\"\x94\x01\n\"CChatRoom_SendChatMessage_Response\
    \x12)\n\x10modified_message\x18\x01\x20\x01(\tR\x0fmodifiedMessage\x12)\
    \n\x10server_timestamp\x18\x02\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\
    \x07ordinal\x18\x03\x20\x01(\rR\x07ordinal\"^\n\x1fCChatRoom_JoinVoiceCh\
    at_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\"E\n\x20CChatRoom_\
    JoinVoiceChat_Response\x12!\n\x0cvoice_chatid\x18\x01\x20\x01(\x04R\x0bv\
    oiceChatid\"_\n\x20CChatRoom_LeaveVoiceChat_Request\x12\"\n\rchat_group_\
    id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\"#\n!CChatRoom_LeaveVoiceChat_Response\"\x83\x02\n#\
    CChatRoom_GetMessageHistory_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06\
    chatId\x12\x1b\n\tlast_time\x18\x03\x20\x01(\rR\x08lastTime\x12!\n\x0cla\
    st_ordinal\x18\x04\x20\x01(\rR\x0blastOrdinal\x12\x1d\n\nstart_time\x18\
    \x05\x20\x01(\rR\tstartTime\x12#\n\rstart_ordinal\x18\x06\x20\x01(\rR\
    \x0cstartOrdinal\x12\x1b\n\tmax_count\x18\x07\x20\x01(\rR\x08maxCount\"\
    \xac\x01\n\rServerMessage\x12O\n\x07message\x18\x01\x20\x01(\x0e2\x17.EC\
    hatRoomServerMessage:\x1ck_EChatRoomServerMsg_InvalidR\x07message\x12!\n\
    \x0cstring_param\x18\x02\x20\x01(\tR\x0bstringParam\x12'\n\x0faccountid_\
    param\x18\x03\x20\x01(\rR\x0eaccountidParam\"\xf4\x02\n$CChatRoom_GetMes\
    sageHistory_Response\x12M\n\x08messages\x18\x01\x20\x03(\x0b21.CChatRoom\
    _GetMessageHistory_Response.ChatMessageR\x08messages\x12%\n\x0emore_avai\
    lable\x18\x04\x20\x01(\x08R\rmoreAvailable\x1a\xd5\x01\n\x0bChatMessage\
    \x12\x16\n\x06sender\x18\x01\x20\x01(\rR\x06sender\x12)\n\x10server_time\
    stamp\x18\x02\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07message\x18\
    \x03\x20\x01(\tR\x07message\x12\x18\n\x07ordinal\x18\x04\x20\x01(\rR\x07\
    ordinal\x125\n\x0eserver_message\x18\x05\x20\x01(\x0b2\x0e.ServerMessage\
    R\rserverMessage\x12\x18\n\x07deleted\x18\x06\x20\x01(\x08R\x07deleted\"\
    '\n%CChatRoom_GetMyChatRoomGroups_Request\"\x91\x07\n*CChatRoom_GetChatR\
    oomGroupSummary_Response\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12&\n\x0fchat_group_name\x18\x02\x20\x01(\tR\rchatGroup\
    Name\x12.\n\x13active_member_count\x18\x03\x20\x01(\rR\x11activeMemberCo\
    unt\x129\n\x19active_voice_member_count\x18\x04\x20\x01(\rR\x16activeVoi\
    ceMemberCount\x12&\n\x0fdefault_chat_id\x18\x05\x20\x01(\x04R\rdefaultCh\
    atId\x12.\n\nchat_rooms\x18\x06\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatR\
    ooms\x12\x16\n\x06clanid\x18\x07\x20\x01(\rR\x06clanid\x12,\n\x12chat_gr\
    oup_tagline\x18\x08\x20\x01(\tR\x10chatGroupTagline\x12'\n\x0faccountid_\
    owner\x18\t\x20\x01(\rR\x0eaccountidOwner\x12\x1f\n\x0btop_members\x18\n\
    \x20\x03(\rR\ntopMembers\x121\n\x15chat_group_avatar_sha\x18\x0b\x20\x01\
    (\x0cR\x12chatGroupAvatarSha\x12E\n\x04rank\x18\x0c\x20\x01(\x0e2\x13.EC\
    hatRoomGroupRank:\x1ck_EChatRoomGroupRank_DefaultR\x04rank\x12&\n\x0fdef\
    ault_role_id\x18\r\x20\x01(\x04R\rdefaultRoleId\x12\x19\n\x08role_ids\
    \x18\x0e\x20\x03(\x04R\x07roleIds\x124\n\x0crole_actions\x18\x0f\x20\x03\
    (\x0b2\x11.CChatRoleActionsR\x0broleActions\x12@\n\x1cwatching_broadcast\
    _accountid\x18\x10\x20\x01(\rR\x1awatchingBroadcastAccountid\x12\x14\n\
    \x05appid\x18\x11\x20\x01(\rR\x05appid\x126\n\rparty_beacons\x18\x12\x20\
    \x03(\x0b2\x11.CChatPartyBeaconR\x0cpartyBeacons\x12A\n\x1dwatching_broa\
    dcast_channel_id\x18\x13\x20\x01(\x04R\x1awatchingBroadcastChannelId\"\
    \xb5\x01\n\x14CChatRoomSummaryPair\x12K\n\x15user_chat_group_state\x18\
    \x01\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\x12userChatGroupState\
    \x12P\n\rgroup_summary\x18\x02\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroup\
    Summary_ResponseR\x0cgroupSummary\"i\n&CChatRoom_GetMyChatRoomGroups_Res\
    ponse\x12?\n\x10chat_room_groups\x18\x01\x20\x03(\x0b2\x15.CChatRoomSumm\
    aryPairR\x0echatRoomGroups\"M\n'CChatRoom_GetChatRoomGroupState_Request\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"V\n(CChatR\
    oom_GetChatRoomGroupState_Response\x12*\n\x05state\x18\x01\x20\x01(\x0b2\
    \x14.CChatRoomGroupStateR\x05state\"O\n)CChatRoom_GetChatRoomGroupSummar\
    y_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"\
    \x82\x01\n%CChatRoom_AckChatMessage_Notification\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestamp\
    \"\x86\x01\n\"CChatRoom_CreateInviteLink_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12#\n\rseconds_valid\x18\x02\x20\
    \x01(\rR\x0csecondsValid\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06c\
    hatId\"k\n#CChatRoom_CreateInviteLink_Response\x12\x1f\n\x0binvite_code\
    \x18\x01\x20\x01(\tR\ninviteCode\x12#\n\rseconds_valid\x18\x02\x20\x01(\
    \rR\x0csecondsValid\"F\n#CChatRoom_GetInviteLinkInfo_Request\x12\x1f\n\
    \x0binvite_code\x18\x01\x20\x01(\tR\ninviteCode\"\xea\x02\n$CChatRoom_Ge\
    tInviteLinkInfo_Response\x12%\n\x0esteamid_sender\x18\x03\x20\x01(\x06R\
    \rsteamidSender\x12!\n\x0ctime_expires\x18\x04\x20\x01(\rR\x0btimeExpire\
    s\x12\x17\n\x07chat_id\x18\x06\x20\x01(\x04R\x06chatId\x12P\n\rgroup_sum\
    mary\x18\x08\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\
    \x0cgroupSummary\x12K\n\x15user_chat_group_state\x18\t\x20\x01(\x0b2\x18\
    .CUserChatRoomGroupStateR\x12userChatGroupState\x12(\n\x10time_kick_expi\
    re\x18\n\x20\x01(\rR\x0etimeKickExpire\x12\x16\n\x06banned\x18\x0b\x20\
    \x01(\x08R\x06banned\"\xa8\x01\n\x1fCChatRoom_GetInviteInfo_Request\x12'\
    \n\x0fsteamid_invitee\x18\x01\x20\x01(\x06R\x0esteamidInvitee\x12\"\n\rc\
    hat_group_id\x18\x02\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\
    \x18\x03\x20\x01(\x04R\x06chatId\x12\x1f\n\x0binvite_code\x18\x04\x20\
    \x01(\tR\ninviteCode\"\xb6\x01\n\x20CChatRoom_GetInviteInfo_Response\x12\
    P\n\rgroup_summary\x18\x01\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSumm\
    ary_ResponseR\x0cgroupSummary\x12(\n\x10time_kick_expire\x18\x02\x20\x01\
    (\rR\x0etimeKickExpire\x12\x16\n\x06banned\x18\x03\x20\x01(\x08R\x06bann\
    ed\"N\n(CChatRoom_GetInviteLinksForGroup_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\"\x96\x02\n)CChatRoom_GetInviteLin\
    ksForGroup_Response\x12V\n\x0cinvite_links\x18\x01\x20\x03(\x0b23.CChatR\
    oom_GetInviteLinksForGroup_Response.LinkInfoR\x0binviteLinks\x1a\x90\x01\
    \n\x08LinkInfo\x12\x1f\n\x0binvite_code\x18\x01\x20\x01(\tR\ninviteCode\
    \x12'\n\x0fsteamid_creator\x18\x02\x20\x01(\x06R\x0esteamidCreator\x12!\
    \n\x0ctime_expires\x18\x03\x20\x01(\rR\x0btimeExpires\x12\x17\n\x07chat_\
    id\x18\x04\x20\x01(\x04R\x06chatId\"B\n\x1cCChatRoom_GetBanList_Request\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"\xee\x01\n\
    \x1dCChatRoom_GetBanList_Response\x12:\n\x04bans\x18\x01\x20\x03(\x0b2&.\
    CChatRoom_GetBanList_Response.BanInfoR\x04bans\x1a\x90\x01\n\x07BanInfo\
    \x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12'\n\x0faccountid\
    _actor\x18\x02\x20\x01(\rR\x0eaccountidActor\x12\x1f\n\x0btime_banned\
    \x18\x03\x20\x01(\rR\ntimeBanned\x12\x1d\n\nban_reason\x18\x04\x20\x01(\
    \tR\tbanReason\"E\n\x1fCChatRoom_GetInviteList_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"\x80\x01\n\x14CChatRoomGroup\
    Invite\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12'\n\x0facc\
    ountid_actor\x18\x02\x20\x01(\rR\x0eaccountidActor\x12!\n\x0ctime_invite\
    d\x18\x03\x20\x01(\rR\x0btimeInvited\"S\n\x20CChatRoom_GetInviteList_Res\
    ponse\x12/\n\x07invites\x18\x01\x20\x03(\x0b2\x15.CChatRoomGroupInviteR\
    \x07invites\"i\n\"CChatRoom_DeleteInviteLink_Request\x12\"\n\rchat_group\
    _id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1f\n\x0binvite_code\x18\
    \x02\x20\x01(\tR\ninviteCode\"%\n#CChatRoom_DeleteInviteLink_Response\"\
    \x95\x01\n0CChatRoom_SetSessionActiveChatRoomGroups_Request\x12$\n\x0ech\
    at_group_ids\x18\x01\x20\x03(\x04R\x0cchatGroupIds\x12;\n\x1achat_groups\
    _data_requested\x18\x02\x20\x03(\x04R\x17chatGroupsDataRequested\"j\n1CC\
    hatRoom_SetSessionActiveChatRoomGroups_Response\x125\n\x0bchat_states\
    \x18\x01\x20\x03(\x0b2\x14.CChatRoomGroupStateR\nchatStates\"\xfc\x07\n-\
    CChatRoom_SetUserChatGroupPreferences_Request\x12\"\n\rchat_group_id\x18\
    \x01\x20\x01(\x04R\x0bchatGroupId\x12y\n\x16chat_group_preferences\x18\
    \x02\x20\x01(\x0b2C.CChatRoom_SetUserChatGroupPreferences_Request.ChatGr\
    oupPreferencesR\x14chatGroupPreferences\x12v\n\x15chat_room_preferences\
    \x18\x03\x20\x03(\x0b2B.CChatRoom_SetUserChatGroupPreferences_Request.Ch\
    atRoomPreferencesR\x13chatRoomPreferences\x1a\xcc\x02\n\x14ChatGroupPref\
    erences\x12\x7f\n\x1adesktop_notification_level\x18\x01\x20\x01(\x0e2\
    \x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLevel_InvalidR\
    \x18desktopNotificationLevel\x12}\n\x19mobile_notification_level\x18\x02\
    \x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLe\
    vel_InvalidR\x17mobileNotificationLevel\x124\n\x16unread_indicator_muted\
    \x18\x03\x20\x01(\x08R\x14unreadIndicatorMuted\x1a\xe4\x02\n\x13ChatRoom\
    Preferences\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x04R\x06chatId\x12\x7f\
    \n\x1adesktop_notification_level\x18\x02\x20\x01(\x0e2\x1b.EChatRoomNoti\
    ficationLevel:$k_EChatroomNotificationLevel_InvalidR\x18desktopNotificat\
    ionLevel\x12}\n\x19mobile_notification_level\x18\x03\x20\x01(\x0e2\x1b.E\
    ChatRoomNotificationLevel:$k_EChatroomNotificationLevel_InvalidR\x17mobi\
    leNotificationLevel\x124\n\x16unread_indicator_muted\x18\x04\x20\x01(\
    \x08R\x14unreadIndicatorMuted\"0\n.CChatRoom_SetUserChatGroupPreferences\
    _Response\"\xfe\x01\n$CChatRoom_DeleteChatMessages_Request\x12\"\n\rchat\
    _group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\
    \x02\x20\x01(\x04R\x06chatId\x12I\n\x08messages\x18\x03\x20\x03(\x0b2-.C\
    ChatRoom_DeleteChatMessages_Request.MessageR\x08messages\x1aN\n\x07Messa\
    ge\x12)\n\x10server_timestamp\x18\x01\x20\x01(\rR\x0fserverTimestamp\x12\
    \x18\n\x07ordinal\x18\x02\x20\x01(\rR\x07ordinal\"'\n%CChatRoom_DeleteCh\
    atMessages_Response\"\xad\x01\n*CClanChatRooms_GetClanChatRoomInfo_Reque\
    st\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12e\n\nautocre\
    ate\x18\x02\x20\x01(\x08:\x04trueR\nautocreateB?\x82\xb5\x18;Create\x20a\
    \x20default\x20chat\x20room\x20if\x20none\x20has\x20been\x20created\x20b\
    efore.\"\x88\x01\n+CClanChatRooms_GetClanChatRoomInfo_Response\x12Y\n\
    \x12chat_group_summary\x18\x01\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroup\
    Summary_ResponseR\x10chatGroupSummary\"u\n-CClanChatRooms_SetClanChatRoo\
    mPrivate_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\
    \x12*\n\x11chat_room_private\x18\x02\x20\x01(\x08R\x0fchatRoomPrivate\"\
    \\\n.CClanChatRooms_SetClanChatRoomPrivate_Response\x12*\n\x11chat_room_\
    private\x18\x01\x20\x01(\x08R\x0fchatRoomPrivate\"\x82\x01\n\rCChatMenti\
    ons\x12\x1f\n\x0bmention_all\x18\x01\x20\x01(\x08R\nmentionAll\x12!\n\
    \x0cmention_here\x18\x02\x20\x01(\x08R\x0bmentionHere\x12-\n\x12mention_\
    accountids\x18\x03\x20\x03(\rR\x11mentionAccountids\"\xca\x03\n*CChatRoo\
    m_IncomingChatMessage_Notification\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06\
    chatId\x12%\n\x0esteamid_sender\x18\x03\x20\x01(\x06R\rsteamidSender\x12\
    \x18\n\x07message\x18\x04\x20\x01(\tR\x07message\x12\x1c\n\ttimestamp\
    \x18\x05\x20\x01(\rR\ttimestamp\x12*\n\x08mentions\x18\x06\x20\x01(\x0b2\
    \x0e.CChatMentionsR\x08mentions\x12\x18\n\x07ordinal\x18\x07\x20\x01(\rR\
    \x07ordinal\x125\n\x0eserver_message\x18\x08\x20\x01(\x0b2\x0e.ServerMes\
    sageR\rserverMessage\x12*\n\x11message_no_bbcode\x18\t\x20\x01(\tR\x0fme\
    ssageNoBbcode\x12W\n\tchat_name\x18\n\x20\x01(\tR\x08chatNameB:\x82\xb5\
    \x186A\x20name\x20to\x20use\x20for\x20the\x20chat,\x20intended\x20for\
    \x20notifications\"\xac\x02\n*CChatRoom_ChatMessageModified_Notification\
    \x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\
    \x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12S\n\x08messages\x18\x03\
    \x20\x03(\x0b27.CChatRoom_ChatMessageModified_Notification.ChatMessageR\
    \x08messages\x1al\n\x0bChatMessage\x12)\n\x10server_timestamp\x18\x01\
    \x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x02\x20\x01(\rR\
    \x07ordinal\x12\x18\n\x07deleted\x18\x03\x20\x01(\x08R\x07deleted\"\xd3\
    \x01\n(CChatRoom_MemberStateChange_Notification\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12(\n\x06member\x18\x02\x20\x01(\
    \x0b2\x10.CChatRoomMemberR\x06member\x12Y\n\x06change\x18\x03\x20\x01(\
    \x0e2\x1b.EChatRoomMemberStateChange:$k_EChatRoomMemberStateChange_Inval\
    idR\x06change\"k\n*CChatRoom_ChatRoomHeaderState_Notification\x12=\n\x0c\
    header_state\x18\x01\x20\x01(\x0b2\x1a.CChatRoomGroupHeaderStateR\x0bhea\
    derState\"\xad\x01\n/CChatRoom_ChatRoomGroupRoomsChange_Notification\x12\
    \"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12&\n\x0fdefau\
    lt_chat_id\x18\x02\x20\x01(\x04R\rdefaultChatId\x12.\n\nchat_rooms\x18\
    \x03\x20\x03(\x0b2\x0f.CChatRoomStateR\tchatRooms\"y\n:CChatRoom_NotifyS\
    houldRejoinChatRoomVoiceChat_Notification\x12\x17\n\x07chat_id\x18\x01\
    \x20\x01(\x04R\x06chatId\x12\"\n\rchat_group_id\x18\x02\x20\x01(\x04R\
    \x0bchatGroupId\"\xe4\x02\n;ChatRoomClient_NotifyChatGroupUserStateChang\
    ed_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGrou\
    pId\x12K\n\x15user_chat_group_state\x18\x02\x20\x01(\x0b2\x18.CUserChatR\
    oomGroupStateR\x12userChatGroupState\x12P\n\rgroup_summary\x18\x03\x20\
    \x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\x0cgroupSummary\
    \x12b\n\x0buser_action\x18\x04\x20\x01(\x0e2\x1b.EChatRoomMemberStateCha\
    nge:$k_EChatRoomMemberStateChange_InvalidR\nuserAction\"\xbb!\n2CChatUsa\
    bility_ClientUsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\
    \x01\x20\x01(\rR\x0cmetricsRunId\x12!\n\x0cclient_build\x18\x02\x20\x01(\
    \rR\x0bclientBuild\x12'\n\x0fmetrics_version\x18\x03\x20\x01(\rR\x0emetr\
    icsVersion\x12\x15\n\x06in_web\x18\x04\x20\x01(\x08R\x05inWeb\x12X\n\x08\
    settings\x18\n\x20\x01(\x0b2<.CChatUsability_ClientUsabilityMetrics_Noti\
    fication.SettingsR\x08settings\x12h\n\x0evoice_settings\x18\x0b\x20\x01(\
    \x0b2A.CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettingsR\
    \rvoiceSettings\x12V\n\x08ui_state\x18\x0c\x20\x01(\x0b2;.CChatUsability\
    _ClientUsabilityMetrics_Notification.UIStateR\x07uiState\x12U\n\x07metri\
    cs\x18\r\x20\x01(\x0b2;.CChatUsability_ClientUsabilityMetrics_Notificati\
    on.MetricsR\x07metrics\x1a\xf6\n\n\x08Settings\x12:\n\x19notifications_s\
    how_ingame\x18\x01\x20\x01(\x08R\x17notificationsShowIngame\x12:\n\x19no\
    tifications_show_online\x18\x02\x20\x01(\x08R\x17notificationsShowOnline\
    \x12<\n\x1anotifications_show_message\x18\x03\x20\x01(\x08R\x18notificat\
    ionsShowMessage\x12S\n&notifications_events_and_announcements\x18\x04\
    \x20\x01(\x08R#notificationsEventsAndAnnouncements\x12,\n\x12sounds_play\
    _ingame\x18\x05\x20\x01(\x08R\x10soundsPlayIngame\x12,\n\x12sounds_play_\
    online\x18\x06\x20\x01(\x08R\x10soundsPlayOnline\x12.\n\x13sounds_play_m\
    essage\x18\x07\x20\x01(\x08R\x11soundsPlayMessage\x12E\n\x1fsounds_event\
    s_and_announcements\x18\x08\x20\x01(\x08R\x1csoundsEventsAndAnnouncement\
    s\x123\n\x16always_new_chat_window\x18\t\x20\x01(\x08R\x13alwaysNewChatW\
    indow\x12E\n\x1fforce_alphabetic_friend_sorting\x18\n\x20\x01(\x08R\x1cf\
    orceAlphabeticFriendSorting\x12&\n\x0fchat_flash_mode\x18\x0b\x20\x01(\
    \x05R\rchatFlashMode\x12.\n\x13remember_open_chats\x18\x0c\x20\x01(\x08R\
    \x11rememberOpenChats\x120\n\x14compact_quick_access\x18\r\x20\x01(\x08R\
    \x12compactQuickAccess\x120\n\x14compact_friends_list\x18\x0e\x20\x01(\
    \x08R\x12compactFriendsList\x12X\n)notifications_show_chat_room_notifica\
    tion\x18\x0f\x20\x01(\x08R%notificationsShowChatRoomNotification\x12J\n\
    \"sounds_play_chat_room_notification\x18\x10\x20\x01(\x08R\x1esoundsPlay\
    ChatRoomNotification\x12I\n\"hide_offline_friends_in_tag_groups\x18\x11\
    \x20\x01(\x08R\x1dhideOfflineFriendsInTagGroups\x128\n\x18hide_categoriz\
    ed_friends\x18\x12\x20\x01(\x08R\x16hideCategorizedFriends\x12I\n\"categ\
    orize_in_game_friends_by_game\x18\x13\x20\x01(\x08R\x1dcategorizeInGameF\
    riendsByGame\x12$\n\x0echat_font_size\x18\x14\x20\x01(\x05R\x0cchatFontS\
    ize\x12'\n\x0fuse24hour_clock\x18\x15\x20\x01(\x08R\x0euse24hourClock\
    \x12-\n\x13do_not_disturb_mode\x18\x16\x20\x01(\x08R\x10doNotDisturbMode\
    \x124\n\x16disable_embed_inlining\x18\x17\x20\x01(\x08R\x14disableEmbedI\
    nlining\x12*\n\x11sign_into_friends\x18\x18\x20\x01(\x08R\x0fsignIntoFri\
    ends\x1a\xcf\x04\n\rVoiceSettings\x12(\n\x10voice_input_gain\x18\x01\x20\
    \x01(\x02R\x0evoiceInputGain\x12*\n\x11voice_output_gain\x18\x02\x20\x01\
    (\x02R\x0fvoiceOutputGain\x12(\n\x10noise_gate_level\x18\x03\x20\x01(\
    \x05R\x0enoiseGateLevel\x12=\n\x1bvoice_use_echo_cancellation\x18\x04\
    \x20\x01(\x08R\x18voiceUseEchoCancellation\x12?\n\x1cvoice_use_noise_can\
    cellation\x18\x05\x20\x01(\x08R\x19voiceUseNoiseCancellation\x12<\n\x1bv\
    oice_use_auto_gain_control\x18\x06\x20\x01(\x08R\x17voiceUseAutoGainCont\
    rol\x127\n\x18selected_non_default_mic\x18\x07\x20\x01(\x08R\x15selected\
    NonDefaultMic\x12=\n\x1bselected_non_default_output\x18\x08\x20\x01(\x08\
    R\x18selectedNonDefaultOutput\x12/\n\x14push_to_talk_enabled\x18\t\x20\
    \x01(\x08R\x11pushToTalkEnabled\x12/\n\x14push_to_mute_enabled\x18\n\x20\
    \x01(\x08R\x11pushToMuteEnabled\x12&\n\x0fplay_ptt_sounds\x18\x0b\x20\
    \x01(\x08R\rplayPttSounds\x1a\xaa\t\n\x07UIState\x12.\n\x13friends_list_\
    height\x18\x01\x20\x01(\x05R\x11friendsListHeight\x12,\n\x12friends_list\
    _width\x18\x02\x20\x01(\x05R\x10friendsListWidth\x12.\n\x13friends_list_\
    docked\x18\x03\x20\x01(\x08R\x11friendsListDocked\x124\n\x16friends_list\
    _collapsed\x18\x04\x20\x01(\x08R\x14friendsListCollapsed\x12D\n\x1ffrien\
    ds_list_group_chats_height\x18\x05\x20\x01(\x05R\x1bfriendsListGroupChat\
    sHeight\x120\n\x14friends_list_visible\x18\x06\x20\x01(\x08R\x12friendsL\
    istVisible\x12,\n\x12chat_popups_opened\x18\x07\x20\x01(\x05R\x10chatPop\
    upsOpened\x123\n\x16group_chat_tabs_opened\x18\x08\x20\x01(\x05R\x13grou\
    pChatTabsOpened\x125\n\x17friend_chat_tabs_opened\x18\t\x20\x01(\x05R\
    \x14friendChatTabsOpened\x12*\n\x11chat_window_width\x18\n\x20\x01(\x05R\
    \x0fchatWindowWidth\x12,\n\x12chat_window_height\x18\x0b\x20\x01(\x05R\
    \x10chatWindowHeight\x12~\n\x11category_collapse\x18\x0c\x20\x01(\x0b2Q.\
    CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryColla\
    pseStateR\x10categoryCollapse\x12@\n\x1dgroup_chat_left_col_collapsed\
    \x18\r\x20\x01(\x05R\x19groupChatLeftColCollapsed\x12B\n\x1egroup_chat_r\
    ight_col_collapsed\x18\x0e\x20\x01(\x05R\x1agroupChatRightColCollapsed\
    \x125\n\x18in_one_on_one_voice_chat\x18\x0f\x20\x01(\x08R\x13inOneOnOneV\
    oiceChat\x12-\n\x13in_group_voice_chat\x18\x10\x20\x01(\x08R\x10inGroupV\
    oiceChat\x1a\x82\x02\n\x15CategoryCollapseState\x12*\n\x11in_game_collap\
    sed\x18\x01\x20\x01(\x08R\x0finGameCollapsed\x12)\n\x10online_collapsed\
    \x18\x02\x20\x01(\x08R\x0fonlineCollapsed\x12+\n\x11offline_collapsed\
    \x18\x03\x20\x01(\x08R\x10offlineCollapsed\x122\n\x15game_groups_collaps\
    ed\x18\x04\x20\x01(\x05R\x13gameGroupsCollapsed\x121\n\x14categories_col\
    lapsed\x18\x05\x20\x01(\x05R\x13categoriesCollapsed\x1a\x90\x04\n\x07Met\
    rics\x12#\n\rfriends_count\x18\x01\x20\x01(\x05R\x0cfriendsCount\x124\n\
    \x16friends_category_count\x18\x02\x20\x01(\x05R\x14friendsCategoryCount\
    \x12:\n\x19friends_categorized_count\x18\x03\x20\x01(\x05R\x17friendsCat\
    egorizedCount\x120\n\x14friends_online_count\x18\x04\x20\x01(\x05R\x12fr\
    iendsOnlineCount\x121\n\x15friends_in_game_count\x18\x05\x20\x01(\x05R\
    \x12friendsInGameCount\x12D\n\x1ffriends_in_game_singleton_count\x18\x06\
    \x20\x01(\x05R\x1bfriendsInGameSingletonCount\x12(\n\x10game_group_count\
    \x18\x07\x20\x01(\x05R\x0egameGroupCount\x124\n\x16friends_favorite_coun\
    t\x18\x08\x20\x01(\x05R\x14friendsFavoriteCount\x12(\n\x10group_chat_cou\
    nt\x18\t\x20\x01(\x05R\x0egroupChatCount\x129\n\x19group_chat_favorite_c\
    ount\x18\n\x20\x01(\x05R\x16groupChatFavoriteCount\"a\n9CChatUsability_R\
    equestClientUsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\
    \x01\x20\x01(\rR\x0cmetricsRunId*\x9c\x01\n\x12EChatRoomJoinState\x12\
    \x20\n\x1ck_EChatRoomJoinState_Default\x10\0\x12\x1d\n\x19k_EChatRoomJoi\
    nState_None\x10\x01\x12\x1f\n\x1bk_EChatRoomJoinState_Joined\x10\x02\x12\
    $\n\x20k_EChatRoomJoinState_TestInvalid\x10c*\xa4\x02\n\x12EChatRoomGrou\
    pRank\x12\x20\n\x1ck_EChatRoomGroupRank_Default\x10\0\x12\x1f\n\x1bk_ECh\
    atRoomGroupRank_Viewer\x10\n\x12\x1e\n\x1ak_EChatRoomGroupRank_Guest\x10\
    \x0f\x12\x1f\n\x1bk_EChatRoomGroupRank_Member\x10\x14\x12\"\n\x1ek_EChat\
    RoomGroupRank_Moderator\x10\x1e\x12\x20\n\x1ck_EChatRoomGroupRank_Office\
    r\x10(\x12\x1e\n\x1ak_EChatRoomGroupRank_Owner\x102\x12$\n\x20k_EChatRoo\
    mGroupRank_TestInvalid\x10c*\xf4\x01\n\x1aEChatRoomNotificationLevel\x12\
    (\n$k_EChatroomNotificationLevel_Invalid\x10\0\x12%\n!k_EChatroomNotific\
    ationLevel_None\x10\x01\x12*\n&k_EChatroomNotificationLevel_MentionMe\
    \x10\x02\x12+\n'k_EChatroomNotificationLevel_MentionAll\x10\x03\x12,\n(k\
    _EChatroomNotificationLevel_AllMessages\x10\x04*\x97\x03\n\x16EChatRoomS\
    erverMessage\x12\x20\n\x1ck_EChatRoomServerMsg_Invalid\x10\0\x12'\n#k_EC\
    hatRoomServerMsg_RenameChatRoom\x10\x01\x12\x1f\n\x1bk_EChatRoomServerMs\
    g_Joined\x10\x02\x12\x1f\n\x1bk_EChatRoomServerMsg_Parted\x10\x03\x12\
    \x1f\n\x1bk_EChatRoomServerMsg_Kicked\x10\x04\x12\x20\n\x1ck_EChatRoomSe\
    rverMsg_Invited\x10\x05\x12(\n$k_EChatRoomServerMsg_InviteDismissed\x10\
    \x08\x12/\n+k_EChatRoomServerMsg_ChatRoomTaglineChanged\x10\t\x12.\n*k_E\
    ChatRoomServerMsg_ChatRoomAvatarChanged\x10\n\x12\"\n\x1ek_EChatRoomServ\
    erMsg_AppCustom\x10\x0b*\xcb\x03\n\x1aEChatRoomMemberStateChange\x12(\n$\
    k_EChatRoomMemberStateChange_Invalid\x10\0\x12'\n#k_EChatRoomMemberState\
    Change_Joined\x10\x01\x12'\n#k_EChatRoomMemberStateChange_Parted\x10\x02\
    \x12'\n#k_EChatRoomMemberStateChange_Kicked\x10\x03\x12(\n$k_EChatRoomMe\
    mberStateChange_Invited\x10\x04\x12,\n(k_EChatRoomMemberStateChange_Rank\
    Changed\x10\x07\x120\n,k_EChatRoomMemberStateChange_InviteDismissed\x10\
    \x08\x12&\n\"k_EChatRoomMemberStateChange_Muted\x10\t\x12'\n#k_EChatRoom\
    MemberStateChange_Banned\x10\n\x12-\n)k_EChatRoomMemberStateChange_Roles\
    Changed\x10\x0c2\x8b\x02\n\x04Chat\x12\xe7\x01\n\x1aRequestFriendPersona\
    States\x12).CChat_RequestFriendPersonaStates_Request\x1a*.CChat_RequestF\
    riendPersonaStates_Response\"r\x82\xb5\x18nRequest\x20to\x20be\x20notifi\
    ed\x20of\x20online\x20friend\x20persona\x20state\x20information.\x20\x20\
    Responses\x20sent\x20via\x20CMsgClientPersonaState.\x1a\x19\x82\xb5\x18\
    \x15Chat-related\x20services2\xff2\n\x08ChatRoom\x12\xa3\x01\n\x13Create\
    ChatRoomGroup\x12&.CChatRoom_CreateChatRoomGroup_Request\x1a'.CChatRoom_\
    CreateChatRoomGroup_Response\";\x82\xb5\x187Create's\x20a\x20chat\x20gro\
    up\x20that\x20can\x20contain\x20other\x20chat\x20rooms\x12z\n\x11SaveCha\
    tRoomGroup\x12$.CChatRoom_SaveChatRoomGroup_Request\x1a%.CChatRoom_SaveC\
    hatRoomGroup_Response\"\x18\x82\xb5\x18\x14Saves's\x20a\x20chat\x20group\
    \x12\x84\x01\n\x13RenameChatRoomGroup\x12&.CChatRoom_RenameChatRoomGroup\
    _Request\x1a'.CChatRoom_RenameChatRoomGroup_Response\"\x1c\x82\xb5\x18\
    \x18Rename\x20a\x20chat\x20room\x20group\x12\x99\x01\n\x17SetChatRoomGro\
    upTagline\x12*.CChatRoom_SetChatRoomGroupTagline_Request\x1a+.CChatRoom_\
    SetChatRoomGroupTagline_Response\"%\x82\xb5\x18!Set\x20tagline\x20for\
    \x20a\x20chat\x20room\x20group\x12\x99\x01\n\x16SetChatRoomGroupAvatar\
    \x12).CChatRoom_SetChatRoomGroupAvatar_Request\x1a*.CChatRoom_SetChatRoo\
    mGroupAvatar_Response\"(\x82\xb5\x18$Set\x20avatar\x20SHA\x20for\x20a\
    \x20chat\x20room\x20group\x12\xcb\x01\n!SetChatRoomGroupWatchingBroadcas\
    t\x124.CChatRoom_SetChatRoomGroupWatchingBroadcast_Request\x1a5.CChatRoo\
    m_SetChatRoomGroupWatchingBroadcast_Response\"9\x82\xb5\x185Sets\x20a\
    \x20broadcast\x20that\x20the\x20chat\x20room\x20group\x20is\x20watching\
    \x12d\n\x0fMuteUserInGroup\x12\x1b.CChatRoom_MuteUser_Request\x1a\x1c.CC\
    hatRoom_MuteUser_Response\"\x16\x82\xb5\x18\x12Mute\x20user\x20in\x20gro\
    up\x12h\n\x11KickUserFromGroup\x12\x1b.CChatRoom_KickUser_Request\x1a\
    \x1c.CChatRoom_KickUser_Response\"\x18\x82\xb5\x18\x14Kick\x20user\x20fr\
    om\x20group\x12y\n\x0fSetUserBanState\x12\".CChatRoom_SetUserBanState_Re\
    quest\x1a#.CChatRoom_SetUserBanState_Response\"\x1d\x82\xb5\x18\x19Ban/u\
    nban\x20user\x20from\x20group\x12\x82\x01\n\x13RevokeInviteToGroup\x12\
    \x1f.CChatRoom_RevokeInvite_Request\x1a\x20.CChatRoom_RevokeInvite_Respo\
    nse\"(\x82\xb5\x18$Revoke\x20a\x20direct\x20invitation\x20of\x20a\x20use\
    r\x12e\n\nCreateRole\x12\x1d.CChatRoom_CreateRole_Request\x1a\x1e.CChatR\
    oom_CreateRole_Response\"\x18\x82\xb5\x18\x14Create\x20role\x20for\x20go\
    up\x12a\n\x08GetRoles\x12\x1b.CChatRoom_GetRoles_Request\x1a\x1c.CChatRo\
    om_GetRoles_Response\"\x1a\x82\xb5\x18\x16Get\x20all\x20roles\x20in\x20g\
    roup\x12e\n\nRenameRole\x12\x1d.CChatRoom_RenameRole_Request\x1a\x1e.CCh\
    atRoom_RenameRole_Response\"\x18\x82\xb5\x18\x14Rename\x20role\x20for\
    \x20goup\x12l\n\x0bReorderRole\x12\x1e.CChatRoom_ReorderRole_Request\x1a\
    \x1f.CChatRoom_ReorderRole_Response\"\x1c\x82\xb5\x18\x18Reorder\x20role\
    \x20with\x20a\x20goup\x12g\n\nDeleteRole\x12\x1d.CChatRoom_DeleteRole_Re\
    quest\x1a\x1e.CChatRoom_DeleteRole_Response\"\x1a\x82\xb5\x18\x16Delete\
    \x20role\x20from\x20group\x12\x87\x01\n\x0eGetRoleActions\x12!.CChatRoom\
    _GetRoleActions_Request\x1a\".CChatRoom_GetRoleActions_Response\".\x82\
    \xb5\x18*Get\x20all\x20defined\x20roles\x20and\x20actions\x20in\x20group\
    \x12\x86\x01\n\x12ReplaceRoleActions\x12%.CChatRoom_ReplaceRoleActions_R\
    equest\x1a&.CChatRoom_ReplaceRoleActions_Response\"!\x82\xb5\x18\x1dRepl\
    ace\x20role\x20actions\x20in\x20group\x12s\n\rAddRoleToUser\x12\x20.CCha\
    tRoom_AddRoleToUser_Request\x1a!.CChatRoom_AddRoleToUser_Response\"\x1d\
    \x82\xb5\x18\x19Add\x20role\x20to\x20user\x20in\x20group\x12\x87\x01\n\
    \x0fGetRolesForUser\x12\".CChatRoom_GetRolesForUser_Request\x1a#.CChatRo\
    om_GetRolesForUser_Response\"+\x82\xb5\x18'Get\x20all\x20roles\x20assign\
    ed\x20to\x20user\x20in\x20group\x12\x87\x01\n\x12DeleteRoleFromUser\x12%\
    .CChatRoom_DeleteRoleFromUser_Request\x1a&.CChatRoom_DeleteRoleFromUser_\
    Response\"\"\x82\xb5\x18\x1eDelete\x20role\x20from\x20user\x20in\x20grou\
    p\x12\x81\x01\n\x11JoinChatRoomGroup\x12$.CChatRoom_JoinChatRoomGroup_Re\
    quest\x1a%.CChatRoom_JoinChatRoomGroup_Response\"\x1f\x82\xb5\x18\x1bJoi\
    n\x20a\x20multi-user\x20chat\x20room\x12\xad\x01\n\x1bInviteFriendToChat\
    RoomGroup\x12..CChatRoom_InviteFriendToChatRoomGroup_Request\x1a/.CChatR\
    oom_InviteFriendToChatRoomGroup_Response\"-\x82\xb5\x18)Invite\x20a\x20f\
    riend\x20to\x20a\x20multi-user\x20chat\x20room\x12\x97\x01\n\x12LeaveCha\
    tRoomGroup\x12%.CChatRoom_LeaveChatRoomGroup_Request\x1a&.CChatRoom_Leav\
    eChatRoomGroup_Response\"2\x82\xb5\x18.Leaves\x20a\x20chat\x20room\x20gr\
    oup\x20and\x20all\x20related\x20chats\x12\x89\x01\n\x0eCreateChatRoom\
    \x12!.CChatRoom_CreateChatRoom_Request\x1a\".CChatRoom_CreateChatRoom_Re\
    sponse\"0\x82\xb5\x18,Creates\x20a\x20chat\x20room\x20inside\x20a\x20cha\
    t\x20room\x20group\x12\x89\x01\n\x0eDeleteChatRoom\x12!.CChatRoom_Delete\
    ChatRoom_Request\x1a\".CChatRoom_DeleteChatRoom_Response\"0\x82\xb5\x18,\
    Deletes\x20a\x20chat\x20room\x20inside\x20a\x20chat\x20room\x20group\x12\
    \x89\x01\n\x0eRenameChatRoom\x12!.CChatRoom_RenameChatRoom_Request\x1a\"\
    .CChatRoom_RenameChatRoom_Response\"0\x82\xb5\x18,Renames\x20a\x20chat\
    \x20room\x20inside\x20a\x20chat\x20room\x20group\x12\x8d\x01\n\x0fReorde\
    rChatRoom\x12\".CChatRoom_ReorderChatRoom_Request\x1a#.CChatRoom_Reorder\
    ChatRoom_Response\"1\x82\xb5\x18-Reorders\x20a\x20chat\x20room\x20inside\
    \x20a\x20chat\x20room\x20group\x12\x8d\x01\n\x0fSendChatMessage\x12\".CC\
    hatRoom_SendChatMessage_Request\x1a#.CChatRoom_SendChatMessage_Response\
    \"1\x82\xb5\x18-Send\x20a\x20chat\x20message\x20to\x20a\x20multi-user\
    \x20chat\x20room\x12\xa7\x01\n\rJoinVoiceChat\x12\x20.CChatRoom_JoinVoic\
    eChat_Request\x1a!.CChatRoom_JoinVoiceChat_Response\"Q\x82\xb5\x18MJoin\
    \x20the\x20voice\x20chat\x20in\x20a\x20multi-room\x20chat\x20(should\x20\
    already\x20be\x20in\x20the\x20chat\x20room)\x12\x86\x01\n\x0eLeaveVoiceC\
    hat\x12!.CChatRoom_LeaveVoiceChat_Request\x1a\".CChatRoom_LeaveVoiceChat\
    _Response\"-\x82\xb5\x18)Leave\x20the\x20voice\x20chat\x20in\x20a\x20mul\
    ti-room\x20chat\x12\xc3\x01\n\x11GetMessageHistory\x12$.CChatRoom_GetMes\
    sageHistory_Request\x1a%.CChatRoom_GetMessageHistory_Response\"a\x82\xb5\
    \x18]Get\x20the\x20history\x20of\x20messages\x20in\x20a\x20chat\x20room.\
    \x20\x20You\x20must\x20currently\x20be\x20a\x20member\x20of\x20the\x20ch\
    at\x20room.\x12\x88\x01\n\x13GetMyChatRoomGroups\x12&.CChatRoom_GetMyCha\
    tRoomGroups_Request\x1a'.CChatRoom_GetMyChatRoomGroups_Response\"\x20\
    \x82\xb5\x18\x1cGet\x20a\x20list\x20of\x20our\x20chat\x20rooms\x12\x9a\
    \x01\n\x15GetChatRoomGroupState\x12(.CChatRoom_GetChatRoomGroupState_Req\
    uest\x1a).CChatRoom_GetChatRoomGroupState_Response\",\x82\xb5\x18(Get\
    \x20information\x20about\x20a\x20single\x20chat\x20room\x12\xa5\x01\n\
    \x17GetChatRoomGroupSummary\x12*.CChatRoom_GetChatRoomGroupSummary_Reque\
    st\x1a+.CChatRoom_GetChatRoomGroupSummary_Response\"1\x82\xb5\x18-Get\
    \x20basic\x20information\x20about\x20a\x20chat\x20room\x20group\x12\x8f\
    \x01\n\x0eAckChatMessage\x12&.CChatRoom_AckChatMessage_Notification\x1a\
    \x0b.NoResponse\"H\x82\xb5\x18DAcknowledge\x20that\x20we\x20have\x20seen\
    \x20the\x20most\x20recent\x20chat\x20message\x20in\x20a\x20chat\x12\x81\
    \x01\n\x10CreateInviteLink\x12#.CChatRoom_CreateInviteLink_Request\x1a$.\
    CChatRoom_CreateInviteLink_Response\"\"\x82\xb5\x18\x1eCreates\x20a\x20c\
    hatroom\x20invite\x20link\x12\x90\x01\n\x11GetInviteLinkInfo\x12$.CChatR\
    oom_GetInviteLinkInfo_Request\x1a%.CChatRoom_GetInviteLinkInfo_Response\
    \".\x82\xb5\x18*Returns\x20chat\x20room\x20info\x20about\x20provided\x20\
    link\x12\xaa\x01\n\rGetInviteInfo\x12\x20.CChatRoom_GetInviteInfo_Reques\
    t\x1a!.CChatRoom_GetInviteInfo_Response\"T\x82\xb5\x18PReturns\x20chat\
    \x20room\x20info\x20about\x20any\x20invite\x20involving\x20the\x20sender\
    \x20and\x20passed\x20group\x20id\x12\xa5\x01\n\x16GetInviteLinksForGroup\
    \x12).CChatRoom_GetInviteLinksForGroup_Request\x1a*.CChatRoom_GetInviteL\
    inksForGroup_Response\"4\x82\xb5\x180Returns\x20all\x20invite\x20links\
    \x20for\x20the\x20specified\x20group\x12\x8b\x01\n\nGetBanList\x12\x1d.C\
    ChatRoom_GetBanList_Request\x1a\x1e.CChatRoom_GetBanList_Response\">\x82\
    \xb5\x18:Gets\x20a\x20list\x20of\x20users\x20who\x20have\x20been\x20bann\
    ed\x20from\x20a\x20chat\x20room\x12\x93\x01\n\rGetInviteList\x12\x20.CCh\
    atRoom_GetInviteList_Request\x1a!.CChatRoom_GetInviteList_Response\"=\
    \x82\xb5\x189Gets\x20a\x20list\x20of\x20users\x20who\x20have\x20been\x20\
    invited\x20to\x20a\x20chat\x20room\x12\x80\x01\n\x10DeleteInviteLink\x12\
    #.CChatRoom_DeleteInviteLink_Request\x1a$.CChatRoom_DeleteInviteLink_Res\
    ponse\"!\x82\xb5\x18\x1dDeletes\x20specified\x20invite\x20link\x12\xc4\
    \x01\n\x1eSetSessionActiveChatRoomGroups\x121.CChatRoom_SetSessionActive\
    ChatRoomGroups_Request\x1a2.CChatRoom_SetSessionActiveChatRoomGroups_Res\
    ponse\";\x82\xb5\x187Set\x20which\x20chat\x20rooms\x20we\x20are\x20using\
    \x20in\x20the\x20active\x20session\x12\xb9\x01\n\x1bSetUserChatGroupPref\
    erences\x12..CChatRoom_SetUserChatGroupPreferences_Request\x1a/.CChatRoo\
    m_SetUserChatGroupPreferences_Response\"9\x82\xb5\x185Set\x20preferences\
    \x20around\x20chat\x20notifications\x20for\x20a\x20group\x12\x88\x01\n\
    \x12DeleteChatMessages\x12%.CChatRoom_DeleteChatMessages_Request\x1a&.CC\
    hatRoom_DeleteChatMessages_Response\"#\x82\xb5\x18\x1fDeletes\x20specifi\
    ed\x20chat\x20messages\x1aB\x82\xb5\x18>Service\x20for\x20joining,\x20ma\
    naging,\x20and\x20using\x20multi-user\x20chat\x20rooms2\xae\x03\n\rClanC\
    hatRooms\x12\xb8\x01\n\x13GetClanChatRoomInfo\x12+.CClanChatRooms_GetCla\
    nChatRoomInfo_Request\x1a,.CClanChatRooms_GetClanChatRoomInfo_Response\"\
    F\x82\xb5\x18BGet\x20a\x20list\x20of\x20chat\x20rooms\x20for\x20a\x20cla\
    n,\x20optionally\x20creating\x20a\x20new\x20one\x12\xb2\x01\n\x16SetClan\
    ChatRoomPrivate\x12..CClanChatRooms_SetClanChatRoomPrivate_Request\x1a/.\
    CClanChatRooms_SetClanChatRoomPrivate_Response\"7\x82\xb5\x183Set\x20a\
    \x20clan\x20chat\x20room\x20to\x20be\x20members\x20only\x20(or\x20public\
    )\x1a-\x82\xb5\x18)Methods\x20for\x20getting\x20clan\x20chat\x20informat\
    ion2\xbe\n\n\x0eChatRoomClient\x12{\n\x19NotifyIncomingChatMessage\x12+.\
    CChatRoom_IncomingChatMessage_Notification\x1a\x0b.NoResponse\"$\x82\xb5\
    \x18\x20New\x20chat\x20message\x20for\x20a\x20chat\x20room\x12\x94\x01\n\
    \x19NotifyChatMessageModified\x12+.CChatRoom_ChatMessageModified_Notific\
    ation\x1a\x0b.NoResponse\"=\x82\xb5\x189An\x20existing\x20chat\x20messag\
    e\x20has\x20been\x20modified\x20on\x20the\x20backend\x12\x95\x01\n\x17No\
    tifyMemberStateChange\x12).CChatRoom_MemberStateChange_Notification\x1a\
    \x0b.NoResponse\"B\x82\xb5\x18>A\x20chat\x20room\x20member's\x20state\
    \x20has\x20changed\x20(join/part/permissions)\x12\x88\x01\n\x1fNotifyCha\
    tRoomHeaderStateChange\x12+.CChatRoom_ChatRoomHeaderState_Notification\
    \x1a\x0b.NoResponse\"+\x82\xb5\x18'Chat\x20Room\x20header\x20/\x20metada\
    ta\x20has\x20changed\x12\xa6\x01\n\x1eNotifyChatRoomGroupRoomsChange\x12\
    0.CChatRoom_ChatRoomGroupRoomsChange_Notification\x1a\x0b.NoResponse\"E\
    \x82\xb5\x18ASomething\x20about\x20a\x20chatroom\x20group\x20changed\x20\
    (created,\x20deleted,\x20etc.)\x12\xd5\x01\n#NotifyShouldRejoinChatRoomV\
    oiceChat\x12;.CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification\
    \x1a\x0b.NoResponse\"d\x82\xb5\x18`Voice\x20chat\x20was\x20recreated\x20\
    or\x20dropped\x20on\x20the\x20backend\x20and\x20client\x20needs\x20to\
    \x20rejoin\x20to\x20remain\x20in\x20chat.\x12\xb3\x01\n\x1fNotifyChatGro\
    upUserStateChanged\x12<.ChatRoomClient_NotifyChatGroupUserStateChanged_N\
    otification\x1a\x0b.NoResponse\"E\x82\xb5\x18AUser\x20chat\x20group\x20s\
    tate\x20(preferences,\x20ack\x20state,\x20etc)\x20have\x20changed.\x12\
    \x8f\x01\n\x18NotifyAckChatMessageEcho\x12&.CChatRoom_AckChatMessage_Not\
    ification\x1a\x0b.NoResponse\">\x82\xb5\x18:A\x20session\x20acked\x20an\
    \x20unread\x20message,\x20echo\x20to\x20other\x20sessions.\x1a,\x82\xb5\
    \x18$Client\x20notifications\x20for\x20chat\x20events\xc0\xb5\x18\x022\
    \xc2\x01\n\rChatUsability\x12\x86\x01\n\x1cNotifyClientUsabilityMetrics\
    \x123.CChatUsability_ClientUsabilityMetrics_Notification\x1a\x0b.NoRespo\
    nse\"$\x82\xb5\x18\x20Incoming\x20metrics\x20from\x20the\x20client\x1a(\
    \x82\xb5\x18$Client\x20notifications\x20for\x20chat\x20events2\xe2\x01\n\
    \x13ChatUsabilityClient\x12\x99\x01\n#NotifyRequestClientUsabilityMetric\
    s\x12:.CChatUsability_RequestClientUsabilityMetrics_Notification\x1a\x0b\
    .NoResponse\")\x82\xb5\x18%Request\x20client\x20send\x20usability\x20met\
    rics\x1a/\x82\xb5\x18'Client\x20notifications\x20for\x20chat\x20usabilit\
    y\xc0\xb5\x18\x02B\x03\x80\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
