// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_publishedfile.steamclient.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Subscribe_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    list_type: ::std::option::Option<u32>,
    appid: ::std::option::Option<i32>,
    notify_client: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Subscribe_Request {
    fn default() -> &'a CPublishedFile_Subscribe_Request {
        <CPublishedFile_Subscribe_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Subscribe_Request {
    pub fn new() -> CPublishedFile_Subscribe_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 list_type = 2;


    pub fn get_list_type(&self) -> u32 {
        self.list_type.unwrap_or(0)
    }
    pub fn clear_list_type(&mut self) {
        self.list_type = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        self.list_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: u32) {
        self.list_type = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 3;


    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool notify_client = 4;


    pub fn get_notify_client(&self) -> bool {
        self.notify_client.unwrap_or(false)
    }
    pub fn clear_notify_client(&mut self) {
        self.notify_client = ::std::option::Option::None;
    }

    pub fn has_notify_client(&self) -> bool {
        self.notify_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notify_client(&mut self, v: bool) {
        self.notify_client = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_Subscribe_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.list_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notify_client = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.list_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.notify_client {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.list_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.notify_client {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Subscribe_Request {
        CPublishedFile_Subscribe_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_Subscribe_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_Subscribe_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "list_type",
                    |m: &CPublishedFile_Subscribe_Request| { &m.list_type },
                    |m: &mut CPublishedFile_Subscribe_Request| { &mut m.list_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "appid",
                    |m: &CPublishedFile_Subscribe_Request| { &m.appid },
                    |m: &mut CPublishedFile_Subscribe_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notify_client",
                    |m: &CPublishedFile_Subscribe_Request| { &m.notify_client },
                    |m: &mut CPublishedFile_Subscribe_Request| { &mut m.notify_client },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Subscribe_Request>(
                    "CPublishedFile_Subscribe_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Subscribe_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Subscribe_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Subscribe_Request,
        };
        unsafe {
            instance.get(CPublishedFile_Subscribe_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Subscribe_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.list_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.notify_client = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Subscribe_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Subscribe_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Subscribe_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Subscribe_Response {
    fn default() -> &'a CPublishedFile_Subscribe_Response {
        <CPublishedFile_Subscribe_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Subscribe_Response {
    pub fn new() -> CPublishedFile_Subscribe_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_Subscribe_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Subscribe_Response {
        CPublishedFile_Subscribe_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Subscribe_Response>(
                    "CPublishedFile_Subscribe_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Subscribe_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Subscribe_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Subscribe_Response,
        };
        unsafe {
            instance.get(CPublishedFile_Subscribe_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Subscribe_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Subscribe_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Subscribe_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Unsubscribe_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    list_type: ::std::option::Option<u32>,
    appid: ::std::option::Option<i32>,
    notify_client: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Unsubscribe_Request {
    fn default() -> &'a CPublishedFile_Unsubscribe_Request {
        <CPublishedFile_Unsubscribe_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Unsubscribe_Request {
    pub fn new() -> CPublishedFile_Unsubscribe_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 list_type = 2;


    pub fn get_list_type(&self) -> u32 {
        self.list_type.unwrap_or(0)
    }
    pub fn clear_list_type(&mut self) {
        self.list_type = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        self.list_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: u32) {
        self.list_type = ::std::option::Option::Some(v);
    }

    // optional int32 appid = 3;


    pub fn get_appid(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool notify_client = 4;


    pub fn get_notify_client(&self) -> bool {
        self.notify_client.unwrap_or(false)
    }
    pub fn clear_notify_client(&mut self) {
        self.notify_client = ::std::option::Option::None;
    }

    pub fn has_notify_client(&self) -> bool {
        self.notify_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notify_client(&mut self, v: bool) {
        self.notify_client = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_Unsubscribe_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.list_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notify_client = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.list_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.notify_client {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.list_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.notify_client {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Unsubscribe_Request {
        CPublishedFile_Unsubscribe_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_Unsubscribe_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "list_type",
                    |m: &CPublishedFile_Unsubscribe_Request| { &m.list_type },
                    |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.list_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "appid",
                    |m: &CPublishedFile_Unsubscribe_Request| { &m.appid },
                    |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notify_client",
                    |m: &CPublishedFile_Unsubscribe_Request| { &m.notify_client },
                    |m: &mut CPublishedFile_Unsubscribe_Request| { &mut m.notify_client },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Unsubscribe_Request>(
                    "CPublishedFile_Unsubscribe_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Unsubscribe_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Unsubscribe_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Unsubscribe_Request,
        };
        unsafe {
            instance.get(CPublishedFile_Unsubscribe_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Unsubscribe_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.list_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.notify_client = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Unsubscribe_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Unsubscribe_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Unsubscribe_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Unsubscribe_Response {
    fn default() -> &'a CPublishedFile_Unsubscribe_Response {
        <CPublishedFile_Unsubscribe_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Unsubscribe_Response {
    pub fn new() -> CPublishedFile_Unsubscribe_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_Unsubscribe_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Unsubscribe_Response {
        CPublishedFile_Unsubscribe_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Unsubscribe_Response>(
                    "CPublishedFile_Unsubscribe_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Unsubscribe_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Unsubscribe_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Unsubscribe_Response,
        };
        unsafe {
            instance.get(CPublishedFile_Unsubscribe_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Unsubscribe_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Unsubscribe_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Unsubscribe_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_CanSubscribe_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_CanSubscribe_Request {
    fn default() -> &'a CPublishedFile_CanSubscribe_Request {
        <CPublishedFile_CanSubscribe_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_CanSubscribe_Request {
    pub fn new() -> CPublishedFile_CanSubscribe_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_CanSubscribe_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_CanSubscribe_Request {
        CPublishedFile_CanSubscribe_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_CanSubscribe_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_CanSubscribe_Request| { &mut m.publishedfileid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_CanSubscribe_Request>(
                    "CPublishedFile_CanSubscribe_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_CanSubscribe_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_CanSubscribe_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_CanSubscribe_Request,
        };
        unsafe {
            instance.get(CPublishedFile_CanSubscribe_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_CanSubscribe_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_CanSubscribe_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_CanSubscribe_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_CanSubscribe_Response {
    // message fields
    can_subscribe: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_CanSubscribe_Response {
    fn default() -> &'a CPublishedFile_CanSubscribe_Response {
        <CPublishedFile_CanSubscribe_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_CanSubscribe_Response {
    pub fn new() -> CPublishedFile_CanSubscribe_Response {
        ::std::default::Default::default()
    }

    // optional bool can_subscribe = 1;


    pub fn get_can_subscribe(&self) -> bool {
        self.can_subscribe.unwrap_or(false)
    }
    pub fn clear_can_subscribe(&mut self) {
        self.can_subscribe = ::std::option::Option::None;
    }

    pub fn has_can_subscribe(&self) -> bool {
        self.can_subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_subscribe(&mut self, v: bool) {
        self.can_subscribe = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_CanSubscribe_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_subscribe = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.can_subscribe {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.can_subscribe {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_CanSubscribe_Response {
        CPublishedFile_CanSubscribe_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_subscribe",
                    |m: &CPublishedFile_CanSubscribe_Response| { &m.can_subscribe },
                    |m: &mut CPublishedFile_CanSubscribe_Response| { &mut m.can_subscribe },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_CanSubscribe_Response>(
                    "CPublishedFile_CanSubscribe_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_CanSubscribe_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_CanSubscribe_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_CanSubscribe_Response,
        };
        unsafe {
            instance.get(CPublishedFile_CanSubscribe_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_CanSubscribe_Response {
    fn clear(&mut self) {
        self.can_subscribe = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_CanSubscribe_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_CanSubscribe_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Publish_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    consumer_appid: ::std::option::Option<u32>,
    cloudfilename: ::protobuf::SingularField<::std::string::String>,
    preview_cloudfilename: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    file_description: ::protobuf::SingularField<::std::string::String>,
    file_type: ::std::option::Option<u32>,
    consumer_shortcut_name: ::protobuf::SingularField<::std::string::String>,
    youtube_username: ::protobuf::SingularField<::std::string::String>,
    youtube_videoid: ::protobuf::SingularField<::std::string::String>,
    visibility: ::std::option::Option<u32>,
    redirect_uri: ::protobuf::SingularField<::std::string::String>,
    tags: ::protobuf::RepeatedField<::std::string::String>,
    collection_type: ::protobuf::SingularField<::std::string::String>,
    game_type: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Publish_Request {
    fn default() -> &'a CPublishedFile_Publish_Request {
        <CPublishedFile_Publish_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Publish_Request {
    pub fn new() -> CPublishedFile_Publish_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 consumer_appid = 2;


    pub fn get_consumer_appid(&self) -> u32 {
        self.consumer_appid.unwrap_or(0)
    }
    pub fn clear_consumer_appid(&mut self) {
        self.consumer_appid = ::std::option::Option::None;
    }

    pub fn has_consumer_appid(&self) -> bool {
        self.consumer_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_appid(&mut self, v: u32) {
        self.consumer_appid = ::std::option::Option::Some(v);
    }

    // optional string cloudfilename = 3;


    pub fn get_cloudfilename(&self) -> &str {
        match self.cloudfilename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cloudfilename(&mut self) {
        self.cloudfilename.clear();
    }

    pub fn has_cloudfilename(&self) -> bool {
        self.cloudfilename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloudfilename(&mut self, v: ::std::string::String) {
        self.cloudfilename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloudfilename(&mut self) -> &mut ::std::string::String {
        if self.cloudfilename.is_none() {
            self.cloudfilename.set_default();
        }
        self.cloudfilename.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloudfilename(&mut self) -> ::std::string::String {
        self.cloudfilename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_cloudfilename = 4;


    pub fn get_preview_cloudfilename(&self) -> &str {
        match self.preview_cloudfilename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_preview_cloudfilename(&mut self) {
        self.preview_cloudfilename.clear();
    }

    pub fn has_preview_cloudfilename(&self) -> bool {
        self.preview_cloudfilename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_cloudfilename(&mut self, v: ::std::string::String) {
        self.preview_cloudfilename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_cloudfilename(&mut self) -> &mut ::std::string::String {
        if self.preview_cloudfilename.is_none() {
            self.preview_cloudfilename.set_default();
        }
        self.preview_cloudfilename.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_cloudfilename(&mut self) -> ::std::string::String {
        self.preview_cloudfilename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_description = 6;


    pub fn get_file_description(&self) -> &str {
        match self.file_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_description(&mut self) {
        self.file_description.clear();
    }

    pub fn has_file_description(&self) -> bool {
        self.file_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_description(&mut self, v: ::std::string::String) {
        self.file_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_description(&mut self) -> &mut ::std::string::String {
        if self.file_description.is_none() {
            self.file_description.set_default();
        }
        self.file_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_description(&mut self) -> ::std::string::String {
        self.file_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_type = 7;


    pub fn get_file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }
    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional string consumer_shortcut_name = 8;


    pub fn get_consumer_shortcut_name(&self) -> &str {
        match self.consumer_shortcut_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_consumer_shortcut_name(&mut self) {
        self.consumer_shortcut_name.clear();
    }

    pub fn has_consumer_shortcut_name(&self) -> bool {
        self.consumer_shortcut_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_shortcut_name(&mut self, v: ::std::string::String) {
        self.consumer_shortcut_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_shortcut_name(&mut self) -> &mut ::std::string::String {
        if self.consumer_shortcut_name.is_none() {
            self.consumer_shortcut_name.set_default();
        }
        self.consumer_shortcut_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumer_shortcut_name(&mut self) -> ::std::string::String {
        self.consumer_shortcut_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_username = 9;


    pub fn get_youtube_username(&self) -> &str {
        match self.youtube_username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtube_username(&mut self) {
        self.youtube_username.clear();
    }

    pub fn has_youtube_username(&self) -> bool {
        self.youtube_username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_username(&mut self, v: ::std::string::String) {
        self.youtube_username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_username(&mut self) -> &mut ::std::string::String {
        if self.youtube_username.is_none() {
            self.youtube_username.set_default();
        }
        self.youtube_username.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_username(&mut self) -> ::std::string::String {
        self.youtube_username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_videoid = 10;


    pub fn get_youtube_videoid(&self) -> &str {
        match self.youtube_videoid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtube_videoid(&mut self) {
        self.youtube_videoid.clear();
    }

    pub fn has_youtube_videoid(&self) -> bool {
        self.youtube_videoid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_videoid(&mut self, v: ::std::string::String) {
        self.youtube_videoid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_videoid(&mut self) -> &mut ::std::string::String {
        if self.youtube_videoid.is_none() {
            self.youtube_videoid.set_default();
        }
        self.youtube_videoid.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_videoid(&mut self) -> ::std::string::String {
        self.youtube_videoid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 visibility = 11;


    pub fn get_visibility(&self) -> u32 {
        self.visibility.unwrap_or(0)
    }
    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: u32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional string redirect_uri = 12;


    pub fn get_redirect_uri(&self) -> &str {
        match self.redirect_uri.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_redirect_uri(&mut self) {
        self.redirect_uri.clear();
    }

    pub fn has_redirect_uri(&self) -> bool {
        self.redirect_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redirect_uri(&mut self, v: ::std::string::String) {
        self.redirect_uri = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redirect_uri(&mut self) -> &mut ::std::string::String {
        if self.redirect_uri.is_none() {
            self.redirect_uri.set_default();
        }
        self.redirect_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_redirect_uri(&mut self) -> ::std::string::String {
        self.redirect_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tags = 13;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // optional string collection_type = 14;


    pub fn get_collection_type(&self) -> &str {
        match self.collection_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_collection_type(&mut self) {
        self.collection_type.clear();
    }

    pub fn has_collection_type(&self) -> bool {
        self.collection_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collection_type(&mut self, v: ::std::string::String) {
        self.collection_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection_type(&mut self) -> &mut ::std::string::String {
        if self.collection_type.is_none() {
            self.collection_type.set_default();
        }
        self.collection_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_collection_type(&mut self) -> ::std::string::String {
        self.collection_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_type = 15;


    pub fn get_game_type(&self) -> &str {
        match self.game_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_type(&mut self) {
        self.game_type.clear();
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: ::std::string::String) {
        self.game_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_type(&mut self) -> &mut ::std::string::String {
        if self.game_type.is_none() {
            self.game_type.set_default();
        }
        self.game_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_type(&mut self) -> ::std::string::String {
        self.game_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 16;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_Publish_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consumer_appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cloudfilename)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_cloudfilename)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_description)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_type = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumer_shortcut_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_username)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_videoid)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.redirect_uri)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.collection_type)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_type)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cloudfilename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.preview_cloudfilename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.file_description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.consumer_shortcut_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.youtube_username.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.youtube_videoid.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.redirect_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if let Some(ref v) = self.collection_type.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.game_type.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.consumer_appid {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.cloudfilename.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.preview_cloudfilename.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.file_description.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.consumer_shortcut_name.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.youtube_username.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.youtube_videoid.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.visibility {
            os.write_uint32(11, v)?;
        }
        if let Some(ref v) = self.redirect_uri.as_ref() {
            os.write_string(12, &v)?;
        }
        for v in &self.tags {
            os.write_string(13, &v)?;
        };
        if let Some(ref v) = self.collection_type.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.game_type.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(16, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Publish_Request {
        CPublishedFile_Publish_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_Publish_Request| { &m.appid },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "consumer_appid",
                    |m: &CPublishedFile_Publish_Request| { &m.consumer_appid },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.consumer_appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cloudfilename",
                    |m: &CPublishedFile_Publish_Request| { &m.cloudfilename },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.cloudfilename },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "preview_cloudfilename",
                    |m: &CPublishedFile_Publish_Request| { &m.preview_cloudfilename },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.preview_cloudfilename },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &CPublishedFile_Publish_Request| { &m.title },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_description",
                    |m: &CPublishedFile_Publish_Request| { &m.file_description },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.file_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "file_type",
                    |m: &CPublishedFile_Publish_Request| { &m.file_type },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.file_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "consumer_shortcut_name",
                    |m: &CPublishedFile_Publish_Request| { &m.consumer_shortcut_name },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.consumer_shortcut_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "youtube_username",
                    |m: &CPublishedFile_Publish_Request| { &m.youtube_username },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.youtube_username },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "youtube_videoid",
                    |m: &CPublishedFile_Publish_Request| { &m.youtube_videoid },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.youtube_videoid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "visibility",
                    |m: &CPublishedFile_Publish_Request| { &m.visibility },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.visibility },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "redirect_uri",
                    |m: &CPublishedFile_Publish_Request| { &m.redirect_uri },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.redirect_uri },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    |m: &CPublishedFile_Publish_Request| { &m.tags },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection_type",
                    |m: &CPublishedFile_Publish_Request| { &m.collection_type },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.collection_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "game_type",
                    |m: &CPublishedFile_Publish_Request| { &m.game_type },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.game_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &CPublishedFile_Publish_Request| { &m.url },
                    |m: &mut CPublishedFile_Publish_Request| { &mut m.url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Publish_Request>(
                    "CPublishedFile_Publish_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Publish_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Publish_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Publish_Request,
        };
        unsafe {
            instance.get(CPublishedFile_Publish_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Publish_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.consumer_appid = ::std::option::Option::None;
        self.cloudfilename.clear();
        self.preview_cloudfilename.clear();
        self.title.clear();
        self.file_description.clear();
        self.file_type = ::std::option::Option::None;
        self.consumer_shortcut_name.clear();
        self.youtube_username.clear();
        self.youtube_videoid.clear();
        self.visibility = ::std::option::Option::None;
        self.redirect_uri.clear();
        self.tags.clear();
        self.collection_type.clear();
        self.game_type.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Publish_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Publish_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Publish_Response {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    redirect_uri: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Publish_Response {
    fn default() -> &'a CPublishedFile_Publish_Response {
        <CPublishedFile_Publish_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Publish_Response {
    pub fn new() -> CPublishedFile_Publish_Response {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional string redirect_uri = 2;


    pub fn get_redirect_uri(&self) -> &str {
        match self.redirect_uri.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_redirect_uri(&mut self) {
        self.redirect_uri.clear();
    }

    pub fn has_redirect_uri(&self) -> bool {
        self.redirect_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redirect_uri(&mut self, v: ::std::string::String) {
        self.redirect_uri = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redirect_uri(&mut self) -> &mut ::std::string::String {
        if self.redirect_uri.is_none() {
            self.redirect_uri.set_default();
        }
        self.redirect_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_redirect_uri(&mut self) -> ::std::string::String {
        self.redirect_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_Publish_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.redirect_uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.redirect_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.redirect_uri.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Publish_Response {
        CPublishedFile_Publish_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_Publish_Response| { &m.publishedfileid },
                    |m: &mut CPublishedFile_Publish_Response| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "redirect_uri",
                    |m: &CPublishedFile_Publish_Response| { &m.redirect_uri },
                    |m: &mut CPublishedFile_Publish_Response| { &mut m.redirect_uri },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Publish_Response>(
                    "CPublishedFile_Publish_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Publish_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Publish_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Publish_Response,
        };
        unsafe {
            instance.get(CPublishedFile_Publish_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Publish_Response {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.redirect_uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Publish_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Publish_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetDetails_Request {
    // message fields
    publishedfileids: ::std::vec::Vec<u64>,
    includetags: ::std::option::Option<bool>,
    includeadditionalpreviews: ::std::option::Option<bool>,
    includechildren: ::std::option::Option<bool>,
    includekvtags: ::std::option::Option<bool>,
    includevotes: ::std::option::Option<bool>,
    short_description: ::std::option::Option<bool>,
    includeforsaledata: ::std::option::Option<bool>,
    includemetadata: ::std::option::Option<bool>,
    language: ::std::option::Option<i32>,
    return_playtime_stats: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    strip_description_bbcode: ::std::option::Option<bool>,
    desired_revision: ::std::option::Option<EPublishedFileRevision>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetDetails_Request {
    fn default() -> &'a CPublishedFile_GetDetails_Request {
        <CPublishedFile_GetDetails_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetDetails_Request {
    pub fn new() -> CPublishedFile_GetDetails_Request {
        ::std::default::Default::default()
    }

    // repeated fixed64 publishedfileids = 1;


    pub fn get_publishedfileids(&self) -> &[u64] {
        &self.publishedfileids
    }
    pub fn clear_publishedfileids(&mut self) {
        self.publishedfileids.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfileids(&mut self, v: ::std::vec::Vec<u64>) {
        self.publishedfileids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfileids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.publishedfileids
    }

    // Take field
    pub fn take_publishedfileids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.publishedfileids, ::std::vec::Vec::new())
    }

    // optional bool includetags = 2;


    pub fn get_includetags(&self) -> bool {
        self.includetags.unwrap_or(false)
    }
    pub fn clear_includetags(&mut self) {
        self.includetags = ::std::option::Option::None;
    }

    pub fn has_includetags(&self) -> bool {
        self.includetags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includetags(&mut self, v: bool) {
        self.includetags = ::std::option::Option::Some(v);
    }

    // optional bool includeadditionalpreviews = 3;


    pub fn get_includeadditionalpreviews(&self) -> bool {
        self.includeadditionalpreviews.unwrap_or(false)
    }
    pub fn clear_includeadditionalpreviews(&mut self) {
        self.includeadditionalpreviews = ::std::option::Option::None;
    }

    pub fn has_includeadditionalpreviews(&self) -> bool {
        self.includeadditionalpreviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeadditionalpreviews(&mut self, v: bool) {
        self.includeadditionalpreviews = ::std::option::Option::Some(v);
    }

    // optional bool includechildren = 4;


    pub fn get_includechildren(&self) -> bool {
        self.includechildren.unwrap_or(false)
    }
    pub fn clear_includechildren(&mut self) {
        self.includechildren = ::std::option::Option::None;
    }

    pub fn has_includechildren(&self) -> bool {
        self.includechildren.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includechildren(&mut self, v: bool) {
        self.includechildren = ::std::option::Option::Some(v);
    }

    // optional bool includekvtags = 5;


    pub fn get_includekvtags(&self) -> bool {
        self.includekvtags.unwrap_or(false)
    }
    pub fn clear_includekvtags(&mut self) {
        self.includekvtags = ::std::option::Option::None;
    }

    pub fn has_includekvtags(&self) -> bool {
        self.includekvtags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includekvtags(&mut self, v: bool) {
        self.includekvtags = ::std::option::Option::Some(v);
    }

    // optional bool includevotes = 6;


    pub fn get_includevotes(&self) -> bool {
        self.includevotes.unwrap_or(false)
    }
    pub fn clear_includevotes(&mut self) {
        self.includevotes = ::std::option::Option::None;
    }

    pub fn has_includevotes(&self) -> bool {
        self.includevotes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includevotes(&mut self, v: bool) {
        self.includevotes = ::std::option::Option::Some(v);
    }

    // optional bool short_description = 8;


    pub fn get_short_description(&self) -> bool {
        self.short_description.unwrap_or(false)
    }
    pub fn clear_short_description(&mut self) {
        self.short_description = ::std::option::Option::None;
    }

    pub fn has_short_description(&self) -> bool {
        self.short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: bool) {
        self.short_description = ::std::option::Option::Some(v);
    }

    // optional bool includeforsaledata = 10;


    pub fn get_includeforsaledata(&self) -> bool {
        self.includeforsaledata.unwrap_or(false)
    }
    pub fn clear_includeforsaledata(&mut self) {
        self.includeforsaledata = ::std::option::Option::None;
    }

    pub fn has_includeforsaledata(&self) -> bool {
        self.includeforsaledata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeforsaledata(&mut self, v: bool) {
        self.includeforsaledata = ::std::option::Option::Some(v);
    }

    // optional bool includemetadata = 11;


    pub fn get_includemetadata(&self) -> bool {
        self.includemetadata.unwrap_or(false)
    }
    pub fn clear_includemetadata(&mut self) {
        self.includemetadata = ::std::option::Option::None;
    }

    pub fn has_includemetadata(&self) -> bool {
        self.includemetadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includemetadata(&mut self, v: bool) {
        self.includemetadata = ::std::option::Option::Some(v);
    }

    // optional int32 language = 12;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint32 return_playtime_stats = 13;


    pub fn get_return_playtime_stats(&self) -> u32 {
        self.return_playtime_stats.unwrap_or(0)
    }
    pub fn clear_return_playtime_stats(&mut self) {
        self.return_playtime_stats = ::std::option::Option::None;
    }

    pub fn has_return_playtime_stats(&self) -> bool {
        self.return_playtime_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_playtime_stats(&mut self, v: u32) {
        self.return_playtime_stats = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 14;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool strip_description_bbcode = 15;


    pub fn get_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.unwrap_or(false)
    }
    pub fn clear_strip_description_bbcode(&mut self) {
        self.strip_description_bbcode = ::std::option::Option::None;
    }

    pub fn has_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_description_bbcode(&mut self, v: bool) {
        self.strip_description_bbcode = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 16;


    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        self.desired_revision.unwrap_or(EPublishedFileRevision::k_EPublishedFileRevision_Default)
    }
    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetDetails_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includetags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeadditionalpreviews = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includechildren = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includekvtags = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includevotes = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.short_description = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeforsaledata = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includemetadata = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.return_playtime_stats = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.strip_description_bbcode = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desired_revision, 16, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.publishedfileids.len() as u32;
        if let Some(v) = self.includetags {
            my_size += 2;
        }
        if let Some(v) = self.includeadditionalpreviews {
            my_size += 2;
        }
        if let Some(v) = self.includechildren {
            my_size += 2;
        }
        if let Some(v) = self.includekvtags {
            my_size += 2;
        }
        if let Some(v) = self.includevotes {
            my_size += 2;
        }
        if let Some(v) = self.short_description {
            my_size += 2;
        }
        if let Some(v) = self.includeforsaledata {
            my_size += 2;
        }
        if let Some(v) = self.includemetadata {
            my_size += 2;
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.return_playtime_stats {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strip_description_bbcode {
            my_size += 2;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.publishedfileids {
            os.write_fixed64(1, *v)?;
        };
        if let Some(v) = self.includetags {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.includeadditionalpreviews {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.includechildren {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.includekvtags {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.includevotes {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.short_description {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.includeforsaledata {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.includemetadata {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.return_playtime_stats {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.strip_description_bbcode {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(16, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetDetails_Request {
        CPublishedFile_GetDetails_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileids",
                    |m: &CPublishedFile_GetDetails_Request| { &m.publishedfileids },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.publishedfileids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includetags",
                    |m: &CPublishedFile_GetDetails_Request| { &m.includetags },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includetags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includeadditionalpreviews",
                    |m: &CPublishedFile_GetDetails_Request| { &m.includeadditionalpreviews },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includeadditionalpreviews },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includechildren",
                    |m: &CPublishedFile_GetDetails_Request| { &m.includechildren },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includechildren },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includekvtags",
                    |m: &CPublishedFile_GetDetails_Request| { &m.includekvtags },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includekvtags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includevotes",
                    |m: &CPublishedFile_GetDetails_Request| { &m.includevotes },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includevotes },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "short_description",
                    |m: &CPublishedFile_GetDetails_Request| { &m.short_description },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.short_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includeforsaledata",
                    |m: &CPublishedFile_GetDetails_Request| { &m.includeforsaledata },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includeforsaledata },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includemetadata",
                    |m: &CPublishedFile_GetDetails_Request| { &m.includemetadata },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.includemetadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPublishedFile_GetDetails_Request| { &m.language },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "return_playtime_stats",
                    |m: &CPublishedFile_GetDetails_Request| { &m.return_playtime_stats },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.return_playtime_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_GetDetails_Request| { &m.appid },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "strip_description_bbcode",
                    |m: &CPublishedFile_GetDetails_Request| { &m.strip_description_bbcode },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.strip_description_bbcode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "desired_revision",
                    |m: &CPublishedFile_GetDetails_Request| { &m.desired_revision },
                    |m: &mut CPublishedFile_GetDetails_Request| { &mut m.desired_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetDetails_Request>(
                    "CPublishedFile_GetDetails_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetDetails_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetDetails_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetDetails_Request,
        };
        unsafe {
            instance.get(CPublishedFile_GetDetails_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetDetails_Request {
    fn clear(&mut self) {
        self.publishedfileids.clear();
        self.includetags = ::std::option::Option::None;
        self.includeadditionalpreviews = ::std::option::Option::None;
        self.includechildren = ::std::option::Option::None;
        self.includekvtags = ::std::option::Option::None;
        self.includevotes = ::std::option::Option::None;
        self.short_description = ::std::option::Option::None;
        self.includeforsaledata = ::std::option::Option::None;
        self.includemetadata = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.return_playtime_stats = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.strip_description_bbcode = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetDetails_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetDetails_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails {
    // message fields
    result: ::std::option::Option<u32>,
    publishedfileid: ::std::option::Option<u64>,
    creator: ::std::option::Option<u64>,
    creator_appid: ::std::option::Option<u32>,
    consumer_appid: ::std::option::Option<u32>,
    consumer_shortcutid: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    file_size: ::std::option::Option<u64>,
    preview_file_size: ::std::option::Option<u64>,
    file_url: ::protobuf::SingularField<::std::string::String>,
    preview_url: ::protobuf::SingularField<::std::string::String>,
    youtubevideoid: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularField<::std::string::String>,
    hcontent_file: ::std::option::Option<u64>,
    hcontent_preview: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    file_description: ::protobuf::SingularField<::std::string::String>,
    short_description: ::protobuf::SingularField<::std::string::String>,
    time_created: ::std::option::Option<u32>,
    time_updated: ::std::option::Option<u32>,
    visibility: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    workshop_file: ::std::option::Option<bool>,
    workshop_accepted: ::std::option::Option<bool>,
    show_subscribe_all: ::std::option::Option<bool>,
    num_comments_developer: ::std::option::Option<i32>,
    num_comments_public: ::std::option::Option<i32>,
    banned: ::std::option::Option<bool>,
    ban_reason: ::protobuf::SingularField<::std::string::String>,
    banner: ::std::option::Option<u64>,
    can_be_deleted: ::std::option::Option<bool>,
    incompatible: ::std::option::Option<bool>,
    app_name: ::protobuf::SingularField<::std::string::String>,
    file_type: ::std::option::Option<u32>,
    can_subscribe: ::std::option::Option<bool>,
    subscriptions: ::std::option::Option<u32>,
    favorited: ::std::option::Option<u32>,
    followers: ::std::option::Option<u32>,
    lifetime_subscriptions: ::std::option::Option<u32>,
    lifetime_favorited: ::std::option::Option<u32>,
    lifetime_followers: ::std::option::Option<u32>,
    lifetime_playtime: ::std::option::Option<u64>,
    lifetime_playtime_sessions: ::std::option::Option<u64>,
    views: ::std::option::Option<u32>,
    image_width: ::std::option::Option<u32>,
    image_height: ::std::option::Option<u32>,
    image_url: ::protobuf::SingularField<::std::string::String>,
    spoiler_tag: ::std::option::Option<bool>,
    shortcutid: ::std::option::Option<u32>,
    shortcutname: ::protobuf::SingularField<::std::string::String>,
    num_children: ::std::option::Option<u32>,
    num_reports: ::std::option::Option<u32>,
    previews: ::protobuf::RepeatedField<PublishedFileDetails_Preview>,
    tags: ::protobuf::RepeatedField<PublishedFileDetails_Tag>,
    children: ::protobuf::RepeatedField<PublishedFileDetails_Child>,
    kvtags: ::protobuf::RepeatedField<PublishedFileDetails_KVTag>,
    vote_data: ::protobuf::SingularPtrField<PublishedFileDetails_VoteData>,
    playtime_stats: ::protobuf::SingularPtrField<PublishedFileDetails_PlaytimeStats>,
    time_subscribed: ::std::option::Option<u32>,
    for_sale_data: ::protobuf::SingularPtrField<PublishedFileDetails_ForSaleData>,
    metadata: ::protobuf::SingularField<::std::string::String>,
    language: ::std::option::Option<i32>,
    maybe_inappropriate_sex: ::std::option::Option<bool>,
    maybe_inappropriate_violence: ::std::option::Option<bool>,
    revision_change_number: ::std::option::Option<u64>,
    revision: ::std::option::Option<EPublishedFileRevision>,
    available_revisions: ::std::vec::Vec<EPublishedFileRevision>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails {
    fn default() -> &'a PublishedFileDetails {
        <PublishedFileDetails as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails {
    pub fn new() -> PublishedFileDetails {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 publishedfileid = 2;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator = 3;


    pub fn get_creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }
    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }

    // optional uint32 creator_appid = 4;


    pub fn get_creator_appid(&self) -> u32 {
        self.creator_appid.unwrap_or(0)
    }
    pub fn clear_creator_appid(&mut self) {
        self.creator_appid = ::std::option::Option::None;
    }

    pub fn has_creator_appid(&self) -> bool {
        self.creator_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_appid(&mut self, v: u32) {
        self.creator_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 consumer_appid = 5;


    pub fn get_consumer_appid(&self) -> u32 {
        self.consumer_appid.unwrap_or(0)
    }
    pub fn clear_consumer_appid(&mut self) {
        self.consumer_appid = ::std::option::Option::None;
    }

    pub fn has_consumer_appid(&self) -> bool {
        self.consumer_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_appid(&mut self, v: u32) {
        self.consumer_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 consumer_shortcutid = 6;


    pub fn get_consumer_shortcutid(&self) -> u32 {
        self.consumer_shortcutid.unwrap_or(0)
    }
    pub fn clear_consumer_shortcutid(&mut self) {
        self.consumer_shortcutid = ::std::option::Option::None;
    }

    pub fn has_consumer_shortcutid(&self) -> bool {
        self.consumer_shortcutid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_shortcutid(&mut self, v: u32) {
        self.consumer_shortcutid = ::std::option::Option::Some(v);
    }

    // optional string filename = 7;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 file_size = 8;


    pub fn get_file_size(&self) -> u64 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint64 preview_file_size = 9;


    pub fn get_preview_file_size(&self) -> u64 {
        self.preview_file_size.unwrap_or(0)
    }
    pub fn clear_preview_file_size(&mut self) {
        self.preview_file_size = ::std::option::Option::None;
    }

    pub fn has_preview_file_size(&self) -> bool {
        self.preview_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_size(&mut self, v: u64) {
        self.preview_file_size = ::std::option::Option::Some(v);
    }

    // optional string file_url = 10;


    pub fn get_file_url(&self) -> &str {
        match self.file_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_url(&mut self) {
        self.file_url.clear();
    }

    pub fn has_file_url(&self) -> bool {
        self.file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_url(&mut self, v: ::std::string::String) {
        self.file_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_url(&mut self) -> &mut ::std::string::String {
        if self.file_url.is_none() {
            self.file_url.set_default();
        }
        self.file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_url(&mut self) -> ::std::string::String {
        self.file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_url = 11;


    pub fn get_preview_url(&self) -> &str {
        match self.preview_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_preview_url(&mut self) {
        self.preview_url.clear();
    }

    pub fn has_preview_url(&self) -> bool {
        self.preview_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_url(&mut self, v: ::std::string::String) {
        self.preview_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_url(&mut self) -> &mut ::std::string::String {
        if self.preview_url.is_none() {
            self.preview_url.set_default();
        }
        self.preview_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_url(&mut self) -> ::std::string::String {
        self.preview_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtubevideoid = 12;


    pub fn get_youtubevideoid(&self) -> &str {
        match self.youtubevideoid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtubevideoid(&mut self) {
        self.youtubevideoid.clear();
    }

    pub fn has_youtubevideoid(&self) -> bool {
        self.youtubevideoid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtubevideoid(&mut self, v: ::std::string::String) {
        self.youtubevideoid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtubevideoid(&mut self) -> &mut ::std::string::String {
        if self.youtubevideoid.is_none() {
            self.youtubevideoid.set_default();
        }
        self.youtubevideoid.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtubevideoid(&mut self) -> ::std::string::String {
        self.youtubevideoid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 13;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 hcontent_file = 14;


    pub fn get_hcontent_file(&self) -> u64 {
        self.hcontent_file.unwrap_or(0)
    }
    pub fn clear_hcontent_file(&mut self) {
        self.hcontent_file = ::std::option::Option::None;
    }

    pub fn has_hcontent_file(&self) -> bool {
        self.hcontent_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent_file(&mut self, v: u64) {
        self.hcontent_file = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent_preview = 15;


    pub fn get_hcontent_preview(&self) -> u64 {
        self.hcontent_preview.unwrap_or(0)
    }
    pub fn clear_hcontent_preview(&mut self) {
        self.hcontent_preview = ::std::option::Option::None;
    }

    pub fn has_hcontent_preview(&self) -> bool {
        self.hcontent_preview.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent_preview(&mut self, v: u64) {
        self.hcontent_preview = ::std::option::Option::Some(v);
    }

    // optional string title = 16;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_description = 17;


    pub fn get_file_description(&self) -> &str {
        match self.file_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_description(&mut self) {
        self.file_description.clear();
    }

    pub fn has_file_description(&self) -> bool {
        self.file_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_description(&mut self, v: ::std::string::String) {
        self.file_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_description(&mut self) -> &mut ::std::string::String {
        if self.file_description.is_none() {
            self.file_description.set_default();
        }
        self.file_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_description(&mut self) -> ::std::string::String {
        self.file_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string short_description = 18;


    pub fn get_short_description(&self) -> &str {
        match self.short_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_short_description(&mut self) {
        self.short_description.clear();
    }

    pub fn has_short_description(&self) -> bool {
        self.short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_short_description(&mut self, v: ::std::string::String) {
        self.short_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
        if self.short_description.is_none() {
            self.short_description.set_default();
        }
        self.short_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_short_description(&mut self) -> ::std::string::String {
        self.short_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_created = 19;


    pub fn get_time_created(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }
    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 20;


    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }
    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional uint32 visibility = 21;


    pub fn get_visibility(&self) -> u32 {
        self.visibility.unwrap_or(0)
    }
    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: u32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 22;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bool workshop_file = 23;


    pub fn get_workshop_file(&self) -> bool {
        self.workshop_file.unwrap_or(false)
    }
    pub fn clear_workshop_file(&mut self) {
        self.workshop_file = ::std::option::Option::None;
    }

    pub fn has_workshop_file(&self) -> bool {
        self.workshop_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file(&mut self, v: bool) {
        self.workshop_file = ::std::option::Option::Some(v);
    }

    // optional bool workshop_accepted = 24;


    pub fn get_workshop_accepted(&self) -> bool {
        self.workshop_accepted.unwrap_or(false)
    }
    pub fn clear_workshop_accepted(&mut self) {
        self.workshop_accepted = ::std::option::Option::None;
    }

    pub fn has_workshop_accepted(&self) -> bool {
        self.workshop_accepted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_accepted(&mut self, v: bool) {
        self.workshop_accepted = ::std::option::Option::Some(v);
    }

    // optional bool show_subscribe_all = 25;


    pub fn get_show_subscribe_all(&self) -> bool {
        self.show_subscribe_all.unwrap_or(false)
    }
    pub fn clear_show_subscribe_all(&mut self) {
        self.show_subscribe_all = ::std::option::Option::None;
    }

    pub fn has_show_subscribe_all(&self) -> bool {
        self.show_subscribe_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_subscribe_all(&mut self, v: bool) {
        self.show_subscribe_all = ::std::option::Option::Some(v);
    }

    // optional int32 num_comments_developer = 26;


    pub fn get_num_comments_developer(&self) -> i32 {
        self.num_comments_developer.unwrap_or(0)
    }
    pub fn clear_num_comments_developer(&mut self) {
        self.num_comments_developer = ::std::option::Option::None;
    }

    pub fn has_num_comments_developer(&self) -> bool {
        self.num_comments_developer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_comments_developer(&mut self, v: i32) {
        self.num_comments_developer = ::std::option::Option::Some(v);
    }

    // optional int32 num_comments_public = 27;


    pub fn get_num_comments_public(&self) -> i32 {
        self.num_comments_public.unwrap_or(0)
    }
    pub fn clear_num_comments_public(&mut self) {
        self.num_comments_public = ::std::option::Option::None;
    }

    pub fn has_num_comments_public(&self) -> bool {
        self.num_comments_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_comments_public(&mut self, v: i32) {
        self.num_comments_public = ::std::option::Option::Some(v);
    }

    // optional bool banned = 28;


    pub fn get_banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }
    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    // optional string ban_reason = 29;


    pub fn get_ban_reason(&self) -> &str {
        match self.ban_reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ban_reason(&mut self) {
        self.ban_reason.clear();
    }

    pub fn has_ban_reason(&self) -> bool {
        self.ban_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_reason(&mut self, v: ::std::string::String) {
        self.ban_reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ban_reason(&mut self) -> &mut ::std::string::String {
        if self.ban_reason.is_none() {
            self.ban_reason.set_default();
        }
        self.ban_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_ban_reason(&mut self) -> ::std::string::String {
        self.ban_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 banner = 30;


    pub fn get_banner(&self) -> u64 {
        self.banner.unwrap_or(0)
    }
    pub fn clear_banner(&mut self) {
        self.banner = ::std::option::Option::None;
    }

    pub fn has_banner(&self) -> bool {
        self.banner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banner(&mut self, v: u64) {
        self.banner = ::std::option::Option::Some(v);
    }

    // optional bool can_be_deleted = 31;


    pub fn get_can_be_deleted(&self) -> bool {
        self.can_be_deleted.unwrap_or(false)
    }
    pub fn clear_can_be_deleted(&mut self) {
        self.can_be_deleted = ::std::option::Option::None;
    }

    pub fn has_can_be_deleted(&self) -> bool {
        self.can_be_deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_be_deleted(&mut self, v: bool) {
        self.can_be_deleted = ::std::option::Option::Some(v);
    }

    // optional bool incompatible = 32;


    pub fn get_incompatible(&self) -> bool {
        self.incompatible.unwrap_or(false)
    }
    pub fn clear_incompatible(&mut self) {
        self.incompatible = ::std::option::Option::None;
    }

    pub fn has_incompatible(&self) -> bool {
        self.incompatible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incompatible(&mut self, v: bool) {
        self.incompatible = ::std::option::Option::Some(v);
    }

    // optional string app_name = 33;


    pub fn get_app_name(&self) -> &str {
        match self.app_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_app_name(&mut self) {
        self.app_name.clear();
    }

    pub fn has_app_name(&self) -> bool {
        self.app_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_name(&mut self, v: ::std::string::String) {
        self.app_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_name(&mut self) -> &mut ::std::string::String {
        if self.app_name.is_none() {
            self.app_name.set_default();
        }
        self.app_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_name(&mut self) -> ::std::string::String {
        self.app_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 file_type = 34;


    pub fn get_file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }
    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional bool can_subscribe = 35;


    pub fn get_can_subscribe(&self) -> bool {
        self.can_subscribe.unwrap_or(false)
    }
    pub fn clear_can_subscribe(&mut self) {
        self.can_subscribe = ::std::option::Option::None;
    }

    pub fn has_can_subscribe(&self) -> bool {
        self.can_subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_subscribe(&mut self, v: bool) {
        self.can_subscribe = ::std::option::Option::Some(v);
    }

    // optional uint32 subscriptions = 36;


    pub fn get_subscriptions(&self) -> u32 {
        self.subscriptions.unwrap_or(0)
    }
    pub fn clear_subscriptions(&mut self) {
        self.subscriptions = ::std::option::Option::None;
    }

    pub fn has_subscriptions(&self) -> bool {
        self.subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriptions(&mut self, v: u32) {
        self.subscriptions = ::std::option::Option::Some(v);
    }

    // optional uint32 favorited = 37;


    pub fn get_favorited(&self) -> u32 {
        self.favorited.unwrap_or(0)
    }
    pub fn clear_favorited(&mut self) {
        self.favorited = ::std::option::Option::None;
    }

    pub fn has_favorited(&self) -> bool {
        self.favorited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorited(&mut self, v: u32) {
        self.favorited = ::std::option::Option::Some(v);
    }

    // optional uint32 followers = 38;


    pub fn get_followers(&self) -> u32 {
        self.followers.unwrap_or(0)
    }
    pub fn clear_followers(&mut self) {
        self.followers = ::std::option::Option::None;
    }

    pub fn has_followers(&self) -> bool {
        self.followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_followers(&mut self, v: u32) {
        self.followers = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_subscriptions = 39;


    pub fn get_lifetime_subscriptions(&self) -> u32 {
        self.lifetime_subscriptions.unwrap_or(0)
    }
    pub fn clear_lifetime_subscriptions(&mut self) {
        self.lifetime_subscriptions = ::std::option::Option::None;
    }

    pub fn has_lifetime_subscriptions(&self) -> bool {
        self.lifetime_subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_subscriptions(&mut self, v: u32) {
        self.lifetime_subscriptions = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_favorited = 40;


    pub fn get_lifetime_favorited(&self) -> u32 {
        self.lifetime_favorited.unwrap_or(0)
    }
    pub fn clear_lifetime_favorited(&mut self) {
        self.lifetime_favorited = ::std::option::Option::None;
    }

    pub fn has_lifetime_favorited(&self) -> bool {
        self.lifetime_favorited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_favorited(&mut self, v: u32) {
        self.lifetime_favorited = ::std::option::Option::Some(v);
    }

    // optional uint32 lifetime_followers = 41;


    pub fn get_lifetime_followers(&self) -> u32 {
        self.lifetime_followers.unwrap_or(0)
    }
    pub fn clear_lifetime_followers(&mut self) {
        self.lifetime_followers = ::std::option::Option::None;
    }

    pub fn has_lifetime_followers(&self) -> bool {
        self.lifetime_followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_followers(&mut self, v: u32) {
        self.lifetime_followers = ::std::option::Option::Some(v);
    }

    // optional uint64 lifetime_playtime = 62;


    pub fn get_lifetime_playtime(&self) -> u64 {
        self.lifetime_playtime.unwrap_or(0)
    }
    pub fn clear_lifetime_playtime(&mut self) {
        self.lifetime_playtime = ::std::option::Option::None;
    }

    pub fn has_lifetime_playtime(&self) -> bool {
        self.lifetime_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_playtime(&mut self, v: u64) {
        self.lifetime_playtime = ::std::option::Option::Some(v);
    }

    // optional uint64 lifetime_playtime_sessions = 63;


    pub fn get_lifetime_playtime_sessions(&self) -> u64 {
        self.lifetime_playtime_sessions.unwrap_or(0)
    }
    pub fn clear_lifetime_playtime_sessions(&mut self) {
        self.lifetime_playtime_sessions = ::std::option::Option::None;
    }

    pub fn has_lifetime_playtime_sessions(&self) -> bool {
        self.lifetime_playtime_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_playtime_sessions(&mut self, v: u64) {
        self.lifetime_playtime_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 views = 42;


    pub fn get_views(&self) -> u32 {
        self.views.unwrap_or(0)
    }
    pub fn clear_views(&mut self) {
        self.views = ::std::option::Option::None;
    }

    pub fn has_views(&self) -> bool {
        self.views.is_some()
    }

    // Param is passed by value, moved
    pub fn set_views(&mut self, v: u32) {
        self.views = ::std::option::Option::Some(v);
    }

    // optional uint32 image_width = 43;


    pub fn get_image_width(&self) -> u32 {
        self.image_width.unwrap_or(0)
    }
    pub fn clear_image_width(&mut self) {
        self.image_width = ::std::option::Option::None;
    }

    pub fn has_image_width(&self) -> bool {
        self.image_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_width(&mut self, v: u32) {
        self.image_width = ::std::option::Option::Some(v);
    }

    // optional uint32 image_height = 44;


    pub fn get_image_height(&self) -> u32 {
        self.image_height.unwrap_or(0)
    }
    pub fn clear_image_height(&mut self) {
        self.image_height = ::std::option::Option::None;
    }

    pub fn has_image_height(&self) -> bool {
        self.image_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_height(&mut self, v: u32) {
        self.image_height = ::std::option::Option::Some(v);
    }

    // optional string image_url = 45;


    pub fn get_image_url(&self) -> &str {
        match self.image_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image_url(&mut self) {
        self.image_url.clear();
    }

    pub fn has_image_url(&self) -> bool {
        self.image_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_url(&mut self, v: ::std::string::String) {
        self.image_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
        if self.image_url.is_none() {
            self.image_url.set_default();
        }
        self.image_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_url(&mut self) -> ::std::string::String {
        self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool spoiler_tag = 46;


    pub fn get_spoiler_tag(&self) -> bool {
        self.spoiler_tag.unwrap_or(false)
    }
    pub fn clear_spoiler_tag(&mut self) {
        self.spoiler_tag = ::std::option::Option::None;
    }

    pub fn has_spoiler_tag(&self) -> bool {
        self.spoiler_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spoiler_tag(&mut self, v: bool) {
        self.spoiler_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 shortcutid = 47;


    pub fn get_shortcutid(&self) -> u32 {
        self.shortcutid.unwrap_or(0)
    }
    pub fn clear_shortcutid(&mut self) {
        self.shortcutid = ::std::option::Option::None;
    }

    pub fn has_shortcutid(&self) -> bool {
        self.shortcutid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcutid(&mut self, v: u32) {
        self.shortcutid = ::std::option::Option::Some(v);
    }

    // optional string shortcutname = 48;


    pub fn get_shortcutname(&self) -> &str {
        match self.shortcutname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shortcutname(&mut self) {
        self.shortcutname.clear();
    }

    pub fn has_shortcutname(&self) -> bool {
        self.shortcutname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcutname(&mut self, v: ::std::string::String) {
        self.shortcutname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcutname(&mut self) -> &mut ::std::string::String {
        if self.shortcutname.is_none() {
            self.shortcutname.set_default();
        }
        self.shortcutname.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcutname(&mut self) -> ::std::string::String {
        self.shortcutname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_children = 49;


    pub fn get_num_children(&self) -> u32 {
        self.num_children.unwrap_or(0)
    }
    pub fn clear_num_children(&mut self) {
        self.num_children = ::std::option::Option::None;
    }

    pub fn has_num_children(&self) -> bool {
        self.num_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_children(&mut self, v: u32) {
        self.num_children = ::std::option::Option::Some(v);
    }

    // optional uint32 num_reports = 50;


    pub fn get_num_reports(&self) -> u32 {
        self.num_reports.unwrap_or(0)
    }
    pub fn clear_num_reports(&mut self) {
        self.num_reports = ::std::option::Option::None;
    }

    pub fn has_num_reports(&self) -> bool {
        self.num_reports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reports(&mut self, v: u32) {
        self.num_reports = ::std::option::Option::Some(v);
    }

    // repeated .PublishedFileDetails.Preview previews = 51;


    pub fn get_previews(&self) -> &[PublishedFileDetails_Preview] {
        &self.previews
    }
    pub fn clear_previews(&mut self) {
        self.previews.clear();
    }

    // Param is passed by value, moved
    pub fn set_previews(&mut self, v: ::protobuf::RepeatedField<PublishedFileDetails_Preview>) {
        self.previews = v;
    }

    // Mutable pointer to the field.
    pub fn mut_previews(&mut self) -> &mut ::protobuf::RepeatedField<PublishedFileDetails_Preview> {
        &mut self.previews
    }

    // Take field
    pub fn take_previews(&mut self) -> ::protobuf::RepeatedField<PublishedFileDetails_Preview> {
        ::std::mem::replace(&mut self.previews, ::protobuf::RepeatedField::new())
    }

    // repeated .PublishedFileDetails.Tag tags = 52;


    pub fn get_tags(&self) -> &[PublishedFileDetails_Tag] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<PublishedFileDetails_Tag>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<PublishedFileDetails_Tag> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<PublishedFileDetails_Tag> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // repeated .PublishedFileDetails.Child children = 53;


    pub fn get_children(&self) -> &[PublishedFileDetails_Child] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<PublishedFileDetails_Child>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<PublishedFileDetails_Child> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<PublishedFileDetails_Child> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }

    // repeated .PublishedFileDetails.KVTag kvtags = 54;


    pub fn get_kvtags(&self) -> &[PublishedFileDetails_KVTag] {
        &self.kvtags
    }
    pub fn clear_kvtags(&mut self) {
        self.kvtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvtags(&mut self, v: ::protobuf::RepeatedField<PublishedFileDetails_KVTag>) {
        self.kvtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvtags(&mut self) -> &mut ::protobuf::RepeatedField<PublishedFileDetails_KVTag> {
        &mut self.kvtags
    }

    // Take field
    pub fn take_kvtags(&mut self) -> ::protobuf::RepeatedField<PublishedFileDetails_KVTag> {
        ::std::mem::replace(&mut self.kvtags, ::protobuf::RepeatedField::new())
    }

    // optional .PublishedFileDetails.VoteData vote_data = 55;


    pub fn get_vote_data(&self) -> &PublishedFileDetails_VoteData {
        self.vote_data.as_ref().unwrap_or_else(|| PublishedFileDetails_VoteData::default_instance())
    }
    pub fn clear_vote_data(&mut self) {
        self.vote_data.clear();
    }

    pub fn has_vote_data(&self) -> bool {
        self.vote_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_data(&mut self, v: PublishedFileDetails_VoteData) {
        self.vote_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote_data(&mut self) -> &mut PublishedFileDetails_VoteData {
        if self.vote_data.is_none() {
            self.vote_data.set_default();
        }
        self.vote_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_vote_data(&mut self) -> PublishedFileDetails_VoteData {
        self.vote_data.take().unwrap_or_else(|| PublishedFileDetails_VoteData::new())
    }

    // optional .PublishedFileDetails.PlaytimeStats playtime_stats = 64;


    pub fn get_playtime_stats(&self) -> &PublishedFileDetails_PlaytimeStats {
        self.playtime_stats.as_ref().unwrap_or_else(|| PublishedFileDetails_PlaytimeStats::default_instance())
    }
    pub fn clear_playtime_stats(&mut self) {
        self.playtime_stats.clear();
    }

    pub fn has_playtime_stats(&self) -> bool {
        self.playtime_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_stats(&mut self, v: PublishedFileDetails_PlaytimeStats) {
        self.playtime_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playtime_stats(&mut self) -> &mut PublishedFileDetails_PlaytimeStats {
        if self.playtime_stats.is_none() {
            self.playtime_stats.set_default();
        }
        self.playtime_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_playtime_stats(&mut self) -> PublishedFileDetails_PlaytimeStats {
        self.playtime_stats.take().unwrap_or_else(|| PublishedFileDetails_PlaytimeStats::new())
    }

    // optional uint32 time_subscribed = 56;


    pub fn get_time_subscribed(&self) -> u32 {
        self.time_subscribed.unwrap_or(0)
    }
    pub fn clear_time_subscribed(&mut self) {
        self.time_subscribed = ::std::option::Option::None;
    }

    pub fn has_time_subscribed(&self) -> bool {
        self.time_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_subscribed(&mut self, v: u32) {
        self.time_subscribed = ::std::option::Option::Some(v);
    }

    // optional .PublishedFileDetails.ForSaleData for_sale_data = 57;


    pub fn get_for_sale_data(&self) -> &PublishedFileDetails_ForSaleData {
        self.for_sale_data.as_ref().unwrap_or_else(|| PublishedFileDetails_ForSaleData::default_instance())
    }
    pub fn clear_for_sale_data(&mut self) {
        self.for_sale_data.clear();
    }

    pub fn has_for_sale_data(&self) -> bool {
        self.for_sale_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_for_sale_data(&mut self, v: PublishedFileDetails_ForSaleData) {
        self.for_sale_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_for_sale_data(&mut self) -> &mut PublishedFileDetails_ForSaleData {
        if self.for_sale_data.is_none() {
            self.for_sale_data.set_default();
        }
        self.for_sale_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_for_sale_data(&mut self) -> PublishedFileDetails_ForSaleData {
        self.for_sale_data.take().unwrap_or_else(|| PublishedFileDetails_ForSaleData::new())
    }

    // optional string metadata = 58;


    pub fn get_metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 61;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool maybe_inappropriate_sex = 65;


    pub fn get_maybe_inappropriate_sex(&self) -> bool {
        self.maybe_inappropriate_sex.unwrap_or(false)
    }
    pub fn clear_maybe_inappropriate_sex(&mut self) {
        self.maybe_inappropriate_sex = ::std::option::Option::None;
    }

    pub fn has_maybe_inappropriate_sex(&self) -> bool {
        self.maybe_inappropriate_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maybe_inappropriate_sex(&mut self, v: bool) {
        self.maybe_inappropriate_sex = ::std::option::Option::Some(v);
    }

    // optional bool maybe_inappropriate_violence = 66;


    pub fn get_maybe_inappropriate_violence(&self) -> bool {
        self.maybe_inappropriate_violence.unwrap_or(false)
    }
    pub fn clear_maybe_inappropriate_violence(&mut self) {
        self.maybe_inappropriate_violence = ::std::option::Option::None;
    }

    pub fn has_maybe_inappropriate_violence(&self) -> bool {
        self.maybe_inappropriate_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maybe_inappropriate_violence(&mut self, v: bool) {
        self.maybe_inappropriate_violence = ::std::option::Option::Some(v);
    }

    // optional uint64 revision_change_number = 67;


    pub fn get_revision_change_number(&self) -> u64 {
        self.revision_change_number.unwrap_or(0)
    }
    pub fn clear_revision_change_number(&mut self) {
        self.revision_change_number = ::std::option::Option::None;
    }

    pub fn has_revision_change_number(&self) -> bool {
        self.revision_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision_change_number(&mut self, v: u64) {
        self.revision_change_number = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision revision = 68;


    pub fn get_revision(&self) -> EPublishedFileRevision {
        self.revision.unwrap_or(EPublishedFileRevision::k_EPublishedFileRevision_Default)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: EPublishedFileRevision) {
        self.revision = ::std::option::Option::Some(v);
    }

    // repeated .EPublishedFileRevision available_revisions = 69;


    pub fn get_available_revisions(&self) -> &[EPublishedFileRevision] {
        &self.available_revisions
    }
    pub fn clear_available_revisions(&mut self) {
        self.available_revisions.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_revisions(&mut self, v: ::std::vec::Vec<EPublishedFileRevision>) {
        self.available_revisions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_available_revisions(&mut self) -> &mut ::std::vec::Vec<EPublishedFileRevision> {
        &mut self.available_revisions
    }

    // Take field
    pub fn take_available_revisions(&mut self) -> ::std::vec::Vec<EPublishedFileRevision> {
        ::std::mem::replace(&mut self.available_revisions, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PublishedFileDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.previews {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kvtags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vote_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.playtime_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.for_sale_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.creator = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.creator_appid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consumer_appid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consumer_shortcutid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.preview_file_size = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_url)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_url)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtubevideoid)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.hcontent_file = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.hcontent_preview = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_description)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.short_description)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_created = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_updated = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.workshop_file = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.workshop_accepted = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_subscribe_all = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_comments_developer = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_comments_public = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.banned = ::std::option::Option::Some(tmp);
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ban_reason)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.banner = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_be_deleted = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incompatible = ::std::option::Option::Some(tmp);
                },
                33 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.app_name)?;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_type = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_subscribe = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.subscriptions = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.favorited = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.followers = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lifetime_subscriptions = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lifetime_favorited = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lifetime_followers = ::std::option::Option::Some(tmp);
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lifetime_playtime = ::std::option::Option::Some(tmp);
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lifetime_playtime_sessions = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.views = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.image_width = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.image_height = ::std::option::Option::Some(tmp);
                },
                45 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image_url)?;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spoiler_tag = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shortcutid = ::std::option::Option::Some(tmp);
                },
                48 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shortcutname)?;
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_children = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_reports = ::std::option::Option::Some(tmp);
                },
                51 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.previews)?;
                },
                52 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tags)?;
                },
                53 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                54 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kvtags)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vote_data)?;
                },
                64 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.playtime_stats)?;
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_subscribed = ::std::option::Option::Some(tmp);
                },
                57 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.for_sale_data)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.metadata)?;
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.maybe_inappropriate_sex = ::std::option::Option::Some(tmp);
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.maybe_inappropriate_violence = ::std::option::Option::Some(tmp);
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.revision_change_number = ::std::option::Option::Some(tmp);
                },
                68 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.revision, 68, &mut self.unknown_fields)?
                },
                69 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.available_revisions, 69, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator {
            my_size += 9;
        }
        if let Some(v) = self.creator_appid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_shortcutid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.preview_file_size {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.preview_url.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.youtubevideoid.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.hcontent_file {
            my_size += 9;
        }
        if let Some(v) = self.hcontent_preview {
            my_size += 9;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.file_description.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.short_description.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.time_created {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.workshop_file {
            my_size += 3;
        }
        if let Some(v) = self.workshop_accepted {
            my_size += 3;
        }
        if let Some(v) = self.show_subscribe_all {
            my_size += 3;
        }
        if let Some(v) = self.num_comments_developer {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_comments_public {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.banned {
            my_size += 3;
        }
        if let Some(ref v) = self.ban_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.banner {
            my_size += 10;
        }
        if let Some(v) = self.can_be_deleted {
            my_size += 3;
        }
        if let Some(v) = self.incompatible {
            my_size += 3;
        }
        if let Some(ref v) = self.app_name.as_ref() {
            my_size += ::protobuf::rt::string_size(33, &v);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.can_subscribe {
            my_size += 3;
        }
        if let Some(v) = self.subscriptions {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.favorited {
            my_size += ::protobuf::rt::value_size(37, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.followers {
            my_size += ::protobuf::rt::value_size(38, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_subscriptions {
            my_size += ::protobuf::rt::value_size(39, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_favorited {
            my_size += ::protobuf::rt::value_size(40, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_followers {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_playtime {
            my_size += ::protobuf::rt::value_size(62, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lifetime_playtime_sessions {
            my_size += ::protobuf::rt::value_size(63, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.views {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_width {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_height {
            my_size += ::protobuf::rt::value_size(44, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image_url.as_ref() {
            my_size += ::protobuf::rt::string_size(45, &v);
        }
        if let Some(v) = self.spoiler_tag {
            my_size += 3;
        }
        if let Some(v) = self.shortcutid {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.shortcutname.as_ref() {
            my_size += ::protobuf::rt::string_size(48, &v);
        }
        if let Some(v) = self.num_children {
            my_size += ::protobuf::rt::value_size(49, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_reports {
            my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.previews {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.children {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.kvtags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.vote_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.playtime_stats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.time_subscribed {
            my_size += ::protobuf::rt::value_size(56, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.for_sale_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(58, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(61, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maybe_inappropriate_sex {
            my_size += 3;
        }
        if let Some(v) = self.maybe_inappropriate_violence {
            my_size += 3;
        }
        if let Some(v) = self.revision_change_number {
            my_size += ::protobuf::rt::value_size(67, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::enum_size(68, v);
        }
        for value in &self.available_revisions {
            my_size += ::protobuf::rt::enum_size(69, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.publishedfileid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.creator {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.creator_appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.consumer_appid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.consumer_shortcutid {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.preview_file_size {
            os.write_uint64(9, v)?;
        }
        if let Some(ref v) = self.file_url.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.preview_url.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.youtubevideoid.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.hcontent_file {
            os.write_fixed64(14, v)?;
        }
        if let Some(v) = self.hcontent_preview {
            os.write_fixed64(15, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.file_description.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.short_description.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(v) = self.time_created {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.workshop_file {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.workshop_accepted {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.show_subscribe_all {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.num_comments_developer {
            os.write_int32(26, v)?;
        }
        if let Some(v) = self.num_comments_public {
            os.write_int32(27, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(28, v)?;
        }
        if let Some(ref v) = self.ban_reason.as_ref() {
            os.write_string(29, &v)?;
        }
        if let Some(v) = self.banner {
            os.write_fixed64(30, v)?;
        }
        if let Some(v) = self.can_be_deleted {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.incompatible {
            os.write_bool(32, v)?;
        }
        if let Some(ref v) = self.app_name.as_ref() {
            os.write_string(33, &v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.can_subscribe {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.subscriptions {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.favorited {
            os.write_uint32(37, v)?;
        }
        if let Some(v) = self.followers {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.lifetime_subscriptions {
            os.write_uint32(39, v)?;
        }
        if let Some(v) = self.lifetime_favorited {
            os.write_uint32(40, v)?;
        }
        if let Some(v) = self.lifetime_followers {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.lifetime_playtime {
            os.write_uint64(62, v)?;
        }
        if let Some(v) = self.lifetime_playtime_sessions {
            os.write_uint64(63, v)?;
        }
        if let Some(v) = self.views {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.image_width {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.image_height {
            os.write_uint32(44, v)?;
        }
        if let Some(ref v) = self.image_url.as_ref() {
            os.write_string(45, &v)?;
        }
        if let Some(v) = self.spoiler_tag {
            os.write_bool(46, v)?;
        }
        if let Some(v) = self.shortcutid {
            os.write_uint32(47, v)?;
        }
        if let Some(ref v) = self.shortcutname.as_ref() {
            os.write_string(48, &v)?;
        }
        if let Some(v) = self.num_children {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.num_reports {
            os.write_uint32(50, v)?;
        }
        for v in &self.previews {
            os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tags {
            os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.children {
            os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.kvtags {
            os.write_tag(54, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.vote_data.as_ref() {
            os.write_tag(55, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.playtime_stats.as_ref() {
            os.write_tag(64, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.time_subscribed {
            os.write_uint32(56, v)?;
        }
        if let Some(ref v) = self.for_sale_data.as_ref() {
            os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_string(58, &v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(61, v)?;
        }
        if let Some(v) = self.maybe_inappropriate_sex {
            os.write_bool(65, v)?;
        }
        if let Some(v) = self.maybe_inappropriate_violence {
            os.write_bool(66, v)?;
        }
        if let Some(v) = self.revision_change_number {
            os.write_uint64(67, v)?;
        }
        if let Some(v) = self.revision {
            os.write_enum(68, v.value())?;
        }
        for v in &self.available_revisions {
            os.write_enum(69, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails {
        PublishedFileDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "result",
                    |m: &PublishedFileDetails| { &m.result },
                    |m: &mut PublishedFileDetails| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &PublishedFileDetails| { &m.publishedfileid },
                    |m: &mut PublishedFileDetails| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "creator",
                    |m: &PublishedFileDetails| { &m.creator },
                    |m: &mut PublishedFileDetails| { &mut m.creator },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "creator_appid",
                    |m: &PublishedFileDetails| { &m.creator_appid },
                    |m: &mut PublishedFileDetails| { &mut m.creator_appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "consumer_appid",
                    |m: &PublishedFileDetails| { &m.consumer_appid },
                    |m: &mut PublishedFileDetails| { &mut m.consumer_appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "consumer_shortcutid",
                    |m: &PublishedFileDetails| { &m.consumer_shortcutid },
                    |m: &mut PublishedFileDetails| { &mut m.consumer_shortcutid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &PublishedFileDetails| { &m.filename },
                    |m: &mut PublishedFileDetails| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "file_size",
                    |m: &PublishedFileDetails| { &m.file_size },
                    |m: &mut PublishedFileDetails| { &mut m.file_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "preview_file_size",
                    |m: &PublishedFileDetails| { &m.preview_file_size },
                    |m: &mut PublishedFileDetails| { &mut m.preview_file_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_url",
                    |m: &PublishedFileDetails| { &m.file_url },
                    |m: &mut PublishedFileDetails| { &mut m.file_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "preview_url",
                    |m: &PublishedFileDetails| { &m.preview_url },
                    |m: &mut PublishedFileDetails| { &mut m.preview_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "youtubevideoid",
                    |m: &PublishedFileDetails| { &m.youtubevideoid },
                    |m: &mut PublishedFileDetails| { &mut m.youtubevideoid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &PublishedFileDetails| { &m.url },
                    |m: &mut PublishedFileDetails| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "hcontent_file",
                    |m: &PublishedFileDetails| { &m.hcontent_file },
                    |m: &mut PublishedFileDetails| { &mut m.hcontent_file },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "hcontent_preview",
                    |m: &PublishedFileDetails| { &m.hcontent_preview },
                    |m: &mut PublishedFileDetails| { &mut m.hcontent_preview },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &PublishedFileDetails| { &m.title },
                    |m: &mut PublishedFileDetails| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_description",
                    |m: &PublishedFileDetails| { &m.file_description },
                    |m: &mut PublishedFileDetails| { &mut m.file_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "short_description",
                    |m: &PublishedFileDetails| { &m.short_description },
                    |m: &mut PublishedFileDetails| { &mut m.short_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_created",
                    |m: &PublishedFileDetails| { &m.time_created },
                    |m: &mut PublishedFileDetails| { &mut m.time_created },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_updated",
                    |m: &PublishedFileDetails| { &m.time_updated },
                    |m: &mut PublishedFileDetails| { &mut m.time_updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "visibility",
                    |m: &PublishedFileDetails| { &m.visibility },
                    |m: &mut PublishedFileDetails| { &mut m.visibility },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &PublishedFileDetails| { &m.flags },
                    |m: &mut PublishedFileDetails| { &mut m.flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "workshop_file",
                    |m: &PublishedFileDetails| { &m.workshop_file },
                    |m: &mut PublishedFileDetails| { &mut m.workshop_file },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "workshop_accepted",
                    |m: &PublishedFileDetails| { &m.workshop_accepted },
                    |m: &mut PublishedFileDetails| { &mut m.workshop_accepted },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show_subscribe_all",
                    |m: &PublishedFileDetails| { &m.show_subscribe_all },
                    |m: &mut PublishedFileDetails| { &mut m.show_subscribe_all },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_comments_developer",
                    |m: &PublishedFileDetails| { &m.num_comments_developer },
                    |m: &mut PublishedFileDetails| { &mut m.num_comments_developer },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_comments_public",
                    |m: &PublishedFileDetails| { &m.num_comments_public },
                    |m: &mut PublishedFileDetails| { &mut m.num_comments_public },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "banned",
                    |m: &PublishedFileDetails| { &m.banned },
                    |m: &mut PublishedFileDetails| { &mut m.banned },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ban_reason",
                    |m: &PublishedFileDetails| { &m.ban_reason },
                    |m: &mut PublishedFileDetails| { &mut m.ban_reason },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "banner",
                    |m: &PublishedFileDetails| { &m.banner },
                    |m: &mut PublishedFileDetails| { &mut m.banner },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_be_deleted",
                    |m: &PublishedFileDetails| { &m.can_be_deleted },
                    |m: &mut PublishedFileDetails| { &mut m.can_be_deleted },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "incompatible",
                    |m: &PublishedFileDetails| { &m.incompatible },
                    |m: &mut PublishedFileDetails| { &mut m.incompatible },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "app_name",
                    |m: &PublishedFileDetails| { &m.app_name },
                    |m: &mut PublishedFileDetails| { &mut m.app_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "file_type",
                    |m: &PublishedFileDetails| { &m.file_type },
                    |m: &mut PublishedFileDetails| { &mut m.file_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "can_subscribe",
                    |m: &PublishedFileDetails| { &m.can_subscribe },
                    |m: &mut PublishedFileDetails| { &mut m.can_subscribe },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "subscriptions",
                    |m: &PublishedFileDetails| { &m.subscriptions },
                    |m: &mut PublishedFileDetails| { &mut m.subscriptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "favorited",
                    |m: &PublishedFileDetails| { &m.favorited },
                    |m: &mut PublishedFileDetails| { &mut m.favorited },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "followers",
                    |m: &PublishedFileDetails| { &m.followers },
                    |m: &mut PublishedFileDetails| { &mut m.followers },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lifetime_subscriptions",
                    |m: &PublishedFileDetails| { &m.lifetime_subscriptions },
                    |m: &mut PublishedFileDetails| { &mut m.lifetime_subscriptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lifetime_favorited",
                    |m: &PublishedFileDetails| { &m.lifetime_favorited },
                    |m: &mut PublishedFileDetails| { &mut m.lifetime_favorited },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lifetime_followers",
                    |m: &PublishedFileDetails| { &m.lifetime_followers },
                    |m: &mut PublishedFileDetails| { &mut m.lifetime_followers },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lifetime_playtime",
                    |m: &PublishedFileDetails| { &m.lifetime_playtime },
                    |m: &mut PublishedFileDetails| { &mut m.lifetime_playtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lifetime_playtime_sessions",
                    |m: &PublishedFileDetails| { &m.lifetime_playtime_sessions },
                    |m: &mut PublishedFileDetails| { &mut m.lifetime_playtime_sessions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "views",
                    |m: &PublishedFileDetails| { &m.views },
                    |m: &mut PublishedFileDetails| { &mut m.views },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "image_width",
                    |m: &PublishedFileDetails| { &m.image_width },
                    |m: &mut PublishedFileDetails| { &mut m.image_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "image_height",
                    |m: &PublishedFileDetails| { &m.image_height },
                    |m: &mut PublishedFileDetails| { &mut m.image_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image_url",
                    |m: &PublishedFileDetails| { &m.image_url },
                    |m: &mut PublishedFileDetails| { &mut m.image_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "spoiler_tag",
                    |m: &PublishedFileDetails| { &m.spoiler_tag },
                    |m: &mut PublishedFileDetails| { &mut m.spoiler_tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "shortcutid",
                    |m: &PublishedFileDetails| { &m.shortcutid },
                    |m: &mut PublishedFileDetails| { &mut m.shortcutid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "shortcutname",
                    |m: &PublishedFileDetails| { &m.shortcutname },
                    |m: &mut PublishedFileDetails| { &mut m.shortcutname },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_children",
                    |m: &PublishedFileDetails| { &m.num_children },
                    |m: &mut PublishedFileDetails| { &mut m.num_children },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_reports",
                    |m: &PublishedFileDetails| { &m.num_reports },
                    |m: &mut PublishedFileDetails| { &mut m.num_reports },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails_Preview>>(
                    "previews",
                    |m: &PublishedFileDetails| { &m.previews },
                    |m: &mut PublishedFileDetails| { &mut m.previews },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails_Tag>>(
                    "tags",
                    |m: &PublishedFileDetails| { &m.tags },
                    |m: &mut PublishedFileDetails| { &mut m.tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails_Child>>(
                    "children",
                    |m: &PublishedFileDetails| { &m.children },
                    |m: &mut PublishedFileDetails| { &mut m.children },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails_KVTag>>(
                    "kvtags",
                    |m: &PublishedFileDetails| { &m.kvtags },
                    |m: &mut PublishedFileDetails| { &mut m.kvtags },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails_VoteData>>(
                    "vote_data",
                    |m: &PublishedFileDetails| { &m.vote_data },
                    |m: &mut PublishedFileDetails| { &mut m.vote_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails_PlaytimeStats>>(
                    "playtime_stats",
                    |m: &PublishedFileDetails| { &m.playtime_stats },
                    |m: &mut PublishedFileDetails| { &mut m.playtime_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_subscribed",
                    |m: &PublishedFileDetails| { &m.time_subscribed },
                    |m: &mut PublishedFileDetails| { &mut m.time_subscribed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails_ForSaleData>>(
                    "for_sale_data",
                    |m: &PublishedFileDetails| { &m.for_sale_data },
                    |m: &mut PublishedFileDetails| { &mut m.for_sale_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &PublishedFileDetails| { &m.metadata },
                    |m: &mut PublishedFileDetails| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &PublishedFileDetails| { &m.language },
                    |m: &mut PublishedFileDetails| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "maybe_inappropriate_sex",
                    |m: &PublishedFileDetails| { &m.maybe_inappropriate_sex },
                    |m: &mut PublishedFileDetails| { &mut m.maybe_inappropriate_sex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "maybe_inappropriate_violence",
                    |m: &PublishedFileDetails| { &m.maybe_inappropriate_violence },
                    |m: &mut PublishedFileDetails| { &mut m.maybe_inappropriate_violence },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "revision_change_number",
                    |m: &PublishedFileDetails| { &m.revision_change_number },
                    |m: &mut PublishedFileDetails| { &mut m.revision_change_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "revision",
                    |m: &PublishedFileDetails| { &m.revision },
                    |m: &mut PublishedFileDetails| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "available_revisions",
                    |m: &PublishedFileDetails| { &m.available_revisions },
                    |m: &mut PublishedFileDetails| { &mut m.available_revisions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails>(
                    "PublishedFileDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails,
        };
        unsafe {
            instance.get(PublishedFileDetails::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.publishedfileid = ::std::option::Option::None;
        self.creator = ::std::option::Option::None;
        self.creator_appid = ::std::option::Option::None;
        self.consumer_appid = ::std::option::Option::None;
        self.consumer_shortcutid = ::std::option::Option::None;
        self.filename.clear();
        self.file_size = ::std::option::Option::None;
        self.preview_file_size = ::std::option::Option::None;
        self.file_url.clear();
        self.preview_url.clear();
        self.youtubevideoid.clear();
        self.url.clear();
        self.hcontent_file = ::std::option::Option::None;
        self.hcontent_preview = ::std::option::Option::None;
        self.title.clear();
        self.file_description.clear();
        self.short_description.clear();
        self.time_created = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.workshop_file = ::std::option::Option::None;
        self.workshop_accepted = ::std::option::Option::None;
        self.show_subscribe_all = ::std::option::Option::None;
        self.num_comments_developer = ::std::option::Option::None;
        self.num_comments_public = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.ban_reason.clear();
        self.banner = ::std::option::Option::None;
        self.can_be_deleted = ::std::option::Option::None;
        self.incompatible = ::std::option::Option::None;
        self.app_name.clear();
        self.file_type = ::std::option::Option::None;
        self.can_subscribe = ::std::option::Option::None;
        self.subscriptions = ::std::option::Option::None;
        self.favorited = ::std::option::Option::None;
        self.followers = ::std::option::Option::None;
        self.lifetime_subscriptions = ::std::option::Option::None;
        self.lifetime_favorited = ::std::option::Option::None;
        self.lifetime_followers = ::std::option::Option::None;
        self.lifetime_playtime = ::std::option::Option::None;
        self.lifetime_playtime_sessions = ::std::option::Option::None;
        self.views = ::std::option::Option::None;
        self.image_width = ::std::option::Option::None;
        self.image_height = ::std::option::Option::None;
        self.image_url.clear();
        self.spoiler_tag = ::std::option::Option::None;
        self.shortcutid = ::std::option::Option::None;
        self.shortcutname.clear();
        self.num_children = ::std::option::Option::None;
        self.num_reports = ::std::option::Option::None;
        self.previews.clear();
        self.tags.clear();
        self.children.clear();
        self.kvtags.clear();
        self.vote_data.clear();
        self.playtime_stats.clear();
        self.time_subscribed = ::std::option::Option::None;
        self.for_sale_data.clear();
        self.metadata.clear();
        self.language = ::std::option::Option::None;
        self.maybe_inappropriate_sex = ::std::option::Option::None;
        self.maybe_inappropriate_violence = ::std::option::Option::None;
        self.revision_change_number = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.available_revisions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails_Tag {
    // message fields
    tag: ::protobuf::SingularField<::std::string::String>,
    adminonly: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails_Tag {
    fn default() -> &'a PublishedFileDetails_Tag {
        <PublishedFileDetails_Tag as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails_Tag {
    pub fn new() -> PublishedFileDetails_Tag {
        ::std::default::Default::default()
    }

    // optional string tag = 1;


    pub fn get_tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag.set_default();
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool adminonly = 2;


    pub fn get_adminonly(&self) -> bool {
        self.adminonly.unwrap_or(false)
    }
    pub fn clear_adminonly(&mut self) {
        self.adminonly = ::std::option::Option::None;
    }

    pub fn has_adminonly(&self) -> bool {
        self.adminonly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminonly(&mut self, v: bool) {
        self.adminonly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PublishedFileDetails_Tag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.adminonly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.adminonly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tag.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.adminonly {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails_Tag {
        PublishedFileDetails_Tag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tag",
                    |m: &PublishedFileDetails_Tag| { &m.tag },
                    |m: &mut PublishedFileDetails_Tag| { &mut m.tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "adminonly",
                    |m: &PublishedFileDetails_Tag| { &m.adminonly },
                    |m: &mut PublishedFileDetails_Tag| { &mut m.adminonly },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails_Tag>(
                    "PublishedFileDetails_Tag",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails_Tag {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails_Tag> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails_Tag,
        };
        unsafe {
            instance.get(PublishedFileDetails_Tag::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails_Tag {
    fn clear(&mut self) {
        self.tag.clear();
        self.adminonly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails_Tag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails_Tag {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails_Preview {
    // message fields
    previewid: ::std::option::Option<u64>,
    sortorder: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    size: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    youtubevideoid: ::protobuf::SingularField<::std::string::String>,
    preview_type: ::std::option::Option<u32>,
    external_reference: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails_Preview {
    fn default() -> &'a PublishedFileDetails_Preview {
        <PublishedFileDetails_Preview as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails_Preview {
    pub fn new() -> PublishedFileDetails_Preview {
        ::std::default::Default::default()
    }

    // optional uint64 previewid = 1;


    pub fn get_previewid(&self) -> u64 {
        self.previewid.unwrap_or(0)
    }
    pub fn clear_previewid(&mut self) {
        self.previewid = ::std::option::Option::None;
    }

    pub fn has_previewid(&self) -> bool {
        self.previewid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previewid(&mut self, v: u64) {
        self.previewid = ::std::option::Option::Some(v);
    }

    // optional uint32 sortorder = 2;


    pub fn get_sortorder(&self) -> u32 {
        self.sortorder.unwrap_or(0)
    }
    pub fn clear_sortorder(&mut self) {
        self.sortorder = ::std::option::Option::None;
    }

    pub fn has_sortorder(&self) -> bool {
        self.sortorder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sortorder(&mut self, v: u32) {
        self.sortorder = ::std::option::Option::Some(v);
    }

    // optional string url = 3;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 size = 4;


    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional string filename = 5;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtubevideoid = 6;


    pub fn get_youtubevideoid(&self) -> &str {
        match self.youtubevideoid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtubevideoid(&mut self) {
        self.youtubevideoid.clear();
    }

    pub fn has_youtubevideoid(&self) -> bool {
        self.youtubevideoid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtubevideoid(&mut self, v: ::std::string::String) {
        self.youtubevideoid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtubevideoid(&mut self) -> &mut ::std::string::String {
        if self.youtubevideoid.is_none() {
            self.youtubevideoid.set_default();
        }
        self.youtubevideoid.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtubevideoid(&mut self) -> ::std::string::String {
        self.youtubevideoid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 preview_type = 7;


    pub fn get_preview_type(&self) -> u32 {
        self.preview_type.unwrap_or(0)
    }
    pub fn clear_preview_type(&mut self) {
        self.preview_type = ::std::option::Option::None;
    }

    pub fn has_preview_type(&self) -> bool {
        self.preview_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_type(&mut self, v: u32) {
        self.preview_type = ::std::option::Option::Some(v);
    }

    // optional string external_reference = 8;


    pub fn get_external_reference(&self) -> &str {
        match self.external_reference.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_external_reference(&mut self) {
        self.external_reference.clear();
    }

    pub fn has_external_reference(&self) -> bool {
        self.external_reference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_external_reference(&mut self, v: ::std::string::String) {
        self.external_reference = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_external_reference(&mut self) -> &mut ::std::string::String {
        if self.external_reference.is_none() {
            self.external_reference.set_default();
        }
        self.external_reference.as_mut().unwrap()
    }

    // Take field
    pub fn take_external_reference(&mut self) -> ::std::string::String {
        self.external_reference.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PublishedFileDetails_Preview {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.previewid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sortorder = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtubevideoid)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.preview_type = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.external_reference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.previewid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sortorder {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.youtubevideoid.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.preview_type {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.external_reference.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.previewid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sortorder {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.youtubevideoid.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.preview_type {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.external_reference.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails_Preview {
        PublishedFileDetails_Preview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "previewid",
                    |m: &PublishedFileDetails_Preview| { &m.previewid },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.previewid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sortorder",
                    |m: &PublishedFileDetails_Preview| { &m.sortorder },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.sortorder },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "url",
                    |m: &PublishedFileDetails_Preview| { &m.url },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &PublishedFileDetails_Preview| { &m.size },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &PublishedFileDetails_Preview| { &m.filename },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "youtubevideoid",
                    |m: &PublishedFileDetails_Preview| { &m.youtubevideoid },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.youtubevideoid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "preview_type",
                    |m: &PublishedFileDetails_Preview| { &m.preview_type },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.preview_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "external_reference",
                    |m: &PublishedFileDetails_Preview| { &m.external_reference },
                    |m: &mut PublishedFileDetails_Preview| { &mut m.external_reference },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails_Preview>(
                    "PublishedFileDetails_Preview",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails_Preview {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails_Preview> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails_Preview,
        };
        unsafe {
            instance.get(PublishedFileDetails_Preview::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails_Preview {
    fn clear(&mut self) {
        self.previewid = ::std::option::Option::None;
        self.sortorder = ::std::option::Option::None;
        self.url.clear();
        self.size = ::std::option::Option::None;
        self.filename.clear();
        self.youtubevideoid.clear();
        self.preview_type = ::std::option::Option::None;
        self.external_reference.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails_Preview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails_Preview {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails_Child {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    sortorder: ::std::option::Option<u32>,
    file_type: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails_Child {
    fn default() -> &'a PublishedFileDetails_Child {
        <PublishedFileDetails_Child as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails_Child {
    pub fn new() -> PublishedFileDetails_Child {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 sortorder = 2;


    pub fn get_sortorder(&self) -> u32 {
        self.sortorder.unwrap_or(0)
    }
    pub fn clear_sortorder(&mut self) {
        self.sortorder = ::std::option::Option::None;
    }

    pub fn has_sortorder(&self) -> bool {
        self.sortorder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sortorder(&mut self, v: u32) {
        self.sortorder = ::std::option::Option::Some(v);
    }

    // optional uint32 file_type = 3;


    pub fn get_file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }
    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PublishedFileDetails_Child {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sortorder = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sortorder {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sortorder {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails_Child {
        PublishedFileDetails_Child::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &PublishedFileDetails_Child| { &m.publishedfileid },
                    |m: &mut PublishedFileDetails_Child| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "sortorder",
                    |m: &PublishedFileDetails_Child| { &m.sortorder },
                    |m: &mut PublishedFileDetails_Child| { &mut m.sortorder },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "file_type",
                    |m: &PublishedFileDetails_Child| { &m.file_type },
                    |m: &mut PublishedFileDetails_Child| { &mut m.file_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails_Child>(
                    "PublishedFileDetails_Child",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails_Child {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails_Child> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails_Child,
        };
        unsafe {
            instance.get(PublishedFileDetails_Child::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails_Child {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.sortorder = ::std::option::Option::None;
        self.file_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails_Child {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails_Child {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails_KVTag {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails_KVTag {
    fn default() -> &'a PublishedFileDetails_KVTag {
        <PublishedFileDetails_KVTag as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails_KVTag {
    pub fn new() -> PublishedFileDetails_KVTag {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PublishedFileDetails_KVTag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails_KVTag {
        PublishedFileDetails_KVTag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &PublishedFileDetails_KVTag| { &m.key },
                    |m: &mut PublishedFileDetails_KVTag| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &PublishedFileDetails_KVTag| { &m.value },
                    |m: &mut PublishedFileDetails_KVTag| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails_KVTag>(
                    "PublishedFileDetails_KVTag",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails_KVTag {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails_KVTag> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails_KVTag,
        };
        unsafe {
            instance.get(PublishedFileDetails_KVTag::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails_KVTag {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails_KVTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails_KVTag {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails_VoteData {
    // message fields
    score: ::std::option::Option<f32>,
    votes_up: ::std::option::Option<u32>,
    votes_down: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails_VoteData {
    fn default() -> &'a PublishedFileDetails_VoteData {
        <PublishedFileDetails_VoteData as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails_VoteData {
    pub fn new() -> PublishedFileDetails_VoteData {
        ::std::default::Default::default()
    }

    // optional float score = 1;


    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 votes_up = 2;


    pub fn get_votes_up(&self) -> u32 {
        self.votes_up.unwrap_or(0)
    }
    pub fn clear_votes_up(&mut self) {
        self.votes_up = ::std::option::Option::None;
    }

    pub fn has_votes_up(&self) -> bool {
        self.votes_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_up(&mut self, v: u32) {
        self.votes_up = ::std::option::Option::Some(v);
    }

    // optional uint32 votes_down = 3;


    pub fn get_votes_down(&self) -> u32 {
        self.votes_down.unwrap_or(0)
    }
    pub fn clear_votes_down(&mut self) {
        self.votes_down = ::std::option::Option::None;
    }

    pub fn has_votes_down(&self) -> bool {
        self.votes_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_down(&mut self, v: u32) {
        self.votes_down = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PublishedFileDetails_VoteData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.votes_up = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.votes_down = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += 5;
        }
        if let Some(v) = self.votes_up {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.votes_down {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.score {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.votes_up {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.votes_down {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails_VoteData {
        PublishedFileDetails_VoteData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    |m: &PublishedFileDetails_VoteData| { &m.score },
                    |m: &mut PublishedFileDetails_VoteData| { &mut m.score },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "votes_up",
                    |m: &PublishedFileDetails_VoteData| { &m.votes_up },
                    |m: &mut PublishedFileDetails_VoteData| { &mut m.votes_up },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "votes_down",
                    |m: &PublishedFileDetails_VoteData| { &m.votes_down },
                    |m: &mut PublishedFileDetails_VoteData| { &mut m.votes_down },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails_VoteData>(
                    "PublishedFileDetails_VoteData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails_VoteData {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails_VoteData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails_VoteData,
        };
        unsafe {
            instance.get(PublishedFileDetails_VoteData::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails_VoteData {
    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.votes_up = ::std::option::Option::None;
        self.votes_down = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails_VoteData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails_VoteData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails_ForSaleData {
    // message fields
    is_for_sale: ::std::option::Option<bool>,
    price_category: ::std::option::Option<u32>,
    estatus: ::std::option::Option<EPublishedFileForSaleStatus>,
    price_category_floor: ::std::option::Option<u32>,
    price_is_pay_what_you_want: ::std::option::Option<bool>,
    discount_percentage: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails_ForSaleData {
    fn default() -> &'a PublishedFileDetails_ForSaleData {
        <PublishedFileDetails_ForSaleData as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails_ForSaleData {
    pub fn new() -> PublishedFileDetails_ForSaleData {
        ::std::default::Default::default()
    }

    // optional bool is_for_sale = 1;


    pub fn get_is_for_sale(&self) -> bool {
        self.is_for_sale.unwrap_or(false)
    }
    pub fn clear_is_for_sale(&mut self) {
        self.is_for_sale = ::std::option::Option::None;
    }

    pub fn has_is_for_sale(&self) -> bool {
        self.is_for_sale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_for_sale(&mut self, v: bool) {
        self.is_for_sale = ::std::option::Option::Some(v);
    }

    // optional uint32 price_category = 2;


    pub fn get_price_category(&self) -> u32 {
        self.price_category.unwrap_or(0)
    }
    pub fn clear_price_category(&mut self) {
        self.price_category = ::std::option::Option::None;
    }

    pub fn has_price_category(&self) -> bool {
        self.price_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_category(&mut self, v: u32) {
        self.price_category = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileForSaleStatus estatus = 3;


    pub fn get_estatus(&self) -> EPublishedFileForSaleStatus {
        self.estatus.unwrap_or(EPublishedFileForSaleStatus::k_PFFSS_NotForSale)
    }
    pub fn clear_estatus(&mut self) {
        self.estatus = ::std::option::Option::None;
    }

    pub fn has_estatus(&self) -> bool {
        self.estatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estatus(&mut self, v: EPublishedFileForSaleStatus) {
        self.estatus = ::std::option::Option::Some(v);
    }

    // optional uint32 price_category_floor = 4;


    pub fn get_price_category_floor(&self) -> u32 {
        self.price_category_floor.unwrap_or(0)
    }
    pub fn clear_price_category_floor(&mut self) {
        self.price_category_floor = ::std::option::Option::None;
    }

    pub fn has_price_category_floor(&self) -> bool {
        self.price_category_floor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_category_floor(&mut self, v: u32) {
        self.price_category_floor = ::std::option::Option::Some(v);
    }

    // optional bool price_is_pay_what_you_want = 5;


    pub fn get_price_is_pay_what_you_want(&self) -> bool {
        self.price_is_pay_what_you_want.unwrap_or(false)
    }
    pub fn clear_price_is_pay_what_you_want(&mut self) {
        self.price_is_pay_what_you_want = ::std::option::Option::None;
    }

    pub fn has_price_is_pay_what_you_want(&self) -> bool {
        self.price_is_pay_what_you_want.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_is_pay_what_you_want(&mut self, v: bool) {
        self.price_is_pay_what_you_want = ::std::option::Option::Some(v);
    }

    // optional uint32 discount_percentage = 6;


    pub fn get_discount_percentage(&self) -> u32 {
        self.discount_percentage.unwrap_or(0)
    }
    pub fn clear_discount_percentage(&mut self) {
        self.discount_percentage = ::std::option::Option::None;
    }

    pub fn has_discount_percentage(&self) -> bool {
        self.discount_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discount_percentage(&mut self, v: u32) {
        self.discount_percentage = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PublishedFileDetails_ForSaleData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_for_sale = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.price_category = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.estatus, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.price_category_floor = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.price_is_pay_what_you_want = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.discount_percentage = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_for_sale {
            my_size += 2;
        }
        if let Some(v) = self.price_category {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.estatus {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.price_category_floor {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.price_is_pay_what_you_want {
            my_size += 2;
        }
        if let Some(v) = self.discount_percentage {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_for_sale {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.price_category {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.estatus {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.price_category_floor {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.price_is_pay_what_you_want {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.discount_percentage {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails_ForSaleData {
        PublishedFileDetails_ForSaleData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_for_sale",
                    |m: &PublishedFileDetails_ForSaleData| { &m.is_for_sale },
                    |m: &mut PublishedFileDetails_ForSaleData| { &mut m.is_for_sale },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "price_category",
                    |m: &PublishedFileDetails_ForSaleData| { &m.price_category },
                    |m: &mut PublishedFileDetails_ForSaleData| { &mut m.price_category },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileForSaleStatus>>(
                    "estatus",
                    |m: &PublishedFileDetails_ForSaleData| { &m.estatus },
                    |m: &mut PublishedFileDetails_ForSaleData| { &mut m.estatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "price_category_floor",
                    |m: &PublishedFileDetails_ForSaleData| { &m.price_category_floor },
                    |m: &mut PublishedFileDetails_ForSaleData| { &mut m.price_category_floor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "price_is_pay_what_you_want",
                    |m: &PublishedFileDetails_ForSaleData| { &m.price_is_pay_what_you_want },
                    |m: &mut PublishedFileDetails_ForSaleData| { &mut m.price_is_pay_what_you_want },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "discount_percentage",
                    |m: &PublishedFileDetails_ForSaleData| { &m.discount_percentage },
                    |m: &mut PublishedFileDetails_ForSaleData| { &mut m.discount_percentage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails_ForSaleData>(
                    "PublishedFileDetails_ForSaleData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails_ForSaleData {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails_ForSaleData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails_ForSaleData,
        };
        unsafe {
            instance.get(PublishedFileDetails_ForSaleData::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails_ForSaleData {
    fn clear(&mut self) {
        self.is_for_sale = ::std::option::Option::None;
        self.price_category = ::std::option::Option::None;
        self.estatus = ::std::option::Option::None;
        self.price_category_floor = ::std::option::Option::None;
        self.price_is_pay_what_you_want = ::std::option::Option::None;
        self.discount_percentage = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails_ForSaleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails_ForSaleData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PublishedFileDetails_PlaytimeStats {
    // message fields
    playtime_seconds: ::std::option::Option<u64>,
    num_sessions: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublishedFileDetails_PlaytimeStats {
    fn default() -> &'a PublishedFileDetails_PlaytimeStats {
        <PublishedFileDetails_PlaytimeStats as ::protobuf::Message>::default_instance()
    }
}

impl PublishedFileDetails_PlaytimeStats {
    pub fn new() -> PublishedFileDetails_PlaytimeStats {
        ::std::default::Default::default()
    }

    // optional uint64 playtime_seconds = 1;


    pub fn get_playtime_seconds(&self) -> u64 {
        self.playtime_seconds.unwrap_or(0)
    }
    pub fn clear_playtime_seconds(&mut self) {
        self.playtime_seconds = ::std::option::Option::None;
    }

    pub fn has_playtime_seconds(&self) -> bool {
        self.playtime_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playtime_seconds(&mut self, v: u64) {
        self.playtime_seconds = ::std::option::Option::Some(v);
    }

    // optional uint64 num_sessions = 2;


    pub fn get_num_sessions(&self) -> u64 {
        self.num_sessions.unwrap_or(0)
    }
    pub fn clear_num_sessions(&mut self) {
        self.num_sessions = ::std::option::Option::None;
    }

    pub fn has_num_sessions(&self) -> bool {
        self.num_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_sessions(&mut self, v: u64) {
        self.num_sessions = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PublishedFileDetails_PlaytimeStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.playtime_seconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_sessions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.playtime_seconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_sessions {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.playtime_seconds {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.num_sessions {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublishedFileDetails_PlaytimeStats {
        PublishedFileDetails_PlaytimeStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "playtime_seconds",
                    |m: &PublishedFileDetails_PlaytimeStats| { &m.playtime_seconds },
                    |m: &mut PublishedFileDetails_PlaytimeStats| { &mut m.playtime_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_sessions",
                    |m: &PublishedFileDetails_PlaytimeStats| { &m.num_sessions },
                    |m: &mut PublishedFileDetails_PlaytimeStats| { &mut m.num_sessions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublishedFileDetails_PlaytimeStats>(
                    "PublishedFileDetails_PlaytimeStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublishedFileDetails_PlaytimeStats {
        static mut instance: ::protobuf::lazy::Lazy<PublishedFileDetails_PlaytimeStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublishedFileDetails_PlaytimeStats,
        };
        unsafe {
            instance.get(PublishedFileDetails_PlaytimeStats::new)
        }
    }
}

impl ::protobuf::Clear for PublishedFileDetails_PlaytimeStats {
    fn clear(&mut self) {
        self.playtime_seconds = ::std::option::Option::None;
        self.num_sessions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublishedFileDetails_PlaytimeStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublishedFileDetails_PlaytimeStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetDetails_Response {
    // message fields
    publishedfiledetails: ::protobuf::RepeatedField<PublishedFileDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetDetails_Response {
    fn default() -> &'a CPublishedFile_GetDetails_Response {
        <CPublishedFile_GetDetails_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetDetails_Response {
    pub fn new() -> CPublishedFile_GetDetails_Response {
        ::std::default::Default::default()
    }

    // repeated .PublishedFileDetails publishedfiledetails = 1;


    pub fn get_publishedfiledetails(&self) -> &[PublishedFileDetails] {
        &self.publishedfiledetails
    }
    pub fn clear_publishedfiledetails(&mut self) {
        self.publishedfiledetails.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfiledetails(&mut self, v: ::protobuf::RepeatedField<PublishedFileDetails>) {
        self.publishedfiledetails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfiledetails(&mut self) -> &mut ::protobuf::RepeatedField<PublishedFileDetails> {
        &mut self.publishedfiledetails
    }

    // Take field
    pub fn take_publishedfiledetails(&mut self) -> ::protobuf::RepeatedField<PublishedFileDetails> {
        ::std::mem::replace(&mut self.publishedfiledetails, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetDetails_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.publishedfiledetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.publishedfiledetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.publishedfiledetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.publishedfiledetails {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetDetails_Response {
        CPublishedFile_GetDetails_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails>>(
                    "publishedfiledetails",
                    |m: &CPublishedFile_GetDetails_Response| { &m.publishedfiledetails },
                    |m: &mut CPublishedFile_GetDetails_Response| { &mut m.publishedfiledetails },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetDetails_Response>(
                    "CPublishedFile_GetDetails_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetDetails_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetDetails_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetDetails_Response,
        };
        unsafe {
            instance.get(CPublishedFile_GetDetails_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetDetails_Response {
    fn clear(&mut self) {
        self.publishedfiledetails.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetDetails_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetDetails_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetItemInfo_Request {
    // message fields
    app_id: ::std::option::Option<u32>,
    last_time_updated: ::std::option::Option<u32>,
    workshop_items: ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Request_WorkshopItem>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetItemInfo_Request {
    fn default() -> &'a CPublishedFile_GetItemInfo_Request {
        <CPublishedFile_GetItemInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetItemInfo_Request {
    pub fn new() -> CPublishedFile_GetItemInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;


    pub fn get_last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }
    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    // repeated .CPublishedFile_GetItemInfo_Request.WorkshopItem workshop_items = 3;


    pub fn get_workshop_items(&self) -> &[CPublishedFile_GetItemInfo_Request_WorkshopItem] {
        &self.workshop_items
    }
    pub fn clear_workshop_items(&mut self) {
        self.workshop_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_workshop_items(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Request_WorkshopItem>) {
        self.workshop_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workshop_items(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Request_WorkshopItem> {
        &mut self.workshop_items
    }

    // Take field
    pub fn take_workshop_items(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Request_WorkshopItem> {
        ::std::mem::replace(&mut self.workshop_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetItemInfo_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time_updated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workshop_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetItemInfo_Request {
        CPublishedFile_GetItemInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "app_id",
                    |m: &CPublishedFile_GetItemInfo_Request| { &m.app_id },
                    |m: &mut CPublishedFile_GetItemInfo_Request| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_time_updated",
                    |m: &CPublishedFile_GetItemInfo_Request| { &m.last_time_updated },
                    |m: &mut CPublishedFile_GetItemInfo_Request| { &mut m.last_time_updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_GetItemInfo_Request_WorkshopItem>>(
                    "workshop_items",
                    |m: &CPublishedFile_GetItemInfo_Request| { &m.workshop_items },
                    |m: &mut CPublishedFile_GetItemInfo_Request| { &mut m.workshop_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetItemInfo_Request>(
                    "CPublishedFile_GetItemInfo_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetItemInfo_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetItemInfo_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetItemInfo_Request,
        };
        unsafe {
            instance.get(CPublishedFile_GetItemInfo_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetItemInfo_Request {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.workshop_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetItemInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetItemInfo_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetItemInfo_Request_WorkshopItem {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    time_updated: ::std::option::Option<u32>,
    desired_revision: ::std::option::Option<EPublishedFileRevision>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetItemInfo_Request_WorkshopItem {
    fn default() -> &'a CPublishedFile_GetItemInfo_Request_WorkshopItem {
        <CPublishedFile_GetItemInfo_Request_WorkshopItem as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetItemInfo_Request_WorkshopItem {
    pub fn new() -> CPublishedFile_GetItemInfo_Request_WorkshopItem {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 2;


    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }
    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 3;


    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        self.desired_revision.unwrap_or(EPublishedFileRevision::k_EPublishedFileRevision_Default)
    }
    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetItemInfo_Request_WorkshopItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_updated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desired_revision, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetItemInfo_Request_WorkshopItem {
        CPublishedFile_GetItemInfo_Request_WorkshopItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "published_file_id",
                    |m: &CPublishedFile_GetItemInfo_Request_WorkshopItem| { &m.published_file_id },
                    |m: &mut CPublishedFile_GetItemInfo_Request_WorkshopItem| { &mut m.published_file_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_updated",
                    |m: &CPublishedFile_GetItemInfo_Request_WorkshopItem| { &m.time_updated },
                    |m: &mut CPublishedFile_GetItemInfo_Request_WorkshopItem| { &mut m.time_updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "desired_revision",
                    |m: &CPublishedFile_GetItemInfo_Request_WorkshopItem| { &m.desired_revision },
                    |m: &mut CPublishedFile_GetItemInfo_Request_WorkshopItem| { &mut m.desired_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetItemInfo_Request_WorkshopItem>(
                    "CPublishedFile_GetItemInfo_Request_WorkshopItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetItemInfo_Request_WorkshopItem {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetItemInfo_Request_WorkshopItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetItemInfo_Request_WorkshopItem,
        };
        unsafe {
            instance.get(CPublishedFile_GetItemInfo_Request_WorkshopItem::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetItemInfo_Request_WorkshopItem {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetItemInfo_Request_WorkshopItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetItemInfo_Request_WorkshopItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetItemInfo_Response {
    // message fields
    update_time: ::std::option::Option<u32>,
    workshop_items: ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Response_WorkshopItemInfo>,
    private_items: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetItemInfo_Response {
    fn default() -> &'a CPublishedFile_GetItemInfo_Response {
        <CPublishedFile_GetItemInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetItemInfo_Response {
    pub fn new() -> CPublishedFile_GetItemInfo_Response {
        ::std::default::Default::default()
    }

    // optional uint32 update_time = 1;


    pub fn get_update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }
    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }

    // repeated .CPublishedFile_GetItemInfo_Response.WorkshopItemInfo workshop_items = 2;


    pub fn get_workshop_items(&self) -> &[CPublishedFile_GetItemInfo_Response_WorkshopItemInfo] {
        &self.workshop_items
    }
    pub fn clear_workshop_items(&mut self) {
        self.workshop_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_workshop_items(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Response_WorkshopItemInfo>) {
        self.workshop_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workshop_items(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Response_WorkshopItemInfo> {
        &mut self.workshop_items
    }

    // Take field
    pub fn take_workshop_items(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_GetItemInfo_Response_WorkshopItemInfo> {
        ::std::mem::replace(&mut self.workshop_items, ::protobuf::RepeatedField::new())
    }

    // repeated fixed64 private_items = 3;


    pub fn get_private_items(&self) -> &[u64] {
        &self.private_items
    }
    pub fn clear_private_items(&mut self) {
        self.private_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_private_items(&mut self, v: ::std::vec::Vec<u64>) {
        self.private_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_private_items(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.private_items
    }

    // Take field
    pub fn take_private_items(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.private_items, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetItemInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.update_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workshop_items)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.private_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 9 * self.private_items.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.update_time {
            os.write_uint32(1, v)?;
        }
        for v in &self.workshop_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.private_items {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetItemInfo_Response {
        CPublishedFile_GetItemInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "update_time",
                    |m: &CPublishedFile_GetItemInfo_Response| { &m.update_time },
                    |m: &mut CPublishedFile_GetItemInfo_Response| { &mut m.update_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_GetItemInfo_Response_WorkshopItemInfo>>(
                    "workshop_items",
                    |m: &CPublishedFile_GetItemInfo_Response| { &m.workshop_items },
                    |m: &mut CPublishedFile_GetItemInfo_Response| { &mut m.workshop_items },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "private_items",
                    |m: &CPublishedFile_GetItemInfo_Response| { &m.private_items },
                    |m: &mut CPublishedFile_GetItemInfo_Response| { &mut m.private_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetItemInfo_Response>(
                    "CPublishedFile_GetItemInfo_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetItemInfo_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetItemInfo_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetItemInfo_Response,
        };
        unsafe {
            instance.get(CPublishedFile_GetItemInfo_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetItemInfo_Response {
    fn clear(&mut self) {
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.private_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetItemInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetItemInfo_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    time_updated: ::std::option::Option<u32>,
    manifest_id: ::std::option::Option<u64>,
    flags: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
    fn default() -> &'a CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
        <CPublishedFile_GetItemInfo_Response_WorkshopItemInfo as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
    pub fn new() -> CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 2;


    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }
    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 manifest_id = 3;


    pub fn get_manifest_id(&self) -> u64 {
        self.manifest_id.unwrap_or(0)
    }
    pub fn clear_manifest_id(&mut self) {
        self.manifest_id = ::std::option::Option::None;
    }

    pub fn has_manifest_id(&self) -> bool {
        self.manifest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest_id(&mut self, v: u64) {
        self.manifest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 4;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_updated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.manifest_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.manifest_id {
            my_size += 9;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.manifest_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
        CPublishedFile_GetItemInfo_Response_WorkshopItemInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "published_file_id",
                    |m: &CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &m.published_file_id },
                    |m: &mut CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &mut m.published_file_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_updated",
                    |m: &CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &m.time_updated },
                    |m: &mut CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &mut m.time_updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "manifest_id",
                    |m: &CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &m.manifest_id },
                    |m: &mut CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &mut m.manifest_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    |m: &CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &m.flags },
                    |m: &mut CPublishedFile_GetItemInfo_Response_WorkshopItemInfo| { &mut m.flags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetItemInfo_Response_WorkshopItemInfo>(
                    "CPublishedFile_GetItemInfo_Response_WorkshopItemInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetItemInfo_Response_WorkshopItemInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetItemInfo_Response_WorkshopItemInfo,
        };
        unsafe {
            instance.get(CPublishedFile_GetItemInfo_Response_WorkshopItemInfo::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.manifest_id = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetUserFiles_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    page: ::std::option::Option<u32>,
    numperpage: ::std::option::Option<u32>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    sortmethod: ::protobuf::SingularField<::std::string::String>,
    privacy: ::std::option::Option<u32>,
    requiredtags: ::protobuf::RepeatedField<::std::string::String>,
    excludedtags: ::protobuf::RepeatedField<::std::string::String>,
    required_kv_tags: ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Request_KVTag>,
    filetype: ::std::option::Option<u32>,
    creator_appid: ::std::option::Option<u32>,
    match_cloud_filename: ::protobuf::SingularField<::std::string::String>,
    cache_max_age_seconds: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    totalonly: ::std::option::Option<bool>,
    ids_only: ::std::option::Option<bool>,
    return_vote_data: ::std::option::Option<bool>,
    return_tags: ::std::option::Option<bool>,
    return_kv_tags: ::std::option::Option<bool>,
    return_previews: ::std::option::Option<bool>,
    return_children: ::std::option::Option<bool>,
    return_short_description: ::std::option::Option<bool>,
    return_for_sale_data: ::std::option::Option<bool>,
    return_metadata: ::std::option::Option<bool>,
    return_playtime_stats: ::std::option::Option<u32>,
    strip_description_bbcode: ::std::option::Option<bool>,
    desired_revision: ::std::option::Option<EPublishedFileRevision>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserFiles_Request {
    fn default() -> &'a CPublishedFile_GetUserFiles_Request {
        <CPublishedFile_GetUserFiles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserFiles_Request {
    pub fn new() -> CPublishedFile_GetUserFiles_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 page = 4;


    pub fn get_page(&self) -> u32 {
        self.page.unwrap_or(1u32)
    }
    pub fn clear_page(&mut self) {
        self.page = ::std::option::Option::None;
    }

    pub fn has_page(&self) -> bool {
        self.page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = ::std::option::Option::Some(v);
    }

    // optional uint32 numperpage = 5;


    pub fn get_numperpage(&self) -> u32 {
        self.numperpage.unwrap_or(1u32)
    }
    pub fn clear_numperpage(&mut self) {
        self.numperpage = ::std::option::Option::None;
    }

    pub fn has_numperpage(&self) -> bool {
        self.numperpage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numperpage(&mut self, v: u32) {
        self.numperpage = ::std::option::Option::Some(v);
    }

    // optional string type = 6;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "myfiles",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sortmethod = 7;


    pub fn get_sortmethod(&self) -> &str {
        match self.sortmethod.as_ref() {
            Some(v) => &v,
            None => "lastupdated",
        }
    }
    pub fn clear_sortmethod(&mut self) {
        self.sortmethod.clear();
    }

    pub fn has_sortmethod(&self) -> bool {
        self.sortmethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sortmethod(&mut self, v: ::std::string::String) {
        self.sortmethod = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortmethod(&mut self) -> &mut ::std::string::String {
        if self.sortmethod.is_none() {
            self.sortmethod.set_default();
        }
        self.sortmethod.as_mut().unwrap()
    }

    // Take field
    pub fn take_sortmethod(&mut self) -> ::std::string::String {
        self.sortmethod.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 privacy = 9;


    pub fn get_privacy(&self) -> u32 {
        self.privacy.unwrap_or(0)
    }
    pub fn clear_privacy(&mut self) {
        self.privacy = ::std::option::Option::None;
    }

    pub fn has_privacy(&self) -> bool {
        self.privacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy(&mut self, v: u32) {
        self.privacy = ::std::option::Option::Some(v);
    }

    // repeated string requiredtags = 10;


    pub fn get_requiredtags(&self) -> &[::std::string::String] {
        &self.requiredtags
    }
    pub fn clear_requiredtags(&mut self) {
        self.requiredtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredtags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.requiredtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredtags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.requiredtags
    }

    // Take field
    pub fn take_requiredtags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.requiredtags, ::protobuf::RepeatedField::new())
    }

    // repeated string excludedtags = 11;


    pub fn get_excludedtags(&self) -> &[::std::string::String] {
        &self.excludedtags
    }
    pub fn clear_excludedtags(&mut self) {
        self.excludedtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludedtags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludedtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludedtags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludedtags
    }

    // Take field
    pub fn take_excludedtags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludedtags, ::protobuf::RepeatedField::new())
    }

    // repeated .CPublishedFile_GetUserFiles_Request.KVTag required_kv_tags = 30;


    pub fn get_required_kv_tags(&self) -> &[CPublishedFile_GetUserFiles_Request_KVTag] {
        &self.required_kv_tags
    }
    pub fn clear_required_kv_tags(&mut self) {
        self.required_kv_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_kv_tags(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Request_KVTag>) {
        self.required_kv_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_kv_tags(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Request_KVTag> {
        &mut self.required_kv_tags
    }

    // Take field
    pub fn take_required_kv_tags(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Request_KVTag> {
        ::std::mem::replace(&mut self.required_kv_tags, ::protobuf::RepeatedField::new())
    }

    // optional uint32 filetype = 14;


    pub fn get_filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }
    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional uint32 creator_appid = 15;


    pub fn get_creator_appid(&self) -> u32 {
        self.creator_appid.unwrap_or(0)
    }
    pub fn clear_creator_appid(&mut self) {
        self.creator_appid = ::std::option::Option::None;
    }

    pub fn has_creator_appid(&self) -> bool {
        self.creator_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_appid(&mut self, v: u32) {
        self.creator_appid = ::std::option::Option::Some(v);
    }

    // optional string match_cloud_filename = 16;


    pub fn get_match_cloud_filename(&self) -> &str {
        match self.match_cloud_filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_match_cloud_filename(&mut self) {
        self.match_cloud_filename.clear();
    }

    pub fn has_match_cloud_filename(&self) -> bool {
        self.match_cloud_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_cloud_filename(&mut self, v: ::std::string::String) {
        self.match_cloud_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_match_cloud_filename(&mut self) -> &mut ::std::string::String {
        if self.match_cloud_filename.is_none() {
            self.match_cloud_filename.set_default();
        }
        self.match_cloud_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_match_cloud_filename(&mut self) -> ::std::string::String {
        self.match_cloud_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 cache_max_age_seconds = 27;


    pub fn get_cache_max_age_seconds(&self) -> u32 {
        self.cache_max_age_seconds.unwrap_or(0u32)
    }
    pub fn clear_cache_max_age_seconds(&mut self) {
        self.cache_max_age_seconds = ::std::option::Option::None;
    }

    pub fn has_cache_max_age_seconds(&self) -> bool {
        self.cache_max_age_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_max_age_seconds(&mut self, v: u32) {
        self.cache_max_age_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 language = 29;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool totalonly = 17;


    pub fn get_totalonly(&self) -> bool {
        self.totalonly.unwrap_or(false)
    }
    pub fn clear_totalonly(&mut self) {
        self.totalonly = ::std::option::Option::None;
    }

    pub fn has_totalonly(&self) -> bool {
        self.totalonly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalonly(&mut self, v: bool) {
        self.totalonly = ::std::option::Option::Some(v);
    }

    // optional bool ids_only = 18;


    pub fn get_ids_only(&self) -> bool {
        self.ids_only.unwrap_or(false)
    }
    pub fn clear_ids_only(&mut self) {
        self.ids_only = ::std::option::Option::None;
    }

    pub fn has_ids_only(&self) -> bool {
        self.ids_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ids_only(&mut self, v: bool) {
        self.ids_only = ::std::option::Option::Some(v);
    }

    // optional bool return_vote_data = 19;


    pub fn get_return_vote_data(&self) -> bool {
        self.return_vote_data.unwrap_or(true)
    }
    pub fn clear_return_vote_data(&mut self) {
        self.return_vote_data = ::std::option::Option::None;
    }

    pub fn has_return_vote_data(&self) -> bool {
        self.return_vote_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_vote_data(&mut self, v: bool) {
        self.return_vote_data = ::std::option::Option::Some(v);
    }

    // optional bool return_tags = 20;


    pub fn get_return_tags(&self) -> bool {
        self.return_tags.unwrap_or(false)
    }
    pub fn clear_return_tags(&mut self) {
        self.return_tags = ::std::option::Option::None;
    }

    pub fn has_return_tags(&self) -> bool {
        self.return_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_tags(&mut self, v: bool) {
        self.return_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_kv_tags = 21;


    pub fn get_return_kv_tags(&self) -> bool {
        self.return_kv_tags.unwrap_or(true)
    }
    pub fn clear_return_kv_tags(&mut self) {
        self.return_kv_tags = ::std::option::Option::None;
    }

    pub fn has_return_kv_tags(&self) -> bool {
        self.return_kv_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_kv_tags(&mut self, v: bool) {
        self.return_kv_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_previews = 22;


    pub fn get_return_previews(&self) -> bool {
        self.return_previews.unwrap_or(false)
    }
    pub fn clear_return_previews(&mut self) {
        self.return_previews = ::std::option::Option::None;
    }

    pub fn has_return_previews(&self) -> bool {
        self.return_previews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_previews(&mut self, v: bool) {
        self.return_previews = ::std::option::Option::Some(v);
    }

    // optional bool return_children = 23;


    pub fn get_return_children(&self) -> bool {
        self.return_children.unwrap_or(false)
    }
    pub fn clear_return_children(&mut self) {
        self.return_children = ::std::option::Option::None;
    }

    pub fn has_return_children(&self) -> bool {
        self.return_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_children(&mut self, v: bool) {
        self.return_children = ::std::option::Option::Some(v);
    }

    // optional bool return_short_description = 24;


    pub fn get_return_short_description(&self) -> bool {
        self.return_short_description.unwrap_or(true)
    }
    pub fn clear_return_short_description(&mut self) {
        self.return_short_description = ::std::option::Option::None;
    }

    pub fn has_return_short_description(&self) -> bool {
        self.return_short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_short_description(&mut self, v: bool) {
        self.return_short_description = ::std::option::Option::Some(v);
    }

    // optional bool return_for_sale_data = 26;


    pub fn get_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.unwrap_or(false)
    }
    pub fn clear_return_for_sale_data(&mut self) {
        self.return_for_sale_data = ::std::option::Option::None;
    }

    pub fn has_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_for_sale_data(&mut self, v: bool) {
        self.return_for_sale_data = ::std::option::Option::Some(v);
    }

    // optional bool return_metadata = 28;


    pub fn get_return_metadata(&self) -> bool {
        self.return_metadata.unwrap_or(false)
    }
    pub fn clear_return_metadata(&mut self) {
        self.return_metadata = ::std::option::Option::None;
    }

    pub fn has_return_metadata(&self) -> bool {
        self.return_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_metadata(&mut self, v: bool) {
        self.return_metadata = ::std::option::Option::Some(v);
    }

    // optional uint32 return_playtime_stats = 31;


    pub fn get_return_playtime_stats(&self) -> u32 {
        self.return_playtime_stats.unwrap_or(0)
    }
    pub fn clear_return_playtime_stats(&mut self) {
        self.return_playtime_stats = ::std::option::Option::None;
    }

    pub fn has_return_playtime_stats(&self) -> bool {
        self.return_playtime_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_playtime_stats(&mut self, v: u32) {
        self.return_playtime_stats = ::std::option::Option::Some(v);
    }

    // optional bool strip_description_bbcode = 32;


    pub fn get_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.unwrap_or(false)
    }
    pub fn clear_strip_description_bbcode(&mut self) {
        self.strip_description_bbcode = ::std::option::Option::None;
    }

    pub fn has_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_description_bbcode(&mut self, v: bool) {
        self.strip_description_bbcode = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 33;


    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        self.desired_revision.unwrap_or(EPublishedFileRevision::k_EPublishedFileRevision_Default)
    }
    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserFiles_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.required_kv_tags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numperpage = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sortmethod)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.privacy = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.requiredtags)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludedtags)?;
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.required_kv_tags)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filetype = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.creator_appid = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.match_cloud_filename)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cache_max_age_seconds = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.totalonly = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ids_only = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_vote_data = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_tags = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_kv_tags = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_previews = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_children = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_short_description = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_for_sale_data = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_metadata = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.return_playtime_stats = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.strip_description_bbcode = ::std::option::Option::Some(tmp);
                },
                33 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desired_revision, 33, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.page {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numperpage {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.sortmethod.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.privacy {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requiredtags {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.excludedtags {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.required_kv_tags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator_appid {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.match_cloud_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.cache_max_age_seconds {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.totalonly {
            my_size += 3;
        }
        if let Some(v) = self.ids_only {
            my_size += 3;
        }
        if let Some(v) = self.return_vote_data {
            my_size += 3;
        }
        if let Some(v) = self.return_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_kv_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_previews {
            my_size += 3;
        }
        if let Some(v) = self.return_children {
            my_size += 3;
        }
        if let Some(v) = self.return_short_description {
            my_size += 3;
        }
        if let Some(v) = self.return_for_sale_data {
            my_size += 3;
        }
        if let Some(v) = self.return_metadata {
            my_size += 3;
        }
        if let Some(v) = self.return_playtime_stats {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strip_description_bbcode {
            my_size += 3;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_size(33, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.page {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.numperpage {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.sortmethod.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.privacy {
            os.write_uint32(9, v)?;
        }
        for v in &self.requiredtags {
            os.write_string(10, &v)?;
        };
        for v in &self.excludedtags {
            os.write_string(11, &v)?;
        };
        for v in &self.required_kv_tags {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.filetype {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.creator_appid {
            os.write_uint32(15, v)?;
        }
        if let Some(ref v) = self.match_cloud_filename.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(v) = self.cache_max_age_seconds {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(29, v)?;
        }
        if let Some(v) = self.totalonly {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.ids_only {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.return_vote_data {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.return_tags {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.return_kv_tags {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.return_previews {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.return_children {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.return_short_description {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.return_for_sale_data {
            os.write_bool(26, v)?;
        }
        if let Some(v) = self.return_metadata {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.return_playtime_stats {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.strip_description_bbcode {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(33, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserFiles_Request {
        CPublishedFile_GetUserFiles_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "steamid",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.steamid },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.appid },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "page",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.page },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.page },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numperpage",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.numperpage },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.numperpage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.field_type },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sortmethod",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.sortmethod },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.sortmethod },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "privacy",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.privacy },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.privacy },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "requiredtags",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.requiredtags },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.requiredtags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "excludedtags",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.excludedtags },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.excludedtags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_GetUserFiles_Request_KVTag>>(
                    "required_kv_tags",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.required_kv_tags },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.required_kv_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filetype",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.filetype },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.filetype },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "creator_appid",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.creator_appid },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.creator_appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match_cloud_filename",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.match_cloud_filename },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.match_cloud_filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cache_max_age_seconds",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.cache_max_age_seconds },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.cache_max_age_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.language },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "totalonly",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.totalonly },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.totalonly },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ids_only",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.ids_only },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.ids_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_vote_data",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_vote_data },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_vote_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_tags",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_tags },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_kv_tags",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_kv_tags },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_kv_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_previews",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_previews },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_previews },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_children",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_children },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_children },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_short_description",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_short_description },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_short_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_for_sale_data",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_for_sale_data },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_for_sale_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_metadata",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_metadata },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "return_playtime_stats",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.return_playtime_stats },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.return_playtime_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "strip_description_bbcode",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.strip_description_bbcode },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.strip_description_bbcode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "desired_revision",
                    |m: &CPublishedFile_GetUserFiles_Request| { &m.desired_revision },
                    |m: &mut CPublishedFile_GetUserFiles_Request| { &mut m.desired_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserFiles_Request>(
                    "CPublishedFile_GetUserFiles_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetUserFiles_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetUserFiles_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetUserFiles_Request,
        };
        unsafe {
            instance.get(CPublishedFile_GetUserFiles_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserFiles_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.page = ::std::option::Option::None;
        self.numperpage = ::std::option::Option::None;
        self.field_type.clear();
        self.sortmethod.clear();
        self.privacy = ::std::option::Option::None;
        self.requiredtags.clear();
        self.excludedtags.clear();
        self.required_kv_tags.clear();
        self.filetype = ::std::option::Option::None;
        self.creator_appid = ::std::option::Option::None;
        self.match_cloud_filename.clear();
        self.cache_max_age_seconds = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.totalonly = ::std::option::Option::None;
        self.ids_only = ::std::option::Option::None;
        self.return_vote_data = ::std::option::Option::None;
        self.return_tags = ::std::option::Option::None;
        self.return_kv_tags = ::std::option::Option::None;
        self.return_previews = ::std::option::Option::None;
        self.return_children = ::std::option::Option::None;
        self.return_short_description = ::std::option::Option::None;
        self.return_for_sale_data = ::std::option::Option::None;
        self.return_metadata = ::std::option::Option::None;
        self.return_playtime_stats = ::std::option::Option::None;
        self.strip_description_bbcode = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserFiles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserFiles_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetUserFiles_Request_KVTag {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserFiles_Request_KVTag {
    fn default() -> &'a CPublishedFile_GetUserFiles_Request_KVTag {
        <CPublishedFile_GetUserFiles_Request_KVTag as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserFiles_Request_KVTag {
    pub fn new() -> CPublishedFile_GetUserFiles_Request_KVTag {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserFiles_Request_KVTag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserFiles_Request_KVTag {
        CPublishedFile_GetUserFiles_Request_KVTag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &CPublishedFile_GetUserFiles_Request_KVTag| { &m.key },
                    |m: &mut CPublishedFile_GetUserFiles_Request_KVTag| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CPublishedFile_GetUserFiles_Request_KVTag| { &m.value },
                    |m: &mut CPublishedFile_GetUserFiles_Request_KVTag| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserFiles_Request_KVTag>(
                    "CPublishedFile_GetUserFiles_Request_KVTag",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetUserFiles_Request_KVTag {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetUserFiles_Request_KVTag> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetUserFiles_Request_KVTag,
        };
        unsafe {
            instance.get(CPublishedFile_GetUserFiles_Request_KVTag::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserFiles_Request_KVTag {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserFiles_Request_KVTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserFiles_Request_KVTag {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetUserFiles_Response {
    // message fields
    total: ::std::option::Option<u32>,
    startindex: ::std::option::Option<u32>,
    publishedfiledetails: ::protobuf::RepeatedField<PublishedFileDetails>,
    apps: ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Response_App>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserFiles_Response {
    fn default() -> &'a CPublishedFile_GetUserFiles_Response {
        <CPublishedFile_GetUserFiles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserFiles_Response {
    pub fn new() -> CPublishedFile_GetUserFiles_Response {
        ::std::default::Default::default()
    }

    // optional uint32 total = 1;


    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }
    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional uint32 startindex = 2;


    pub fn get_startindex(&self) -> u32 {
        self.startindex.unwrap_or(0)
    }
    pub fn clear_startindex(&mut self) {
        self.startindex = ::std::option::Option::None;
    }

    pub fn has_startindex(&self) -> bool {
        self.startindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startindex(&mut self, v: u32) {
        self.startindex = ::std::option::Option::Some(v);
    }

    // repeated .PublishedFileDetails publishedfiledetails = 3;


    pub fn get_publishedfiledetails(&self) -> &[PublishedFileDetails] {
        &self.publishedfiledetails
    }
    pub fn clear_publishedfiledetails(&mut self) {
        self.publishedfiledetails.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfiledetails(&mut self, v: ::protobuf::RepeatedField<PublishedFileDetails>) {
        self.publishedfiledetails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfiledetails(&mut self) -> &mut ::protobuf::RepeatedField<PublishedFileDetails> {
        &mut self.publishedfiledetails
    }

    // Take field
    pub fn take_publishedfiledetails(&mut self) -> ::protobuf::RepeatedField<PublishedFileDetails> {
        ::std::mem::replace(&mut self.publishedfiledetails, ::protobuf::RepeatedField::new())
    }

    // repeated .CPublishedFile_GetUserFiles_Response.App apps = 4;


    pub fn get_apps(&self) -> &[CPublishedFile_GetUserFiles_Response_App] {
        &self.apps
    }
    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Response_App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Response_App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_GetUserFiles_Response_App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserFiles_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.publishedfiledetails {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.startindex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.publishedfiledetails)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.startindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfiledetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.startindex {
            os.write_uint32(2, v)?;
        }
        for v in &self.publishedfiledetails {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.apps {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserFiles_Response {
        CPublishedFile_GetUserFiles_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    |m: &CPublishedFile_GetUserFiles_Response| { &m.total },
                    |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.total },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "startindex",
                    |m: &CPublishedFile_GetUserFiles_Response| { &m.startindex },
                    |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.startindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails>>(
                    "publishedfiledetails",
                    |m: &CPublishedFile_GetUserFiles_Response| { &m.publishedfiledetails },
                    |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.publishedfiledetails },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_GetUserFiles_Response_App>>(
                    "apps",
                    |m: &CPublishedFile_GetUserFiles_Response| { &m.apps },
                    |m: &mut CPublishedFile_GetUserFiles_Response| { &mut m.apps },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserFiles_Response>(
                    "CPublishedFile_GetUserFiles_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetUserFiles_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetUserFiles_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetUserFiles_Response,
        };
        unsafe {
            instance.get(CPublishedFile_GetUserFiles_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserFiles_Response {
    fn clear(&mut self) {
        self.total = ::std::option::Option::None;
        self.startindex = ::std::option::Option::None;
        self.publishedfiledetails.clear();
        self.apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserFiles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserFiles_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetUserFiles_Response_App {
    // message fields
    appid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    shortcutid: ::std::option::Option<u32>,
    private: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserFiles_Response_App {
    fn default() -> &'a CPublishedFile_GetUserFiles_Response_App {
        <CPublishedFile_GetUserFiles_Response_App as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserFiles_Response_App {
    pub fn new() -> CPublishedFile_GetUserFiles_Response_App {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 shortcutid = 3;


    pub fn get_shortcutid(&self) -> u32 {
        self.shortcutid.unwrap_or(0)
    }
    pub fn clear_shortcutid(&mut self) {
        self.shortcutid = ::std::option::Option::None;
    }

    pub fn has_shortcutid(&self) -> bool {
        self.shortcutid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcutid(&mut self, v: u32) {
        self.shortcutid = ::std::option::Option::Some(v);
    }

    // optional bool private = 4;


    pub fn get_private(&self) -> bool {
        self.private.unwrap_or(false)
    }
    pub fn clear_private(&mut self) {
        self.private = ::std::option::Option::None;
    }

    pub fn has_private(&self) -> bool {
        self.private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserFiles_Response_App {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shortcutid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.shortcutid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.private {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.shortcutid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.private {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserFiles_Response_App {
        CPublishedFile_GetUserFiles_Response_App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_GetUserFiles_Response_App| { &m.appid },
                    |m: &mut CPublishedFile_GetUserFiles_Response_App| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CPublishedFile_GetUserFiles_Response_App| { &m.name },
                    |m: &mut CPublishedFile_GetUserFiles_Response_App| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "shortcutid",
                    |m: &CPublishedFile_GetUserFiles_Response_App| { &m.shortcutid },
                    |m: &mut CPublishedFile_GetUserFiles_Response_App| { &mut m.shortcutid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &CPublishedFile_GetUserFiles_Response_App| { &m.private },
                    |m: &mut CPublishedFile_GetUserFiles_Response_App| { &mut m.private },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserFiles_Response_App>(
                    "CPublishedFile_GetUserFiles_Response_App",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetUserFiles_Response_App {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetUserFiles_Response_App> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetUserFiles_Response_App,
        };
        unsafe {
            instance.get(CPublishedFile_GetUserFiles_Response_App::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserFiles_Response_App {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name.clear();
        self.shortcutid = ::std::option::Option::None;
        self.private = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserFiles_Response_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserFiles_Response_App {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_AreFilesInSubscriptionList_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    publishedfileids: ::std::vec::Vec<u64>,
    listtype: ::std::option::Option<u32>,
    filetype: ::std::option::Option<u32>,
    workshopfiletype: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AreFilesInSubscriptionList_Request {
    fn default() -> &'a CPublishedFile_AreFilesInSubscriptionList_Request {
        <CPublishedFile_AreFilesInSubscriptionList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AreFilesInSubscriptionList_Request {
    pub fn new() -> CPublishedFile_AreFilesInSubscriptionList_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated fixed64 publishedfileids = 2;


    pub fn get_publishedfileids(&self) -> &[u64] {
        &self.publishedfileids
    }
    pub fn clear_publishedfileids(&mut self) {
        self.publishedfileids.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfileids(&mut self, v: ::std::vec::Vec<u64>) {
        self.publishedfileids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfileids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.publishedfileids
    }

    // Take field
    pub fn take_publishedfileids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.publishedfileids, ::std::vec::Vec::new())
    }

    // optional uint32 listtype = 3;


    pub fn get_listtype(&self) -> u32 {
        self.listtype.unwrap_or(0)
    }
    pub fn clear_listtype(&mut self) {
        self.listtype = ::std::option::Option::None;
    }

    pub fn has_listtype(&self) -> bool {
        self.listtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listtype(&mut self, v: u32) {
        self.listtype = ::std::option::Option::Some(v);
    }

    // optional uint32 filetype = 4;


    pub fn get_filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }
    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional uint32 workshopfiletype = 5;


    pub fn get_workshopfiletype(&self) -> u32 {
        self.workshopfiletype.unwrap_or(0)
    }
    pub fn clear_workshopfiletype(&mut self) {
        self.workshopfiletype = ::std::option::Option::None;
    }

    pub fn has_workshopfiletype(&self) -> bool {
        self.workshopfiletype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshopfiletype(&mut self, v: u32) {
        self.workshopfiletype = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_AreFilesInSubscriptionList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.listtype = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filetype = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.workshopfiletype = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.publishedfileids.len() as u32;
        if let Some(v) = self.listtype {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.workshopfiletype {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfileids {
            os.write_fixed64(2, *v)?;
        };
        if let Some(v) = self.listtype {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.filetype {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.workshopfiletype {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AreFilesInSubscriptionList_Request {
        CPublishedFile_AreFilesInSubscriptionList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.appid },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileids",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.publishedfileids },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.publishedfileids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "listtype",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.listtype },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.listtype },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filetype",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.filetype },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.filetype },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "workshopfiletype",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Request| { &m.workshopfiletype },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Request| { &mut m.workshopfiletype },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AreFilesInSubscriptionList_Request>(
                    "CPublishedFile_AreFilesInSubscriptionList_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_AreFilesInSubscriptionList_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_AreFilesInSubscriptionList_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_AreFilesInSubscriptionList_Request,
        };
        unsafe {
            instance.get(CPublishedFile_AreFilesInSubscriptionList_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_AreFilesInSubscriptionList_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileids.clear();
        self.listtype = ::std::option::Option::None;
        self.filetype = ::std::option::Option::None;
        self.workshopfiletype = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AreFilesInSubscriptionList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AreFilesInSubscriptionList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_AreFilesInSubscriptionList_Response {
    // message fields
    files: ::protobuf::RepeatedField<CPublishedFile_AreFilesInSubscriptionList_Response_InList>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AreFilesInSubscriptionList_Response {
    fn default() -> &'a CPublishedFile_AreFilesInSubscriptionList_Response {
        <CPublishedFile_AreFilesInSubscriptionList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AreFilesInSubscriptionList_Response {
    pub fn new() -> CPublishedFile_AreFilesInSubscriptionList_Response {
        ::std::default::Default::default()
    }

    // repeated .CPublishedFile_AreFilesInSubscriptionList_Response.InList files = 1;


    pub fn get_files(&self) -> &[CPublishedFile_AreFilesInSubscriptionList_Response_InList] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_AreFilesInSubscriptionList_Response_InList>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_AreFilesInSubscriptionList_Response_InList> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_AreFilesInSubscriptionList_Response_InList> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_AreFilesInSubscriptionList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AreFilesInSubscriptionList_Response {
        CPublishedFile_AreFilesInSubscriptionList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_AreFilesInSubscriptionList_Response_InList>>(
                    "files",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Response| { &m.files },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Response| { &mut m.files },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AreFilesInSubscriptionList_Response>(
                    "CPublishedFile_AreFilesInSubscriptionList_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_AreFilesInSubscriptionList_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_AreFilesInSubscriptionList_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_AreFilesInSubscriptionList_Response,
        };
        unsafe {
            instance.get(CPublishedFile_AreFilesInSubscriptionList_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_AreFilesInSubscriptionList_Response {
    fn clear(&mut self) {
        self.files.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AreFilesInSubscriptionList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AreFilesInSubscriptionList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_AreFilesInSubscriptionList_Response_InList {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    inlist: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AreFilesInSubscriptionList_Response_InList {
    fn default() -> &'a CPublishedFile_AreFilesInSubscriptionList_Response_InList {
        <CPublishedFile_AreFilesInSubscriptionList_Response_InList as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AreFilesInSubscriptionList_Response_InList {
    pub fn new() -> CPublishedFile_AreFilesInSubscriptionList_Response_InList {
        ::std::default::Default::default()
    }

    // optional fixed64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional bool inlist = 2;


    pub fn get_inlist(&self) -> bool {
        self.inlist.unwrap_or(false)
    }
    pub fn clear_inlist(&mut self) {
        self.inlist = ::std::option::Option::None;
    }

    pub fn has_inlist(&self) -> bool {
        self.inlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inlist(&mut self, v: bool) {
        self.inlist = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_AreFilesInSubscriptionList_Response_InList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inlist = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.inlist {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.inlist {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AreFilesInSubscriptionList_Response_InList {
        CPublishedFile_AreFilesInSubscriptionList_Response_InList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileid",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Response_InList| { &m.publishedfileid },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Response_InList| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inlist",
                    |m: &CPublishedFile_AreFilesInSubscriptionList_Response_InList| { &m.inlist },
                    |m: &mut CPublishedFile_AreFilesInSubscriptionList_Response_InList| { &mut m.inlist },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AreFilesInSubscriptionList_Response_InList>(
                    "CPublishedFile_AreFilesInSubscriptionList_Response_InList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_AreFilesInSubscriptionList_Response_InList {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_AreFilesInSubscriptionList_Response_InList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_AreFilesInSubscriptionList_Response_InList,
        };
        unsafe {
            instance.get(CPublishedFile_AreFilesInSubscriptionList_Response_InList::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_AreFilesInSubscriptionList_Response_InList {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.inlist = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AreFilesInSubscriptionList_Response_InList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AreFilesInSubscriptionList_Response_InList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Update_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    publishedfileid: ::std::option::Option<u64>,
    title: ::protobuf::SingularField<::std::string::String>,
    file_description: ::protobuf::SingularField<::std::string::String>,
    visibility: ::std::option::Option<u32>,
    tags: ::protobuf::RepeatedField<::std::string::String>,
    filename: ::protobuf::SingularField<::std::string::String>,
    preview_filename: ::protobuf::SingularField<::std::string::String>,
    image_width: ::std::option::Option<u32>,
    image_height: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Update_Request {
    fn default() -> &'a CPublishedFile_Update_Request {
        <CPublishedFile_Update_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Update_Request {
    pub fn new() -> CPublishedFile_Update_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 publishedfileid = 2;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional string title = 3;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_description = 4;


    pub fn get_file_description(&self) -> &str {
        match self.file_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_description(&mut self) {
        self.file_description.clear();
    }

    pub fn has_file_description(&self) -> bool {
        self.file_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_description(&mut self, v: ::std::string::String) {
        self.file_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_description(&mut self) -> &mut ::std::string::String {
        if self.file_description.is_none() {
            self.file_description.set_default();
        }
        self.file_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_description(&mut self) -> ::std::string::String {
        self.file_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 visibility = 5;


    pub fn get_visibility(&self) -> u32 {
        self.visibility.unwrap_or(0)
    }
    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: u32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // repeated string tags = 6;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // optional string filename = 7;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_filename = 8;


    pub fn get_preview_filename(&self) -> &str {
        match self.preview_filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_preview_filename(&mut self) {
        self.preview_filename.clear();
    }

    pub fn has_preview_filename(&self) -> bool {
        self.preview_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_filename(&mut self, v: ::std::string::String) {
        self.preview_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_filename(&mut self) -> &mut ::std::string::String {
        if self.preview_filename.is_none() {
            self.preview_filename.set_default();
        }
        self.preview_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_filename(&mut self) -> ::std::string::String {
        self.preview_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 image_width = 15;


    pub fn get_image_width(&self) -> u32 {
        self.image_width.unwrap_or(0)
    }
    pub fn clear_image_width(&mut self) {
        self.image_width = ::std::option::Option::None;
    }

    pub fn has_image_width(&self) -> bool {
        self.image_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_width(&mut self, v: u32) {
        self.image_width = ::std::option::Option::Some(v);
    }

    // optional uint32 image_height = 16;


    pub fn get_image_height(&self) -> u32 {
        self.image_height.unwrap_or(0)
    }
    pub fn clear_image_height(&mut self) {
        self.image_height = ::std::option::Option::None;
    }

    pub fn has_image_height(&self) -> bool {
        self.image_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_height(&mut self, v: u32) {
        self.image_height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_Update_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_filename)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.image_width = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.image_height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.file_description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.preview_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.image_width {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image_height {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.file_description.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.visibility {
            os.write_uint32(5, v)?;
        }
        for v in &self.tags {
            os.write_string(6, &v)?;
        };
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.preview_filename.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.image_width {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.image_height {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Update_Request {
        CPublishedFile_Update_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_Update_Request| { &m.appid },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileid",
                    |m: &CPublishedFile_Update_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &CPublishedFile_Update_Request| { &m.title },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_description",
                    |m: &CPublishedFile_Update_Request| { &m.file_description },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.file_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "visibility",
                    |m: &CPublishedFile_Update_Request| { &m.visibility },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.visibility },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    |m: &CPublishedFile_Update_Request| { &m.tags },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &CPublishedFile_Update_Request| { &m.filename },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "preview_filename",
                    |m: &CPublishedFile_Update_Request| { &m.preview_filename },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.preview_filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "image_width",
                    |m: &CPublishedFile_Update_Request| { &m.image_width },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.image_width },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "image_height",
                    |m: &CPublishedFile_Update_Request| { &m.image_height },
                    |m: &mut CPublishedFile_Update_Request| { &mut m.image_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Update_Request>(
                    "CPublishedFile_Update_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Update_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Update_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Update_Request,
        };
        unsafe {
            instance.get(CPublishedFile_Update_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Update_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileid = ::std::option::Option::None;
        self.title.clear();
        self.file_description.clear();
        self.visibility = ::std::option::Option::None;
        self.tags.clear();
        self.filename.clear();
        self.preview_filename.clear();
        self.image_width = ::std::option::Option::None;
        self.image_height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Update_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Update_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_Update_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_Update_Response {
    fn default() -> &'a CPublishedFile_Update_Response {
        <CPublishedFile_Update_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_Update_Response {
    pub fn new() -> CPublishedFile_Update_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_Update_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_Update_Response {
        CPublishedFile_Update_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_Update_Response>(
                    "CPublishedFile_Update_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_Update_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_Update_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_Update_Response,
        };
        unsafe {
            instance.get(CPublishedFile_Update_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_Update_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_Update_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_Update_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetChangeHistoryEntry_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistoryEntry_Request {
    fn default() -> &'a CPublishedFile_GetChangeHistoryEntry_Request {
        <CPublishedFile_GetChangeHistoryEntry_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistoryEntry_Request {
    pub fn new() -> CPublishedFile_GetChangeHistoryEntry_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 language = 3;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistoryEntry_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistoryEntry_Request {
        CPublishedFile_GetChangeHistoryEntry_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileid",
                    |m: &CPublishedFile_GetChangeHistoryEntry_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_GetChangeHistoryEntry_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &CPublishedFile_GetChangeHistoryEntry_Request| { &m.timestamp },
                    |m: &mut CPublishedFile_GetChangeHistoryEntry_Request| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPublishedFile_GetChangeHistoryEntry_Request| { &m.language },
                    |m: &mut CPublishedFile_GetChangeHistoryEntry_Request| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistoryEntry_Request>(
                    "CPublishedFile_GetChangeHistoryEntry_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistoryEntry_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetChangeHistoryEntry_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetChangeHistoryEntry_Request,
        };
        unsafe {
            instance.get(CPublishedFile_GetChangeHistoryEntry_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistoryEntry_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistoryEntry_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistoryEntry_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetChangeHistoryEntry_Response {
    // message fields
    change_description: ::protobuf::SingularField<::std::string::String>,
    language: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistoryEntry_Response {
    fn default() -> &'a CPublishedFile_GetChangeHistoryEntry_Response {
        <CPublishedFile_GetChangeHistoryEntry_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistoryEntry_Response {
    pub fn new() -> CPublishedFile_GetChangeHistoryEntry_Response {
        ::std::default::Default::default()
    }

    // optional string change_description = 1;


    pub fn get_change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_change_description(&mut self) {
        self.change_description.clear();
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description.set_default();
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistoryEntry_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.change_description)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.change_description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.change_description.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistoryEntry_Response {
        CPublishedFile_GetChangeHistoryEntry_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "change_description",
                    |m: &CPublishedFile_GetChangeHistoryEntry_Response| { &m.change_description },
                    |m: &mut CPublishedFile_GetChangeHistoryEntry_Response| { &mut m.change_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPublishedFile_GetChangeHistoryEntry_Response| { &m.language },
                    |m: &mut CPublishedFile_GetChangeHistoryEntry_Response| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistoryEntry_Response>(
                    "CPublishedFile_GetChangeHistoryEntry_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistoryEntry_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetChangeHistoryEntry_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetChangeHistoryEntry_Response,
        };
        unsafe {
            instance.get(CPublishedFile_GetChangeHistoryEntry_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistoryEntry_Response {
    fn clear(&mut self) {
        self.change_description.clear();
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistoryEntry_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistoryEntry_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetChangeHistory_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    total_only: ::std::option::Option<bool>,
    startindex: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistory_Request {
    fn default() -> &'a CPublishedFile_GetChangeHistory_Request {
        <CPublishedFile_GetChangeHistory_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistory_Request {
    pub fn new() -> CPublishedFile_GetChangeHistory_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional bool total_only = 2;


    pub fn get_total_only(&self) -> bool {
        self.total_only.unwrap_or(false)
    }
    pub fn clear_total_only(&mut self) {
        self.total_only = ::std::option::Option::None;
    }

    pub fn has_total_only(&self) -> bool {
        self.total_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_only(&mut self, v: bool) {
        self.total_only = ::std::option::Option::Some(v);
    }

    // optional uint32 startindex = 3;


    pub fn get_startindex(&self) -> u32 {
        self.startindex.unwrap_or(0)
    }
    pub fn clear_startindex(&mut self) {
        self.startindex = ::std::option::Option::None;
    }

    pub fn has_startindex(&self) -> bool {
        self.startindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startindex(&mut self, v: u32) {
        self.startindex = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 4;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 language = 5;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistory_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.total_only = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.startindex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.total_only {
            my_size += 2;
        }
        if let Some(v) = self.startindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.total_only {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.startindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistory_Request {
        CPublishedFile_GetChangeHistory_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileid",
                    |m: &CPublishedFile_GetChangeHistory_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "total_only",
                    |m: &CPublishedFile_GetChangeHistory_Request| { &m.total_only },
                    |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.total_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "startindex",
                    |m: &CPublishedFile_GetChangeHistory_Request| { &m.startindex },
                    |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.startindex },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "count",
                    |m: &CPublishedFile_GetChangeHistory_Request| { &m.count },
                    |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPublishedFile_GetChangeHistory_Request| { &m.language },
                    |m: &mut CPublishedFile_GetChangeHistory_Request| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistory_Request>(
                    "CPublishedFile_GetChangeHistory_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistory_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetChangeHistory_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetChangeHistory_Request,
        };
        unsafe {
            instance.get(CPublishedFile_GetChangeHistory_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistory_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.total_only = ::std::option::Option::None;
        self.startindex = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistory_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistory_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetChangeHistory_Response {
    // message fields
    changes: ::protobuf::RepeatedField<CPublishedFile_GetChangeHistory_Response_ChangeLog>,
    total: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistory_Response {
    fn default() -> &'a CPublishedFile_GetChangeHistory_Response {
        <CPublishedFile_GetChangeHistory_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistory_Response {
    pub fn new() -> CPublishedFile_GetChangeHistory_Response {
        ::std::default::Default::default()
    }

    // repeated .CPublishedFile_GetChangeHistory_Response.ChangeLog changes = 1;


    pub fn get_changes(&self) -> &[CPublishedFile_GetChangeHistory_Response_ChangeLog] {
        &self.changes
    }
    pub fn clear_changes(&mut self) {
        self.changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_changes(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_GetChangeHistory_Response_ChangeLog>) {
        self.changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_changes(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_GetChangeHistory_Response_ChangeLog> {
        &mut self.changes
    }

    // Take field
    pub fn take_changes(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_GetChangeHistory_Response_ChangeLog> {
        ::std::mem::replace(&mut self.changes, ::protobuf::RepeatedField::new())
    }

    // optional uint32 total = 2;


    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }
    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistory_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.changes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.changes)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.changes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistory_Response {
        CPublishedFile_GetChangeHistory_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_GetChangeHistory_Response_ChangeLog>>(
                    "changes",
                    |m: &CPublishedFile_GetChangeHistory_Response| { &m.changes },
                    |m: &mut CPublishedFile_GetChangeHistory_Response| { &mut m.changes },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    |m: &CPublishedFile_GetChangeHistory_Response| { &m.total },
                    |m: &mut CPublishedFile_GetChangeHistory_Response| { &mut m.total },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistory_Response>(
                    "CPublishedFile_GetChangeHistory_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistory_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetChangeHistory_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetChangeHistory_Response,
        };
        unsafe {
            instance.get(CPublishedFile_GetChangeHistory_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistory_Response {
    fn clear(&mut self) {
        self.changes.clear();
        self.total = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistory_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistory_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetChangeHistory_Response_ChangeLog {
    // message fields
    timestamp: ::std::option::Option<u32>,
    change_description: ::protobuf::SingularField<::std::string::String>,
    language: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetChangeHistory_Response_ChangeLog {
    fn default() -> &'a CPublishedFile_GetChangeHistory_Response_ChangeLog {
        <CPublishedFile_GetChangeHistory_Response_ChangeLog as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetChangeHistory_Response_ChangeLog {
    pub fn new() -> CPublishedFile_GetChangeHistory_Response_ChangeLog {
        ::std::default::Default::default()
    }

    // optional uint32 timestamp = 1;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string change_description = 2;


    pub fn get_change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_change_description(&mut self) {
        self.change_description.clear();
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description.set_default();
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 3;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetChangeHistory_Response_ChangeLog {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.change_description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.change_description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.change_description.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetChangeHistory_Response_ChangeLog {
        CPublishedFile_GetChangeHistory_Response_ChangeLog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &CPublishedFile_GetChangeHistory_Response_ChangeLog| { &m.timestamp },
                    |m: &mut CPublishedFile_GetChangeHistory_Response_ChangeLog| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "change_description",
                    |m: &CPublishedFile_GetChangeHistory_Response_ChangeLog| { &m.change_description },
                    |m: &mut CPublishedFile_GetChangeHistory_Response_ChangeLog| { &mut m.change_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPublishedFile_GetChangeHistory_Response_ChangeLog| { &m.language },
                    |m: &mut CPublishedFile_GetChangeHistory_Response_ChangeLog| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetChangeHistory_Response_ChangeLog>(
                    "CPublishedFile_GetChangeHistory_Response_ChangeLog",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetChangeHistory_Response_ChangeLog {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetChangeHistory_Response_ChangeLog> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetChangeHistory_Response_ChangeLog,
        };
        unsafe {
            instance.get(CPublishedFile_GetChangeHistory_Response_ChangeLog::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetChangeHistory_Response_ChangeLog {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.change_description.clear();
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetChangeHistory_Response_ChangeLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetChangeHistory_Response_ChangeLog {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_RefreshVotingQueue_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    matching_file_type: ::std::option::Option<u32>,
    tags: ::protobuf::RepeatedField<::std::string::String>,
    match_all_tags: ::std::option::Option<bool>,
    excluded_tags: ::protobuf::RepeatedField<::std::string::String>,
    desired_queue_size: ::std::option::Option<u32>,
    desired_revision: ::std::option::Option<EPublishedFileRevision>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RefreshVotingQueue_Request {
    fn default() -> &'a CPublishedFile_RefreshVotingQueue_Request {
        <CPublishedFile_RefreshVotingQueue_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RefreshVotingQueue_Request {
    pub fn new() -> CPublishedFile_RefreshVotingQueue_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_file_type = 2;


    pub fn get_matching_file_type(&self) -> u32 {
        self.matching_file_type.unwrap_or(0)
    }
    pub fn clear_matching_file_type(&mut self) {
        self.matching_file_type = ::std::option::Option::None;
    }

    pub fn has_matching_file_type(&self) -> bool {
        self.matching_file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_file_type(&mut self, v: u32) {
        self.matching_file_type = ::std::option::Option::Some(v);
    }

    // repeated string tags = 3;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // optional bool match_all_tags = 4;


    pub fn get_match_all_tags(&self) -> bool {
        self.match_all_tags.unwrap_or(true)
    }
    pub fn clear_match_all_tags(&mut self) {
        self.match_all_tags = ::std::option::Option::None;
    }

    pub fn has_match_all_tags(&self) -> bool {
        self.match_all_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_all_tags(&mut self, v: bool) {
        self.match_all_tags = ::std::option::Option::Some(v);
    }

    // repeated string excluded_tags = 5;


    pub fn get_excluded_tags(&self) -> &[::std::string::String] {
        &self.excluded_tags
    }
    pub fn clear_excluded_tags(&mut self) {
        self.excluded_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_excluded_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excluded_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excluded_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excluded_tags
    }

    // Take field
    pub fn take_excluded_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excluded_tags, ::protobuf::RepeatedField::new())
    }

    // optional uint32 desired_queue_size = 6;


    pub fn get_desired_queue_size(&self) -> u32 {
        self.desired_queue_size.unwrap_or(0)
    }
    pub fn clear_desired_queue_size(&mut self) {
        self.desired_queue_size = ::std::option::Option::None;
    }

    pub fn has_desired_queue_size(&self) -> bool {
        self.desired_queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_queue_size(&mut self, v: u32) {
        self.desired_queue_size = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 8;


    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        self.desired_revision.unwrap_or(EPublishedFileRevision::k_EPublishedFileRevision_Default)
    }
    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_RefreshVotingQueue_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_file_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.match_all_tags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excluded_tags)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.desired_queue_size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desired_revision, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_file_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.match_all_tags {
            my_size += 2;
        }
        for value in &self.excluded_tags {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.desired_queue_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.matching_file_type {
            os.write_uint32(2, v)?;
        }
        for v in &self.tags {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.match_all_tags {
            os.write_bool(4, v)?;
        }
        for v in &self.excluded_tags {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.desired_queue_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(8, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RefreshVotingQueue_Request {
        CPublishedFile_RefreshVotingQueue_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.appid },
                    |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "matching_file_type",
                    |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.matching_file_type },
                    |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.matching_file_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.tags },
                    |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "match_all_tags",
                    |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.match_all_tags },
                    |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.match_all_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "excluded_tags",
                    |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.excluded_tags },
                    |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.excluded_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "desired_queue_size",
                    |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.desired_queue_size },
                    |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.desired_queue_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "desired_revision",
                    |m: &CPublishedFile_RefreshVotingQueue_Request| { &m.desired_revision },
                    |m: &mut CPublishedFile_RefreshVotingQueue_Request| { &mut m.desired_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RefreshVotingQueue_Request>(
                    "CPublishedFile_RefreshVotingQueue_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_RefreshVotingQueue_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_RefreshVotingQueue_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_RefreshVotingQueue_Request,
        };
        unsafe {
            instance.get(CPublishedFile_RefreshVotingQueue_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_RefreshVotingQueue_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.matching_file_type = ::std::option::Option::None;
        self.tags.clear();
        self.match_all_tags = ::std::option::Option::None;
        self.excluded_tags.clear();
        self.desired_queue_size = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RefreshVotingQueue_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RefreshVotingQueue_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_RefreshVotingQueue_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RefreshVotingQueue_Response {
    fn default() -> &'a CPublishedFile_RefreshVotingQueue_Response {
        <CPublishedFile_RefreshVotingQueue_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RefreshVotingQueue_Response {
    pub fn new() -> CPublishedFile_RefreshVotingQueue_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_RefreshVotingQueue_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RefreshVotingQueue_Response {
        CPublishedFile_RefreshVotingQueue_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RefreshVotingQueue_Response>(
                    "CPublishedFile_RefreshVotingQueue_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_RefreshVotingQueue_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_RefreshVotingQueue_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_RefreshVotingQueue_Response,
        };
        unsafe {
            instance.get(CPublishedFile_RefreshVotingQueue_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_RefreshVotingQueue_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RefreshVotingQueue_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RefreshVotingQueue_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_QueryFiles_Request {
    // message fields
    query_type: ::std::option::Option<u32>,
    page: ::std::option::Option<u32>,
    cursor: ::protobuf::SingularField<::std::string::String>,
    numperpage: ::std::option::Option<u32>,
    creator_appid: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    requiredtags: ::protobuf::RepeatedField<::std::string::String>,
    excludedtags: ::protobuf::RepeatedField<::std::string::String>,
    match_all_tags: ::std::option::Option<bool>,
    required_flags: ::protobuf::RepeatedField<::std::string::String>,
    omitted_flags: ::protobuf::RepeatedField<::std::string::String>,
    search_text: ::protobuf::SingularField<::std::string::String>,
    filetype: ::std::option::Option<u32>,
    child_publishedfileid: ::std::option::Option<u64>,
    days: ::std::option::Option<u32>,
    include_recent_votes_only: ::std::option::Option<bool>,
    cache_max_age_seconds: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    required_kv_tags: ::protobuf::RepeatedField<CPublishedFile_QueryFiles_Request_KVTag>,
    totalonly: ::std::option::Option<bool>,
    ids_only: ::std::option::Option<bool>,
    return_vote_data: ::std::option::Option<bool>,
    return_tags: ::std::option::Option<bool>,
    return_kv_tags: ::std::option::Option<bool>,
    return_previews: ::std::option::Option<bool>,
    return_children: ::std::option::Option<bool>,
    return_short_description: ::std::option::Option<bool>,
    return_for_sale_data: ::std::option::Option<bool>,
    return_metadata: ::std::option::Option<bool>,
    return_playtime_stats: ::std::option::Option<u32>,
    return_details: ::std::option::Option<bool>,
    strip_description_bbcode: ::std::option::Option<bool>,
    desired_revision: ::std::option::Option<EPublishedFileRevision>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_QueryFiles_Request {
    fn default() -> &'a CPublishedFile_QueryFiles_Request {
        <CPublishedFile_QueryFiles_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_QueryFiles_Request {
    pub fn new() -> CPublishedFile_QueryFiles_Request {
        ::std::default::Default::default()
    }

    // optional uint32 query_type = 1;


    pub fn get_query_type(&self) -> u32 {
        self.query_type.unwrap_or(0)
    }
    pub fn clear_query_type(&mut self) {
        self.query_type = ::std::option::Option::None;
    }

    pub fn has_query_type(&self) -> bool {
        self.query_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_type(&mut self, v: u32) {
        self.query_type = ::std::option::Option::Some(v);
    }

    // optional uint32 page = 2;


    pub fn get_page(&self) -> u32 {
        self.page.unwrap_or(0)
    }
    pub fn clear_page(&mut self) {
        self.page = ::std::option::Option::None;
    }

    pub fn has_page(&self) -> bool {
        self.page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = ::std::option::Option::Some(v);
    }

    // optional string cursor = 39;


    pub fn get_cursor(&self) -> &str {
        match self.cursor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: ::std::string::String) {
        self.cursor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut ::std::string::String {
        if self.cursor.is_none() {
            self.cursor.set_default();
        }
        self.cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_cursor(&mut self) -> ::std::string::String {
        self.cursor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 numperpage = 3;


    pub fn get_numperpage(&self) -> u32 {
        self.numperpage.unwrap_or(1u32)
    }
    pub fn clear_numperpage(&mut self) {
        self.numperpage = ::std::option::Option::None;
    }

    pub fn has_numperpage(&self) -> bool {
        self.numperpage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numperpage(&mut self, v: u32) {
        self.numperpage = ::std::option::Option::Some(v);
    }

    // optional uint32 creator_appid = 4;


    pub fn get_creator_appid(&self) -> u32 {
        self.creator_appid.unwrap_or(0)
    }
    pub fn clear_creator_appid(&mut self) {
        self.creator_appid = ::std::option::Option::None;
    }

    pub fn has_creator_appid(&self) -> bool {
        self.creator_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_appid(&mut self, v: u32) {
        self.creator_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 5;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated string requiredtags = 6;


    pub fn get_requiredtags(&self) -> &[::std::string::String] {
        &self.requiredtags
    }
    pub fn clear_requiredtags(&mut self) {
        self.requiredtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredtags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.requiredtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredtags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.requiredtags
    }

    // Take field
    pub fn take_requiredtags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.requiredtags, ::protobuf::RepeatedField::new())
    }

    // repeated string excludedtags = 7;


    pub fn get_excludedtags(&self) -> &[::std::string::String] {
        &self.excludedtags
    }
    pub fn clear_excludedtags(&mut self) {
        self.excludedtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludedtags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excludedtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludedtags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excludedtags
    }

    // Take field
    pub fn take_excludedtags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excludedtags, ::protobuf::RepeatedField::new())
    }

    // optional bool match_all_tags = 8;


    pub fn get_match_all_tags(&self) -> bool {
        self.match_all_tags.unwrap_or(true)
    }
    pub fn clear_match_all_tags(&mut self) {
        self.match_all_tags = ::std::option::Option::None;
    }

    pub fn has_match_all_tags(&self) -> bool {
        self.match_all_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_all_tags(&mut self, v: bool) {
        self.match_all_tags = ::std::option::Option::Some(v);
    }

    // repeated string required_flags = 9;


    pub fn get_required_flags(&self) -> &[::std::string::String] {
        &self.required_flags
    }
    pub fn clear_required_flags(&mut self) {
        self.required_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_flags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.required_flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_flags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.required_flags
    }

    // Take field
    pub fn take_required_flags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.required_flags, ::protobuf::RepeatedField::new())
    }

    // repeated string omitted_flags = 10;


    pub fn get_omitted_flags(&self) -> &[::std::string::String] {
        &self.omitted_flags
    }
    pub fn clear_omitted_flags(&mut self) {
        self.omitted_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_omitted_flags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.omitted_flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_omitted_flags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.omitted_flags
    }

    // Take field
    pub fn take_omitted_flags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.omitted_flags, ::protobuf::RepeatedField::new())
    }

    // optional string search_text = 11;


    pub fn get_search_text(&self) -> &str {
        match self.search_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_search_text(&mut self) {
        self.search_text.clear();
    }

    pub fn has_search_text(&self) -> bool {
        self.search_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_text(&mut self, v: ::std::string::String) {
        self.search_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_text(&mut self) -> &mut ::std::string::String {
        if self.search_text.is_none() {
            self.search_text.set_default();
        }
        self.search_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_text(&mut self) -> ::std::string::String {
        self.search_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 filetype = 12;


    pub fn get_filetype(&self) -> u32 {
        self.filetype.unwrap_or(0)
    }
    pub fn clear_filetype(&mut self) {
        self.filetype = ::std::option::Option::None;
    }

    pub fn has_filetype(&self) -> bool {
        self.filetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filetype(&mut self, v: u32) {
        self.filetype = ::std::option::Option::Some(v);
    }

    // optional fixed64 child_publishedfileid = 13;


    pub fn get_child_publishedfileid(&self) -> u64 {
        self.child_publishedfileid.unwrap_or(0)
    }
    pub fn clear_child_publishedfileid(&mut self) {
        self.child_publishedfileid = ::std::option::Option::None;
    }

    pub fn has_child_publishedfileid(&self) -> bool {
        self.child_publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_publishedfileid(&mut self, v: u64) {
        self.child_publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 days = 14;


    pub fn get_days(&self) -> u32 {
        self.days.unwrap_or(0)
    }
    pub fn clear_days(&mut self) {
        self.days = ::std::option::Option::None;
    }

    pub fn has_days(&self) -> bool {
        self.days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days(&mut self, v: u32) {
        self.days = ::std::option::Option::Some(v);
    }

    // optional bool include_recent_votes_only = 15;


    pub fn get_include_recent_votes_only(&self) -> bool {
        self.include_recent_votes_only.unwrap_or(false)
    }
    pub fn clear_include_recent_votes_only(&mut self) {
        self.include_recent_votes_only = ::std::option::Option::None;
    }

    pub fn has_include_recent_votes_only(&self) -> bool {
        self.include_recent_votes_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_recent_votes_only(&mut self, v: bool) {
        self.include_recent_votes_only = ::std::option::Option::Some(v);
    }

    // optional uint32 cache_max_age_seconds = 31;


    pub fn get_cache_max_age_seconds(&self) -> u32 {
        self.cache_max_age_seconds.unwrap_or(0u32)
    }
    pub fn clear_cache_max_age_seconds(&mut self) {
        self.cache_max_age_seconds = ::std::option::Option::None;
    }

    pub fn has_cache_max_age_seconds(&self) -> bool {
        self.cache_max_age_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_max_age_seconds(&mut self, v: u32) {
        self.cache_max_age_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 language = 33;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // repeated .CPublishedFile_QueryFiles_Request.KVTag required_kv_tags = 34;


    pub fn get_required_kv_tags(&self) -> &[CPublishedFile_QueryFiles_Request_KVTag] {
        &self.required_kv_tags
    }
    pub fn clear_required_kv_tags(&mut self) {
        self.required_kv_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_kv_tags(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_QueryFiles_Request_KVTag>) {
        self.required_kv_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_kv_tags(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_QueryFiles_Request_KVTag> {
        &mut self.required_kv_tags
    }

    // Take field
    pub fn take_required_kv_tags(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_QueryFiles_Request_KVTag> {
        ::std::mem::replace(&mut self.required_kv_tags, ::protobuf::RepeatedField::new())
    }

    // optional bool totalonly = 16;


    pub fn get_totalonly(&self) -> bool {
        self.totalonly.unwrap_or(false)
    }
    pub fn clear_totalonly(&mut self) {
        self.totalonly = ::std::option::Option::None;
    }

    pub fn has_totalonly(&self) -> bool {
        self.totalonly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalonly(&mut self, v: bool) {
        self.totalonly = ::std::option::Option::Some(v);
    }

    // optional bool ids_only = 35;


    pub fn get_ids_only(&self) -> bool {
        self.ids_only.unwrap_or(false)
    }
    pub fn clear_ids_only(&mut self) {
        self.ids_only = ::std::option::Option::None;
    }

    pub fn has_ids_only(&self) -> bool {
        self.ids_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ids_only(&mut self, v: bool) {
        self.ids_only = ::std::option::Option::Some(v);
    }

    // optional bool return_vote_data = 17;


    pub fn get_return_vote_data(&self) -> bool {
        self.return_vote_data.unwrap_or(false)
    }
    pub fn clear_return_vote_data(&mut self) {
        self.return_vote_data = ::std::option::Option::None;
    }

    pub fn has_return_vote_data(&self) -> bool {
        self.return_vote_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_vote_data(&mut self, v: bool) {
        self.return_vote_data = ::std::option::Option::Some(v);
    }

    // optional bool return_tags = 18;


    pub fn get_return_tags(&self) -> bool {
        self.return_tags.unwrap_or(false)
    }
    pub fn clear_return_tags(&mut self) {
        self.return_tags = ::std::option::Option::None;
    }

    pub fn has_return_tags(&self) -> bool {
        self.return_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_tags(&mut self, v: bool) {
        self.return_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_kv_tags = 19;


    pub fn get_return_kv_tags(&self) -> bool {
        self.return_kv_tags.unwrap_or(false)
    }
    pub fn clear_return_kv_tags(&mut self) {
        self.return_kv_tags = ::std::option::Option::None;
    }

    pub fn has_return_kv_tags(&self) -> bool {
        self.return_kv_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_kv_tags(&mut self, v: bool) {
        self.return_kv_tags = ::std::option::Option::Some(v);
    }

    // optional bool return_previews = 20;


    pub fn get_return_previews(&self) -> bool {
        self.return_previews.unwrap_or(false)
    }
    pub fn clear_return_previews(&mut self) {
        self.return_previews = ::std::option::Option::None;
    }

    pub fn has_return_previews(&self) -> bool {
        self.return_previews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_previews(&mut self, v: bool) {
        self.return_previews = ::std::option::Option::Some(v);
    }

    // optional bool return_children = 21;


    pub fn get_return_children(&self) -> bool {
        self.return_children.unwrap_or(false)
    }
    pub fn clear_return_children(&mut self) {
        self.return_children = ::std::option::Option::None;
    }

    pub fn has_return_children(&self) -> bool {
        self.return_children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_children(&mut self, v: bool) {
        self.return_children = ::std::option::Option::Some(v);
    }

    // optional bool return_short_description = 22;


    pub fn get_return_short_description(&self) -> bool {
        self.return_short_description.unwrap_or(false)
    }
    pub fn clear_return_short_description(&mut self) {
        self.return_short_description = ::std::option::Option::None;
    }

    pub fn has_return_short_description(&self) -> bool {
        self.return_short_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_short_description(&mut self, v: bool) {
        self.return_short_description = ::std::option::Option::Some(v);
    }

    // optional bool return_for_sale_data = 30;


    pub fn get_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.unwrap_or(false)
    }
    pub fn clear_return_for_sale_data(&mut self) {
        self.return_for_sale_data = ::std::option::Option::None;
    }

    pub fn has_return_for_sale_data(&self) -> bool {
        self.return_for_sale_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_for_sale_data(&mut self, v: bool) {
        self.return_for_sale_data = ::std::option::Option::Some(v);
    }

    // optional bool return_metadata = 32;


    pub fn get_return_metadata(&self) -> bool {
        self.return_metadata.unwrap_or(false)
    }
    pub fn clear_return_metadata(&mut self) {
        self.return_metadata = ::std::option::Option::None;
    }

    pub fn has_return_metadata(&self) -> bool {
        self.return_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_metadata(&mut self, v: bool) {
        self.return_metadata = ::std::option::Option::Some(v);
    }

    // optional uint32 return_playtime_stats = 36;


    pub fn get_return_playtime_stats(&self) -> u32 {
        self.return_playtime_stats.unwrap_or(0)
    }
    pub fn clear_return_playtime_stats(&mut self) {
        self.return_playtime_stats = ::std::option::Option::None;
    }

    pub fn has_return_playtime_stats(&self) -> bool {
        self.return_playtime_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_playtime_stats(&mut self, v: u32) {
        self.return_playtime_stats = ::std::option::Option::Some(v);
    }

    // optional bool return_details = 37;


    pub fn get_return_details(&self) -> bool {
        self.return_details.unwrap_or(false)
    }
    pub fn clear_return_details(&mut self) {
        self.return_details = ::std::option::Option::None;
    }

    pub fn has_return_details(&self) -> bool {
        self.return_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_details(&mut self, v: bool) {
        self.return_details = ::std::option::Option::Some(v);
    }

    // optional bool strip_description_bbcode = 38;


    pub fn get_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.unwrap_or(false)
    }
    pub fn clear_strip_description_bbcode(&mut self) {
        self.strip_description_bbcode = ::std::option::Option::None;
    }

    pub fn has_strip_description_bbcode(&self) -> bool {
        self.strip_description_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strip_description_bbcode(&mut self, v: bool) {
        self.strip_description_bbcode = ::std::option::Option::Some(v);
    }

    // optional .EPublishedFileRevision desired_revision = 40;


    pub fn get_desired_revision(&self) -> EPublishedFileRevision {
        self.desired_revision.unwrap_or(EPublishedFileRevision::k_EPublishedFileRevision_Default)
    }
    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: EPublishedFileRevision) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_QueryFiles_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.required_kv_tags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.query_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = ::std::option::Option::Some(tmp);
                },
                39 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cursor)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numperpage = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.creator_appid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.requiredtags)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excludedtags)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.match_all_tags = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.required_flags)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.omitted_flags)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.search_text)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filetype = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.child_publishedfileid = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.days = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_recent_votes_only = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cache_max_age_seconds = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                34 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.required_kv_tags)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.totalonly = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ids_only = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_vote_data = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_tags = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_kv_tags = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_previews = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_children = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_short_description = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_for_sale_data = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_metadata = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.return_playtime_stats = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_details = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.strip_description_bbcode = ::std::option::Option::Some(tmp);
                },
                40 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.desired_revision, 40, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.query_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.page {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.cursor.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.numperpage {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator_appid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requiredtags {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.excludedtags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.match_all_tags {
            my_size += 2;
        }
        for value in &self.required_flags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.omitted_flags {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.search_text.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.filetype {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.days {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.include_recent_votes_only {
            my_size += 2;
        }
        if let Some(v) = self.cache_max_age_seconds {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.required_kv_tags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.totalonly {
            my_size += 3;
        }
        if let Some(v) = self.ids_only {
            my_size += 3;
        }
        if let Some(v) = self.return_vote_data {
            my_size += 3;
        }
        if let Some(v) = self.return_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_kv_tags {
            my_size += 3;
        }
        if let Some(v) = self.return_previews {
            my_size += 3;
        }
        if let Some(v) = self.return_children {
            my_size += 3;
        }
        if let Some(v) = self.return_short_description {
            my_size += 3;
        }
        if let Some(v) = self.return_for_sale_data {
            my_size += 3;
        }
        if let Some(v) = self.return_metadata {
            my_size += 3;
        }
        if let Some(v) = self.return_playtime_stats {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.return_details {
            my_size += 3;
        }
        if let Some(v) = self.strip_description_bbcode {
            my_size += 3;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::enum_size(40, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.query_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.page {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.cursor.as_ref() {
            os.write_string(39, &v)?;
        }
        if let Some(v) = self.numperpage {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.creator_appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        for v in &self.requiredtags {
            os.write_string(6, &v)?;
        };
        for v in &self.excludedtags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.match_all_tags {
            os.write_bool(8, v)?;
        }
        for v in &self.required_flags {
            os.write_string(9, &v)?;
        };
        for v in &self.omitted_flags {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.search_text.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.filetype {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.child_publishedfileid {
            os.write_fixed64(13, v)?;
        }
        if let Some(v) = self.days {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.include_recent_votes_only {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.cache_max_age_seconds {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(33, v)?;
        }
        for v in &self.required_kv_tags {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.totalonly {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.ids_only {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.return_vote_data {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.return_tags {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.return_kv_tags {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.return_previews {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.return_children {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.return_short_description {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.return_for_sale_data {
            os.write_bool(30, v)?;
        }
        if let Some(v) = self.return_metadata {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.return_playtime_stats {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.return_details {
            os.write_bool(37, v)?;
        }
        if let Some(v) = self.strip_description_bbcode {
            os.write_bool(38, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_enum(40, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_QueryFiles_Request {
        CPublishedFile_QueryFiles_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "query_type",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.query_type },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.query_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "page",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.page },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.page },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cursor",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.cursor },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.cursor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numperpage",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.numperpage },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.numperpage },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "creator_appid",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.creator_appid },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.creator_appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.appid },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "requiredtags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.requiredtags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.requiredtags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "excludedtags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.excludedtags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.excludedtags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "match_all_tags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.match_all_tags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.match_all_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "required_flags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.required_flags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.required_flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "omitted_flags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.omitted_flags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.omitted_flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "search_text",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.search_text },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.search_text },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "filetype",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.filetype },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.filetype },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "child_publishedfileid",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.child_publishedfileid },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.child_publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "days",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.days },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.days },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_recent_votes_only",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.include_recent_votes_only },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.include_recent_votes_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cache_max_age_seconds",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.cache_max_age_seconds },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.cache_max_age_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "language",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.language },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_QueryFiles_Request_KVTag>>(
                    "required_kv_tags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.required_kv_tags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.required_kv_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "totalonly",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.totalonly },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.totalonly },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ids_only",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.ids_only },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.ids_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_vote_data",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_vote_data },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_vote_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_tags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_tags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_kv_tags",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_kv_tags },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_kv_tags },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_previews",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_previews },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_previews },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_children",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_children },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_children },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_short_description",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_short_description },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_short_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_for_sale_data",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_for_sale_data },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_for_sale_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_metadata",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_metadata },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "return_playtime_stats",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_playtime_stats },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_playtime_stats },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_details",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.return_details },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.return_details },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "strip_description_bbcode",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.strip_description_bbcode },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.strip_description_bbcode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "desired_revision",
                    |m: &CPublishedFile_QueryFiles_Request| { &m.desired_revision },
                    |m: &mut CPublishedFile_QueryFiles_Request| { &mut m.desired_revision },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_QueryFiles_Request>(
                    "CPublishedFile_QueryFiles_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_QueryFiles_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_QueryFiles_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_QueryFiles_Request,
        };
        unsafe {
            instance.get(CPublishedFile_QueryFiles_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_QueryFiles_Request {
    fn clear(&mut self) {
        self.query_type = ::std::option::Option::None;
        self.page = ::std::option::Option::None;
        self.cursor.clear();
        self.numperpage = ::std::option::Option::None;
        self.creator_appid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.requiredtags.clear();
        self.excludedtags.clear();
        self.match_all_tags = ::std::option::Option::None;
        self.required_flags.clear();
        self.omitted_flags.clear();
        self.search_text.clear();
        self.filetype = ::std::option::Option::None;
        self.child_publishedfileid = ::std::option::Option::None;
        self.days = ::std::option::Option::None;
        self.include_recent_votes_only = ::std::option::Option::None;
        self.cache_max_age_seconds = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.required_kv_tags.clear();
        self.totalonly = ::std::option::Option::None;
        self.ids_only = ::std::option::Option::None;
        self.return_vote_data = ::std::option::Option::None;
        self.return_tags = ::std::option::Option::None;
        self.return_kv_tags = ::std::option::Option::None;
        self.return_previews = ::std::option::Option::None;
        self.return_children = ::std::option::Option::None;
        self.return_short_description = ::std::option::Option::None;
        self.return_for_sale_data = ::std::option::Option::None;
        self.return_metadata = ::std::option::Option::None;
        self.return_playtime_stats = ::std::option::Option::None;
        self.return_details = ::std::option::Option::None;
        self.strip_description_bbcode = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_QueryFiles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_QueryFiles_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_QueryFiles_Request_KVTag {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_QueryFiles_Request_KVTag {
    fn default() -> &'a CPublishedFile_QueryFiles_Request_KVTag {
        <CPublishedFile_QueryFiles_Request_KVTag as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_QueryFiles_Request_KVTag {
    pub fn new() -> CPublishedFile_QueryFiles_Request_KVTag {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_QueryFiles_Request_KVTag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_QueryFiles_Request_KVTag {
        CPublishedFile_QueryFiles_Request_KVTag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &CPublishedFile_QueryFiles_Request_KVTag| { &m.key },
                    |m: &mut CPublishedFile_QueryFiles_Request_KVTag| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &CPublishedFile_QueryFiles_Request_KVTag| { &m.value },
                    |m: &mut CPublishedFile_QueryFiles_Request_KVTag| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_QueryFiles_Request_KVTag>(
                    "CPublishedFile_QueryFiles_Request_KVTag",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_QueryFiles_Request_KVTag {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_QueryFiles_Request_KVTag> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_QueryFiles_Request_KVTag,
        };
        unsafe {
            instance.get(CPublishedFile_QueryFiles_Request_KVTag::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_QueryFiles_Request_KVTag {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_QueryFiles_Request_KVTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_QueryFiles_Request_KVTag {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_QueryFiles_Response {
    // message fields
    total: ::std::option::Option<u32>,
    publishedfiledetails: ::protobuf::RepeatedField<PublishedFileDetails>,
    next_cursor: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_QueryFiles_Response {
    fn default() -> &'a CPublishedFile_QueryFiles_Response {
        <CPublishedFile_QueryFiles_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_QueryFiles_Response {
    pub fn new() -> CPublishedFile_QueryFiles_Response {
        ::std::default::Default::default()
    }

    // optional uint32 total = 1;


    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }
    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    // repeated .PublishedFileDetails publishedfiledetails = 2;


    pub fn get_publishedfiledetails(&self) -> &[PublishedFileDetails] {
        &self.publishedfiledetails
    }
    pub fn clear_publishedfiledetails(&mut self) {
        self.publishedfiledetails.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfiledetails(&mut self, v: ::protobuf::RepeatedField<PublishedFileDetails>) {
        self.publishedfiledetails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfiledetails(&mut self) -> &mut ::protobuf::RepeatedField<PublishedFileDetails> {
        &mut self.publishedfiledetails
    }

    // Take field
    pub fn take_publishedfiledetails(&mut self) -> ::protobuf::RepeatedField<PublishedFileDetails> {
        ::std::mem::replace(&mut self.publishedfiledetails, ::protobuf::RepeatedField::new())
    }

    // optional string next_cursor = 3;


    pub fn get_next_cursor(&self) -> &str {
        match self.next_cursor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_next_cursor(&mut self) {
        self.next_cursor.clear();
    }

    pub fn has_next_cursor(&self) -> bool {
        self.next_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_cursor(&mut self, v: ::std::string::String) {
        self.next_cursor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_cursor(&mut self) -> &mut ::std::string::String {
        if self.next_cursor.is_none() {
            self.next_cursor.set_default();
        }
        self.next_cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_cursor(&mut self) -> ::std::string::String {
        self.next_cursor.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPublishedFile_QueryFiles_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.publishedfiledetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.publishedfiledetails)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.next_cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfiledetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.next_cursor.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.total {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfiledetails {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.next_cursor.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_QueryFiles_Response {
        CPublishedFile_QueryFiles_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total",
                    |m: &CPublishedFile_QueryFiles_Response| { &m.total },
                    |m: &mut CPublishedFile_QueryFiles_Response| { &mut m.total },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublishedFileDetails>>(
                    "publishedfiledetails",
                    |m: &CPublishedFile_QueryFiles_Response| { &m.publishedfiledetails },
                    |m: &mut CPublishedFile_QueryFiles_Response| { &mut m.publishedfiledetails },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_cursor",
                    |m: &CPublishedFile_QueryFiles_Response| { &m.next_cursor },
                    |m: &mut CPublishedFile_QueryFiles_Response| { &mut m.next_cursor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_QueryFiles_Response>(
                    "CPublishedFile_QueryFiles_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_QueryFiles_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_QueryFiles_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_QueryFiles_Response,
        };
        unsafe {
            instance.get(CPublishedFile_QueryFiles_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_QueryFiles_Response {
    fn clear(&mut self) {
        self.total = ::std::option::Option::None;
        self.publishedfiledetails.clear();
        self.next_cursor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_QueryFiles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_QueryFiles_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_AddAppRelationship_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddAppRelationship_Request {
    fn default() -> &'a CPublishedFile_AddAppRelationship_Request {
        <CPublishedFile_AddAppRelationship_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddAppRelationship_Request {
    pub fn new() -> CPublishedFile_AddAppRelationship_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 relationship = 3;


    pub fn get_relationship(&self) -> u32 {
        self.relationship.unwrap_or(0)
    }
    pub fn clear_relationship(&mut self) {
        self.relationship = ::std::option::Option::None;
    }

    pub fn has_relationship(&self) -> bool {
        self.relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relationship(&mut self, v: u32) {
        self.relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_AddAppRelationship_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relationship {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.relationship {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddAppRelationship_Request {
        CPublishedFile_AddAppRelationship_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_AddAppRelationship_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_AddAppRelationship_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_AddAppRelationship_Request| { &m.appid },
                    |m: &mut CPublishedFile_AddAppRelationship_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "relationship",
                    |m: &CPublishedFile_AddAppRelationship_Request| { &m.relationship },
                    |m: &mut CPublishedFile_AddAppRelationship_Request| { &mut m.relationship },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddAppRelationship_Request>(
                    "CPublishedFile_AddAppRelationship_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_AddAppRelationship_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_AddAppRelationship_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_AddAppRelationship_Request,
        };
        unsafe {
            instance.get(CPublishedFile_AddAppRelationship_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_AddAppRelationship_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddAppRelationship_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddAppRelationship_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_AddAppRelationship_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddAppRelationship_Response {
    fn default() -> &'a CPublishedFile_AddAppRelationship_Response {
        <CPublishedFile_AddAppRelationship_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddAppRelationship_Response {
    pub fn new() -> CPublishedFile_AddAppRelationship_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_AddAppRelationship_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddAppRelationship_Response {
        CPublishedFile_AddAppRelationship_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddAppRelationship_Response>(
                    "CPublishedFile_AddAppRelationship_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_AddAppRelationship_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_AddAppRelationship_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_AddAppRelationship_Response,
        };
        unsafe {
            instance.get(CPublishedFile_AddAppRelationship_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_AddAppRelationship_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddAppRelationship_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddAppRelationship_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_RemoveAppRelationship_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveAppRelationship_Request {
    fn default() -> &'a CPublishedFile_RemoveAppRelationship_Request {
        <CPublishedFile_RemoveAppRelationship_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveAppRelationship_Request {
    pub fn new() -> CPublishedFile_RemoveAppRelationship_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 relationship = 3;


    pub fn get_relationship(&self) -> u32 {
        self.relationship.unwrap_or(0)
    }
    pub fn clear_relationship(&mut self) {
        self.relationship = ::std::option::Option::None;
    }

    pub fn has_relationship(&self) -> bool {
        self.relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relationship(&mut self, v: u32) {
        self.relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveAppRelationship_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relationship {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.relationship {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveAppRelationship_Request {
        CPublishedFile_RemoveAppRelationship_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_RemoveAppRelationship_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_RemoveAppRelationship_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_RemoveAppRelationship_Request| { &m.appid },
                    |m: &mut CPublishedFile_RemoveAppRelationship_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "relationship",
                    |m: &CPublishedFile_RemoveAppRelationship_Request| { &m.relationship },
                    |m: &mut CPublishedFile_RemoveAppRelationship_Request| { &mut m.relationship },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveAppRelationship_Request>(
                    "CPublishedFile_RemoveAppRelationship_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_RemoveAppRelationship_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_RemoveAppRelationship_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_RemoveAppRelationship_Request,
        };
        unsafe {
            instance.get(CPublishedFile_RemoveAppRelationship_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveAppRelationship_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveAppRelationship_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveAppRelationship_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_RemoveAppRelationship_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveAppRelationship_Response {
    fn default() -> &'a CPublishedFile_RemoveAppRelationship_Response {
        <CPublishedFile_RemoveAppRelationship_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveAppRelationship_Response {
    pub fn new() -> CPublishedFile_RemoveAppRelationship_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveAppRelationship_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveAppRelationship_Response {
        CPublishedFile_RemoveAppRelationship_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveAppRelationship_Response>(
                    "CPublishedFile_RemoveAppRelationship_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_RemoveAppRelationship_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_RemoveAppRelationship_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_RemoveAppRelationship_Response,
        };
        unsafe {
            instance.get(CPublishedFile_RemoveAppRelationship_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveAppRelationship_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveAppRelationship_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveAppRelationship_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetAppRelationships_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetAppRelationships_Request {
    fn default() -> &'a CPublishedFile_GetAppRelationships_Request {
        <CPublishedFile_GetAppRelationships_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetAppRelationships_Request {
    pub fn new() -> CPublishedFile_GetAppRelationships_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetAppRelationships_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetAppRelationships_Request {
        CPublishedFile_GetAppRelationships_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_GetAppRelationships_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_GetAppRelationships_Request| { &mut m.publishedfileid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetAppRelationships_Request>(
                    "CPublishedFile_GetAppRelationships_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetAppRelationships_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetAppRelationships_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetAppRelationships_Request,
        };
        unsafe {
            instance.get(CPublishedFile_GetAppRelationships_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetAppRelationships_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetAppRelationships_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetAppRelationships_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetAppRelationships_Response {
    // message fields
    app_relationships: ::protobuf::RepeatedField<CPublishedFile_GetAppRelationships_Response_AppRelationship>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetAppRelationships_Response {
    fn default() -> &'a CPublishedFile_GetAppRelationships_Response {
        <CPublishedFile_GetAppRelationships_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetAppRelationships_Response {
    pub fn new() -> CPublishedFile_GetAppRelationships_Response {
        ::std::default::Default::default()
    }

    // repeated .CPublishedFile_GetAppRelationships_Response.AppRelationship app_relationships = 3;


    pub fn get_app_relationships(&self) -> &[CPublishedFile_GetAppRelationships_Response_AppRelationship] {
        &self.app_relationships
    }
    pub fn clear_app_relationships(&mut self) {
        self.app_relationships.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_relationships(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_GetAppRelationships_Response_AppRelationship>) {
        self.app_relationships = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_relationships(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_GetAppRelationships_Response_AppRelationship> {
        &mut self.app_relationships
    }

    // Take field
    pub fn take_app_relationships(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_GetAppRelationships_Response_AppRelationship> {
        ::std::mem::replace(&mut self.app_relationships, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetAppRelationships_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.app_relationships {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_relationships)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.app_relationships {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.app_relationships {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetAppRelationships_Response {
        CPublishedFile_GetAppRelationships_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_GetAppRelationships_Response_AppRelationship>>(
                    "app_relationships",
                    |m: &CPublishedFile_GetAppRelationships_Response| { &m.app_relationships },
                    |m: &mut CPublishedFile_GetAppRelationships_Response| { &mut m.app_relationships },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetAppRelationships_Response>(
                    "CPublishedFile_GetAppRelationships_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetAppRelationships_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetAppRelationships_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetAppRelationships_Response,
        };
        unsafe {
            instance.get(CPublishedFile_GetAppRelationships_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetAppRelationships_Response {
    fn clear(&mut self) {
        self.app_relationships.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetAppRelationships_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetAppRelationships_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetAppRelationships_Response_AppRelationship {
    // message fields
    appid: ::std::option::Option<u32>,
    relationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetAppRelationships_Response_AppRelationship {
    fn default() -> &'a CPublishedFile_GetAppRelationships_Response_AppRelationship {
        <CPublishedFile_GetAppRelationships_Response_AppRelationship as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetAppRelationships_Response_AppRelationship {
    pub fn new() -> CPublishedFile_GetAppRelationships_Response_AppRelationship {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 relationship = 2;


    pub fn get_relationship(&self) -> u32 {
        self.relationship.unwrap_or(0)
    }
    pub fn clear_relationship(&mut self) {
        self.relationship = ::std::option::Option::None;
    }

    pub fn has_relationship(&self) -> bool {
        self.relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relationship(&mut self, v: u32) {
        self.relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetAppRelationships_Response_AppRelationship {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relationship {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.relationship {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetAppRelationships_Response_AppRelationship {
        CPublishedFile_GetAppRelationships_Response_AppRelationship::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_GetAppRelationships_Response_AppRelationship| { &m.appid },
                    |m: &mut CPublishedFile_GetAppRelationships_Response_AppRelationship| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "relationship",
                    |m: &CPublishedFile_GetAppRelationships_Response_AppRelationship| { &m.relationship },
                    |m: &mut CPublishedFile_GetAppRelationships_Response_AppRelationship| { &mut m.relationship },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetAppRelationships_Response_AppRelationship>(
                    "CPublishedFile_GetAppRelationships_Response_AppRelationship",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetAppRelationships_Response_AppRelationship {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetAppRelationships_Response_AppRelationship> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetAppRelationships_Response_AppRelationship,
        };
        unsafe {
            instance.get(CPublishedFile_GetAppRelationships_Response_AppRelationship::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetAppRelationships_Response_AppRelationship {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetAppRelationships_Response_AppRelationship {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetAppRelationships_Response_AppRelationship {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_StartPlaytimeTracking_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    publishedfileids: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StartPlaytimeTracking_Request {
    fn default() -> &'a CPublishedFile_StartPlaytimeTracking_Request {
        <CPublishedFile_StartPlaytimeTracking_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StartPlaytimeTracking_Request {
    pub fn new() -> CPublishedFile_StartPlaytimeTracking_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated uint64 publishedfileids = 2;


    pub fn get_publishedfileids(&self) -> &[u64] {
        &self.publishedfileids
    }
    pub fn clear_publishedfileids(&mut self) {
        self.publishedfileids.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfileids(&mut self, v: ::std::vec::Vec<u64>) {
        self.publishedfileids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfileids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.publishedfileids
    }

    // Take field
    pub fn take_publishedfileids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.publishedfileids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPublishedFile_StartPlaytimeTracking_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfileids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfileids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StartPlaytimeTracking_Request {
        CPublishedFile_StartPlaytimeTracking_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_StartPlaytimeTracking_Request| { &m.appid },
                    |m: &mut CPublishedFile_StartPlaytimeTracking_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileids",
                    |m: &CPublishedFile_StartPlaytimeTracking_Request| { &m.publishedfileids },
                    |m: &mut CPublishedFile_StartPlaytimeTracking_Request| { &mut m.publishedfileids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StartPlaytimeTracking_Request>(
                    "CPublishedFile_StartPlaytimeTracking_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_StartPlaytimeTracking_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_StartPlaytimeTracking_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_StartPlaytimeTracking_Request,
        };
        unsafe {
            instance.get(CPublishedFile_StartPlaytimeTracking_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_StartPlaytimeTracking_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StartPlaytimeTracking_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StartPlaytimeTracking_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_StartPlaytimeTracking_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StartPlaytimeTracking_Response {
    fn default() -> &'a CPublishedFile_StartPlaytimeTracking_Response {
        <CPublishedFile_StartPlaytimeTracking_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StartPlaytimeTracking_Response {
    pub fn new() -> CPublishedFile_StartPlaytimeTracking_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_StartPlaytimeTracking_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StartPlaytimeTracking_Response {
        CPublishedFile_StartPlaytimeTracking_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StartPlaytimeTracking_Response>(
                    "CPublishedFile_StartPlaytimeTracking_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_StartPlaytimeTracking_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_StartPlaytimeTracking_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_StartPlaytimeTracking_Response,
        };
        unsafe {
            instance.get(CPublishedFile_StartPlaytimeTracking_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_StartPlaytimeTracking_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StartPlaytimeTracking_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StartPlaytimeTracking_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_StopPlaytimeTracking_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    publishedfileids: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTracking_Request {
    fn default() -> &'a CPublishedFile_StopPlaytimeTracking_Request {
        <CPublishedFile_StopPlaytimeTracking_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTracking_Request {
    pub fn new() -> CPublishedFile_StopPlaytimeTracking_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated uint64 publishedfileids = 2;


    pub fn get_publishedfileids(&self) -> &[u64] {
        &self.publishedfileids
    }
    pub fn clear_publishedfileids(&mut self) {
        self.publishedfileids.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfileids(&mut self, v: ::std::vec::Vec<u64>) {
        self.publishedfileids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfileids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.publishedfileids
    }

    // Take field
    pub fn take_publishedfileids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.publishedfileids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTracking_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.publishedfileids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.publishedfileids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTracking_Request {
        CPublishedFile_StopPlaytimeTracking_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_StopPlaytimeTracking_Request| { &m.appid },
                    |m: &mut CPublishedFile_StopPlaytimeTracking_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileids",
                    |m: &CPublishedFile_StopPlaytimeTracking_Request| { &m.publishedfileids },
                    |m: &mut CPublishedFile_StopPlaytimeTracking_Request| { &mut m.publishedfileids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTracking_Request>(
                    "CPublishedFile_StopPlaytimeTracking_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTracking_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_StopPlaytimeTracking_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_StopPlaytimeTracking_Request,
        };
        unsafe {
            instance.get(CPublishedFile_StopPlaytimeTracking_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTracking_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.publishedfileids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTracking_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTracking_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_StopPlaytimeTracking_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTracking_Response {
    fn default() -> &'a CPublishedFile_StopPlaytimeTracking_Response {
        <CPublishedFile_StopPlaytimeTracking_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTracking_Response {
    pub fn new() -> CPublishedFile_StopPlaytimeTracking_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTracking_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTracking_Response {
        CPublishedFile_StopPlaytimeTracking_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTracking_Response>(
                    "CPublishedFile_StopPlaytimeTracking_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTracking_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_StopPlaytimeTracking_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_StopPlaytimeTracking_Response,
        };
        unsafe {
            instance.get(CPublishedFile_StopPlaytimeTracking_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTracking_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTracking_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTracking_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn default() -> &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        <CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    pub fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request| { &m.appid },
                    |m: &mut CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request| { &mut m.appid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request>(
                    "CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request,
        };
        unsafe {
            instance.get(CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn default() -> &'a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        <CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    pub fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response>(
                    "CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response,
        };
        unsafe {
            instance.get(CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    controller_config_usage: ::protobuf::RepeatedField<CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn default() -> &'a CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        <CPublishedFile_SetPlaytimeForControllerConfigs_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    pub fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated .CPublishedFile_SetPlaytimeForControllerConfigs_Request.ControllerConfigUsage controller_config_usage = 2;


    pub fn get_controller_config_usage(&self) -> &[CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage] {
        &self.controller_config_usage
    }
    pub fn clear_controller_config_usage(&mut self) {
        self.controller_config_usage.clear();
    }

    // Param is passed by value, moved
    pub fn set_controller_config_usage(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage>) {
        self.controller_config_usage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_controller_config_usage(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage> {
        &mut self.controller_config_usage
    }

    // Take field
    pub fn take_controller_config_usage(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage> {
        ::std::mem::replace(&mut self.controller_config_usage, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.controller_config_usage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.controller_config_usage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.controller_config_usage {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.controller_config_usage {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        CPublishedFile_SetPlaytimeForControllerConfigs_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "appid",
                    |m: &CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &m.appid },
                    |m: &mut CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &mut m.appid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage>>(
                    "controller_config_usage",
                    |m: &CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &m.controller_config_usage },
                    |m: &mut CPublishedFile_SetPlaytimeForControllerConfigs_Request| { &mut m.controller_config_usage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_SetPlaytimeForControllerConfigs_Request>(
                    "CPublishedFile_SetPlaytimeForControllerConfigs_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_SetPlaytimeForControllerConfigs_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_SetPlaytimeForControllerConfigs_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_SetPlaytimeForControllerConfigs_Request,
        };
        unsafe {
            instance.get(CPublishedFile_SetPlaytimeForControllerConfigs_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.controller_config_usage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_SetPlaytimeForControllerConfigs_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    seconds_active: ::std::option::Option<f32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
    fn default() -> &'a CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
        <CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
    pub fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional float seconds_active = 2;


    pub fn get_seconds_active(&self) -> f32 {
        self.seconds_active.unwrap_or(0.)
    }
    pub fn clear_seconds_active(&mut self) {
        self.seconds_active = ::std::option::Option::None;
    }

    pub fn has_seconds_active(&self) -> bool {
        self.seconds_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_active(&mut self, v: f32) {
        self.seconds_active = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.seconds_active = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_active {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.seconds_active {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
        CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage| { &m.publishedfileid },
                    |m: &mut CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "seconds_active",
                    |m: &CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage| { &m.seconds_active },
                    |m: &mut CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage| { &mut m.seconds_active },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage>(
                    "CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage,
        };
        unsafe {
            instance.get(CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.seconds_active = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn default() -> &'a CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        <CPublishedFile_SetPlaytimeForControllerConfigs_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    pub fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        CPublishedFile_SetPlaytimeForControllerConfigs_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_SetPlaytimeForControllerConfigs_Response>(
                    "CPublishedFile_SetPlaytimeForControllerConfigs_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_SetPlaytimeForControllerConfigs_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_SetPlaytimeForControllerConfigs_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_SetPlaytimeForControllerConfigs_Response,
        };
        unsafe {
            instance.get(CPublishedFile_SetPlaytimeForControllerConfigs_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_SetPlaytimeForControllerConfigs_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_AddChild_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    child_publishedfileid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddChild_Request {
    fn default() -> &'a CPublishedFile_AddChild_Request {
        <CPublishedFile_AddChild_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddChild_Request {
    pub fn new() -> CPublishedFile_AddChild_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint64 child_publishedfileid = 2;


    pub fn get_child_publishedfileid(&self) -> u64 {
        self.child_publishedfileid.unwrap_or(0)
    }
    pub fn clear_child_publishedfileid(&mut self) {
        self.child_publishedfileid = ::std::option::Option::None;
    }

    pub fn has_child_publishedfileid(&self) -> bool {
        self.child_publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_publishedfileid(&mut self, v: u64) {
        self.child_publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_AddChild_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.child_publishedfileid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_publishedfileid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.child_publishedfileid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddChild_Request {
        CPublishedFile_AddChild_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_AddChild_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_AddChild_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "child_publishedfileid",
                    |m: &CPublishedFile_AddChild_Request| { &m.child_publishedfileid },
                    |m: &mut CPublishedFile_AddChild_Request| { &mut m.child_publishedfileid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddChild_Request>(
                    "CPublishedFile_AddChild_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_AddChild_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_AddChild_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_AddChild_Request,
        };
        unsafe {
            instance.get(CPublishedFile_AddChild_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_AddChild_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.child_publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddChild_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddChild_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_AddChild_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_AddChild_Response {
    fn default() -> &'a CPublishedFile_AddChild_Response {
        <CPublishedFile_AddChild_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_AddChild_Response {
    pub fn new() -> CPublishedFile_AddChild_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_AddChild_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_AddChild_Response {
        CPublishedFile_AddChild_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_AddChild_Response>(
                    "CPublishedFile_AddChild_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_AddChild_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_AddChild_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_AddChild_Response,
        };
        unsafe {
            instance.get(CPublishedFile_AddChild_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_AddChild_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_AddChild_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_AddChild_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_RemoveChild_Request {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    child_publishedfileid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveChild_Request {
    fn default() -> &'a CPublishedFile_RemoveChild_Request {
        <CPublishedFile_RemoveChild_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveChild_Request {
    pub fn new() -> CPublishedFile_RemoveChild_Request {
        ::std::default::Default::default()
    }

    // optional uint64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional uint64 child_publishedfileid = 2;


    pub fn get_child_publishedfileid(&self) -> u64 {
        self.child_publishedfileid.unwrap_or(0)
    }
    pub fn clear_child_publishedfileid(&mut self) {
        self.child_publishedfileid = ::std::option::Option::None;
    }

    pub fn has_child_publishedfileid(&self) -> bool {
        self.child_publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_publishedfileid(&mut self, v: u64) {
        self.child_publishedfileid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveChild_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.child_publishedfileid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_publishedfileid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.child_publishedfileid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveChild_Request {
        CPublishedFile_RemoveChild_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publishedfileid",
                    |m: &CPublishedFile_RemoveChild_Request| { &m.publishedfileid },
                    |m: &mut CPublishedFile_RemoveChild_Request| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "child_publishedfileid",
                    |m: &CPublishedFile_RemoveChild_Request| { &m.child_publishedfileid },
                    |m: &mut CPublishedFile_RemoveChild_Request| { &mut m.child_publishedfileid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveChild_Request>(
                    "CPublishedFile_RemoveChild_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_RemoveChild_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_RemoveChild_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_RemoveChild_Request,
        };
        unsafe {
            instance.get(CPublishedFile_RemoveChild_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveChild_Request {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.child_publishedfileid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveChild_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveChild_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_RemoveChild_Response {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_RemoveChild_Response {
    fn default() -> &'a CPublishedFile_RemoveChild_Response {
        <CPublishedFile_RemoveChild_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_RemoveChild_Response {
    pub fn new() -> CPublishedFile_RemoveChild_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPublishedFile_RemoveChild_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_RemoveChild_Response {
        CPublishedFile_RemoveChild_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_RemoveChild_Response>(
                    "CPublishedFile_RemoveChild_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_RemoveChild_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_RemoveChild_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_RemoveChild_Response,
        };
        unsafe {
            instance.get(CPublishedFile_RemoveChild_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_RemoveChild_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_RemoveChild_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_RemoveChild_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetUserVoteSummary_Request {
    // message fields
    publishedfileids: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserVoteSummary_Request {
    fn default() -> &'a CPublishedFile_GetUserVoteSummary_Request {
        <CPublishedFile_GetUserVoteSummary_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserVoteSummary_Request {
    pub fn new() -> CPublishedFile_GetUserVoteSummary_Request {
        ::std::default::Default::default()
    }

    // repeated fixed64 publishedfileids = 1;


    pub fn get_publishedfileids(&self) -> &[u64] {
        &self.publishedfileids
    }
    pub fn clear_publishedfileids(&mut self) {
        self.publishedfileids.clear();
    }

    // Param is passed by value, moved
    pub fn set_publishedfileids(&mut self, v: ::std::vec::Vec<u64>) {
        self.publishedfileids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_publishedfileids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.publishedfileids
    }

    // Take field
    pub fn take_publishedfileids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.publishedfileids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserVoteSummary_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.publishedfileids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.publishedfileids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.publishedfileids {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserVoteSummary_Request {
        CPublishedFile_GetUserVoteSummary_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileids",
                    |m: &CPublishedFile_GetUserVoteSummary_Request| { &m.publishedfileids },
                    |m: &mut CPublishedFile_GetUserVoteSummary_Request| { &mut m.publishedfileids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserVoteSummary_Request>(
                    "CPublishedFile_GetUserVoteSummary_Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetUserVoteSummary_Request {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetUserVoteSummary_Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetUserVoteSummary_Request,
        };
        unsafe {
            instance.get(CPublishedFile_GetUserVoteSummary_Request::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserVoteSummary_Request {
    fn clear(&mut self) {
        self.publishedfileids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserVoteSummary_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserVoteSummary_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetUserVoteSummary_Response {
    // message fields
    summaries: ::protobuf::RepeatedField<CPublishedFile_GetUserVoteSummary_Response_VoteSummary>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserVoteSummary_Response {
    fn default() -> &'a CPublishedFile_GetUserVoteSummary_Response {
        <CPublishedFile_GetUserVoteSummary_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserVoteSummary_Response {
    pub fn new() -> CPublishedFile_GetUserVoteSummary_Response {
        ::std::default::Default::default()
    }

    // repeated .CPublishedFile_GetUserVoteSummary_Response.VoteSummary summaries = 1;


    pub fn get_summaries(&self) -> &[CPublishedFile_GetUserVoteSummary_Response_VoteSummary] {
        &self.summaries
    }
    pub fn clear_summaries(&mut self) {
        self.summaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_summaries(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_GetUserVoteSummary_Response_VoteSummary>) {
        self.summaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_summaries(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_GetUserVoteSummary_Response_VoteSummary> {
        &mut self.summaries
    }

    // Take field
    pub fn take_summaries(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_GetUserVoteSummary_Response_VoteSummary> {
        ::std::mem::replace(&mut self.summaries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserVoteSummary_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.summaries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.summaries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.summaries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserVoteSummary_Response {
        CPublishedFile_GetUserVoteSummary_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_GetUserVoteSummary_Response_VoteSummary>>(
                    "summaries",
                    |m: &CPublishedFile_GetUserVoteSummary_Response| { &m.summaries },
                    |m: &mut CPublishedFile_GetUserVoteSummary_Response| { &mut m.summaries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserVoteSummary_Response>(
                    "CPublishedFile_GetUserVoteSummary_Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetUserVoteSummary_Response {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetUserVoteSummary_Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetUserVoteSummary_Response,
        };
        unsafe {
            instance.get(CPublishedFile_GetUserVoteSummary_Response::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserVoteSummary_Response {
    fn clear(&mut self) {
        self.summaries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserVoteSummary_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserVoteSummary_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
    // message fields
    publishedfileid: ::std::option::Option<u64>,
    vote_for: ::std::option::Option<bool>,
    vote_against: ::std::option::Option<bool>,
    reported: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
    fn default() -> &'a CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
        <CPublishedFile_GetUserVoteSummary_Response_VoteSummary as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
    pub fn new() -> CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
        ::std::default::Default::default()
    }

    // optional fixed64 publishedfileid = 1;


    pub fn get_publishedfileid(&self) -> u64 {
        self.publishedfileid.unwrap_or(0)
    }
    pub fn clear_publishedfileid(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
    }

    pub fn has_publishedfileid(&self) -> bool {
        self.publishedfileid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishedfileid(&mut self, v: u64) {
        self.publishedfileid = ::std::option::Option::Some(v);
    }

    // optional bool vote_for = 2;


    pub fn get_vote_for(&self) -> bool {
        self.vote_for.unwrap_or(false)
    }
    pub fn clear_vote_for(&mut self) {
        self.vote_for = ::std::option::Option::None;
    }

    pub fn has_vote_for(&self) -> bool {
        self.vote_for.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_for(&mut self, v: bool) {
        self.vote_for = ::std::option::Option::Some(v);
    }

    // optional bool vote_against = 3;


    pub fn get_vote_against(&self) -> bool {
        self.vote_against.unwrap_or(false)
    }
    pub fn clear_vote_against(&mut self) {
        self.vote_against = ::std::option::Option::None;
    }

    pub fn has_vote_against(&self) -> bool {
        self.vote_against.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_against(&mut self, v: bool) {
        self.vote_against = ::std::option::Option::Some(v);
    }

    // optional bool reported = 4;


    pub fn get_reported(&self) -> bool {
        self.reported.unwrap_or(false)
    }
    pub fn clear_reported(&mut self) {
        self.reported = ::std::option::Option::None;
    }

    pub fn has_reported(&self) -> bool {
        self.reported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reported(&mut self, v: bool) {
        self.reported = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.publishedfileid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vote_for = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vote_against = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reported = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.publishedfileid {
            my_size += 9;
        }
        if let Some(v) = self.vote_for {
            my_size += 2;
        }
        if let Some(v) = self.vote_against {
            my_size += 2;
        }
        if let Some(v) = self.reported {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.publishedfileid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote_for {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.vote_against {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.reported {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
        CPublishedFile_GetUserVoteSummary_Response_VoteSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "publishedfileid",
                    |m: &CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &m.publishedfileid },
                    |m: &mut CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &mut m.publishedfileid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "vote_for",
                    |m: &CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &m.vote_for },
                    |m: &mut CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &mut m.vote_for },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "vote_against",
                    |m: &CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &m.vote_against },
                    |m: &mut CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &mut m.vote_against },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reported",
                    |m: &CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &m.reported },
                    |m: &mut CPublishedFile_GetUserVoteSummary_Response_VoteSummary| { &mut m.reported },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_GetUserVoteSummary_Response_VoteSummary>(
                    "CPublishedFile_GetUserVoteSummary_Response_VoteSummary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_GetUserVoteSummary_Response_VoteSummary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_GetUserVoteSummary_Response_VoteSummary,
        };
        unsafe {
            instance.get(CPublishedFile_GetUserVoteSummary_Response_VoteSummary::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
    fn clear(&mut self) {
        self.publishedfileid = ::std::option::Option::None;
        self.vote_for = ::std::option::Option::None;
        self.vote_against = ::std::option::Option::None;
        self.reported = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_FileSubscribed_Notification {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    file_hcontent: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    rtime_subscribed: ::std::option::Option<u32>,
    is_depot_content: ::std::option::Option<bool>,
    rtime_updated: ::std::option::Option<u32>,
    revisions: ::protobuf::RepeatedField<CPublishedFile_FileSubscribed_Notification_RevisionData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_FileSubscribed_Notification {
    fn default() -> &'a CPublishedFile_FileSubscribed_Notification {
        <CPublishedFile_FileSubscribed_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_FileSubscribed_Notification {
    pub fn new() -> CPublishedFile_FileSubscribed_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 file_hcontent = 3;


    pub fn get_file_hcontent(&self) -> u64 {
        self.file_hcontent.unwrap_or(0)
    }
    pub fn clear_file_hcontent(&mut self) {
        self.file_hcontent = ::std::option::Option::None;
    }

    pub fn has_file_hcontent(&self) -> bool {
        self.file_hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_hcontent(&mut self, v: u64) {
        self.file_hcontent = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 4;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_subscribed = 5;


    pub fn get_rtime_subscribed(&self) -> u32 {
        self.rtime_subscribed.unwrap_or(0)
    }
    pub fn clear_rtime_subscribed(&mut self) {
        self.rtime_subscribed = ::std::option::Option::None;
    }

    pub fn has_rtime_subscribed(&self) -> bool {
        self.rtime_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_subscribed(&mut self, v: u32) {
        self.rtime_subscribed = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 6;


    pub fn get_is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }
    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_updated = 7;


    pub fn get_rtime_updated(&self) -> u32 {
        self.rtime_updated.unwrap_or(0)
    }
    pub fn clear_rtime_updated(&mut self) {
        self.rtime_updated = ::std::option::Option::None;
    }

    pub fn has_rtime_updated(&self) -> bool {
        self.rtime_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_updated(&mut self, v: u32) {
        self.rtime_updated = ::std::option::Option::Some(v);
    }

    // repeated .CPublishedFile_FileSubscribed_Notification.RevisionData revisions = 8;


    pub fn get_revisions(&self) -> &[CPublishedFile_FileSubscribed_Notification_RevisionData] {
        &self.revisions
    }
    pub fn clear_revisions(&mut self) {
        self.revisions.clear();
    }

    // Param is passed by value, moved
    pub fn set_revisions(&mut self, v: ::protobuf::RepeatedField<CPublishedFile_FileSubscribed_Notification_RevisionData>) {
        self.revisions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_revisions(&mut self) -> &mut ::protobuf::RepeatedField<CPublishedFile_FileSubscribed_Notification_RevisionData> {
        &mut self.revisions
    }

    // Take field
    pub fn take_revisions(&mut self) -> ::protobuf::RepeatedField<CPublishedFile_FileSubscribed_Notification_RevisionData> {
        ::std::mem::replace(&mut self.revisions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CPublishedFile_FileSubscribed_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.revisions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.file_hcontent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_subscribed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_depot_content = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_updated = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.revisions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_hcontent {
            my_size += 9;
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime_subscribed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_depot_content {
            my_size += 2;
        }
        if let Some(v) = self.rtime_updated {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.revisions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_hcontent {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtime_subscribed {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.rtime_updated {
            os.write_uint32(7, v)?;
        }
        for v in &self.revisions {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_FileSubscribed_Notification {
        CPublishedFile_FileSubscribed_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "published_file_id",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.published_file_id },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.published_file_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "app_id",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.app_id },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.app_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "file_hcontent",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.file_hcontent },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.file_hcontent },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "file_size",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.file_size },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.file_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtime_subscribed",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.rtime_subscribed },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.rtime_subscribed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_depot_content",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.is_depot_content },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.is_depot_content },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtime_updated",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.rtime_updated },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.rtime_updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CPublishedFile_FileSubscribed_Notification_RevisionData>>(
                    "revisions",
                    |m: &CPublishedFile_FileSubscribed_Notification| { &m.revisions },
                    |m: &mut CPublishedFile_FileSubscribed_Notification| { &mut m.revisions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_FileSubscribed_Notification>(
                    "CPublishedFile_FileSubscribed_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_FileSubscribed_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_FileSubscribed_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_FileSubscribed_Notification,
        };
        unsafe {
            instance.get(CPublishedFile_FileSubscribed_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_FileSubscribed_Notification {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.file_hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.rtime_subscribed = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.rtime_updated = ::std::option::Option::None;
        self.revisions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_FileSubscribed_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_FileSubscribed_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_FileSubscribed_Notification_RevisionData {
    // message fields
    revision: ::std::option::Option<EPublishedFileRevision>,
    file_hcontent: ::std::option::Option<u64>,
    rtime_updated: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_FileSubscribed_Notification_RevisionData {
    fn default() -> &'a CPublishedFile_FileSubscribed_Notification_RevisionData {
        <CPublishedFile_FileSubscribed_Notification_RevisionData as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_FileSubscribed_Notification_RevisionData {
    pub fn new() -> CPublishedFile_FileSubscribed_Notification_RevisionData {
        ::std::default::Default::default()
    }

    // optional .EPublishedFileRevision revision = 1;


    pub fn get_revision(&self) -> EPublishedFileRevision {
        self.revision.unwrap_or(EPublishedFileRevision::k_EPublishedFileRevision_Default)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: EPublishedFileRevision) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional fixed64 file_hcontent = 2;


    pub fn get_file_hcontent(&self) -> u64 {
        self.file_hcontent.unwrap_or(0)
    }
    pub fn clear_file_hcontent(&mut self) {
        self.file_hcontent = ::std::option::Option::None;
    }

    pub fn has_file_hcontent(&self) -> bool {
        self.file_hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_hcontent(&mut self, v: u64) {
        self.file_hcontent = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_updated = 3;


    pub fn get_rtime_updated(&self) -> u32 {
        self.rtime_updated.unwrap_or(0)
    }
    pub fn clear_rtime_updated(&mut self) {
        self.rtime_updated = ::std::option::Option::None;
    }

    pub fn has_rtime_updated(&self) -> bool {
        self.rtime_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_updated(&mut self, v: u32) {
        self.rtime_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_FileSubscribed_Notification_RevisionData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.revision, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.file_hcontent = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_updated = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.file_hcontent {
            my_size += 9;
        }
        if let Some(v) = self.rtime_updated {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.revision {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.file_hcontent {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.rtime_updated {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_FileSubscribed_Notification_RevisionData {
        CPublishedFile_FileSubscribed_Notification_RevisionData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EPublishedFileRevision>>(
                    "revision",
                    |m: &CPublishedFile_FileSubscribed_Notification_RevisionData| { &m.revision },
                    |m: &mut CPublishedFile_FileSubscribed_Notification_RevisionData| { &mut m.revision },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "file_hcontent",
                    |m: &CPublishedFile_FileSubscribed_Notification_RevisionData| { &m.file_hcontent },
                    |m: &mut CPublishedFile_FileSubscribed_Notification_RevisionData| { &mut m.file_hcontent },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rtime_updated",
                    |m: &CPublishedFile_FileSubscribed_Notification_RevisionData| { &m.rtime_updated },
                    |m: &mut CPublishedFile_FileSubscribed_Notification_RevisionData| { &mut m.rtime_updated },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_FileSubscribed_Notification_RevisionData>(
                    "CPublishedFile_FileSubscribed_Notification_RevisionData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_FileSubscribed_Notification_RevisionData {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_FileSubscribed_Notification_RevisionData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_FileSubscribed_Notification_RevisionData,
        };
        unsafe {
            instance.get(CPublishedFile_FileSubscribed_Notification_RevisionData::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_FileSubscribed_Notification_RevisionData {
    fn clear(&mut self) {
        self.revision = ::std::option::Option::None;
        self.file_hcontent = ::std::option::Option::None;
        self.rtime_updated = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_FileSubscribed_Notification_RevisionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_FileSubscribed_Notification_RevisionData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_FileUnsubscribed_Notification {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_FileUnsubscribed_Notification {
    fn default() -> &'a CPublishedFile_FileUnsubscribed_Notification {
        <CPublishedFile_FileUnsubscribed_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_FileUnsubscribed_Notification {
    pub fn new() -> CPublishedFile_FileUnsubscribed_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_FileUnsubscribed_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_FileUnsubscribed_Notification {
        CPublishedFile_FileUnsubscribed_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "published_file_id",
                    |m: &CPublishedFile_FileUnsubscribed_Notification| { &m.published_file_id },
                    |m: &mut CPublishedFile_FileUnsubscribed_Notification| { &mut m.published_file_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "app_id",
                    |m: &CPublishedFile_FileUnsubscribed_Notification| { &m.app_id },
                    |m: &mut CPublishedFile_FileUnsubscribed_Notification| { &mut m.app_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_FileUnsubscribed_Notification>(
                    "CPublishedFile_FileUnsubscribed_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_FileUnsubscribed_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_FileUnsubscribed_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_FileUnsubscribed_Notification,
        };
        unsafe {
            instance.get(CPublishedFile_FileUnsubscribed_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_FileUnsubscribed_Notification {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_FileUnsubscribed_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_FileUnsubscribed_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPublishedFile_FileDeleted_Client_Notification {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPublishedFile_FileDeleted_Client_Notification {
    fn default() -> &'a CPublishedFile_FileDeleted_Client_Notification {
        <CPublishedFile_FileDeleted_Client_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPublishedFile_FileDeleted_Client_Notification {
    pub fn new() -> CPublishedFile_FileDeleted_Client_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPublishedFile_FileDeleted_Client_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPublishedFile_FileDeleted_Client_Notification {
        CPublishedFile_FileDeleted_Client_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "published_file_id",
                    |m: &CPublishedFile_FileDeleted_Client_Notification| { &m.published_file_id },
                    |m: &mut CPublishedFile_FileDeleted_Client_Notification| { &mut m.published_file_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "app_id",
                    |m: &CPublishedFile_FileDeleted_Client_Notification| { &m.app_id },
                    |m: &mut CPublishedFile_FileDeleted_Client_Notification| { &mut m.app_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CPublishedFile_FileDeleted_Client_Notification>(
                    "CPublishedFile_FileDeleted_Client_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CPublishedFile_FileDeleted_Client_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CPublishedFile_FileDeleted_Client_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CPublishedFile_FileDeleted_Client_Notification,
        };
        unsafe {
            instance.get(CPublishedFile_FileDeleted_Client_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CPublishedFile_FileDeleted_Client_Notification {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPublishedFile_FileDeleted_Client_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPublishedFile_FileDeleted_Client_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EPublishedFileRevision {
    k_EPublishedFileRevision_Default = 0,
    k_EPublishedFileRevision_Latest = 1,
    k_EPublishedFileRevision_ApprovedSnapshot = 2,
    k_EPublishedFileRevision_ApprovedSnapshot_China = 3,
    k_EPublishedFileRevision_RejectedSnapshot = 4,
    k_EPublishedFileRevision_RejectedSnapshot_China = 5,
}

impl ::protobuf::ProtobufEnum for EPublishedFileRevision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileRevision> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_Default),
            1 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_Latest),
            2 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot),
            3 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot_China),
            4 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot),
            5 => ::std::option::Option::Some(EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot_China),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPublishedFileRevision] = &[
            EPublishedFileRevision::k_EPublishedFileRevision_Default,
            EPublishedFileRevision::k_EPublishedFileRevision_Latest,
            EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot,
            EPublishedFileRevision::k_EPublishedFileRevision_ApprovedSnapshot_China,
            EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot,
            EPublishedFileRevision::k_EPublishedFileRevision_RejectedSnapshot_China,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EPublishedFileRevision", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EPublishedFileRevision {
}

impl ::std::default::Default for EPublishedFileRevision {
    fn default() -> Self {
        EPublishedFileRevision::k_EPublishedFileRevision_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for EPublishedFileRevision {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EPublishedFileForSaleStatus {
    k_PFFSS_NotForSale = 0,
    k_PFFSS_PendingApproval = 1,
    k_PFFSS_ApprovedForSale = 2,
    k_PFFSS_RejectedForSale = 3,
    k_PFFSS_NoLongerForSale = 4,
    k_PFFSS_TentativeApproval = 5,
}

impl ::protobuf::ProtobufEnum for EPublishedFileForSaleStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileForSaleStatus> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_NotForSale),
            1 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_PendingApproval),
            2 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_ApprovedForSale),
            3 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_RejectedForSale),
            4 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_NoLongerForSale),
            5 => ::std::option::Option::Some(EPublishedFileForSaleStatus::k_PFFSS_TentativeApproval),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EPublishedFileForSaleStatus] = &[
            EPublishedFileForSaleStatus::k_PFFSS_NotForSale,
            EPublishedFileForSaleStatus::k_PFFSS_PendingApproval,
            EPublishedFileForSaleStatus::k_PFFSS_ApprovedForSale,
            EPublishedFileForSaleStatus::k_PFFSS_RejectedForSale,
            EPublishedFileForSaleStatus::k_PFFSS_NoLongerForSale,
            EPublishedFileForSaleStatus::k_PFFSS_TentativeApproval,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EPublishedFileForSaleStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EPublishedFileForSaleStatus {
}

impl ::std::default::Default for EPublishedFileForSaleStatus {
    fn default() -> Self {
        EPublishedFileForSaleStatus::k_PFFSS_NotForSale
    }
}

impl ::protobuf::reflect::ProtobufValue for EPublishedFileForSaleStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_publishedfile.steamclient.proto\x1a,steammessages_unifi\
    ed_base.steamclient.proto\"\xa4\x01\n\x20CPublishedFile_Subscribe_Reques\
    t\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\x12\
    \x1b\n\tlist_type\x18\x02\x20\x01(\rR\x08listType\x12\x14\n\x05appid\x18\
    \x03\x20\x01(\x05R\x05appid\x12#\n\rnotify_client\x18\x04\x20\x01(\x08R\
    \x0cnotifyClient\"#\n!CPublishedFile_Subscribe_Response\"\xa6\x01\n\"CPu\
    blishedFile_Unsubscribe_Request\x12(\n\x0fpublishedfileid\x18\x01\x20\
    \x01(\x04R\x0fpublishedfileid\x12\x1b\n\tlist_type\x18\x02\x20\x01(\rR\
    \x08listType\x12\x14\n\x05appid\x18\x03\x20\x01(\x05R\x05appid\x12#\n\rn\
    otify_client\x18\x04\x20\x01(\x08R\x0cnotifyClient\"%\n#CPublishedFile_U\
    nsubscribe_Response\"O\n#CPublishedFile_CanSubscribe_Request\x12(\n\x0fp\
    ublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\"K\n$CPublishedF\
    ile_CanSubscribe_Response\x12#\n\rcan_subscribe\x18\x01\x20\x01(\x08R\
    \x0ccanSubscribe\"\x9e\x0c\n\x1eCPublishedFile_Publish_Request\x12C\n\
    \x05appid\x18\x01\x20\x01(\rR\x05appidB-\x82\xb5\x18)App\x20Id\x20this\
    \x20file\x20is\x20being\x20published\x20FROM.\x12R\n\x0econsumer_appid\
    \x18\x02\x20\x01(\rR\rconsumerAppidB+\x82\xb5\x18'App\x20Id\x20this\x20f\
    ile\x20is\x20being\x20published\x20TO.\x12Z\n\rcloudfilename\x18\x03\x20\
    \x01(\tR\rcloudfilenameB4\x82\xb5\x180Name\x20of\x20the\x20file\x20to\
    \x20publish\x20in\x20the\x20user's\x20cloud.\x12q\n\x15preview_cloudfile\
    name\x18\x04\x20\x01(\tR\x14previewCloudfilenameB<\x82\xb5\x188Name\x20o\
    f\x20the\x20file\x20to\x20use\x20as\x20the\x20published\x20file's\x20pre\
    view.\x12<\n\x05title\x18\x05\x20\x01(\tR\x05titleB&\x82\xb5\x18\"Text\
    \x20title\x20for\x20the\x20published\x20file.\x12W\n\x10file_description\
    \x18\x06\x20\x01(\tR\x0ffileDescriptionB,\x82\xb5\x18(Text\x20descriptio\
    n\x20for\x20the\x20published\x20file.\x12V\n\tfile_type\x18\x07\x20\x01(\
    \rR\x08fileTypeB9\x82\xb5\x185(EWorkshopFileType)\x20Type\x20of\x20Works\
    hop\x20file\x20to\x20publish.\x12_\n\x16consumer_shortcut_name\x18\x08\
    \x20\x01(\tR\x14consumerShortcutNameB)\x82\xb5\x18%Shortcut\x20name\x20f\
    or\x20the\x20published\x20file.\x12Z\n\x10youtube_username\x18\t\x20\x01\
    (\tR\x0fyoutubeUsernameB/\x82\xb5\x18+(Optional)\x20User's\x20YouTube\
    \x20account\x20username.\x12l\n\x0fyoutube_videoid\x18\n\x20\x01(\tR\x0e\
    youtubeVideoidBC\x82\xb5\x18?(Optional)\x20Video\x20Id\x20of\x20a\x20You\
    Tube\x20video\x20for\x20this\x20published\x20file.\x12\x8d\x01\n\nvisibi\
    lity\x18\x0b\x20\x01(\rR\nvisibilityBm\x82\xb5\x18i(ERemoteStoragePublis\
    hedFileVisibility)\x20Visibility\x20of\x20the\x20published\x20file\x20(p\
    rivate,\x20friends,\x20public,\x20etc.)\x12x\n\x0credirect_uri\x18\x0c\
    \x20\x01(\tR\x0bredirectUriBU\x82\xb5\x18Q(Optional)\x20If\x20supplied,\
    \x20the\x20resulting\x20published\x20file's\x20Id\x20is\x20appended\x20t\
    o\x20the\x20URI.\x12J\n\x04tags\x18\r\x20\x03(\tR\x04tagsB6\x82\xb5\x182\
    Array\x20of\x20text\x20tags\x20to\x20apply\x20to\x20the\x20published\x20\
    file.\x12i\n\x0fcollection_type\x18\x0e\x20\x01(\tR\x0ecollectionTypeB@\
    \x82\xb5\x18<(Optional)\x20Type\x20of\x20collection\x20the\x20published\
    \x20file\x20represents.\x12W\n\tgame_type\x18\x0f\x20\x01(\tR\x08gameTyp\
    eB:\x82\xb5\x186(Optional)\x20Type\x20of\x20game\x20the\x20published\x20\
    file\x20represents.\x12`\n\x03url\x18\x10\x20\x01(\tR\x03urlBN\x82\xb5\
    \x18J(Optional)\x20If\x20this\x20represents\x20a\x20game,\x20this\x20is\
    \x20the\x20URL\x20to\x20that\x20game's\x20page.\"n\n\x1fCPublishedFile_P\
    ublish_Response\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpubli\
    shedfileid\x12!\n\x0credirect_uri\x18\x02\x20\x01(\tR\x0bredirectUri\"\
    \xa2\x0b\n!CPublishedFile_GetDetails_Request\x12b\n\x10publishedfileids\
    \x18\x01\x20\x03(\x06R\x10publishedfileidsB6\x82\xb5\x182Set\x20of\x20pu\
    blished\x20file\x20Ids\x20to\x20retrieve\x20details\x20for.\x12^\n\x0bin\
    cludetags\x18\x02\x20\x01(\x08R\x0bincludetagsB<\x82\xb5\x188If\x20true,\
    \x20return\x20tag\x20information\x20in\x20the\x20returned\x20details.\
    \x12~\n\x19includeadditionalpreviews\x18\x03\x20\x01(\x08R\x19includeadd\
    itionalpreviewsB@\x82\xb5\x18<If\x20true,\x20return\x20preview\x20inform\
    ation\x20in\x20the\x20returned\x20details.\x12_\n\x0fincludechildren\x18\
    \x04\x20\x01(\x08R\x0fincludechildrenB5\x82\xb5\x181If\x20true,\x20retur\
    n\x20children\x20in\x20the\x20returned\x20details.\x12a\n\rincludekvtags\
    \x18\x05\x20\x01(\x08R\rincludekvtagsB;\x82\xb5\x187If\x20true,\x20retur\
    n\x20key\x20value\x20tags\x20in\x20the\x20returned\x20details.\x12Z\n\
    \x0cincludevotes\x18\x06\x20\x01(\x08R\x0cincludevotesB6\x82\xb5\x182If\
    \x20true,\x20return\x20vote\x20data\x20in\x20the\x20returned\x20details.\
    \x12u\n\x11short_description\x18\x08\x20\x01(\x08R\x10shortDescriptionBH\
    \x82\xb5\x18DIf\x20true,\x20return\x20a\x20short\x20description\x20inste\
    ad\x20of\x20the\x20full\x20description.\x12`\n\x12includeforsaledata\x18\
    \n\x20\x01(\x08R\x12includeforsaledataB0\x82\xb5\x18,If\x20true,\x20retu\
    rn\x20pricing\x20data,\x20if\x20applicable.\x12S\n\x0fincludemetadata\
    \x18\x0b\x20\x01(\x08R\x0fincludemetadataB)\x82\xb5\x18%If\x20true,\x20p\
    opulate\x20the\x20metadata\x20field.\x12_\n\x08language\x18\x0c\x20\x01(\
    \x05:\x010R\x08languageB@\x82\xb5\x18<Specifies\x20the\x20localized\x20t\
    ext\x20to\x20return.\x20Defaults\x20to\x20English.\x12|\n\x15return_play\
    time_stats\x18\r\x20\x01(\rR\x13returnPlaytimeStatsBH\x82\xb5\x18DReturn\
    \x20playtime\x20stats\x20for\x20the\x20specified\x20number\x20of\x20days\
    \x20before\x20today.\x12\x14\n\x05appid\x18\x0e\x20\x01(\rR\x05appid\x12\
    ^\n\x18strip_description_bbcode\x18\x0f\x20\x01(\x08R\x16stripDescriptio\
    nBbcodeB$\x82\xb5\x18\x20Strips\x20BBCode\x20from\x20descriptions.\x12\
    \x95\x01\n\x10desired_revision\x18\x10\x20\x01(\x0e2\x17.EPublishedFileR\
    evision:\x20k_EPublishedFileRevision_DefaultR\x0fdesiredRevisionB/\x82\
    \xb5\x18+Return\x20the\x20data\x20for\x20the\x20specified\x20revision.\"\
    \xcf\x20\n\x14PublishedFileDetails\x12\x16\n\x06result\x18\x01\x20\x01(\
    \rR\x06result\x12(\n\x0fpublishedfileid\x18\x02\x20\x01(\x04R\x0fpublish\
    edfileid\x12\x18\n\x07creator\x18\x03\x20\x01(\x06R\x07creator\x12#\n\rc\
    reator_appid\x18\x04\x20\x01(\rR\x0ccreatorAppid\x12%\n\x0econsumer_appi\
    d\x18\x05\x20\x01(\rR\rconsumerAppid\x12/\n\x13consumer_shortcutid\x18\
    \x06\x20\x01(\rR\x12consumerShortcutid\x12\x1a\n\x08filename\x18\x07\x20\
    \x01(\tR\x08filename\x12\x1b\n\tfile_size\x18\x08\x20\x01(\x04R\x08fileS\
    ize\x12*\n\x11preview_file_size\x18\t\x20\x01(\x04R\x0fpreviewFileSize\
    \x12\x19\n\x08file_url\x18\n\x20\x01(\tR\x07fileUrl\x12\x1f\n\x0bpreview\
    _url\x18\x0b\x20\x01(\tR\npreviewUrl\x12&\n\x0eyoutubevideoid\x18\x0c\
    \x20\x01(\tR\x0eyoutubevideoid\x12\x10\n\x03url\x18\r\x20\x01(\tR\x03url\
    \x12#\n\rhcontent_file\x18\x0e\x20\x01(\x06R\x0chcontentFile\x12)\n\x10h\
    content_preview\x18\x0f\x20\x01(\x06R\x0fhcontentPreview\x12\x14\n\x05ti\
    tle\x18\x10\x20\x01(\tR\x05title\x12)\n\x10file_description\x18\x11\x20\
    \x01(\tR\x0ffileDescription\x12+\n\x11short_description\x18\x12\x20\x01(\
    \tR\x10shortDescription\x12!\n\x0ctime_created\x18\x13\x20\x01(\rR\x0bti\
    meCreated\x12!\n\x0ctime_updated\x18\x14\x20\x01(\rR\x0btimeUpdated\x12\
    \x1e\n\nvisibility\x18\x15\x20\x01(\rR\nvisibility\x12\x14\n\x05flags\
    \x18\x16\x20\x01(\rR\x05flags\x12#\n\rworkshop_file\x18\x17\x20\x01(\x08\
    R\x0cworkshopFile\x12+\n\x11workshop_accepted\x18\x18\x20\x01(\x08R\x10w\
    orkshopAccepted\x12,\n\x12show_subscribe_all\x18\x19\x20\x01(\x08R\x10sh\
    owSubscribeAll\x124\n\x16num_comments_developer\x18\x1a\x20\x01(\x05R\
    \x14numCommentsDeveloper\x12.\n\x13num_comments_public\x18\x1b\x20\x01(\
    \x05R\x11numCommentsPublic\x12\x16\n\x06banned\x18\x1c\x20\x01(\x08R\x06\
    banned\x12\x1d\n\nban_reason\x18\x1d\x20\x01(\tR\tbanReason\x12\x16\n\
    \x06banner\x18\x1e\x20\x01(\x06R\x06banner\x12$\n\x0ecan_be_deleted\x18\
    \x1f\x20\x01(\x08R\x0ccanBeDeleted\x12\"\n\x0cincompatible\x18\x20\x20\
    \x01(\x08R\x0cincompatible\x12\x19\n\x08app_name\x18!\x20\x01(\tR\x07app\
    Name\x12\x1b\n\tfile_type\x18\"\x20\x01(\rR\x08fileType\x12#\n\rcan_subs\
    cribe\x18#\x20\x01(\x08R\x0ccanSubscribe\x12$\n\rsubscriptions\x18$\x20\
    \x01(\rR\rsubscriptions\x12\x1c\n\tfavorited\x18%\x20\x01(\rR\tfavorited\
    \x12\x1c\n\tfollowers\x18&\x20\x01(\rR\tfollowers\x125\n\x16lifetime_sub\
    scriptions\x18'\x20\x01(\rR\x15lifetimeSubscriptions\x12-\n\x12lifetime_\
    favorited\x18(\x20\x01(\rR\x11lifetimeFavorited\x12-\n\x12lifetime_follo\
    wers\x18)\x20\x01(\rR\x11lifetimeFollowers\x12+\n\x11lifetime_playtime\
    \x18>\x20\x01(\x04R\x10lifetimePlaytime\x12<\n\x1alifetime_playtime_sess\
    ions\x18?\x20\x01(\x04R\x18lifetimePlaytimeSessions\x12\x14\n\x05views\
    \x18*\x20\x01(\rR\x05views\x12\x1f\n\x0bimage_width\x18+\x20\x01(\rR\nim\
    ageWidth\x12!\n\x0cimage_height\x18,\x20\x01(\rR\x0bimageHeight\x12\x1b\
    \n\timage_url\x18-\x20\x01(\tR\x08imageUrl\x12\x1f\n\x0bspoiler_tag\x18.\
    \x20\x01(\x08R\nspoilerTag\x12\x1e\n\nshortcutid\x18/\x20\x01(\rR\nshort\
    cutid\x12\"\n\x0cshortcutname\x180\x20\x01(\tR\x0cshortcutname\x12!\n\
    \x0cnum_children\x181\x20\x01(\rR\x0bnumChildren\x12\x1f\n\x0bnum_report\
    s\x182\x20\x01(\rR\nnumReports\x129\n\x08previews\x183\x20\x03(\x0b2\x1d\
    .PublishedFileDetails.PreviewR\x08previews\x12-\n\x04tags\x184\x20\x03(\
    \x0b2\x19.PublishedFileDetails.TagR\x04tags\x127\n\x08children\x185\x20\
    \x03(\x0b2\x1b.PublishedFileDetails.ChildR\x08children\x123\n\x06kvtags\
    \x186\x20\x03(\x0b2\x1b.PublishedFileDetails.KVTagR\x06kvtags\x12;\n\tvo\
    te_data\x187\x20\x01(\x0b2\x1e.PublishedFileDetails.VoteDataR\x08voteDat\
    a\x12J\n\x0eplaytime_stats\x18@\x20\x01(\x0b2#.PublishedFileDetails.Play\
    timeStatsR\rplaytimeStats\x12\x82\x01\n\x0ftime_subscribed\x188\x20\x01(\
    \rR\x0etimeSubscribedBY\x82\xb5\x18UOnly\x20valid\x20in\x20PublishedFile\
    .GetUserFiles\x20and\x20not\x20normal\x20PublishedFile.GetDetail\x20call\
    s\x12n\n\rfor_sale_data\x189\x20\x01(\x0b2!.PublishedFileDetails.ForSale\
    DataR\x0bforSaleDataB'\x82\xb5\x18#Pricing\x20information,\x20if\x20appl\
    icable.\x12A\n\x08metadata\x18:\x20\x01(\tR\x08metadataB%\x82\xb5\x18!Me\
    tadata\x20associated\x20with\x20the\x20item\x12M\n\x08language\x18=\x20\
    \x01(\x05:\x010R\x08languageB.\x82\xb5\x18*The\x20language\x20of\x20the\
    \x20title\x20and\x20description.\x126\n\x17maybe_inappropriate_sex\x18A\
    \x20\x01(\x08R\x15maybeInappropriateSex\x12@\n\x1cmaybe_inappropriate_vi\
    olence\x18B\x20\x01(\x08R\x1amaybeInappropriateViolence\x12g\n\x16revisi\
    on_change_number\x18C\x20\x01(\x04R\x14revisionChangeNumberB1\x82\xb5\
    \x18-The\x20change\x20number\x20for\x20the\x20specified\x20revision.\x12\
    \xe6\x01\n\x08revision\x18D\x20\x01(\x0e2\x17.EPublishedFileRevision:\
    \x20k_EPublishedFileRevision_DefaultR\x08revisionB\x8e\x01\x82\xb5\x18\
    \x89\x01The\x20revision\x20of\x20the\x20data\x20returned,\x20usually\x20\
    k_EPublishedFileRevision_Latest,\x20but\x20can\x20be\x20another\x20revis\
    ion/snapshot\x20depending\x20on\x20the\x20caller.\x12a\n\x13available_re\
    visions\x18E\x20\x03(\x0e2\x17.EPublishedFileRevisionR\x12availableRevis\
    ionsB\x17\x82\xb5\x18\x13Available\x20revisions\x1a5\n\x03Tag\x12\x10\n\
    \x03tag\x18\x01\x20\x01(\tR\x03tag\x12\x1c\n\tadminonly\x18\x02\x20\x01(\
    \x08R\tadminonly\x1a\x81\x02\n\x07Preview\x12\x1c\n\tpreviewid\x18\x01\
    \x20\x01(\x04R\tpreviewid\x12\x1c\n\tsortorder\x18\x02\x20\x01(\rR\tsort\
    order\x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12\x12\n\x04size\x18\
    \x04\x20\x01(\rR\x04size\x12\x1a\n\x08filename\x18\x05\x20\x01(\tR\x08fi\
    lename\x12&\n\x0eyoutubevideoid\x18\x06\x20\x01(\tR\x0eyoutubevideoid\
    \x12!\n\x0cpreview_type\x18\x07\x20\x01(\rR\x0bpreviewType\x12-\n\x12ext\
    ernal_reference\x18\x08\x20\x01(\tR\x11externalReference\x1al\n\x05Child\
    \x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\x12\
    \x1c\n\tsortorder\x18\x02\x20\x01(\rR\tsortorder\x12\x1b\n\tfile_type\
    \x18\x03\x20\x01(\rR\x08fileType\x1a/\n\x05KVTag\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \x1aZ\n\x08VoteData\x12\x14\n\x05score\x18\x01\x20\x01(\x02R\x05score\
    \x12\x19\n\x08votes_up\x18\x02\x20\x01(\rR\x07votesUp\x12\x1d\n\nvotes_d\
    own\x18\x03\x20\x01(\rR\tvotesDown\x1a\xbe\x02\n\x0bForSaleData\x12\x1e\
    \n\x0bis_for_sale\x18\x01\x20\x01(\x08R\tisForSale\x12%\n\x0eprice_categ\
    ory\x18\x02\x20\x01(\rR\rpriceCategory\x12J\n\x07estatus\x18\x03\x20\x01\
    (\x0e2\x1c.EPublishedFileForSaleStatus:\x12k_PFFSS_NotForSaleR\x07estatu\
    s\x120\n\x14price_category_floor\x18\x04\x20\x01(\rR\x12priceCategoryFlo\
    or\x129\n\x1aprice_is_pay_what_you_want\x18\x05\x20\x01(\x08R\x15priceIs\
    PayWhatYouWant\x12/\n\x13discount_percentage\x18\x06\x20\x01(\rR\x12disc\
    ountPercentage\x1a]\n\rPlaytimeStats\x12)\n\x10playtime_seconds\x18\x01\
    \x20\x01(\x04R\x0fplaytimeSeconds\x12!\n\x0cnum_sessions\x18\x02\x20\x01\
    (\x04R\x0bnumSessions\"o\n\"CPublishedFile_GetDetails_Response\x12I\n\
    \x14publishedfiledetails\x18\x01\x20\x03(\x0b2\x15.PublishedFileDetailsR\
    \x14publishedfiledetails\"\xb8\x03\n\"CPublishedFile_GetItemInfo_Request\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\x11last_time_up\
    dated\x18\x02\x20\x01(\rR\x0flastTimeUpdated\x12W\n\x0eworkshop_items\
    \x18\x03\x20\x03(\x0b20.CPublishedFile_GetItemInfo_Request.WorkshopItemR\
    \rworkshopItems\x1a\xf5\x01\n\x0cWorkshopItem\x12*\n\x11published_file_i\
    d\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\x0ctime_updated\x18\
    \x02\x20\x01(\rR\x0btimeUpdated\x12\x95\x01\n\x10desired_revision\x18\
    \x03\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPublishedFileRevisi\
    on_DefaultR\x0fdesiredRevisionB/\x82\xb5\x18+Return\x20the\x20data\x20fo\
    r\x20the\x20specified\x20revision.\"\xe4\x02\n#CPublishedFile_GetItemInf\
    o_Response\x12\x1f\n\x0bupdate_time\x18\x01\x20\x01(\rR\nupdateTime\x12\
    \\\n\x0eworkshop_items\x18\x02\x20\x03(\x0b25.CPublishedFile_GetItemInfo\
    _Response.WorkshopItemInfoR\rworkshopItems\x12#\n\rprivate_items\x18\x03\
    \x20\x03(\x06R\x0cprivateItems\x1a\x98\x01\n\x10WorkshopItemInfo\x12*\n\
    \x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\
    \x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\x12\x1f\n\x0bmanifes\
    t_id\x18\x03\x20\x01(\x06R\nmanifestId\x12\x14\n\x05flags\x18\x04\x20\
    \x01(\rR\x05flags\"\xc5\x16\n#CPublishedFile_GetUserFiles_Request\x12S\n\
    \x07steamid\x18\x01\x20\x01(\x06R\x07steamidB9\x82\xb5\x185Steam\x20ID\
    \x20of\x20the\x20user\x20whose\x20files\x20are\x20being\x20requested.\
    \x12M\n\x05appid\x18\x02\x20\x01(\rR\x05appidB7\x82\xb5\x183App\x20Id\
    \x20of\x20the\x20app\x20that\x20the\x20files\x20were\x20published\x20to.\
    \x12@\n\x04page\x18\x04\x20\x01(\r:\x011R\x04pageB)\x82\xb5\x18%(Optiona\
    l)\x20Starting\x20page\x20for\x20results.\x12\\\n\nnumperpage\x18\x05\
    \x20\x01(\r:\x011R\nnumperpageB9\x82\xb5\x185(Optional)\x20The\x20number\
    \x20of\x20results,\x20per\x20page\x20to\x20return.\x12I\n\x04type\x18\
    \x06\x20\x01(\t:\x07myfilesR\x04typeB,\x82\xb5\x18((Optional)\x20Type\
    \x20of\x20files\x20to\x20be\x20returned.\x12e\n\nsortmethod\x18\x07\x20\
    \x01(\t:\x0blastupdatedR\nsortmethodB8\x82\xb5\x184(Optional)\x20Sorting\
    \x20method\x20to\x20use\x20on\x20returned\x20values.\x12D\n\x07privacy\
    \x18\t\x20\x01(\rR\x07privacyB*\x82\xb5\x18&(optional)\x20Filter\x20by\
    \x20privacy\x20settings.\x12v\n\x0crequiredtags\x18\n\x20\x03(\tR\x0creq\
    uiredtagsBR\x82\xb5\x18N(Optional)\x20Tags\x20that\x20must\x20be\x20pres\
    ent\x20on\x20a\x20published\x20file\x20to\x20satisfy\x20the\x20query.\
    \x12z\n\x0cexcludedtags\x18\x0b\x20\x03(\tR\x0cexcludedtagsBV\x82\xb5\
    \x18R(Optional)\x20Tags\x20that\x20must\x20NOT\x20be\x20present\x20on\
    \x20a\x20published\x20file\x20to\x20satisfy\x20the\x20query.\x12~\n\x10r\
    equired_kv_tags\x18\x1e\x20\x03(\x0b2*.CPublishedFile_GetUserFiles_Reque\
    st.KVTagR\x0erequiredKvTagsB(\x82\xb5\x18$Required\x20key-value\x20tags\
    \x20to\x20match\x20on.\x12G\n\x08filetype\x18\x0e\x20\x01(\rR\x08filetyp\
    eB+\x82\xb5\x18'(Optional)\x20File\x20type\x20to\x20match\x20files\x20to\
    .\x12o\n\rcreator_appid\x18\x0f\x20\x01(\rR\x0ccreatorAppidBJ\x82\xb5\
    \x18FApp\x20Id\x20of\x20the\x20app\x20that\x20published\x20the\x20files,\
    \x20only\x20matched\x20if\x20specified.\x12]\n\x14match_cloud_filename\
    \x18\x10\x20\x01(\tR\x12matchCloudFilenameB+\x82\xb5\x18'Match\x20this\
    \x20cloud\x20filename\x20if\x20specified.\x12~\n\x15cache_max_age_second\
    s\x18\x1b\x20\x01(\r:\x010R\x12cacheMaxAgeSecondsBH\x82\xb5\x18DAllow\
    \x20stale\x20data\x20to\x20be\x20returned\x20for\x20the\x20specified\x20\
    number\x20of\x20seconds.\x12_\n\x08language\x18\x1d\x20\x01(\x05:\x010R\
    \x08languageB@\x82\xb5\x18<Specifies\x20the\x20localized\x20text\x20to\
    \x20return.\x20Defaults\x20to\x20English.\x12t\n\ttotalonly\x18\x11\x20\
    \x01(\x08R\ttotalonlyBV\x82\xb5\x18R(Optional)\x20If\x20true,\x20only\
    \x20return\x20the\x20total\x20number\x20of\x20files\x20that\x20satisfy\
    \x20this\x20query.\x12w\n\x08ids_only\x18\x12\x20\x01(\x08R\x07idsOnlyB\
    \\\x82\xb5\x18X(Optional)\x20If\x20true,\x20only\x20return\x20the\x20pub\
    lished\x20file\x20ids\x20of\x20files\x20that\x20satisfy\x20this\x20query\
    .\x12D\n\x10return_vote_data\x18\x13\x20\x01(\x08:\x04trueR\x0ereturnVot\
    eDataB\x14\x82\xb5\x18\x10Return\x20vote\x20data\x12D\n\x0breturn_tags\
    \x18\x14\x20\x01(\x08R\nreturnTagsB#\x82\xb5\x18\x1fReturn\x20tags\x20in\
    \x20the\x20file\x20details\x12Y\n\x0ereturn_kv_tags\x18\x15\x20\x01(\x08\
    :\x04trueR\x0creturnKvTagsB-\x82\xb5\x18)Return\x20key-value\x20tags\x20\
    in\x20the\x20file\x20details\x12g\n\x0freturn_previews\x18\x16\x20\x01(\
    \x08R\x0ereturnPreviewsB>\x82\xb5\x18:Return\x20preview\x20image\x20and\
    \x20video\x20details\x20in\x20the\x20file\x20details\x12V\n\x0freturn_ch\
    ildren\x18\x17\x20\x01(\x08R\x0ereturnChildrenB-\x82\xb5\x18)Return\x20c\
    hild\x20item\x20ids\x20in\x20the\x20file\x20details\x12\x84\x01\n\x18ret\
    urn_short_description\x18\x18\x20\x01(\x08:\x04trueR\x16returnShortDescr\
    iptionBD\x82\xb5\x18@Populate\x20the\x20short_description\x20field\x20in\
    stead\x20of\x20file_description\x12^\n\x14return_for_sale_data\x18\x1a\
    \x20\x01(\x08R\x11returnForSaleDataB-\x82\xb5\x18)Return\x20pricing\x20i\
    nformation,\x20if\x20applicable\x12O\n\x0freturn_metadata\x18\x1c\x20\
    \x01(\x08:\x05falseR\x0ereturnMetadataB\x1f\x82\xb5\x18\x1bPopulate\x20t\
    he\x20metadata\x20field\x12|\n\x15return_playtime_stats\x18\x1f\x20\x01(\
    \rR\x13returnPlaytimeStatsBH\x82\xb5\x18DReturn\x20playtime\x20stats\x20\
    for\x20the\x20specified\x20number\x20of\x20days\x20before\x20today.\x12^\
    \n\x18strip_description_bbcode\x18\x20\x20\x01(\x08R\x16stripDescription\
    BbcodeB$\x82\xb5\x18\x20Strips\x20BBCode\x20from\x20descriptions.\x12\
    \x95\x01\n\x10desired_revision\x18!\x20\x01(\x0e2\x17.EPublishedFileRevi\
    sion:\x20k_EPublishedFileRevision_DefaultR\x0fdesiredRevisionB/\x82\xb5\
    \x18+Return\x20the\x20data\x20for\x20the\x20specified\x20revision.\x1a/\
    \n\x05KVTag\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value\"\xd1\x02\n$CPublishedFile_GetUserFiles_\
    Response\x12\x14\n\x05total\x18\x01\x20\x01(\rR\x05total\x12\x1e\n\nstar\
    tindex\x18\x02\x20\x01(\rR\nstartindex\x12I\n\x14publishedfiledetails\
    \x18\x03\x20\x03(\x0b2\x15.PublishedFileDetailsR\x14publishedfiledetails\
    \x12=\n\x04apps\x18\x04\x20\x03(\x0b2).CPublishedFile_GetUserFiles_Respo\
    nse.AppR\x04apps\x1ai\n\x03App\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1e\n\nshort\
    cutid\x18\x03\x20\x01(\rR\nshortcutid\x12\x18\n\x07private\x18\x04\x20\
    \x01(\x08R\x07private\"\xd9\x02\n1CPublishedFile_AreFilesInSubscriptionL\
    ist_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12*\n\x10pu\
    blishedfileids\x18\x02\x20\x03(\x06R\x10publishedfileids\x120\n\x08listt\
    ype\x18\x03\x20\x01(\rR\x08listtypeB\x14\x82\xb5\x18\x10See\x20EUCMListT\
    ype\x12F\n\x08filetype\x18\x04\x20\x01(\rR\x08filetypeB*\x82\xb5\x18&See\
    \x20EPublishedFileInfoMatchingFileType\x12h\n\x10workshopfiletype\x18\
    \x05\x20\x01(\rR\x10workshopfiletypeB<\x82\xb5\x188See\x20EWorkshopFileT\
    ype.\x20\x20If\x20specified,\x20overrides\x20filetype\"\xd2\x01\n2CPubli\
    shedFile_AreFilesInSubscriptionList_Response\x12P\n\x05files\x18\x01\x20\
    \x03(\x0b2:.CPublishedFile_AreFilesInSubscriptionList_Response.InListR\
    \x05files\x1aJ\n\x06InList\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\
    \x06R\x0fpublishedfileid\x12\x16\n\x06inlist\x18\x02\x20\x01(\x08R\x06in\
    list\"\x87\x07\n\x1dCPublishedFile_Update_Request\x12@\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appidB*\x82\xb5\x18&App\x20Id\x20this\x20published\
    \x20file\x20belongs\x20to.\x12]\n\x0fpublishedfileid\x18\x02\x20\x01(\
    \x06R\x0fpublishedfileidB3\x82\xb5\x18/Published\x20file\x20id\x20of\x20\
    the\x20file\x20we'd\x20like\x20update.\x12A\n\x05title\x18\x03\x20\x01(\
    \tR\x05titleB+\x82\xb5\x18'(Optional)\x20Title\x20of\x20the\x20published\
    \x20file.\x12\\\n\x10file_description\x18\x04\x20\x01(\tR\x0ffileDescrip\
    tionB1\x82\xb5\x18-(Optional)\x20Description\x20of\x20the\x20published\
    \x20file.\x12P\n\nvisibility\x18\x05\x20\x01(\rR\nvisibilityB0\x82\xb5\
    \x18,(Optional)\x20Visibility\x20of\x20the\x20published\x20file.\x12F\n\
    \x04tags\x18\x06\x20\x03(\tR\x04tagsB2\x82\xb5\x18.(Optional)\x20Set\x20\
    of\x20tags\x20for\x20the\x20published\x20file.\x12K\n\x08filename\x18\
    \x07\x20\x01(\tR\x08filenameB/\x82\xb5\x18+(Optional)\x20Filename\x20for\
    \x20the\x20published\x20file.\x12b\n\x10preview_filename\x18\x08\x20\x01\
    (\tR\x0fpreviewFilenameB7\x82\xb5\x183(Optional)\x20Preview\x20filename\
    \x20for\x20the\x20published\x20file.\x12j\n\x0bimage_width\x18\x0f\x20\
    \x01(\rR\nimageWidthBI\x82\xb5\x18E(Optional)\x20If\x20this\x20is\x20an\
    \x20image\x20file,\x20you\x20can\x20specify\x20the\x20image\x20width.\
    \x12m\n\x0cimage_height\x18\x10\x20\x01(\rR\x0bimageHeightBJ\x82\xb5\x18\
    F(Optional)\x20If\x20this\x20is\x20an\x20image\x20file,\x20you\x20can\
    \x20specify\x20the\x20image\x20height.\"\x20\n\x1eCPublishedFile_Update_\
    Response\"\xde\x01\n,CPublishedFile_GetChangeHistoryEntry_Request\x12t\n\
    \x0fpublishedfileid\x18\x01\x20\x01(\x06R\x0fpublishedfileidBJ\x82\xb5\
    \x18FPublished\x20file\x20id\x20of\x20the\x20file\x20we'd\x20like\x20to\
    \x20get\x20the\x20change\x20history\x20for.\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\rR\ttimestamp\x12\x1a\n\x08language\x18\x03\x20\x01(\x05R\x08l\
    anguage\"z\n-CPublishedFile_GetChangeHistoryEntry_Response\x12-\n\x12cha\
    nge_description\x18\x01\x20\x01(\tR\x11changeDescription\x12\x1a\n\x08la\
    nguage\x18\x02\x20\x01(\x05R\x08language\"\xd7\x02\n'CPublishedFile_GetC\
    hangeHistory_Request\x12t\n\x0fpublishedfileid\x18\x01\x20\x01(\x06R\x0f\
    publishedfileidBJ\x82\xb5\x18FPublished\x20file\x20id\x20of\x20the\x20fi\
    le\x20we'd\x20like\x20to\x20get\x20the\x20change\x20history\x20for.\x12K\
    \n\ntotal_only\x18\x02\x20\x01(\x08R\ttotalOnlyB,\x82\xb5\x18(Return\x20\
    the\x20total\x20number\x20of\x20changes\x20only.\x12\x1e\n\nstartindex\
    \x18\x03\x20\x01(\rR\nstartindex\x12\x14\n\x05count\x18\x04\x20\x01(\rR\
    \x05count\x123\n\x08language\x18\x05\x20\x01(\x05:\x010R\x08languageB\
    \x14\x82\xb5\x18\x10Desired\x20language\"\x85\x02\n(CPublishedFile_GetCh\
    angeHistory_Response\x12M\n\x07changes\x18\x01\x20\x03(\x0b23.CPublished\
    File_GetChangeHistory_Response.ChangeLogR\x07changes\x12\x14\n\x05total\
    \x18\x02\x20\x01(\rR\x05total\x1at\n\tChangeLog\x12\x1c\n\ttimestamp\x18\
    \x01\x20\x01(\rR\ttimestamp\x12-\n\x12change_description\x18\x02\x20\x01\
    (\tR\x11changeDescription\x12\x1a\n\x08language\x18\x03\x20\x01(\x05R\
    \x08language\"\xaf\x06\n)CPublishedFile_RefreshVotingQueue_Request\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12T\n\x12matching_file_typ\
    e\x18\x02\x20\x01(\rR\x10matchingFileTypeB&\x82\xb5\x18\"EPublishedFileI\
    nfoMatchingFileType\x12r\n\x04tags\x18\x03\x20\x03(\tR\x04tagsB^\x82\xb5\
    \x18ZInclude\x20files\x20that\x20have\x20all\x20the\x20tags\x20or\x20any\
    \x20of\x20the\x20tags\x20if\x20match_all_tags\x20is\x20set\x20to\x20fals\
    e.\x12\xa3\x01\n\x0ematch_all_tags\x18\x04\x20\x01(\x08:\x04trueR\x0cmat\
    chAllTagsBw\x82\xb5\x18sIf\x20true,\x20then\x20files\x20must\x20have\x20\
    all\x20the\x20tags\x20specified.\x20\x20If\x20false,\x20then\x20must\x20\
    have\x20at\x20least\x20one\x20of\x20the\x20tags\x20specified.\x12W\n\rex\
    cluded_tags\x18\x05\x20\x03(\tR\x0cexcludedTagsB2\x82\xb5\x18.Exclude\
    \x20any\x20files\x20that\x20have\x20any\x20of\x20these\x20tags.\x12|\n\
    \x12desired_queue_size\x18\x06\x20\x01(\rR\x10desiredQueueSizeBN\x82\xb5\
    \x18JDesired\x20number\x20of\x20items\x20in\x20the\x20voting\x20queue.\
    \x20\x20May\x20be\x20clamped\x20by\x20the\x20server\x12\xa4\x01\n\x10des\
    ired_revision\x18\x08\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPu\
    blishedFileRevision_DefaultR\x0fdesiredRevisionB>\x82\xb5\x18:Filter\x20\
    to\x20items\x20that\x20have\x20data\x20for\x20the\x20specified\x20revisi\
    on.\",\n*CPublishedFile_RefreshVotingQueue_Response\"\x8a\x1d\n!CPublish\
    edFile_QueryFiles_Request\x12W\n\nquery_type\x18\x01\x20\x01(\rR\tqueryT\
    ypeB8\x82\xb5\x184enumeration\x20EPublishedFileQueryType\x20in\x20client\
    enums.h\x12$\n\x04page\x18\x02\x20\x01(\rR\x04pageB\x10\x82\xb5\x18\x0cC\
    urrent\x20page\x12\xf0\x01\n\x06cursor\x18'\x20\x01(\tR\x06cursorB\xd7\
    \x01\x82\xb5\x18\xd2\x01Cursor\x20to\x20paginate\x20through\x20the\x20re\
    sults\x20(set\x20to\x20'*'\x20for\x20the\x20first\x20request).\x20\x20Pr\
    efer\x20this\x20over\x20using\x20the\x20page\x20parameter,\x20as\x20it\
    \x20will\x20allow\x20you\x20to\x20do\x20deep\x20pagination.\x20\x20When\
    \x20used,\x20the\x20page\x20parameter\x20will\x20be\x20ignored.\x12\\\n\
    \nnumperpage\x18\x03\x20\x01(\r:\x011R\nnumperpageB9\x82\xb5\x185(Option\
    al)\x20The\x20number\x20of\x20results,\x20per\x20page\x20to\x20return.\
    \x12C\n\rcreator_appid\x18\x04\x20\x01(\rR\x0ccreatorAppidB\x1e\x82\xb5\
    \x18\x1aApp\x20that\x20created\x20the\x20files\x125\n\x05appid\x18\x05\
    \x20\x01(\rR\x05appidB\x1f\x82\xb5\x18\x1bApp\x20that\x20consumes\x20the\
    \x20files\x12\\\n\x0crequiredtags\x18\x06\x20\x03(\tR\x0crequiredtagsB8\
    \x82\xb5\x184Tags\x20to\x20match\x20on.\x20See\x20match_all_tags\x20para\
    meter\x20below\x12z\n\x0cexcludedtags\x18\x07\x20\x03(\tR\x0cexcludedtag\
    sBV\x82\xb5\x18R(Optional)\x20Tags\x20that\x20must\x20NOT\x20be\x20prese\
    nt\x20on\x20a\x20published\x20file\x20to\x20satisfy\x20the\x20query.\x12\
    \x98\x01\n\x0ematch_all_tags\x18\x08\x20\x01(\x08:\x04trueR\x0cmatchAllT\
    agsBl\x82\xb5\x18hIf\x20true,\x20then\x20items\x20must\x20have\x20all\
    \x20the\x20tags\x20specified,\x20otherwise\x20they\x20must\x20have\x20at\
    \x20least\x20one\x20of\x20the\x20tags.\x12`\n\x0erequired_flags\x18\t\
    \x20\x03(\tR\rrequiredFlagsB9\x82\xb5\x185Required\x20flags\x20that\x20m\
    ust\x20be\x20set\x20on\x20any\x20returned\x20items\x12Y\n\romitted_flags\
    \x18\n\x20\x03(\tR\x0comittedFlagsB4\x82\xb5\x180Flags\x20that\x20must\
    \x20not\x20be\x20set\x20on\x20any\x20returned\x20items\x12U\n\x0bsearch_\
    text\x18\x0b\x20\x01(\tR\nsearchTextB4\x82\xb5\x180Text\x20to\x20match\
    \x20in\x20the\x20item's\x20title\x20or\x20description\x12B\n\x08filetype\
    \x18\x0c\x20\x01(\rR\x08filetypeB&\x82\xb5\x18\"EPublishedFileInfoMatchi\
    ngFileType\x12f\n\x15child_publishedfileid\x18\r\x20\x01(\x06R\x14childP\
    ublishedfileidB1\x82\xb5\x18-Find\x20all\x20items\x20that\x20reference\
    \x20the\x20given\x20item.\x12\x88\x01\n\x04days\x18\x0e\x20\x01(\rR\x04d\
    aysBt\x82\xb5\x18pIf\x20query_type\x20is\x20k_PublishedFileQueryType_Ran\
    kedByTrend,\x20then\x20this\x20is\x20the\x20number\x20of\x20days\x20to\
    \x20get\x20votes\x20for\x20[1,7].\x12\xc8\x01\n\x19include_recent_votes_\
    only\x18\x0f\x20\x01(\x08R\x16includeRecentVotesOnlyB\x8c\x01\x82\xb5\
    \x18\x87\x01If\x20query_type\x20is\x20k_PublishedFileQueryType_RankedByT\
    rend,\x20then\x20limit\x20result\x20set\x20just\x20to\x20items\x20that\
    \x20have\x20votes\x20within\x20the\x20day\x20range\x20given\x12~\n\x15ca\
    che_max_age_seconds\x18\x1f\x20\x01(\r:\x010R\x12cacheMaxAgeSecondsBH\
    \x82\xb5\x18DAllow\x20stale\x20data\x20to\x20be\x20returned\x20for\x20th\
    e\x20specified\x20number\x20of\x20seconds.\x12j\n\x08language\x18!\x20\
    \x01(\x05:\x010R\x08languageBK\x82\xb5\x18GLanguage\x20to\x20search\x20i\
    n\x20and\x20also\x20what\x20gets\x20returned.\x20Defaults\x20to\x20Engli\
    sh.\x12|\n\x10required_kv_tags\x18\"\x20\x03(\x0b2(.CPublishedFile_Query\
    Files_Request.KVTagR\x0erequiredKvTagsB(\x82\xb5\x18$Required\x20key-val\
    ue\x20tags\x20to\x20match\x20on.\x12t\n\ttotalonly\x18\x10\x20\x01(\x08R\
    \ttotalonlyBV\x82\xb5\x18R(Optional)\x20If\x20true,\x20only\x20return\
    \x20the\x20total\x20number\x20of\x20files\x20that\x20satisfy\x20this\x20\
    query.\x12w\n\x08ids_only\x18#\x20\x01(\x08R\x07idsOnlyB\\\x82\xb5\x18X(\
    Optional)\x20If\x20true,\x20only\x20return\x20the\x20published\x20file\
    \x20ids\x20of\x20files\x20that\x20satisfy\x20this\x20query.\x12>\n\x10re\
    turn_vote_data\x18\x11\x20\x01(\x08R\x0ereturnVoteDataB\x14\x82\xb5\x18\
    \x10Return\x20vote\x20data\x12D\n\x0breturn_tags\x18\x12\x20\x01(\x08R\n\
    returnTagsB#\x82\xb5\x18\x1fReturn\x20tags\x20in\x20the\x20file\x20detai\
    ls\x12S\n\x0ereturn_kv_tags\x18\x13\x20\x01(\x08R\x0creturnKvTagsB-\x82\
    \xb5\x18)Return\x20key-value\x20tags\x20in\x20the\x20file\x20details\x12\
    g\n\x0freturn_previews\x18\x14\x20\x01(\x08R\x0ereturnPreviewsB>\x82\xb5\
    \x18:Return\x20preview\x20image\x20and\x20video\x20details\x20in\x20the\
    \x20file\x20details\x12V\n\x0freturn_children\x18\x15\x20\x01(\x08R\x0er\
    eturnChildrenB-\x82\xb5\x18)Return\x20child\x20item\x20ids\x20in\x20the\
    \x20file\x20details\x12~\n\x18return_short_description\x18\x16\x20\x01(\
    \x08R\x16returnShortDescriptionBD\x82\xb5\x18@Populate\x20the\x20short_d\
    escription\x20field\x20instead\x20of\x20file_description\x12^\n\x14retur\
    n_for_sale_data\x18\x1e\x20\x01(\x08R\x11returnForSaleDataB-\x82\xb5\x18\
    )Return\x20pricing\x20information,\x20if\x20applicable\x12I\n\x0freturn_\
    metadata\x18\x20\x20\x01(\x08:\x05falseR\x0ereturnMetadataB\x19\x82\xb5\
    \x18\x15Populate\x20the\x20metadata\x12|\n\x15return_playtime_stats\x18$\
    \x20\x01(\rR\x13returnPlaytimeStatsBH\x82\xb5\x18DReturn\x20playtime\x20\
    stats\x20for\x20the\x20specified\x20number\x20of\x20days\x20before\x20to\
    day.\x12\xc6\x01\n\x0ereturn_details\x18%\x20\x01(\x08R\rreturnDetailsB\
    \x9e\x01\x82\xb5\x18\x99\x01By\x20default,\x20if\x20none\x20of\x20the\
    \x20other\x20'return_*'\x20fields\x20are\x20set,\x20only\x20some\x20voti\
    ng\x20details\x20are\x20returned.\x20Set\x20this\x20to\x20true\x20to\x20\
    return\x20the\x20default\x20set\x20of\x20details.\x12^\n\x18strip_descri\
    ption_bbcode\x18&\x20\x01(\x08R\x16stripDescriptionBbcodeB$\x82\xb5\x18\
    \x20Strips\x20BBCode\x20from\x20descriptions.\x12\x95\x01\n\x10desired_r\
    evision\x18(\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPublishedFi\
    leRevision_DefaultR\x0fdesiredRevisionB/\x82\xb5\x18+Return\x20the\x20da\
    ta\x20for\x20the\x20specified\x20revision.\x1a/\n\x05KVTag\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value\"\xaf\x03\n\"CPublishedFile_QueryFiles_Response\x12[\n\x05tota\
    l\x18\x01\x20\x01(\rR\x05totalBE\x82\xb5\x18ANumber\x20of\x20matches\x20\
    found,\x20not\x20necessarily\x20number\x20of\x20items\x20returned\x12\
    \xa3\x01\n\x14publishedfiledetails\x18\x02\x20\x03(\x0b2\x15.PublishedFi\
    leDetailsR\x14publishedfiledetailsBX\x82\xb5\x18TEach\x20file\x20details\
    \x20will\x20be\x20populated,\x20depending\x20on\x20what\x20return\x20val\
    ues\x20were\x20requested.\x12\x85\x01\n\x0bnext_cursor\x18\x03\x20\x01(\
    \tR\nnextCursorBd\x82\xb5\x18`If\x20a\x20paging\x20cursor\x20was\x20used\
    ,\x20then\x20this\x20will\x20be\x20the\x20next\x20cursor\x20to\x20use\
    \x20for\x20paging\x20through\x20results\"\x8f\x01\n)CPublishedFile_AddAp\
    pRelationship_Request\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\
    \x0fpublishedfileid\x12\x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12\
    \"\n\x0crelationship\x18\x03\x20\x01(\rR\x0crelationship\",\n*CPublished\
    File_AddAppRelationship_Response\"\x92\x01\n,CPublishedFile_RemoveAppRel\
    ationship_Request\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpub\
    lishedfileid\x12\x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12\"\n\x0c\
    relationship\x18\x03\x20\x01(\rR\x0crelationship\"/\n-CPublishedFile_Rem\
    oveAppRelationship_Response\"V\n*CPublishedFile_GetAppRelationships_Requ\
    est\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\"\
    \xe5\x01\n+CPublishedFile_GetAppRelationships_Response\x12i\n\x11app_rel\
    ationships\x18\x03\x20\x03(\x0b2<.CPublishedFile_GetAppRelationships_Res\
    ponse.AppRelationshipR\x10appRelationships\x1aK\n\x0fAppRelationship\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\"\n\x0crelationship\x18\
    \x02\x20\x01(\rR\x0crelationship\"p\n,CPublishedFile_StartPlaytimeTracki\
    ng_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12*\n\x10pub\
    lishedfileids\x18\x02\x20\x03(\x04R\x10publishedfileids\"/\n-CPublishedF\
    ile_StartPlaytimeTracking_Response\"o\n+CPublishedFile_StopPlaytimeTrack\
    ing_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12*\n\x10pu\
    blishedfileids\x18\x02\x20\x03(\x04R\x10publishedfileids\".\n,CPublished\
    File_StopPlaytimeTracking_Response\"Q\n9CPublishedFile_StopPlaytimeTrack\
    ingForAllAppItems_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appi\
    d\"<\n:CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response\"\xc0\
    \x02\n6CPublishedFile_SetPlaytimeForControllerConfigs_Request\x12\x14\n\
    \x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x85\x01\n\x17controller_confi\
    g_usage\x18\x02\x20\x03(\x0b2M.CPublishedFile_SetPlaytimeForControllerCo\
    nfigs_Request.ControllerConfigUsageR\x15controllerConfigUsage\x1ah\n\x15\
    ControllerConfigUsage\x12(\n\x0fpublishedfileid\x18\x01\x20\x01(\x04R\
    \x0fpublishedfileid\x12%\n\x0eseconds_active\x18\x02\x20\x01(\x02R\rseco\
    ndsActive\"9\n7CPublishedFile_SetPlaytimeForControllerConfigs_Response\"\
    \x80\x01\n\x1fCPublishedFile_AddChild_Request\x12(\n\x0fpublishedfileid\
    \x18\x01\x20\x01(\x04R\x0fpublishedfileid\x123\n\x15child_publishedfilei\
    d\x18\x02\x20\x01(\x04R\x14childPublishedfileid\"\"\n\x20CPublishedFile_\
    AddChild_Response\"\x83\x01\n\"CPublishedFile_RemoveChild_Request\x12(\n\
    \x0fpublishedfileid\x18\x01\x20\x01(\x04R\x0fpublishedfileid\x123\n\x15c\
    hild_publishedfileid\x18\x02\x20\x01(\x04R\x14childPublishedfileid\"%\n#\
    CPublishedFile_RemoveChild_Response\"W\n)CPublishedFile_GetUserVoteSumma\
    ry_Request\x12*\n\x10publishedfileids\x18\x01\x20\x03(\x06R\x10published\
    fileids\"\x97\x02\n*CPublishedFile_GetUserVoteSummary_Response\x12U\n\ts\
    ummaries\x18\x01\x20\x03(\x0b27.CPublishedFile_GetUserVoteSummary_Respon\
    se.VoteSummaryR\tsummaries\x1a\x91\x01\n\x0bVoteSummary\x12(\n\x0fpublis\
    hedfileid\x18\x01\x20\x01(\x06R\x0fpublishedfileid\x12\x19\n\x08vote_for\
    \x18\x02\x20\x01(\x08R\x07voteFor\x12!\n\x0cvote_against\x18\x03\x20\x01\
    (\x08R\x0bvoteAgainst\x12\x1a\n\x08reported\x18\x04\x20\x01(\x08R\x08rep\
    orted\"\xbf\x06\n*CPublishedFile_FileSubscribed_Notification\x12Q\n\x11p\
    ublished_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileIdB%\x82\xb5\x18!\
    PublishedFileID_t\x20for\x20the\x20content\x12\x15\n\x06app_id\x18\x02\
    \x20\x01(\rR\x05appId\x12H\n\rfile_hcontent\x18\x03\x20\x01(\x06R\x0cfil\
    eHcontentB#\x82\xb5\x18\x1fUGC\x20file\x20handle\x20or\x20manifest\x20GI\
    D\x12\x1b\n\tfile_size\x18\x04\x20\x01(\rR\x08fileSize\x12)\n\x10rtime_s\
    ubscribed\x18\x05\x20\x01(\rR\x0frtimeSubscribed\x12^\n\x10is_depot_cont\
    ent\x18\x06\x20\x01(\x08R\x0eisDepotContentB4\x82\xb5\x180True\x20if\x20\
    workshop\x20item\x20is\x20delivered\x20via\x20Steampipe\x12B\n\rrtime_up\
    dated\x18\x07\x20\x01(\rR\x0crtimeUpdatedB\x1d\x82\xb5\x18\x19Last\x20ti\
    me\x20content\x20updated\x12\x8d\x01\n\trevisions\x18\x08\x20\x03(\x0b28\
    .CPublishedFile_FileSubscribed_Notification.RevisionDataR\trevisionsB5\
    \x82\xb5\x181Data\x20for\x20each\x20of\x20the\x20revisions\x20that\x20th\
    is\x20item\x20has\x1a\xe0\x01\n\x0cRevisionData\x12U\n\x08revision\x18\
    \x01\x20\x01(\x0e2\x17.EPublishedFileRevision:\x20k_EPublishedFileRevisi\
    on_DefaultR\x08revision\x125\n\rfile_hcontent\x18\x02\x20\x01(\x06R\x0cf\
    ileHcontentB\x10\x82\xb5\x18\x0cManifest\x20GID\x12B\n\rrtime_updated\
    \x18\x03\x20\x01(\rR\x0crtimeUpdatedB\x1d\x82\xb5\x18\x19Last\x20time\
    \x20content\x20updated\"\x98\x01\n,CPublishedFile_FileUnsubscribed_Notif\
    ication\x12Q\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFi\
    leIdB%\x82\xb5\x18!PublishedFileID_t\x20for\x20the\x20content\x12\x15\n\
    \x06app_id\x18\x02\x20\x01(\rR\x05appId\"\x9a\x01\n.CPublishedFile_FileD\
    eleted_Client_Notification\x12Q\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileIdB%\x82\xb5\x18!PublishedFileID_t\x20for\x20the\
    \x20content\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId*\xab\x02\n\
    \x16EPublishedFileRevision\x12$\n\x20k_EPublishedFileRevision_Default\
    \x10\0\x12#\n\x1fk_EPublishedFileRevision_Latest\x10\x01\x12-\n)k_EPubli\
    shedFileRevision_ApprovedSnapshot\x10\x02\x123\n/k_EPublishedFileRevisio\
    n_ApprovedSnapshot_China\x10\x03\x12-\n)k_EPublishedFileRevision_Rejecte\
    dSnapshot\x10\x04\x123\n/k_EPublishedFileRevision_RejectedSnapshot_China\
    \x10\x05*\xc8\x01\n\x1bEPublishedFileForSaleStatus\x12\x16\n\x12k_PFFSS_\
    NotForSale\x10\0\x12\x1b\n\x17k_PFFSS_PendingApproval\x10\x01\x12\x1b\n\
    \x17k_PFFSS_ApprovedForSale\x10\x02\x12\x1b\n\x17k_PFFSS_RejectedForSale\
    \x10\x03\x12\x1b\n\x17k_PFFSS_NoLongerForSale\x10\x04\x12\x1d\n\x19k_PFF\
    SS_TentativeApproval\x10\x052\xd7\x1e\n\rPublishedFile\x12\x81\x01\n\tSu\
    bscribe\x12!.CPublishedFile_Subscribe_Request\x1a\".CPublishedFile_Subsc\
    ribe_Response\"-\x82\xb5\x18)Subscribes\x20the\x20user\x20to\x20the\x20p\
    ublished\x20file\x12\x8b\x01\n\x0bUnsubscribe\x12#.CPublishedFile_Unsubs\
    cribe_Request\x1a$.CPublishedFile_Unsubscribe_Response\"1\x82\xb5\x18-Un\
    subscribes\x20the\x20user\x20from\x20the\x20published\x20file\x12\x96\
    \x01\n\x0cCanSubscribe\x12$.CPublishedFile_CanSubscribe_Request\x1a%.CPu\
    blishedFile_CanSubscribe_Response\"9\x82\xb5\x185Check\x20if\x20the\x20u\
    ser\x20can\x20subscribe\x20to\x20the\x20published\x20file\x12\x80\x01\n\
    \x07Publish\x12\x1f.CPublishedFile_Publish_Request\x1a\x20.CPublishedFil\
    e_Publish_Response\"2\x82\xb5\x18.Publishes\x20a\x20clouded\x20user\x20f\
    ile\x20to\x20the\x20Workshop.\x12\x90\x01\n\nGetDetails\x12\".CPublished\
    File_GetDetails_Request\x1a#.CPublishedFile_GetDetails_Response\"9\x82\
    \xb5\x185Retrieves\x20information\x20about\x20a\x20set\x20of\x20publishe\
    d\x20files.\x12\x93\x01\n\x0bGetItemInfo\x12#.CPublishedFile_GetItemInfo\
    _Request\x1a$.CPublishedFile_GetItemInfo_Response\"9\x82\xb5\x185Retriev\
    es\x20information\x20about\x20a\x20set\x20of\x20published\x20files.\x12\
    \x85\x01\n\x0cGetUserFiles\x12$.CPublishedFile_GetUserFiles_Request\x1a%\
    .CPublishedFile_GetUserFiles_Response\"(\x82\xb5\x18$Retrieves\x20files\
    \x20published\x20by\x20a\x20user.\x12\xd5\x01\n\x1aAreFilesInSubscriptio\
    nList\x122.CPublishedFile_AreFilesInSubscriptionList_Request\x1a3.CPubli\
    shedFile_AreFilesInSubscriptionList_Response\"N\x82\xb5\x18JDetermines\
    \x20which\x20files\x20in\x20the\x20given\x20list\x20are\x20in\x20a\x20us\
    er's\x20subscription\x20list\x12z\n\x06Update\x12\x1e.CPublishedFile_Upd\
    ate_Request\x1a\x1f.CPublishedFile_Update_Response\"/\x82\xb5\x18+Update\
    s\x20information\x20about\x20a\x20published\x20file.\x12\xc0\x01\n\x15Ge\
    tChangeHistoryEntry\x12-.CPublishedFile_GetChangeHistoryEntry_Request\
    \x1a..CPublishedFile_GetChangeHistoryEntry_Response\"H\x82\xb5\x18DRetur\
    ns\x20data\x20on\x20a\x20specific\x20change\x20history\x20entry\x20for\
    \x20a\x20published\x20file\x12\xa4\x01\n\x10GetChangeHistory\x12(.CPubli\
    shedFile_GetChangeHistory_Request\x1a).CPublishedFile_GetChangeHistory_R\
    esponse\";\x82\xb5\x187Returns\x20data\x20on\x20the\x20change\x20history\
    \x20for\x20a\x20published\x20file\x12\x98\x01\n\x12RefreshVotingQueue\
    \x12*.CPublishedFile_RefreshVotingQueue_Request\x1a+.CPublishedFile_Refr\
    eshVotingQueue_Response\")\x82\xb5\x18%Refresh\x20the\x20voting\x20queue\
    \x20for\x20the\x20user\x12\x86\x01\n\nQueryFiles\x12\".CPublishedFile_Qu\
    eryFiles_Request\x1a#.CPublishedFile_QueryFiles_Response\"/\x82\xb5\x18+\
    Performs\x20a\x20search\x20query\x20for\x20published\x20files\x12\xb3\
    \x01\n\x12AddAppRelationship\x12*.CPublishedFile_AddAppRelationship_Requ\
    est\x1a+.CPublishedFile_AddAppRelationship_Response\"D\x82\xb5\x18@Adds\
    \x20a\x20relationship\x20between\x20the\x20published\x20file\x20and\x20t\
    he\x20given\x20app\x12\xbe\x01\n\x15RemoveAppRelationship\x12-.CPublishe\
    dFile_RemoveAppRelationship_Request\x1a..CPublishedFile_RemoveAppRelatio\
    nship_Response\"F\x82\xb5\x18BRemove\x20a\x20relationship\x20between\x20\
    the\x20published\x20file\x20and\x20the\x20given\x20app\x12\xb3\x01\n\x13\
    GetAppRelationships\x12+.CPublishedFile_GetAppRelationships_Request\x1a,\
    .CPublishedFile_GetAppRelationships_Response\"A\x82\xb5\x18=Returns\x20t\
    he\x20list\x20of\x20app\x20relationships\x20for\x20this\x20published\x20\
    file\x12\xb3\x01\n\x15StartPlaytimeTracking\x12-.CPublishedFile_StartPla\
    ytimeTracking_Request\x1a..CPublishedFile_StartPlaytimeTracking_Response\
    \";\x82\xb5\x187Start\x20usage\x20tracking\x20for\x20a\x20given\x20set\
    \x20of\x20published\x20files\x12\xb0\x01\n\x14StopPlaytimeTracking\x12,.\
    CPublishedFile_StopPlaytimeTracking_Request\x1a-.CPublishedFile_StopPlay\
    timeTracking_Response\";\x82\xb5\x187Stops\x20usage\x20tracking\x20for\
    \x20a\x20given\x20set\x20of\x20published\x20files\x12\xed\x01\n\"StopPla\
    ytimeTrackingForAllAppItems\x12:.CPublishedFile_StopPlaytimeTrackingForA\
    llAppItems_Request\x1a;.CPublishedFile_StopPlaytimeTrackingForAllAppItem\
    s_Response\"N\x82\xb5\x18JStops\x20usage\x20tracking\x20for\x20all\x20it\
    ems\x20currently\x20tracked\x20for\x20the\x20specified\x20app\x12\x98\
    \x02\n\x1fSetPlaytimeForControllerConfigs\x127.CPublishedFile_SetPlaytim\
    eForControllerConfigs_Request\x1a8.CPublishedFile_SetPlaytimeForControll\
    erConfigs_Response\"\x81\x01\x82\xb5\x18}Stops\x20usage\x20tracking\x20a\
    ll\x20controller\x20configs\x20for\x20the\x20given\x20app\x20and\x20set\
    \x20the\x20usage\x20time\x20for\x20the\x20for\x20the\x20given\x20control\
    ler\x20configs\x12\x8f\x01\n\x08AddChild\x12\x20.CPublishedFile_AddChild\
    _Request\x1a!.CPublishedFile_AddChild_Response\">\x82\xb5\x18:Adds\x20a\
    \x20parent->child\x20relationship\x20between\x20the\x20given\x20items.\
    \x12\x99\x01\n\x0bRemoveChild\x12#.CPublishedFile_RemoveChild_Request\
    \x1a$.CPublishedFile_RemoveChild_Response\"?\x82\xb5\x18;Removes\x20pare\
    nt->child\x20relationship\x20between\x20the\x20given\x20items.\x12\x88\
    \x01\n\x12GetUserVoteSummary\x12*.CPublishedFile_GetUserVoteSummary_Requ\
    est\x1a+.CPublishedFile_GetUserVoteSummary_Response\"\x19\x82\xb5\x18\
    \x15Get\x20user\x20vote\x20summary\x1a+\x82\xb5\x18'A\x20service\x20to\
    \x20access\x20published\x20file\x20data2\x8d\x04\n\x13PublishedFileClien\
    t\x12\x93\x01\n\x14NotifyFileSubscribed\x12+.CPublishedFile_FileSubscrib\
    ed_Notification\x1a\x0b.NoResponse\"A\x82\xb5\x18=Notification\x20from\
    \x20the\x20server\x20when\x20a\x20user\x20subscribes\x20to\x20a\x20file\
    \x12\x9b\x01\n\x16NotifyFileUnsubscribed\x12-.CPublishedFile_FileUnsubsc\
    ribed_Notification\x1a\x0b.NoResponse\"E\x82\xb5\x18ANotification\x20fro\
    m\x20the\x20server\x20when\x20a\x20user\x20unsubscribes\x20from\x20a\x20\
    file\x12\x94\x01\n\x11NotifyFileDeleted\x12/.CPublishedFile_FileDeleted_\
    Client_Notification\x1a\x0b.NoResponse\"A\x82\xb5\x18=Notification\x20fr\
    om\x20the\x20server\x20when\x20a\x20published\x20file\x20is\x20deleted\
    \x1a+\x82\xb5\x18#Published\x20file\x20client\x20notifications\xc0\xb5\
    \x18\x02B\x03\x80\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
