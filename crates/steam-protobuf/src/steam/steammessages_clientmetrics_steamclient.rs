// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `steammessages_clientmetrics.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CClientMetrics_AppInterfaceCreation {
    // message fields
    raw_version: ::protobuf::SingularField<::std::string::String>,
    requested_interface_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceCreation {
    fn default() -> &'a CClientMetrics_AppInterfaceCreation {
        <CClientMetrics_AppInterfaceCreation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceCreation {
    pub fn new() -> CClientMetrics_AppInterfaceCreation {
        ::std::default::Default::default()
    }

    // optional string raw_version = 1;

    pub fn get_raw_version(&self) -> &str {
        match self.raw_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_raw_version(&mut self) {
        self.raw_version.clear();
    }

    pub fn has_raw_version(&self) -> bool {
        self.raw_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_version(&mut self, v: ::std::string::String) {
        self.raw_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_version(&mut self) -> &mut ::std::string::String {
        if self.raw_version.is_none() {
            self.raw_version.set_default();
        }
        self.raw_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_version(&mut self) -> ::std::string::String {
        self.raw_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requested_interface_type = 2;

    pub fn get_requested_interface_type(&self) -> &str {
        match self.requested_interface_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requested_interface_type(&mut self) {
        self.requested_interface_type.clear();
    }

    pub fn has_requested_interface_type(&self) -> bool {
        self.requested_interface_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_interface_type(&mut self, v: ::std::string::String) {
        self.requested_interface_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requested_interface_type(&mut self) -> &mut ::std::string::String {
        if self.requested_interface_type.is_none() {
            self.requested_interface_type.set_default();
        }
        self.requested_interface_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_requested_interface_type(&mut self) -> ::std::string::String {
        self.requested_interface_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceCreation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.raw_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.requested_interface_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.raw_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.raw_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.requested_interface_type.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceCreation {
        CClientMetrics_AppInterfaceCreation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "raw_version",
                |m: &CClientMetrics_AppInterfaceCreation| { &m.raw_version },
                |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.raw_version },
                CClientMetrics_AppInterfaceCreation::get_raw_version,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "requested_interface_type",
                |m: &CClientMetrics_AppInterfaceCreation| { &m.requested_interface_type },
                |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.requested_interface_type },
                CClientMetrics_AppInterfaceCreation::get_requested_interface_type,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_AppInterfaceCreation>(
                "CClientMetrics_AppInterfaceCreation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceCreation {
        static instance: ::protobuf::rt::Lazy<CClientMetrics_AppInterfaceCreation> = ::protobuf::rt::Lazy::INIT;
        instance.get(CClientMetrics_AppInterfaceCreation::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceCreation {
    fn clear(&mut self) {
        self.raw_version.clear();
        self.requested_interface_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceCreation {
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientMetrics_AppInterfaceMethodCounts {
    // message fields
    interface_name: ::protobuf::SingularField<::std::string::String>,
    method_name: ::protobuf::SingularField<::std::string::String>,
    call_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceMethodCounts {
    fn default() -> &'a CClientMetrics_AppInterfaceMethodCounts {
        <CClientMetrics_AppInterfaceMethodCounts as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceMethodCounts {
    pub fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        ::std::default::Default::default()
    }

    // optional string interface_name = 1;

    pub fn get_interface_name(&self) -> &str {
        match self.interface_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interface_name(&mut self) {
        self.interface_name.clear();
    }

    pub fn has_interface_name(&self) -> bool {
        self.interface_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_name(&mut self, v: ::std::string::String) {
        self.interface_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_name(&mut self) -> &mut ::std::string::String {
        if self.interface_name.is_none() {
            self.interface_name.set_default();
        }
        self.interface_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface_name(&mut self) -> ::std::string::String {
        self.interface_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string method_name = 2;

    pub fn get_method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name.set_default();
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 call_count = 3;

    pub fn get_call_count(&self) -> u32 {
        self.call_count.unwrap_or(0)
    }

    pub fn clear_call_count(&mut self) {
        self.call_count = ::std::option::Option::None;
    }

    pub fn has_call_count(&self) -> bool {
        self.call_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_count(&mut self, v: u32) {
        self.call_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceMethodCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.interface_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.method_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.call_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.interface_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.call_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.interface_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.method_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.call_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        CClientMetrics_AppInterfaceMethodCounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "interface_name",
                |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.interface_name },
                |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.interface_name },
                CClientMetrics_AppInterfaceMethodCounts::get_interface_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "method_name",
                |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.method_name },
                |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.method_name },
                CClientMetrics_AppInterfaceMethodCounts::get_method_name,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "call_count",
                |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.call_count },
                |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.call_count },
                CClientMetrics_AppInterfaceMethodCounts::get_call_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_AppInterfaceMethodCounts>(
                "CClientMetrics_AppInterfaceMethodCounts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceMethodCounts {
        static instance: ::protobuf::rt::Lazy<CClientMetrics_AppInterfaceMethodCounts> = ::protobuf::rt::Lazy::INIT;
        instance.get(CClientMetrics_AppInterfaceMethodCounts::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceMethodCounts {
    fn clear(&mut self) {
        self.interface_name.clear();
        self.method_name.clear();
        self.call_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceMethodCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceMethodCounts {
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientMetrics_AppInterfaceStats_Notification {
    // message fields
    game_id: ::std::option::Option<u64>,
    pub interfaces_created: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation>,
    pub methods_called: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts>,
    session_length_seconds: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceStats_Notification {
    fn default() -> &'a CClientMetrics_AppInterfaceStats_Notification {
        <CClientMetrics_AppInterfaceStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceStats_Notification {
    pub fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;

    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 session_length_seconds = 4;

    pub fn get_session_length_seconds(&self) -> u32 {
        self.session_length_seconds.unwrap_or(0)
    }

    pub fn clear_session_length_seconds(&mut self) {
        self.session_length_seconds = ::std::option::Option::None;
    }

    pub fn has_session_length_seconds(&self) -> bool {
        self.session_length_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_seconds(&mut self, v: u32) {
        self.session_length_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceStats_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.interfaces_created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.methods_called {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.interfaces_created)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.methods_called)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.session_length_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.interfaces_created {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.methods_called {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.session_length_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.interfaces_created {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.methods_called {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.session_length_seconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        CClientMetrics_AppInterfaceStats_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "game_id",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.game_id },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.game_id },
                CClientMetrics_AppInterfaceStats_Notification::get_game_id,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CClientMetrics_AppInterfaceCreation>>(
                "interfaces_created",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.interfaces_created },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.interfaces_created },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CClientMetrics_AppInterfaceMethodCounts>>(
                "methods_called",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.methods_called },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.methods_called },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "session_length_seconds",
                |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.session_length_seconds },
                |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.session_length_seconds },
                CClientMetrics_AppInterfaceStats_Notification::get_session_length_seconds,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_AppInterfaceStats_Notification>(
                "CClientMetrics_AppInterfaceStats_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceStats_Notification {
        static instance: ::protobuf::rt::Lazy<CClientMetrics_AppInterfaceStats_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CClientMetrics_AppInterfaceStats_Notification::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceStats_Notification {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.interfaces_created.clear();
        self.methods_called.clear();
        self.session_length_seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceStats_Notification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientMetrics_IPv6Connectivity_Result {
    // message fields
    protocol_tested: ::std::option::Option<u32>,
    connectivity_state: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Result {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Result {
        <CClientMetrics_IPv6Connectivity_Result as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Result {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Result {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_tested = 1;

    pub fn get_protocol_tested(&self) -> u32 {
        self.protocol_tested.unwrap_or(0)
    }

    pub fn clear_protocol_tested(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
    }

    pub fn has_protocol_tested(&self) -> bool {
        self.protocol_tested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_tested(&mut self, v: u32) {
        self.protocol_tested = ::std::option::Option::Some(v);
    }

    // optional uint32 connectivity_state = 2;

    pub fn get_connectivity_state(&self) -> u32 {
        self.connectivity_state.unwrap_or(0)
    }

    pub fn clear_connectivity_state(&mut self) {
        self.connectivity_state = ::std::option::Option::None;
    }

    pub fn has_connectivity_state(&self) -> bool {
        self.connectivity_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectivity_state(&mut self, v: u32) {
        self.connectivity_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.protocol_tested = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.connectivity_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_tested {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connectivity_state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_tested {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connectivity_state {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Result {
        CClientMetrics_IPv6Connectivity_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "protocol_tested",
                |m: &CClientMetrics_IPv6Connectivity_Result| { &m.protocol_tested },
                |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.protocol_tested },
                CClientMetrics_IPv6Connectivity_Result::get_protocol_tested,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "connectivity_state",
                |m: &CClientMetrics_IPv6Connectivity_Result| { &m.connectivity_state },
                |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.connectivity_state },
                CClientMetrics_IPv6Connectivity_Result::get_connectivity_state,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_IPv6Connectivity_Result>(
                "CClientMetrics_IPv6Connectivity_Result",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Result {
        static instance: ::protobuf::rt::Lazy<CClientMetrics_IPv6Connectivity_Result> = ::protobuf::rt::Lazy::INIT;
        instance.get(CClientMetrics_IPv6Connectivity_Result::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_IPv6Connectivity_Result {
    fn clear(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
        self.connectivity_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_IPv6Connectivity_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Result {
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientMetrics_IPv6Connectivity_Notification {
    // message fields
    cell_id: ::std::option::Option<u32>,
    pub results: ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result>,
    private_ip_is_rfc6598: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Notification {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Notification {
        <CClientMetrics_IPv6Connectivity_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Notification {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;

    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // optional bool private_ip_is_rfc6598 = 3;

    pub fn get_private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.unwrap_or(false)
    }

    pub fn clear_private_ip_is_rfc6598(&mut self) {
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
    }

    pub fn has_private_ip_is_rfc6598(&self) -> bool {
        self.private_ip_is_rfc6598.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_ip_is_rfc6598(&mut self, v: bool) {
        self.private_ip_is_rfc6598 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cell_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.results)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.private_ip_is_rfc6598 = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.private_ip_is_rfc6598 {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        CClientMetrics_IPv6Connectivity_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "cell_id",
                |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.cell_id },
                |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.cell_id },
                CClientMetrics_IPv6Connectivity_Notification::get_cell_id,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CClientMetrics_IPv6Connectivity_Result>>(
                "results",
                |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.results },
                |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.results },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "private_ip_is_rfc6598",
                |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.private_ip_is_rfc6598 },
                |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.private_ip_is_rfc6598 },
                CClientMetrics_IPv6Connectivity_Notification::get_private_ip_is_rfc6598,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_IPv6Connectivity_Notification>(
                "CClientMetrics_IPv6Connectivity_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Notification {
        static instance: ::protobuf::rt::Lazy<CClientMetrics_IPv6Connectivity_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CClientMetrics_IPv6Connectivity_Notification::new)
    }
}

impl ::protobuf::Clear for CClientMetrics_IPv6Connectivity_Notification {
    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.results.clear();
        self.private_ip_is_rfc6598 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_IPv6Connectivity_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Notification {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_clientmetrics.steamclient.proto\x1a,steammessages_unifi\
    ed_base.steamclient.proto\"\x80\x01\n#CClientMetrics_AppInterfaceCreatio\
    n\x12\x1f\n\x0braw_version\x18\x01\x20\x01(\tR\nrawVersion\x128\n\x18req\
    uested_interface_type\x18\x02\x20\x01(\tR\x16requestedInterfaceType\"\
    \x90\x01\n'CClientMetrics_AppInterfaceMethodCounts\x12%\n\x0einterface_n\
    ame\x18\x01\x20\x01(\tR\rinterfaceName\x12\x1f\n\x0bmethod_name\x18\x02\
    \x20\x01(\tR\nmethodName\x12\x1d\n\ncall_count\x18\x03\x20\x01(\rR\tcall\
    Count\"\xa4\x02\n-CClientMetrics_AppInterfaceStats_Notification\x12\x17\
    \n\x07game_id\x18\x01\x20\x01(\x04R\x06gameId\x12S\n\x12interfaces_creat\
    ed\x18\x02\x20\x03(\x0b2$.CClientMetrics_AppInterfaceCreationR\x11interf\
    acesCreated\x12O\n\x0emethods_called\x18\x03\x20\x03(\x0b2(.CClientMetri\
    cs_AppInterfaceMethodCountsR\rmethodsCalled\x124\n\x16session_length_sec\
    onds\x18\x04\x20\x01(\rR\x14sessionLengthSeconds\"\x80\x01\n&CClientMetr\
    ics_IPv6Connectivity_Result\x12'\n\x0fprotocol_tested\x18\x01\x20\x01(\r\
    R\x0eprotocolTested\x12-\n\x12connectivity_state\x18\x02\x20\x01(\rR\x11\
    connectivityState\"\xbd\x01\n,CClientMetrics_IPv6Connectivity_Notificati\
    on\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellId\x12A\n\x07results\
    \x18\x02\x20\x03(\x0b2'.CClientMetrics_IPv6Connectivity_ResultR\x07resul\
    ts\x121\n\x15private_ip_is_rfc6598\x18\x03\x20\x01(\x08R\x12privateIpIsR\
    fc65982\xf4\x01\n\rClientMetrics\x12\\\n\x1dClientAppInterfaceStatsRepor\
    t\x12..CClientMetrics_AppInterfaceStats_Notification\x1a\x0b.NoResponse\
    \x12Z\n\x1cClientIPv6ConnectivityReport\x12-.CClientMetrics_IPv6Connecti\
    vity_Notification\x1a\x0b.NoResponse\x1a)\x82\xb5\x18%A\x20service\x20fo\
    r\x20client-reported\x20metricsB\x03\x80\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
