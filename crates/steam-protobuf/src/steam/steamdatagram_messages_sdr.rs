// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steamdatagram_messages_sdr.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterPingReply {
    // message fields
    client_timestamp: ::std::option::Option<u32>,
    pub latency_datacenter_ids: ::std::vec::Vec<u32>,
    pub latency_ping_ms: ::std::vec::Vec<u32>,
    your_public_ip: ::std::option::Option<u32>,
    your_public_port: ::std::option::Option<u32>,
    server_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    client_cookie: ::std::option::Option<u32>,
    scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    pub route_exceptions: ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException>,
    pub alt_addresses: ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_AltAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply {
        <CMsgSteamDatagramRouterPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply {
    pub fn new() -> CMsgSteamDatagramRouterPingReply {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp = 1;


    pub fn get_client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }
    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // repeated fixed32 latency_datacenter_ids = 2;


    pub fn get_latency_datacenter_ids(&self) -> &[u32] {
        &self.latency_datacenter_ids
    }
    pub fn clear_latency_datacenter_ids(&mut self) {
        self.latency_datacenter_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_latency_datacenter_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.latency_datacenter_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latency_datacenter_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.latency_datacenter_ids
    }

    // Take field
    pub fn take_latency_datacenter_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.latency_datacenter_ids, ::std::vec::Vec::new())
    }

    // repeated uint32 latency_ping_ms = 3;


    pub fn get_latency_ping_ms(&self) -> &[u32] {
        &self.latency_ping_ms
    }
    pub fn clear_latency_ping_ms(&mut self) {
        self.latency_ping_ms.clear();
    }

    // Param is passed by value, moved
    pub fn set_latency_ping_ms(&mut self, v: ::std::vec::Vec<u32>) {
        self.latency_ping_ms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latency_ping_ms(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.latency_ping_ms
    }

    // Take field
    pub fn take_latency_ping_ms(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.latency_ping_ms, ::std::vec::Vec::new())
    }

    // optional fixed32 your_public_ip = 4;


    pub fn get_your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }
    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_port = 11;


    pub fn get_your_public_port(&self) -> u32 {
        self.your_public_port.unwrap_or(0)
    }
    pub fn clear_your_public_port(&mut self) {
        self.your_public_port = ::std::option::Option::None;
    }

    pub fn has_your_public_port(&self) -> bool {
        self.your_public_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_port(&mut self, v: u32) {
        self.your_public_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 5;


    pub fn get_server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }
    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 6;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 7;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 8;


    pub fn get_client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }
    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 9;


    pub fn get_scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }
    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 12;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramRouterPingReply.RouteException route_exceptions = 10;


    pub fn get_route_exceptions(&self) -> &[CMsgSteamDatagramRouterPingReply_RouteException] {
        &self.route_exceptions
    }
    pub fn clear_route_exceptions(&mut self) {
        self.route_exceptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_exceptions(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException>) {
        self.route_exceptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_exceptions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException> {
        &mut self.route_exceptions
    }

    // Take field
    pub fn take_route_exceptions(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_RouteException> {
        ::std::mem::replace(&mut self.route_exceptions, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgSteamDatagramRouterPingReply.AltAddress alt_addresses = 13;


    pub fn get_alt_addresses(&self) -> &[CMsgSteamDatagramRouterPingReply_AltAddress] {
        &self.alt_addresses
    }
    pub fn clear_alt_addresses(&mut self) {
        self.alt_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_alt_addresses(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_AltAddress>) {
        self.alt_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alt_addresses(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_AltAddress> {
        &mut self.alt_addresses
    }

    // Take field
    pub fn take_alt_addresses(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramRouterPingReply_AltAddress> {
        ::std::mem::replace(&mut self.alt_addresses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterPingReply {
    fn is_initialized(&self) -> bool {
        for v in &self.route_exceptions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alt_addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.latency_datacenter_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.latency_ping_ms)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_ip = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_cookie = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_exceptions)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.alt_addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_timestamp {
            my_size += 5;
        }
        if !self.latency_datacenter_ids.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.latency_datacenter_ids.len() * 4) as u32) + (self.latency_datacenter_ids.len() * 4) as u32;
        }
        if !self.latency_ping_ms.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(3, &self.latency_ping_ms);
        }
        if let Some(v) = self.your_public_ip {
            my_size += 5;
        }
        if let Some(v) = self.your_public_port {
            my_size += 5;
        }
        if let Some(v) = self.server_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_cookie {
            my_size += 5;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_exceptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.alt_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(1, v)?;
        }
        if !self.latency_datacenter_ids.is_empty() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.latency_datacenter_ids.len() * 4) as u32)?;
            for v in &self.latency_datacenter_ids {
                os.write_fixed32_no_tag(*v)?;
            };
        }
        if !self.latency_ping_ms.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.latency_ping_ms))?;
            for v in &self.latency_ping_ms {
                os.write_uint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.your_public_port {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        for v in &self.route_exceptions {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.alt_addresses {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterPingReply {
        CMsgSteamDatagramRouterPingReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_timestamp",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.client_timestamp },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "latency_datacenter_ids",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_datacenter_ids },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_datacenter_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "latency_ping_ms",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_ping_ms },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_ip",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.your_public_ip },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.your_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_port",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.your_public_port },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.your_public_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_time",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.server_time },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.server_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.challenge },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_cookie",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.client_cookie },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_cookie },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scoring_penalty_relay_cluster",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.scoring_penalty_relay_cluster },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.scoring_penalty_relay_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.flags },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramRouterPingReply_RouteException>>(
                "route_exceptions",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.route_exceptions },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.route_exceptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramRouterPingReply_AltAddress>>(
                "alt_addresses",
                |m: &CMsgSteamDatagramRouterPingReply| { &m.alt_addresses },
                |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.alt_addresses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterPingReply>(
                "CMsgSteamDatagramRouterPingReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterPingReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterPingReply::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterPingReply {
    fn clear(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
        self.latency_datacenter_ids.clear();
        self.latency_ping_ms.clear();
        self.your_public_ip = ::std::option::Option::None;
        self.your_public_port = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.route_exceptions.clear();
        self.alt_addresses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterPingReply_RouteException {
    // message fields
    data_center_id: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    penalty: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply_RouteException {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply_RouteException {
        <CMsgSteamDatagramRouterPingReply_RouteException as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply_RouteException {
    pub fn new() -> CMsgSteamDatagramRouterPingReply_RouteException {
        ::std::default::Default::default()
    }

    // optional fixed32 data_center_id = 1;


    pub fn get_data_center_id(&self) -> u32 {
        self.data_center_id.unwrap_or(0)
    }
    pub fn clear_data_center_id(&mut self) {
        self.data_center_id = ::std::option::Option::None;
    }

    pub fn has_data_center_id(&self) -> bool {
        self.data_center_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_center_id(&mut self, v: u32) {
        self.data_center_id = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty = 3;


    pub fn get_penalty(&self) -> u32 {
        self.penalty.unwrap_or(0)
    }
    pub fn clear_penalty(&mut self) {
        self.penalty = ::std::option::Option::None;
    }

    pub fn has_penalty(&self) -> bool {
        self.penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty(&mut self, v: u32) {
        self.penalty = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterPingReply_RouteException {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.data_center_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_center_id {
            my_size += 5;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_center_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.penalty {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterPingReply_RouteException {
        CMsgSteamDatagramRouterPingReply_RouteException::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "data_center_id",
                |m: &CMsgSteamDatagramRouterPingReply_RouteException| { &m.data_center_id },
                |m: &mut CMsgSteamDatagramRouterPingReply_RouteException| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramRouterPingReply_RouteException| { &m.flags },
                |m: &mut CMsgSteamDatagramRouterPingReply_RouteException| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "penalty",
                |m: &CMsgSteamDatagramRouterPingReply_RouteException| { &m.penalty },
                |m: &mut CMsgSteamDatagramRouterPingReply_RouteException| { &mut m.penalty },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterPingReply_RouteException>(
                "CMsgSteamDatagramRouterPingReply.RouteException",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply_RouteException {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterPingReply_RouteException> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterPingReply_RouteException::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterPingReply_RouteException {
    fn clear(&mut self) {
        self.data_center_id = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.penalty = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterPingReply_RouteException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply_RouteException {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterPingReply_AltAddress {
    // message fields
    ipv4: ::std::option::Option<u32>,
    port: ::std::option::Option<u32>,
    penalty: ::std::option::Option<u32>,
    protocol: ::std::option::Option<CMsgSteamDatagramRouterPingReply_AltAddress_Protocol>,
    id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply_AltAddress {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply_AltAddress {
        <CMsgSteamDatagramRouterPingReply_AltAddress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply_AltAddress {
    pub fn new() -> CMsgSteamDatagramRouterPingReply_AltAddress {
        ::std::default::Default::default()
    }

    // optional fixed32 ipv4 = 1;


    pub fn get_ipv4(&self) -> u32 {
        self.ipv4.unwrap_or(0)
    }
    pub fn clear_ipv4(&mut self) {
        self.ipv4 = ::std::option::Option::None;
    }

    pub fn has_ipv4(&self) -> bool {
        self.ipv4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4(&mut self, v: u32) {
        self.ipv4 = ::std::option::Option::Some(v);
    }

    // optional uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty = 3;


    pub fn get_penalty(&self) -> u32 {
        self.penalty.unwrap_or(0)
    }
    pub fn clear_penalty(&mut self) {
        self.penalty = ::std::option::Option::None;
    }

    pub fn has_penalty(&self) -> bool {
        self.penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty(&mut self, v: u32) {
        self.penalty = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramRouterPingReply.AltAddress.Protocol protocol = 4;


    pub fn get_protocol(&self) -> CMsgSteamDatagramRouterPingReply_AltAddress_Protocol {
        self.protocol.unwrap_or(CMsgSteamDatagramRouterPingReply_AltAddress_Protocol::DefaultProtocol)
    }
    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: CMsgSteamDatagramRouterPingReply_AltAddress_Protocol) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // optional string id = 5;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterPingReply_AltAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ipv4 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.protocol, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ipv4 {
            my_size += 5;
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.protocol {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ipv4 {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.penalty {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.protocol {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterPingReply_AltAddress {
        CMsgSteamDatagramRouterPingReply_AltAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ipv4",
                |m: &CMsgSteamDatagramRouterPingReply_AltAddress| { &m.ipv4 },
                |m: &mut CMsgSteamDatagramRouterPingReply_AltAddress| { &mut m.ipv4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &CMsgSteamDatagramRouterPingReply_AltAddress| { &m.port },
                |m: &mut CMsgSteamDatagramRouterPingReply_AltAddress| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "penalty",
                |m: &CMsgSteamDatagramRouterPingReply_AltAddress| { &m.penalty },
                |m: &mut CMsgSteamDatagramRouterPingReply_AltAddress| { &mut m.penalty },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgSteamDatagramRouterPingReply_AltAddress_Protocol>>(
                "protocol",
                |m: &CMsgSteamDatagramRouterPingReply_AltAddress| { &m.protocol },
                |m: &mut CMsgSteamDatagramRouterPingReply_AltAddress| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &CMsgSteamDatagramRouterPingReply_AltAddress| { &m.id },
                |m: &mut CMsgSteamDatagramRouterPingReply_AltAddress| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterPingReply_AltAddress>(
                "CMsgSteamDatagramRouterPingReply.AltAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply_AltAddress {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterPingReply_AltAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterPingReply_AltAddress::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterPingReply_AltAddress {
    fn clear(&mut self) {
        self.ipv4 = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.penalty = ::std::option::Option::None;
        self.protocol = ::std::option::Option::None;
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterPingReply_AltAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply_AltAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramRouterPingReply_AltAddress_Protocol {
    DefaultProtocol = 0,
    NetworkNext = 1,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramRouterPingReply_AltAddress_Protocol {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramRouterPingReply_AltAddress_Protocol> {
        match value {
            0 => ::std::option::Option::Some(CMsgSteamDatagramRouterPingReply_AltAddress_Protocol::DefaultProtocol),
            1 => ::std::option::Option::Some(CMsgSteamDatagramRouterPingReply_AltAddress_Protocol::NetworkNext),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramRouterPingReply_AltAddress_Protocol] = &[
            CMsgSteamDatagramRouterPingReply_AltAddress_Protocol::DefaultProtocol,
            CMsgSteamDatagramRouterPingReply_AltAddress_Protocol::NetworkNext,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramRouterPingReply_AltAddress_Protocol>("CMsgSteamDatagramRouterPingReply.AltAddress.Protocol", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramRouterPingReply_AltAddress_Protocol {
}

impl ::std::default::Default for CMsgSteamDatagramRouterPingReply_AltAddress_Protocol {
    fn default() -> Self {
        CMsgSteamDatagramRouterPingReply_AltAddress_Protocol::DefaultProtocol
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply_AltAddress_Protocol {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramRouterPingReply_Flags {
    FLAG_MAYBE_MORE_DATA_CENTERS = 1,
    FLAG_MAYBE_MORE_ALT_ADDRESSES = 2,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramRouterPingReply_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramRouterPingReply_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramRouterPingReply_Flags::FLAG_MAYBE_MORE_DATA_CENTERS),
            2 => ::std::option::Option::Some(CMsgSteamDatagramRouterPingReply_Flags::FLAG_MAYBE_MORE_ALT_ADDRESSES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramRouterPingReply_Flags] = &[
            CMsgSteamDatagramRouterPingReply_Flags::FLAG_MAYBE_MORE_DATA_CENTERS,
            CMsgSteamDatagramRouterPingReply_Flags::FLAG_MAYBE_MORE_ALT_ADDRESSES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramRouterPingReply_Flags>("CMsgSteamDatagramRouterPingReply.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramRouterPingReply_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramRouterPingReply_Flags {
    fn default() -> Self {
        CMsgSteamDatagramRouterPingReply_Flags::FLAG_MAYBE_MORE_DATA_CENTERS
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverPingRequest {
    // message fields
    your_public_ip: ::std::option::Option<u32>,
    your_public_port: ::std::option::Option<u32>,
    server_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    router_timestamp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPingRequest {
    fn default() -> &'a CMsgSteamDatagramGameserverPingRequest {
        <CMsgSteamDatagramGameserverPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPingRequest {
    pub fn new() -> CMsgSteamDatagramGameserverPingRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 your_public_ip = 1;


    pub fn get_your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }
    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_port = 5;


    pub fn get_your_public_port(&self) -> u32 {
        self.your_public_port.unwrap_or(0)
    }
    pub fn clear_your_public_port(&mut self) {
        self.your_public_port = ::std::option::Option::None;
    }

    pub fn has_your_public_port(&self) -> bool {
        self.your_public_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_port(&mut self, v: u32) {
        self.your_public_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 2;


    pub fn get_server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }
    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 3;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 router_timestamp = 4;


    pub fn get_router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }
    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverPingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.router_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.your_public_ip {
            my_size += 5;
        }
        if let Some(v) = self.your_public_port {
            my_size += 5;
        }
        if let Some(v) = self.server_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.router_timestamp {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.your_public_port {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverPingRequest {
        CMsgSteamDatagramGameserverPingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_ip",
                |m: &CMsgSteamDatagramGameserverPingRequest| { &m.your_public_ip },
                |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.your_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_port",
                |m: &CMsgSteamDatagramGameserverPingRequest| { &m.your_public_port },
                |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.your_public_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_time",
                |m: &CMsgSteamDatagramGameserverPingRequest| { &m.server_time },
                |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.server_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramGameserverPingRequest| { &m.challenge },
                |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "router_timestamp",
                |m: &CMsgSteamDatagramGameserverPingRequest| { &m.router_timestamp },
                |m: &mut CMsgSteamDatagramGameserverPingRequest| { &mut m.router_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverPingRequest>(
                "CMsgSteamDatagramGameserverPingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPingRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverPingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverPingRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverPingRequest {
    fn clear(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
        self.your_public_port = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.router_timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverPingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramLegacyGameserverPingReply {
    // message fields
    router_timestamp: ::std::option::Option<u32>,
    dummy_pad: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLegacyGameserverPingReply {
    fn default() -> &'a CMsgSteamDatagramLegacyGameserverPingReply {
        <CMsgSteamDatagramLegacyGameserverPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLegacyGameserverPingReply {
    pub fn new() -> CMsgSteamDatagramLegacyGameserverPingReply {
        ::std::default::Default::default()
    }

    // optional fixed32 router_timestamp = 4;


    pub fn get_router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }
    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed64 dummy_pad = 99;


    pub fn get_dummy_pad(&self) -> u64 {
        self.dummy_pad.unwrap_or(0)
    }
    pub fn clear_dummy_pad(&mut self) {
        self.dummy_pad = ::std::option::Option::None;
    }

    pub fn has_dummy_pad(&self) -> bool {
        self.dummy_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_pad(&mut self, v: u64) {
        self.dummy_pad = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLegacyGameserverPingReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.router_timestamp = ::std::option::Option::Some(tmp);
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.dummy_pad = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.router_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.dummy_pad {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.dummy_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramLegacyGameserverPingReply {
        CMsgSteamDatagramLegacyGameserverPingReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "router_timestamp",
                |m: &CMsgSteamDatagramLegacyGameserverPingReply| { &m.router_timestamp },
                |m: &mut CMsgSteamDatagramLegacyGameserverPingReply| { &mut m.router_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "dummy_pad",
                |m: &CMsgSteamDatagramLegacyGameserverPingReply| { &m.dummy_pad },
                |m: &mut CMsgSteamDatagramLegacyGameserverPingReply| { &mut m.dummy_pad },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramLegacyGameserverPingReply>(
                "CMsgSteamDatagramLegacyGameserverPingReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramLegacyGameserverPingReply {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramLegacyGameserverPingReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramLegacyGameserverPingReply::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramLegacyGameserverPingReply {
    fn clear(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
        self.dummy_pad = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramLegacyGameserverPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLegacyGameserverPingReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverPingReply {
    // message fields
    pub cert: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    signed_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPingReply {
    fn default() -> &'a CMsgSteamDatagramGameserverPingReply {
        <CMsgSteamDatagramGameserverPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPingReply {
    pub fn new() -> CMsgSteamDatagramGameserverPingReply {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 1;


    pub fn get_cert(&self) -> &super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional bytes signed_data = 2;


    pub fn get_signed_data(&self) -> &[u8] {
        match self.signed_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signed_data(&mut self) {
        self.signed_data.clear();
    }

    pub fn has_signed_data(&self) -> bool {
        self.signed_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signed_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.signed_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signed_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signed_data.is_none() {
            self.signed_data.set_default();
        }
        self.signed_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_signed_data(&mut self) -> ::std::vec::Vec<u8> {
        self.signed_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverPingReply {
    fn is_initialized(&self) -> bool {
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signed_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.signed_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.signed_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverPingReply {
        CMsgSteamDatagramGameserverPingReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamDatagramGameserverPingReply| { &m.cert },
                |m: &mut CMsgSteamDatagramGameserverPingReply| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signed_data",
                |m: &CMsgSteamDatagramGameserverPingReply| { &m.signed_data },
                |m: &mut CMsgSteamDatagramGameserverPingReply| { &mut m.signed_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &CMsgSteamDatagramGameserverPingReply| { &m.signature },
                |m: &mut CMsgSteamDatagramGameserverPingReply| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverPingReply>(
                "CMsgSteamDatagramGameserverPingReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPingReply {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverPingReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverPingReply::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverPingReply {
    fn clear(&mut self) {
        self.cert.clear();
        self.signed_data.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverPingReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverPingReply_SignedData {
    // message fields
    challenge_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    router_timestamp: ::std::option::Option<u32>,
    data_center_id: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPingReply_SignedData {
    fn default() -> &'a CMsgSteamDatagramGameserverPingReply_SignedData {
        <CMsgSteamDatagramGameserverPingReply_SignedData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPingReply_SignedData {
    pub fn new() -> CMsgSteamDatagramGameserverPingReply_SignedData {
        ::std::default::Default::default()
    }

    // optional fixed32 challenge_time = 2;


    pub fn get_challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }
    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 3;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 router_timestamp = 4;


    pub fn get_router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }
    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 data_center_id = 5;


    pub fn get_data_center_id(&self) -> u32 {
        self.data_center_id.unwrap_or(0)
    }
    pub fn clear_data_center_id(&mut self) {
        self.data_center_id = ::std::option::Option::None;
    }

    pub fn has_data_center_id(&self) -> bool {
        self.data_center_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_center_id(&mut self, v: u32) {
        self.data_center_id = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 6;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverPingReply_SignedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.challenge_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.router_timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.data_center_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.router_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.data_center_id {
            my_size += 5;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.challenge_time {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.data_center_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverPingReply_SignedData {
        CMsgSteamDatagramGameserverPingReply_SignedData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "challenge_time",
                |m: &CMsgSteamDatagramGameserverPingReply_SignedData| { &m.challenge_time },
                |m: &mut CMsgSteamDatagramGameserverPingReply_SignedData| { &mut m.challenge_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramGameserverPingReply_SignedData| { &m.challenge },
                |m: &mut CMsgSteamDatagramGameserverPingReply_SignedData| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "router_timestamp",
                |m: &CMsgSteamDatagramGameserverPingReply_SignedData| { &m.router_timestamp },
                |m: &mut CMsgSteamDatagramGameserverPingReply_SignedData| { &mut m.router_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "data_center_id",
                |m: &CMsgSteamDatagramGameserverPingReply_SignedData| { &m.data_center_id },
                |m: &mut CMsgSteamDatagramGameserverPingReply_SignedData| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgSteamDatagramGameserverPingReply_SignedData| { &m.appid },
                |m: &mut CMsgSteamDatagramGameserverPingReply_SignedData| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverPingReply_SignedData>(
                "CMsgSteamDatagramGameserverPingReply.SignedData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPingReply_SignedData {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverPingReply_SignedData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverPingReply_SignedData::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverPingReply_SignedData {
    fn clear(&mut self) {
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.router_timestamp = ::std::option::Option::None;
        self.data_center_id = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverPingReply_SignedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverPingReply_SignedData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNoSessionRelayToClient {
    // message fields
    connection_id: ::std::option::Option<u32>,
    your_public_ip: ::std::option::Option<u32>,
    your_public_port: ::std::option::Option<u32>,
    server_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToClient {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToClient {
        <CMsgSteamDatagramNoSessionRelayToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToClient {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 7;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 2;


    pub fn get_your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }
    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_port = 6;


    pub fn get_your_public_port(&self) -> u32 {
        self.your_public_port.unwrap_or(0)
    }
    pub fn clear_your_public_port(&mut self) {
        self.your_public_port = ::std::option::Option::None;
    }

    pub fn has_your_public_port(&self) -> bool {
        self.your_public_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_port(&mut self, v: u32) {
        self.your_public_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 3;


    pub fn get_server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }
    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoSessionRelayToClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_ip = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_public_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.your_public_ip {
            my_size += 5;
        }
        if let Some(v) = self.your_public_port {
            my_size += 5;
        }
        if let Some(v) = self.server_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.your_public_port {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToClient {
        CMsgSteamDatagramNoSessionRelayToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.connection_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_ip",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.your_public_ip },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.your_public_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_public_port",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.your_public_port },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.your_public_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_time",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.server_time },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.server_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.challenge },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramNoSessionRelayToClient| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramNoSessionRelayToClient| { &mut m.seconds_until_shutdown },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNoSessionRelayToClient>(
                "CMsgSteamDatagramNoSessionRelayToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToClient {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNoSessionRelayToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNoSessionRelayToClient::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNoSessionRelayToClient {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.your_public_ip = ::std::option::Option::None;
        self.your_public_port = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNoSessionRelayToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoSessionRelayToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNoSessionRelayToPeer {
    // message fields
    legacy_relay_session_id: ::std::option::Option<u32>,
    from_relay_session_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    kludge_pad: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSessionRelayToPeer {
    fn default() -> &'a CMsgSteamDatagramNoSessionRelayToPeer {
        <CMsgSteamDatagramNoSessionRelayToPeer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSessionRelayToPeer {
    pub fn new() -> CMsgSteamDatagramNoSessionRelayToPeer {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_relay_session_id = 1;


    pub fn get_legacy_relay_session_id(&self) -> u32 {
        self.legacy_relay_session_id.unwrap_or(0)
    }
    pub fn clear_legacy_relay_session_id(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_relay_session_id(&self) -> bool {
        self.legacy_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_relay_session_id(&mut self, v: u32) {
        self.legacy_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 2;


    pub fn get_from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }
    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 7;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 kludge_pad = 99;


    pub fn get_kludge_pad(&self) -> u64 {
        self.kludge_pad.unwrap_or(0)
    }
    pub fn clear_kludge_pad(&mut self) {
        self.kludge_pad = ::std::option::Option::None;
    }

    pub fn has_kludge_pad(&self) -> bool {
        self.kludge_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kludge_pad(&mut self, v: u64) {
        self.kludge_pad = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoSessionRelayToPeer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_relay_session_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_relay_session_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.kludge_pad = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_relay_session_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.kludge_pad {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_relay_session_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.kludge_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNoSessionRelayToPeer {
        CMsgSteamDatagramNoSessionRelayToPeer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_relay_session_id",
                |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.legacy_relay_session_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.legacy_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_relay_session_id",
                |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.from_relay_session_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.from_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.from_connection_id },
                |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "kludge_pad",
                |m: &CMsgSteamDatagramNoSessionRelayToPeer| { &m.kludge_pad },
                |m: &mut CMsgSteamDatagramNoSessionRelayToPeer| { &mut m.kludge_pad },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNoSessionRelayToPeer>(
                "CMsgSteamDatagramNoSessionRelayToPeer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSessionRelayToPeer {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNoSessionRelayToPeer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNoSessionRelayToPeer::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNoSessionRelayToPeer {
    fn clear(&mut self) {
        self.legacy_relay_session_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.kludge_pad = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNoSessionRelayToPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoSessionRelayToPeer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleRequest {
    // message fields
    connection_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleRequest {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleRequest {
        <CMsgSteamDatagramClientPingSampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleRequest {
    pub fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        CMsgSteamDatagramClientPingSampleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramClientPingSampleRequest| { &m.connection_id },
                |m: &mut CMsgSteamDatagramClientPingSampleRequest| { &mut m.connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleRequest>(
                "CMsgSteamDatagramClientPingSampleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleRequest {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleReply {
    // message fields
    connection_id: ::std::option::Option<u32>,
    override_active: ::std::option::Option<bool>,
    pub pops: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP>,
    pub legacy_data_centers: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply {
        <CMsgSteamDatagramClientPingSampleReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional bool override_active = 4;


    pub fn get_override_active(&self) -> bool {
        self.override_active.unwrap_or(false)
    }
    pub fn clear_override_active(&mut self) {
        self.override_active = ::std::option::Option::None;
    }

    pub fn has_override_active(&self) -> bool {
        self.override_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_active(&mut self, v: bool) {
        self.override_active = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramClientPingSampleReply.POP pops = 2;


    pub fn get_pops(&self) -> &[CMsgSteamDatagramClientPingSampleReply_POP] {
        &self.pops
    }
    pub fn clear_pops(&mut self) {
        self.pops.clear();
    }

    // Param is passed by value, moved
    pub fn set_pops(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP>) {
        self.pops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pops(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP> {
        &mut self.pops
    }

    // Take field
    pub fn take_pops(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP> {
        ::std::mem::replace(&mut self.pops, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter legacy_data_centers = 3;


    pub fn get_legacy_data_centers(&self) -> &[CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter] {
        &self.legacy_data_centers
    }
    pub fn clear_legacy_data_centers(&mut self) {
        self.legacy_data_centers.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_data_centers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter>) {
        self.legacy_data_centers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_data_centers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter> {
        &mut self.legacy_data_centers
    }

    // Take field
    pub fn take_legacy_data_centers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter> {
        ::std::mem::replace(&mut self.legacy_data_centers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply {
    fn is_initialized(&self) -> bool {
        for v in &self.pops {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.legacy_data_centers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.override_active = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pops)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.legacy_data_centers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.override_active {
            my_size += 2;
        }
        for value in &self.pops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.legacy_data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.override_active {
            os.write_bool(4, v)?;
        }
        for v in &self.pops {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.legacy_data_centers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply {
        CMsgSteamDatagramClientPingSampleReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramClientPingSampleReply| { &m.connection_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "override_active",
                |m: &CMsgSteamDatagramClientPingSampleReply| { &m.override_active },
                |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.override_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientPingSampleReply_POP>>(
                "pops",
                |m: &CMsgSteamDatagramClientPingSampleReply| { &m.pops },
                |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.pops },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter>>(
                "legacy_data_centers",
                |m: &CMsgSteamDatagramClientPingSampleReply| { &m.legacy_data_centers },
                |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.legacy_data_centers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleReply>(
                "CMsgSteamDatagramClientPingSampleReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleReply::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleReply {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.override_active = ::std::option::Option::None;
        self.pops.clear();
        self.legacy_data_centers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleReply_POP {
    // message fields
    pop_id: ::std::option::Option<u32>,
    default_front_ping_ms: ::std::option::Option<u32>,
    cluster_penalty: ::std::option::Option<u32>,
    pub alt_addresses: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress>,
    default_e2e_ping_ms: ::std::option::Option<u32>,
    default_e2e_score: ::std::option::Option<u32>,
    p2p_via_peer_relay_pop_id: ::std::option::Option<u32>,
    best_dc_ping_ms: ::std::option::Option<u32>,
    best_dc_score: ::std::option::Option<u32>,
    best_dc_via_relay_pop_id: ::std::option::Option<u32>,
    default_dc_ping_ms: ::std::option::Option<u32>,
    default_dc_score: ::std::option::Option<u32>,
    default_dc_via_relay_pop_id: ::std::option::Option<u32>,
    test_dc_ping_ms: ::std::option::Option<u32>,
    test_dc_score: ::std::option::Option<u32>,
    test_dc_via_relay_pop_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply_POP {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply_POP {
        <CMsgSteamDatagramClientPingSampleReply_POP as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply_POP {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply_POP {
        ::std::default::Default::default()
    }

    // optional fixed32 pop_id = 1;


    pub fn get_pop_id(&self) -> u32 {
        self.pop_id.unwrap_or(0)
    }
    pub fn clear_pop_id(&mut self) {
        self.pop_id = ::std::option::Option::None;
    }

    pub fn has_pop_id(&self) -> bool {
        self.pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pop_id(&mut self, v: u32) {
        self.pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 default_front_ping_ms = 2;


    pub fn get_default_front_ping_ms(&self) -> u32 {
        self.default_front_ping_ms.unwrap_or(0)
    }
    pub fn clear_default_front_ping_ms(&mut self) {
        self.default_front_ping_ms = ::std::option::Option::None;
    }

    pub fn has_default_front_ping_ms(&self) -> bool {
        self.default_front_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_front_ping_ms(&mut self, v: u32) {
        self.default_front_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster_penalty = 4;


    pub fn get_cluster_penalty(&self) -> u32 {
        self.cluster_penalty.unwrap_or(0)
    }
    pub fn clear_cluster_penalty(&mut self) {
        self.cluster_penalty = ::std::option::Option::None;
    }

    pub fn has_cluster_penalty(&self) -> bool {
        self.cluster_penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_penalty(&mut self, v: u32) {
        self.cluster_penalty = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramClientPingSampleReply.POP.AltAddress alt_addresses = 7;


    pub fn get_alt_addresses(&self) -> &[CMsgSteamDatagramClientPingSampleReply_POP_AltAddress] {
        &self.alt_addresses
    }
    pub fn clear_alt_addresses(&mut self) {
        self.alt_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_alt_addresses(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress>) {
        self.alt_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alt_addresses(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress> {
        &mut self.alt_addresses
    }

    // Take field
    pub fn take_alt_addresses(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress> {
        ::std::mem::replace(&mut self.alt_addresses, ::protobuf::RepeatedField::new())
    }

    // optional uint32 default_e2e_ping_ms = 3;


    pub fn get_default_e2e_ping_ms(&self) -> u32 {
        self.default_e2e_ping_ms.unwrap_or(0)
    }
    pub fn clear_default_e2e_ping_ms(&mut self) {
        self.default_e2e_ping_ms = ::std::option::Option::None;
    }

    pub fn has_default_e2e_ping_ms(&self) -> bool {
        self.default_e2e_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_e2e_ping_ms(&mut self, v: u32) {
        self.default_e2e_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 default_e2e_score = 5;


    pub fn get_default_e2e_score(&self) -> u32 {
        self.default_e2e_score.unwrap_or(0)
    }
    pub fn clear_default_e2e_score(&mut self) {
        self.default_e2e_score = ::std::option::Option::None;
    }

    pub fn has_default_e2e_score(&self) -> bool {
        self.default_e2e_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_e2e_score(&mut self, v: u32) {
        self.default_e2e_score = ::std::option::Option::Some(v);
    }

    // optional fixed32 p2p_via_peer_relay_pop_id = 6;


    pub fn get_p2p_via_peer_relay_pop_id(&self) -> u32 {
        self.p2p_via_peer_relay_pop_id.unwrap_or(0)
    }
    pub fn clear_p2p_via_peer_relay_pop_id(&mut self) {
        self.p2p_via_peer_relay_pop_id = ::std::option::Option::None;
    }

    pub fn has_p2p_via_peer_relay_pop_id(&self) -> bool {
        self.p2p_via_peer_relay_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2p_via_peer_relay_pop_id(&mut self, v: u32) {
        self.p2p_via_peer_relay_pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 best_dc_ping_ms = 9;


    pub fn get_best_dc_ping_ms(&self) -> u32 {
        self.best_dc_ping_ms.unwrap_or(0)
    }
    pub fn clear_best_dc_ping_ms(&mut self) {
        self.best_dc_ping_ms = ::std::option::Option::None;
    }

    pub fn has_best_dc_ping_ms(&self) -> bool {
        self.best_dc_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_dc_ping_ms(&mut self, v: u32) {
        self.best_dc_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 best_dc_score = 10;


    pub fn get_best_dc_score(&self) -> u32 {
        self.best_dc_score.unwrap_or(0)
    }
    pub fn clear_best_dc_score(&mut self) {
        self.best_dc_score = ::std::option::Option::None;
    }

    pub fn has_best_dc_score(&self) -> bool {
        self.best_dc_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_dc_score(&mut self, v: u32) {
        self.best_dc_score = ::std::option::Option::Some(v);
    }

    // optional fixed32 best_dc_via_relay_pop_id = 11;


    pub fn get_best_dc_via_relay_pop_id(&self) -> u32 {
        self.best_dc_via_relay_pop_id.unwrap_or(0)
    }
    pub fn clear_best_dc_via_relay_pop_id(&mut self) {
        self.best_dc_via_relay_pop_id = ::std::option::Option::None;
    }

    pub fn has_best_dc_via_relay_pop_id(&self) -> bool {
        self.best_dc_via_relay_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_dc_via_relay_pop_id(&mut self, v: u32) {
        self.best_dc_via_relay_pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 default_dc_ping_ms = 12;


    pub fn get_default_dc_ping_ms(&self) -> u32 {
        self.default_dc_ping_ms.unwrap_or(0)
    }
    pub fn clear_default_dc_ping_ms(&mut self) {
        self.default_dc_ping_ms = ::std::option::Option::None;
    }

    pub fn has_default_dc_ping_ms(&self) -> bool {
        self.default_dc_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_dc_ping_ms(&mut self, v: u32) {
        self.default_dc_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 default_dc_score = 13;


    pub fn get_default_dc_score(&self) -> u32 {
        self.default_dc_score.unwrap_or(0)
    }
    pub fn clear_default_dc_score(&mut self) {
        self.default_dc_score = ::std::option::Option::None;
    }

    pub fn has_default_dc_score(&self) -> bool {
        self.default_dc_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_dc_score(&mut self, v: u32) {
        self.default_dc_score = ::std::option::Option::Some(v);
    }

    // optional fixed32 default_dc_via_relay_pop_id = 14;


    pub fn get_default_dc_via_relay_pop_id(&self) -> u32 {
        self.default_dc_via_relay_pop_id.unwrap_or(0)
    }
    pub fn clear_default_dc_via_relay_pop_id(&mut self) {
        self.default_dc_via_relay_pop_id = ::std::option::Option::None;
    }

    pub fn has_default_dc_via_relay_pop_id(&self) -> bool {
        self.default_dc_via_relay_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_dc_via_relay_pop_id(&mut self, v: u32) {
        self.default_dc_via_relay_pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 test_dc_ping_ms = 15;


    pub fn get_test_dc_ping_ms(&self) -> u32 {
        self.test_dc_ping_ms.unwrap_or(0)
    }
    pub fn clear_test_dc_ping_ms(&mut self) {
        self.test_dc_ping_ms = ::std::option::Option::None;
    }

    pub fn has_test_dc_ping_ms(&self) -> bool {
        self.test_dc_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_dc_ping_ms(&mut self, v: u32) {
        self.test_dc_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 test_dc_score = 16;


    pub fn get_test_dc_score(&self) -> u32 {
        self.test_dc_score.unwrap_or(0)
    }
    pub fn clear_test_dc_score(&mut self) {
        self.test_dc_score = ::std::option::Option::None;
    }

    pub fn has_test_dc_score(&self) -> bool {
        self.test_dc_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_dc_score(&mut self, v: u32) {
        self.test_dc_score = ::std::option::Option::Some(v);
    }

    // optional fixed32 test_dc_via_relay_pop_id = 17;


    pub fn get_test_dc_via_relay_pop_id(&self) -> u32 {
        self.test_dc_via_relay_pop_id.unwrap_or(0)
    }
    pub fn clear_test_dc_via_relay_pop_id(&mut self) {
        self.test_dc_via_relay_pop_id = ::std::option::Option::None;
    }

    pub fn has_test_dc_via_relay_pop_id(&self) -> bool {
        self.test_dc_via_relay_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_dc_via_relay_pop_id(&mut self, v: u32) {
        self.test_dc_via_relay_pop_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply_POP {
    fn is_initialized(&self) -> bool {
        for v in &self.alt_addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.pop_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_front_ping_ms = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cluster_penalty = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.alt_addresses)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_e2e_ping_ms = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_e2e_score = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.p2p_via_peer_relay_pop_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_dc_ping_ms = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_dc_score = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.best_dc_via_relay_pop_id = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_dc_ping_ms = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_dc_score = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.default_dc_via_relay_pop_id = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.test_dc_ping_ms = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.test_dc_score = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.test_dc_via_relay_pop_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pop_id {
            my_size += 5;
        }
        if let Some(v) = self.default_front_ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cluster_penalty {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.alt_addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.default_e2e_ping_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_e2e_score {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p2p_via_peer_relay_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.best_dc_ping_ms {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_dc_score {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.best_dc_via_relay_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.default_dc_ping_ms {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_dc_score {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_dc_via_relay_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.test_dc_ping_ms {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.test_dc_score {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.test_dc_via_relay_pop_id {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pop_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.default_front_ping_ms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cluster_penalty {
            os.write_uint32(4, v)?;
        }
        for v in &self.alt_addresses {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.default_e2e_ping_ms {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.default_e2e_score {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.p2p_via_peer_relay_pop_id {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.best_dc_ping_ms {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.best_dc_score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.best_dc_via_relay_pop_id {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.default_dc_ping_ms {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.default_dc_score {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.default_dc_via_relay_pop_id {
            os.write_fixed32(14, v)?;
        }
        if let Some(v) = self.test_dc_ping_ms {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.test_dc_score {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.test_dc_via_relay_pop_id {
            os.write_fixed32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply_POP {
        CMsgSteamDatagramClientPingSampleReply_POP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "pop_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.pop_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_front_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.default_front_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.default_front_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cluster_penalty",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.cluster_penalty },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.cluster_penalty },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress>>(
                "alt_addresses",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.alt_addresses },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.alt_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_e2e_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.default_e2e_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.default_e2e_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_e2e_score",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.default_e2e_score },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.default_e2e_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "p2p_via_peer_relay_pop_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.p2p_via_peer_relay_pop_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.p2p_via_peer_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "best_dc_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.best_dc_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.best_dc_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "best_dc_score",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.best_dc_score },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.best_dc_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "best_dc_via_relay_pop_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.best_dc_via_relay_pop_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.best_dc_via_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_dc_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.default_dc_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.default_dc_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_dc_score",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.default_dc_score },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.default_dc_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "default_dc_via_relay_pop_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.default_dc_via_relay_pop_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.default_dc_via_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "test_dc_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.test_dc_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.test_dc_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "test_dc_score",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.test_dc_score },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.test_dc_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "test_dc_via_relay_pop_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP| { &m.test_dc_via_relay_pop_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP| { &mut m.test_dc_via_relay_pop_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleReply_POP>(
                "CMsgSteamDatagramClientPingSampleReply.POP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply_POP {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleReply_POP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleReply_POP::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleReply_POP {
    fn clear(&mut self) {
        self.pop_id = ::std::option::Option::None;
        self.default_front_ping_ms = ::std::option::Option::None;
        self.cluster_penalty = ::std::option::Option::None;
        self.alt_addresses.clear();
        self.default_e2e_ping_ms = ::std::option::Option::None;
        self.default_e2e_score = ::std::option::Option::None;
        self.p2p_via_peer_relay_pop_id = ::std::option::Option::None;
        self.best_dc_ping_ms = ::std::option::Option::None;
        self.best_dc_score = ::std::option::Option::None;
        self.best_dc_via_relay_pop_id = ::std::option::Option::None;
        self.default_dc_ping_ms = ::std::option::Option::None;
        self.default_dc_score = ::std::option::Option::None;
        self.default_dc_via_relay_pop_id = ::std::option::Option::None;
        self.test_dc_ping_ms = ::std::option::Option::None;
        self.test_dc_score = ::std::option::Option::None;
        self.test_dc_via_relay_pop_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleReply_POP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply_POP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    front_ping_ms: ::std::option::Option<u32>,
    penalty: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
        <CMsgSteamDatagramClientPingSampleReply_POP_AltAddress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
        ::std::default::Default::default()
    }

    // optional string id = 1;


    pub fn get_id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 front_ping_ms = 2;


    pub fn get_front_ping_ms(&self) -> u32 {
        self.front_ping_ms.unwrap_or(0)
    }
    pub fn clear_front_ping_ms(&mut self) {
        self.front_ping_ms = ::std::option::Option::None;
    }

    pub fn has_front_ping_ms(&self) -> bool {
        self.front_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_ping_ms(&mut self, v: u32) {
        self.front_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty = 3;


    pub fn get_penalty(&self) -> u32 {
        self.penalty.unwrap_or(0)
    }
    pub fn clear_penalty(&mut self) {
        self.penalty = ::std::option::Option::None;
    }

    pub fn has_penalty(&self) -> bool {
        self.penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty(&mut self, v: u32) {
        self.penalty = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.front_ping_ms = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.penalty = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.front_ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.penalty {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.front_ping_ms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.penalty {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
        CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP_AltAddress| { &m.id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP_AltAddress| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "front_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP_AltAddress| { &m.front_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP_AltAddress| { &mut m.front_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "penalty",
                |m: &CMsgSteamDatagramClientPingSampleReply_POP_AltAddress| { &m.penalty },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_POP_AltAddress| { &mut m.penalty },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress>(
                "CMsgSteamDatagramClientPingSampleReply.POP.AltAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleReply_POP_AltAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleReply_POP_AltAddress::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    fn clear(&mut self) {
        self.id.clear();
        self.front_ping_ms = ::std::option::Option::None;
        self.penalty = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply_POP_AltAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    // message fields
    data_center_id: ::std::option::Option<u32>,
    best_dc_via_relay_pop_id: ::std::option::Option<u32>,
    best_dc_ping_ms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
        <CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
        ::std::default::Default::default()
    }

    // optional fixed32 data_center_id = 1;


    pub fn get_data_center_id(&self) -> u32 {
        self.data_center_id.unwrap_or(0)
    }
    pub fn clear_data_center_id(&mut self) {
        self.data_center_id = ::std::option::Option::None;
    }

    pub fn has_data_center_id(&self) -> bool {
        self.data_center_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_center_id(&mut self, v: u32) {
        self.data_center_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 best_dc_via_relay_pop_id = 2;


    pub fn get_best_dc_via_relay_pop_id(&self) -> u32 {
        self.best_dc_via_relay_pop_id.unwrap_or(0)
    }
    pub fn clear_best_dc_via_relay_pop_id(&mut self) {
        self.best_dc_via_relay_pop_id = ::std::option::Option::None;
    }

    pub fn has_best_dc_via_relay_pop_id(&self) -> bool {
        self.best_dc_via_relay_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_dc_via_relay_pop_id(&mut self, v: u32) {
        self.best_dc_via_relay_pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 best_dc_ping_ms = 3;


    pub fn get_best_dc_ping_ms(&self) -> u32 {
        self.best_dc_ping_ms.unwrap_or(0)
    }
    pub fn clear_best_dc_ping_ms(&mut self) {
        self.best_dc_ping_ms = ::std::option::Option::None;
    }

    pub fn has_best_dc_ping_ms(&self) -> bool {
        self.best_dc_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_dc_ping_ms(&mut self, v: u32) {
        self.best_dc_ping_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.data_center_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.best_dc_via_relay_pop_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.best_dc_ping_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_center_id {
            my_size += 5;
        }
        if let Some(v) = self.best_dc_via_relay_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.best_dc_ping_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_center_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.best_dc_via_relay_pop_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.best_dc_ping_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
        CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "data_center_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter| { &m.data_center_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter| { &mut m.data_center_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "best_dc_via_relay_pop_id",
                |m: &CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter| { &m.best_dc_via_relay_pop_id },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter| { &mut m.best_dc_via_relay_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "best_dc_ping_ms",
                |m: &CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter| { &m.best_dc_ping_ms },
                |m: &mut CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter| { &mut m.best_dc_ping_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter>(
                "CMsgSteamDatagramClientPingSampleReply.LegacyDataCenter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    fn clear(&mut self) {
        self.data_center_id = ::std::option::Option::None;
        self.best_dc_via_relay_pop_id = ::std::option::Option::None;
        self.best_dc_ping_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply_LegacyDataCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientSwitchedPrimary {
    // message fields
    connection_id: ::std::option::Option<u32>,
    from_ip: ::std::option::Option<u32>,
    from_port: ::std::option::Option<u32>,
    from_router_cluster: ::std::option::Option<u32>,
    from_active_time: ::std::option::Option<u32>,
    from_active_packets_recv: ::std::option::Option<u32>,
    from_dropped_reason: ::protobuf::SingularField<::std::string::String>,
    gap_ms: ::std::option::Option<u32>,
    pub from_quality_now: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    pub to_quality_now: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    pub from_quality_then: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    pub to_quality_then: ::protobuf::SingularPtrField<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientSwitchedPrimary {
    fn default() -> &'a CMsgSteamDatagramClientSwitchedPrimary {
        <CMsgSteamDatagramClientSwitchedPrimary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientSwitchedPrimary {
    pub fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_ip = 2;


    pub fn get_from_ip(&self) -> u32 {
        self.from_ip.unwrap_or(0)
    }
    pub fn clear_from_ip(&mut self) {
        self.from_ip = ::std::option::Option::None;
    }

    pub fn has_from_ip(&self) -> bool {
        self.from_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_ip(&mut self, v: u32) {
        self.from_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 from_port = 3;


    pub fn get_from_port(&self) -> u32 {
        self.from_port.unwrap_or(0)
    }
    pub fn clear_from_port(&mut self) {
        self.from_port = ::std::option::Option::None;
    }

    pub fn has_from_port(&self) -> bool {
        self.from_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_port(&mut self, v: u32) {
        self.from_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_router_cluster = 4;


    pub fn get_from_router_cluster(&self) -> u32 {
        self.from_router_cluster.unwrap_or(0)
    }
    pub fn clear_from_router_cluster(&mut self) {
        self.from_router_cluster = ::std::option::Option::None;
    }

    pub fn has_from_router_cluster(&self) -> bool {
        self.from_router_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_router_cluster(&mut self, v: u32) {
        self.from_router_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_time = 5;


    pub fn get_from_active_time(&self) -> u32 {
        self.from_active_time.unwrap_or(0)
    }
    pub fn clear_from_active_time(&mut self) {
        self.from_active_time = ::std::option::Option::None;
    }

    pub fn has_from_active_time(&self) -> bool {
        self.from_active_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_time(&mut self, v: u32) {
        self.from_active_time = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_packets_recv = 6;


    pub fn get_from_active_packets_recv(&self) -> u32 {
        self.from_active_packets_recv.unwrap_or(0)
    }
    pub fn clear_from_active_packets_recv(&mut self) {
        self.from_active_packets_recv = ::std::option::Option::None;
    }

    pub fn has_from_active_packets_recv(&self) -> bool {
        self.from_active_packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_packets_recv(&mut self, v: u32) {
        self.from_active_packets_recv = ::std::option::Option::Some(v);
    }

    // optional string from_dropped_reason = 7;


    pub fn get_from_dropped_reason(&self) -> &str {
        match self.from_dropped_reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_from_dropped_reason(&mut self) {
        self.from_dropped_reason.clear();
    }

    pub fn has_from_dropped_reason(&self) -> bool {
        self.from_dropped_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_dropped_reason(&mut self, v: ::std::string::String) {
        self.from_dropped_reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_dropped_reason(&mut self) -> &mut ::std::string::String {
        if self.from_dropped_reason.is_none() {
            self.from_dropped_reason.set_default();
        }
        self.from_dropped_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_dropped_reason(&mut self) -> ::std::string::String {
        self.from_dropped_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gap_ms = 8;


    pub fn get_gap_ms(&self) -> u32 {
        self.gap_ms.unwrap_or(0)
    }
    pub fn clear_gap_ms(&mut self) {
        self.gap_ms = ::std::option::Option::None;
    }

    pub fn has_gap_ms(&self) -> bool {
        self.gap_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gap_ms(&mut self, v: u32) {
        self.gap_ms = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_now = 9;


    pub fn get_from_quality_now(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_now.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from_quality_now(&mut self) {
        self.from_quality_now.clear();
    }

    pub fn has_from_quality_now(&self) -> bool {
        self.from_quality_now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_quality_now(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.from_quality_now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_quality_now(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.from_quality_now.is_none() {
            self.from_quality_now.set_default();
        }
        self.from_quality_now.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_quality_now(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_now.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_now = 10;


    pub fn get_to_quality_now(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_now.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_to_quality_now(&mut self) {
        self.to_quality_now.clear();
    }

    pub fn has_to_quality_now(&self) -> bool {
        self.to_quality_now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_quality_now(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.to_quality_now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_quality_now(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.to_quality_now.is_none() {
            self.to_quality_now.set_default();
        }
        self.to_quality_now.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_quality_now(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_now.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality from_quality_then = 11;


    pub fn get_from_quality_then(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_then.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from_quality_then(&mut self) {
        self.from_quality_then.clear();
    }

    pub fn has_from_quality_then(&self) -> bool {
        self.from_quality_then.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_quality_then(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.from_quality_then = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_quality_then(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.from_quality_then.is_none() {
            self.from_quality_then.set_default();
        }
        self.from_quality_then.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_quality_then(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.from_quality_then.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }

    // optional .CMsgSteamDatagramClientSwitchedPrimary.RouterQuality to_quality_then = 12;


    pub fn get_to_quality_then(&self) -> &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_then.as_ref().unwrap_or_else(|| <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_to_quality_then(&mut self) {
        self.to_quality_then.clear();
    }

    pub fn has_to_quality_then(&self) -> bool {
        self.to_quality_then.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_quality_then(&mut self, v: CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
        self.to_quality_then = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_quality_then(&mut self) -> &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        if self.to_quality_then.is_none() {
            self.to_quality_then.set_default();
        }
        self.to_quality_then.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_quality_then(&mut self) -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        self.to_quality_then.take().unwrap_or_else(|| CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientSwitchedPrimary {
    fn is_initialized(&self) -> bool {
        for v in &self.from_quality_now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.to_quality_now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.from_quality_then {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.to_quality_then {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_router_cluster = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_active_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.from_active_packets_recv = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.from_dropped_reason)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gap_ms = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_quality_now)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.to_quality_now)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_quality_then)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.to_quality_then)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_ip {
            my_size += 5;
        }
        if let Some(v) = self.from_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_router_cluster {
            my_size += 5;
        }
        if let Some(v) = self.from_active_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_active_packets_recv {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.from_dropped_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gap_ms {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.from_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.to_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.from_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.to_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.from_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.from_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.from_router_cluster {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.from_active_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.from_active_packets_recv {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.from_dropped_reason.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.gap_ms {
            os.write_uint32(8, v)?;
        }
        if let Some(ref v) = self.from_quality_now.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.to_quality_now.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.from_quality_then.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.to_quality_then.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        CMsgSteamDatagramClientSwitchedPrimary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.connection_id },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_ip",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_ip },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "from_port",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_port },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_router_cluster",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_router_cluster },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_router_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "from_active_time",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_time },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "from_active_packets_recv",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_packets_recv },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_packets_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_dropped_reason",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_dropped_reason },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_dropped_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gap_ms",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.gap_ms },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.gap_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "from_quality_now",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_now },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_now },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "to_quality_now",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_now },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_now },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "from_quality_then",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_then },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_then },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>>(
                "to_quality_then",
                |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_then },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_then },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientSwitchedPrimary>(
                "CMsgSteamDatagramClientSwitchedPrimary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientSwitchedPrimary {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientSwitchedPrimary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientSwitchedPrimary::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientSwitchedPrimary {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.from_ip = ::std::option::Option::None;
        self.from_port = ::std::option::Option::None;
        self.from_router_cluster = ::std::option::Option::None;
        self.from_active_time = ::std::option::Option::None;
        self.from_active_packets_recv = ::std::option::Option::None;
        self.from_dropped_reason.clear();
        self.gap_ms = ::std::option::Option::None;
        self.from_quality_now.clear();
        self.to_quality_now.clear();
        self.from_quality_then.clear();
        self.to_quality_then.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientSwitchedPrimary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientSwitchedPrimary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    // message fields
    score: ::std::option::Option<u32>,
    front_ping: ::std::option::Option<u32>,
    back_ping: ::std::option::Option<u32>,
    seconds_until_down: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn default() -> &'a CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        <CMsgSteamDatagramClientSwitchedPrimary_RouterQuality as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    pub fn new() -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        ::std::default::Default::default()
    }

    // optional uint32 score = 1;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 front_ping = 2;


    pub fn get_front_ping(&self) -> u32 {
        self.front_ping.unwrap_or(0)
    }
    pub fn clear_front_ping(&mut self) {
        self.front_ping = ::std::option::Option::None;
    }

    pub fn has_front_ping(&self) -> bool {
        self.front_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_ping(&mut self, v: u32) {
        self.front_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 back_ping = 3;


    pub fn get_back_ping(&self) -> u32 {
        self.back_ping.unwrap_or(0)
    }
    pub fn clear_back_ping(&mut self) {
        self.back_ping = ::std::option::Option::None;
    }

    pub fn has_back_ping(&self) -> bool {
        self.back_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_back_ping(&mut self, v: u32) {
        self.back_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_down = 4;


    pub fn get_seconds_until_down(&self) -> u32 {
        self.seconds_until_down.unwrap_or(0)
    }
    pub fn clear_seconds_until_down(&mut self) {
        self.seconds_until_down = ::std::option::Option::None;
    }

    pub fn has_seconds_until_down(&self) -> bool {
        self.seconds_until_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_down(&mut self, v: u32) {
        self.seconds_until_down = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.front_ping = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.back_ping = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_down = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.front_ping {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.back_ping {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_until_down {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.score {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.front_ping {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.back_ping {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seconds_until_down {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.score },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "front_ping",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.front_ping },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.front_ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "back_ping",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.back_ping },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.back_ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_down",
                |m: &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &m.seconds_until_down },
                |m: &mut CMsgSteamDatagramClientSwitchedPrimary_RouterQuality| { &mut m.seconds_until_down },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality>(
                "CMsgSteamDatagramClientSwitchedPrimary.RouterQuality",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramClientSwitchedPrimary_RouterQuality> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramClientSwitchedPrimary_RouterQuality::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.front_ping = ::std::option::Option::None;
        self.back_ping = ::std::option::Option::None;
        self.seconds_until_down = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectRequest {
    // message fields
    connection_id: ::std::option::Option<u32>,
    my_timestamp: ::std::option::Option<u64>,
    ping_est_ms: ::std::option::Option<u32>,
    virtual_port: ::std::option::Option<u32>,
    gameserver_relay_session_id: ::std::option::Option<u32>,
    pub crypt: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    routing_secret: ::std::option::Option<u64>,
    legacy_client_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectRequest {
    fn default() -> &'a CMsgSteamDatagramConnectRequest {
        <CMsgSteamDatagramConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectRequest {
    pub fn new() -> CMsgSteamDatagramConnectRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 my_timestamp = 4;


    pub fn get_my_timestamp(&self) -> u64 {
        self.my_timestamp.unwrap_or(0)
    }
    pub fn clear_my_timestamp(&mut self) {
        self.my_timestamp = ::std::option::Option::None;
    }

    pub fn has_my_timestamp(&self) -> bool {
        self.my_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_timestamp(&mut self, v: u64) {
        self.my_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_est_ms = 5;


    pub fn get_ping_est_ms(&self) -> u32 {
        self.ping_est_ms.unwrap_or(0)
    }
    pub fn clear_ping_est_ms(&mut self) {
        self.ping_est_ms = ::std::option::Option::None;
    }

    pub fn has_ping_est_ms(&self) -> bool {
        self.ping_est_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_est_ms(&mut self, v: u32) {
        self.ping_est_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 virtual_port = 9;


    pub fn get_virtual_port(&self) -> u32 {
        self.virtual_port.unwrap_or(0)
    }
    pub fn clear_virtual_port(&mut self) {
        self.virtual_port = ::std::option::Option::None;
    }

    pub fn has_virtual_port(&self) -> bool {
        self.virtual_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtual_port(&mut self, v: u32) {
        self.virtual_port = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;


    pub fn get_gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 6;


    pub fn get_crypt(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 7;


    pub fn get_cert(&self) -> &super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional fixed64 routing_secret = 10;


    pub fn get_routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }
    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_client_steam_id = 3;


    pub fn get_legacy_client_steam_id(&self) -> u64 {
        self.legacy_client_steam_id.unwrap_or(0)
    }
    pub fn clear_legacy_client_steam_id(&mut self) {
        self.legacy_client_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_steam_id(&self) -> bool {
        self.legacy_client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_steam_id(&mut self, v: u64) {
        self.legacy_client_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.my_timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_est_ms = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.virtual_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.routing_secret = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.legacy_client_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.my_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.ping_est_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.virtual_port {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.routing_secret {
            my_size += 9;
        }
        if let Some(v) = self.legacy_client_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.my_timestamp {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.ping_est_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.virtual_port {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.legacy_client_steam_id {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectRequest {
        CMsgSteamDatagramConnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramConnectRequest| { &m.connection_id },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "my_timestamp",
                |m: &CMsgSteamDatagramConnectRequest| { &m.my_timestamp },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.my_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_est_ms",
                |m: &CMsgSteamDatagramConnectRequest| { &m.ping_est_ms },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.ping_est_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "virtual_port",
                |m: &CMsgSteamDatagramConnectRequest| { &m.virtual_port },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.virtual_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameserver_relay_session_id",
                |m: &CMsgSteamDatagramConnectRequest| { &m.gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamDatagramConnectRequest| { &m.crypt },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamDatagramConnectRequest| { &m.cert },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "routing_secret",
                |m: &CMsgSteamDatagramConnectRequest| { &m.routing_secret },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.routing_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "legacy_client_steam_id",
                |m: &CMsgSteamDatagramConnectRequest| { &m.legacy_client_steam_id },
                |m: &mut CMsgSteamDatagramConnectRequest| { &mut m.legacy_client_steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectRequest>(
                "CMsgSteamDatagramConnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectRequest {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.my_timestamp = ::std::option::Option::None;
        self.ping_est_ms = ::std::option::Option::None;
        self.virtual_port = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.routing_secret = ::std::option::Option::None;
        self.legacy_client_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectOK {
    // message fields
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    your_timestamp: ::std::option::Option<u64>,
    delay_time_usec: ::std::option::Option<u32>,
    gameserver_relay_session_id: ::std::option::Option<u32>,
    pub crypt: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>,
    pub cert: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectOK {
    fn default() -> &'a CMsgSteamDatagramConnectOK {
        <CMsgSteamDatagramConnectOK as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectOK {
    pub fn new() -> CMsgSteamDatagramConnectOK {
        ::std::default::Default::default()
    }

    // optional fixed32 client_connection_id = 1;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 7;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 your_timestamp = 3;


    pub fn get_your_timestamp(&self) -> u64 {
        self.your_timestamp.unwrap_or(0)
    }
    pub fn clear_your_timestamp(&mut self) {
        self.your_timestamp = ::std::option::Option::None;
    }

    pub fn has_your_timestamp(&self) -> bool {
        self.your_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_timestamp(&mut self, v: u64) {
        self.your_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 delay_time_usec = 4;


    pub fn get_delay_time_usec(&self) -> u32 {
        self.delay_time_usec.unwrap_or(0)
    }
    pub fn clear_delay_time_usec(&mut self) {
        self.delay_time_usec = ::std::option::Option::None;
    }

    pub fn has_delay_time_usec(&self) -> bool {
        self.delay_time_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_time_usec(&mut self, v: u32) {
        self.delay_time_usec = ::std::option::Option::Some(v);
    }

    // optional uint32 gameserver_relay_session_id = 2;


    pub fn get_gameserver_relay_session_id(&self) -> u32 {
        self.gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_gameserver_relay_session_id(&mut self) {
        self.gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_relay_session_id(&self) -> bool {
        self.gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_relay_session_id(&mut self, v: u32) {
        self.gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramSessionCryptInfoSigned crypt = 5;


    pub fn get_crypt(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crypt(&mut self) {
        self.crypt.clear();
    }

    pub fn has_crypt(&self) -> bool {
        self.crypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crypt(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned) {
        self.crypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crypt(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned {
        if self.crypt.is_none() {
            self.crypt.set_default();
        }
        self.crypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_crypt(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned {
        self.crypt.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned::new())
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 6;


    pub fn get_cert(&self) -> &super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectOK {
    fn is_initialized(&self) -> bool {
        for v in &self.crypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.your_timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay_time_usec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crypt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.your_timestamp {
            my_size += 9;
        }
        if let Some(v) = self.delay_time_usec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.crypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_timestamp {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.delay_time_usec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.crypt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectOK {
        CMsgSteamDatagramConnectOK::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectOK| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramConnectOK| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.server_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "your_timestamp",
                |m: &CMsgSteamDatagramConnectOK| { &m.your_timestamp },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.your_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delay_time_usec",
                |m: &CMsgSteamDatagramConnectOK| { &m.delay_time_usec },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.delay_time_usec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameserver_relay_session_id",
                |m: &CMsgSteamDatagramConnectOK| { &m.gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramSessionCryptInfoSigned>>(
                "crypt",
                |m: &CMsgSteamDatagramConnectOK| { &m.crypt },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamDatagramConnectOK| { &m.cert },
                |m: &mut CMsgSteamDatagramConnectOK| { &mut m.cert },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectOK>(
                "CMsgSteamDatagramConnectOK",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectOK {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectOK> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectOK::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectOK {
    fn clear(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.your_timestamp = ::std::option::Option::None;
        self.delay_time_usec = ::std::option::Option::None;
        self.gameserver_relay_session_id = ::std::option::Option::None;
        self.crypt.clear();
        self.cert.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectOK {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectOK {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamNetworkingP2PSDRRoutingSummary {
    // message fields
    initial_ping: ::std::option::Option<u32>,
    initial_ping_front_local: ::std::option::Option<u32>,
    initial_ping_front_remote: ::std::option::Option<u32>,
    initial_score: ::std::option::Option<u32>,
    initial_pop_local: ::std::option::Option<u32>,
    initial_pop_remote: ::std::option::Option<u32>,
    negotiation_ms: ::std::option::Option<u32>,
    selected_seconds: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn default() -> &'a CMsgSteamNetworkingP2PSDRRoutingSummary {
        <CMsgSteamNetworkingP2PSDRRoutingSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PSDRRoutingSummary {
    pub fn new() -> CMsgSteamNetworkingP2PSDRRoutingSummary {
        ::std::default::Default::default()
    }

    // optional uint32 initial_ping = 1;


    pub fn get_initial_ping(&self) -> u32 {
        self.initial_ping.unwrap_or(0)
    }
    pub fn clear_initial_ping(&mut self) {
        self.initial_ping = ::std::option::Option::None;
    }

    pub fn has_initial_ping(&self) -> bool {
        self.initial_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping(&mut self, v: u32) {
        self.initial_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_ping_front_local = 2;


    pub fn get_initial_ping_front_local(&self) -> u32 {
        self.initial_ping_front_local.unwrap_or(0)
    }
    pub fn clear_initial_ping_front_local(&mut self) {
        self.initial_ping_front_local = ::std::option::Option::None;
    }

    pub fn has_initial_ping_front_local(&self) -> bool {
        self.initial_ping_front_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping_front_local(&mut self, v: u32) {
        self.initial_ping_front_local = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_ping_front_remote = 3;


    pub fn get_initial_ping_front_remote(&self) -> u32 {
        self.initial_ping_front_remote.unwrap_or(0)
    }
    pub fn clear_initial_ping_front_remote(&mut self) {
        self.initial_ping_front_remote = ::std::option::Option::None;
    }

    pub fn has_initial_ping_front_remote(&self) -> bool {
        self.initial_ping_front_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping_front_remote(&mut self, v: u32) {
        self.initial_ping_front_remote = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_score = 4;


    pub fn get_initial_score(&self) -> u32 {
        self.initial_score.unwrap_or(0)
    }
    pub fn clear_initial_score(&mut self) {
        self.initial_score = ::std::option::Option::None;
    }

    pub fn has_initial_score(&self) -> bool {
        self.initial_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_score(&mut self, v: u32) {
        self.initial_score = ::std::option::Option::Some(v);
    }

    // optional fixed32 initial_pop_local = 5;


    pub fn get_initial_pop_local(&self) -> u32 {
        self.initial_pop_local.unwrap_or(0)
    }
    pub fn clear_initial_pop_local(&mut self) {
        self.initial_pop_local = ::std::option::Option::None;
    }

    pub fn has_initial_pop_local(&self) -> bool {
        self.initial_pop_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_pop_local(&mut self, v: u32) {
        self.initial_pop_local = ::std::option::Option::Some(v);
    }

    // optional fixed32 initial_pop_remote = 6;


    pub fn get_initial_pop_remote(&self) -> u32 {
        self.initial_pop_remote.unwrap_or(0)
    }
    pub fn clear_initial_pop_remote(&mut self) {
        self.initial_pop_remote = ::std::option::Option::None;
    }

    pub fn has_initial_pop_remote(&self) -> bool {
        self.initial_pop_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_pop_remote(&mut self, v: u32) {
        self.initial_pop_remote = ::std::option::Option::Some(v);
    }

    // optional uint32 negotiation_ms = 7;


    pub fn get_negotiation_ms(&self) -> u32 {
        self.negotiation_ms.unwrap_or(0)
    }
    pub fn clear_negotiation_ms(&mut self) {
        self.negotiation_ms = ::std::option::Option::None;
    }

    pub fn has_negotiation_ms(&self) -> bool {
        self.negotiation_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negotiation_ms(&mut self, v: u32) {
        self.negotiation_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_seconds = 8;


    pub fn get_selected_seconds(&self) -> u32 {
        self.selected_seconds.unwrap_or(0)
    }
    pub fn clear_selected_seconds(&mut self) {
        self.selected_seconds = ::std::option::Option::None;
    }

    pub fn has_selected_seconds(&self) -> bool {
        self.selected_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_seconds(&mut self, v: u32) {
        self.selected_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_ping = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_ping_front_local = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_ping_front_remote = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_score = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.initial_pop_local = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.initial_pop_remote = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.negotiation_ms = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selected_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.initial_ping {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_ping_front_local {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_ping_front_remote {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_score {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_pop_local {
            my_size += 5;
        }
        if let Some(v) = self.initial_pop_remote {
            my_size += 5;
        }
        if let Some(v) = self.negotiation_ms {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.selected_seconds {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.initial_ping {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.initial_ping_front_local {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.initial_ping_front_remote {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.initial_score {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initial_pop_local {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.initial_pop_remote {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.negotiation_ms {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.selected_seconds {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamNetworkingP2PSDRRoutingSummary {
        CMsgSteamNetworkingP2PSDRRoutingSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_ping",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_ping },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_ping_front_local",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_ping_front_local },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_ping_front_local },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_ping_front_remote",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_ping_front_remote },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_ping_front_remote },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_score",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_score },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "initial_pop_local",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_pop_local },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_pop_local },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "initial_pop_remote",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.initial_pop_remote },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.initial_pop_remote },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "negotiation_ms",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.negotiation_ms },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.negotiation_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "selected_seconds",
                |m: &CMsgSteamNetworkingP2PSDRRoutingSummary| { &m.selected_seconds },
                |m: &mut CMsgSteamNetworkingP2PSDRRoutingSummary| { &mut m.selected_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamNetworkingP2PSDRRoutingSummary>(
                "CMsgSteamNetworkingP2PSDRRoutingSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PSDRRoutingSummary {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamNetworkingP2PSDRRoutingSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamNetworkingP2PSDRRoutingSummary::new)
    }
}

impl ::protobuf::Clear for CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn clear(&mut self) {
        self.initial_ping = ::std::option::Option::None;
        self.initial_ping_front_local = ::std::option::Option::None;
        self.initial_ping_front_remote = ::std::option::Option::None;
        self.initial_score = ::std::option::Option::None;
        self.initial_pop_local = ::std::option::Option::None;
        self.initial_pop_remote = ::std::option::Option::None;
        self.negotiation_ms = ::std::option::Option::None;
        self.selected_seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PSDRRoutingSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRoutingSummary {
    // message fields
    pub ice: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary>,
    pub sdr: ::protobuf::SingularPtrField<CMsgSteamNetworkingP2PSDRRoutingSummary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutingSummary {
    fn default() -> &'a CMsgSteamDatagramP2PRoutingSummary {
        <CMsgSteamDatagramP2PRoutingSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutingSummary {
    pub fn new() -> CMsgSteamDatagramP2PRoutingSummary {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamNetworkingICESessionSummary ice = 2;


    pub fn get_ice(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary {
        self.ice.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ice(&mut self) {
        self.ice.clear();
    }

    pub fn has_ice(&self) -> bool {
        self.ice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ice(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary) {
        self.ice = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ice(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary {
        if self.ice.is_none() {
            self.ice.set_default();
        }
        self.ice.as_mut().unwrap()
    }

    // Take field
    pub fn take_ice(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary {
        self.ice.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary::new())
    }

    // optional .CMsgSteamNetworkingP2PSDRRoutingSummary sdr = 3;


    pub fn get_sdr(&self) -> &CMsgSteamNetworkingP2PSDRRoutingSummary {
        self.sdr.as_ref().unwrap_or_else(|| <CMsgSteamNetworkingP2PSDRRoutingSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sdr(&mut self) {
        self.sdr.clear();
    }

    pub fn has_sdr(&self) -> bool {
        self.sdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr(&mut self, v: CMsgSteamNetworkingP2PSDRRoutingSummary) {
        self.sdr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr(&mut self) -> &mut CMsgSteamNetworkingP2PSDRRoutingSummary {
        if self.sdr.is_none() {
            self.sdr.set_default();
        }
        self.sdr.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr(&mut self) -> CMsgSteamNetworkingP2PSDRRoutingSummary {
        self.sdr.take().unwrap_or_else(|| CMsgSteamNetworkingP2PSDRRoutingSummary::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutingSummary {
    fn is_initialized(&self) -> bool {
        for v in &self.ice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sdr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ice)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sdr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sdr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ice.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sdr.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRoutingSummary {
        CMsgSteamDatagramP2PRoutingSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamNetworkingICESessionSummary>>(
                "ice",
                |m: &CMsgSteamDatagramP2PRoutingSummary| { &m.ice },
                |m: &mut CMsgSteamDatagramP2PRoutingSummary| { &mut m.ice },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamNetworkingP2PSDRRoutingSummary>>(
                "sdr",
                |m: &CMsgSteamDatagramP2PRoutingSummary| { &m.sdr },
                |m: &mut CMsgSteamDatagramP2PRoutingSummary| { &mut m.sdr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRoutingSummary>(
                "CMsgSteamDatagramP2PRoutingSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutingSummary {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRoutingSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRoutingSummary::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRoutingSummary {
    fn clear(&mut self) {
        self.ice.clear();
        self.sdr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRoutingSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutingSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionClosed {
    // message fields
    to_connection_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    from_identity_string: ::protobuf::SingularField<::std::string::String>,
    pub legacy_from_identity_binary: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary>,
    legacy_from_steam_id: ::std::option::Option<u64>,
    legacy_gameserver_relay_session_id: ::std::option::Option<u32>,
    to_relay_session_id: ::std::option::Option<u32>,
    from_relay_session_id: ::std::option::Option<u32>,
    forward_target_relay_routing_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    forward_target_revision: ::std::option::Option<u32>,
    relay_mode: ::std::option::Option<CMsgSteamDatagramConnectionClosed_ERelayMode>,
    debug: ::protobuf::SingularField<::std::string::String>,
    reason_code: ::std::option::Option<u32>,
    routing_secret: ::std::option::Option<u64>,
    not_primary_session: ::std::option::Option<bool>,
    not_primary_transport: ::std::option::Option<bool>,
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub p2p_routing_summary: ::protobuf::SingularPtrField<CMsgSteamDatagramP2PRoutingSummary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionClosed {
    fn default() -> &'a CMsgSteamDatagramConnectionClosed {
        <CMsgSteamDatagramConnectionClosed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionClosed {
    pub fn new() -> CMsgSteamDatagramConnectionClosed {
        ::std::default::Default::default()
    }

    // optional fixed32 to_connection_id = 7;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 8;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional string from_identity_string = 15;


    pub fn get_from_identity_string(&self) -> &str {
        match self.from_identity_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_from_identity_string(&mut self) {
        self.from_identity_string.clear();
    }

    pub fn has_from_identity_string(&self) -> bool {
        self.from_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_identity_string(&mut self, v: ::std::string::String) {
        self.from_identity_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_identity_string(&mut self) -> &mut ::std::string::String {
        if self.from_identity_string.is_none() {
            self.from_identity_string.set_default();
        }
        self.from_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_identity_string(&mut self) -> ::std::string::String {
        self.from_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgSteamNetworkingIdentityLegacyBinary legacy_from_identity_binary = 13;


    pub fn get_legacy_from_identity_binary(&self) -> &super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary {
        self.legacy_from_identity_binary.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_legacy_from_identity_binary(&mut self) {
        self.legacy_from_identity_binary.clear();
    }

    pub fn has_legacy_from_identity_binary(&self) -> bool {
        self.legacy_from_identity_binary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_from_identity_binary(&mut self, v: super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary) {
        self.legacy_from_identity_binary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_from_identity_binary(&mut self) -> &mut super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary {
        if self.legacy_from_identity_binary.is_none() {
            self.legacy_from_identity_binary.set_default();
        }
        self.legacy_from_identity_binary.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_from_identity_binary(&mut self) -> super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary {
        self.legacy_from_identity_binary.take().unwrap_or_else(|| super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary::new())
    }

    // optional fixed64 legacy_from_steam_id = 3;


    pub fn get_legacy_from_steam_id(&self) -> u64 {
        self.legacy_from_steam_id.unwrap_or(0)
    }
    pub fn clear_legacy_from_steam_id(&mut self) {
        self.legacy_from_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_from_steam_id(&self) -> bool {
        self.legacy_from_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_from_steam_id(&mut self, v: u64) {
        self.legacy_from_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_gameserver_relay_session_id = 2;


    pub fn get_legacy_gameserver_relay_session_id(&self) -> u32 {
        self.legacy_gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_legacy_gameserver_relay_session_id(&mut self) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_relay_session_id(&self) -> bool {
        self.legacy_gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_relay_session_id(&mut self, v: u32) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_relay_session_id = 9;


    pub fn get_to_relay_session_id(&self) -> u32 {
        self.to_relay_session_id.unwrap_or(0)
    }
    pub fn clear_to_relay_session_id(&mut self) {
        self.to_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_to_relay_session_id(&self) -> bool {
        self.to_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_relay_session_id(&mut self, v: u32) {
        self.to_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 10;


    pub fn get_from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }
    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional bytes forward_target_relay_routing_token = 11;


    pub fn get_forward_target_relay_routing_token(&self) -> &[u8] {
        match self.forward_target_relay_routing_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_forward_target_relay_routing_token(&mut self) {
        self.forward_target_relay_routing_token.clear();
    }

    pub fn has_forward_target_relay_routing_token(&self) -> bool {
        self.forward_target_relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.forward_target_relay_routing_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward_target_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.forward_target_relay_routing_token.is_none() {
            self.forward_target_relay_routing_token.set_default();
        }
        self.forward_target_relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward_target_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.forward_target_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 forward_target_revision = 12;


    pub fn get_forward_target_revision(&self) -> u32 {
        self.forward_target_revision.unwrap_or(0)
    }
    pub fn clear_forward_target_revision(&mut self) {
        self.forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_forward_target_revision(&self) -> bool {
        self.forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_revision(&mut self, v: u32) {
        self.forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramConnectionClosed.ERelayMode relay_mode = 4;


    pub fn get_relay_mode(&self) -> CMsgSteamDatagramConnectionClosed_ERelayMode {
        self.relay_mode.unwrap_or(CMsgSteamDatagramConnectionClosed_ERelayMode::None)
    }
    pub fn clear_relay_mode(&mut self) {
        self.relay_mode = ::std::option::Option::None;
    }

    pub fn has_relay_mode(&self) -> bool {
        self.relay_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_mode(&mut self, v: CMsgSteamDatagramConnectionClosed_ERelayMode) {
        self.relay_mode = ::std::option::Option::Some(v);
    }

    // optional string debug = 5;


    pub fn get_debug(&self) -> &str {
        match self.debug.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_debug(&mut self) {
        self.debug.clear();
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ::std::string::String) {
        self.debug = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug(&mut self) -> &mut ::std::string::String {
        if self.debug.is_none() {
            self.debug.set_default();
        }
        self.debug.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug(&mut self) -> ::std::string::String {
        self.debug.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reason_code = 6;


    pub fn get_reason_code(&self) -> u32 {
        self.reason_code.unwrap_or(0)
    }
    pub fn clear_reason_code(&mut self) {
        self.reason_code = ::std::option::Option::None;
    }

    pub fn has_reason_code(&self) -> bool {
        self.reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason_code(&mut self, v: u32) {
        self.reason_code = ::std::option::Option::Some(v);
    }

    // optional fixed64 routing_secret = 14;


    pub fn get_routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }
    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_session = 16;


    pub fn get_not_primary_session(&self) -> bool {
        self.not_primary_session.unwrap_or(false)
    }
    pub fn clear_not_primary_session(&mut self) {
        self.not_primary_session = ::std::option::Option::None;
    }

    pub fn has_not_primary_session(&self) -> bool {
        self.not_primary_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_session(&mut self, v: bool) {
        self.not_primary_session = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_transport = 19;


    pub fn get_not_primary_transport(&self) -> bool {
        self.not_primary_transport.unwrap_or(false)
    }
    pub fn clear_not_primary_transport(&mut self) {
        self.not_primary_transport = ::std::option::Option::None;
    }

    pub fn has_not_primary_transport(&self) -> bool {
        self.not_primary_transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_transport(&mut self, v: bool) {
        self.not_primary_transport = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 17;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 18;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 21;


    pub fn get_p2p_routing_summary(&self) -> &CMsgSteamDatagramP2PRoutingSummary {
        self.p2p_routing_summary.as_ref().unwrap_or_else(|| <CMsgSteamDatagramP2PRoutingSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2p_routing_summary(&mut self) {
        self.p2p_routing_summary.clear();
    }

    pub fn has_p2p_routing_summary(&self) -> bool {
        self.p2p_routing_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2p_routing_summary(&mut self, v: CMsgSteamDatagramP2PRoutingSummary) {
        self.p2p_routing_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2p_routing_summary(&mut self) -> &mut CMsgSteamDatagramP2PRoutingSummary {
        if self.p2p_routing_summary.is_none() {
            self.p2p_routing_summary.set_default();
        }
        self.p2p_routing_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2p_routing_summary(&mut self) -> CMsgSteamDatagramP2PRoutingSummary {
        self.p2p_routing_summary.take().unwrap_or_else(|| CMsgSteamDatagramP2PRoutingSummary::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionClosed {
    fn is_initialized(&self) -> bool {
        for v in &self.legacy_from_identity_binary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2p_routing_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.from_identity_string)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.legacy_from_identity_binary)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.legacy_from_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_relay_session_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_relay_session_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.forward_target_relay_routing_token)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.forward_target_revision = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.relay_mode, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.debug)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason_code = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.routing_secret = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_primary_session = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_primary_transport = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2p_routing_summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(ref v) = self.from_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(ref v) = self.legacy_from_identity_binary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.legacy_from_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.to_relay_session_id {
            my_size += 5;
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 5;
        }
        if let Some(ref v) = self.forward_target_relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.forward_target_revision {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relay_mode {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.debug.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.reason_code {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.routing_secret {
            my_size += 9;
        }
        if let Some(v) = self.not_primary_session {
            my_size += 3;
        }
        if let Some(v) = self.not_primary_transport {
            my_size += 3;
        }
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2p_routing_summary.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(ref v) = self.from_identity_string.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(ref v) = self.legacy_from_identity_binary.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.legacy_from_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.to_relay_session_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(ref v) = self.forward_target_relay_routing_token.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(v) = self.forward_target_revision {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.relay_mode {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.debug.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.reason_code {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(14, v)?;
        }
        if let Some(v) = self.not_primary_session {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.not_primary_transport {
            os.write_bool(19, v)?;
        }
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2p_routing_summary.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionClosed {
        CMsgSteamDatagramConnectionClosed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.to_connection_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.from_connection_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_identity_string",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.from_identity_string },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.from_identity_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages_certs::CMsgSteamNetworkingIdentityLegacyBinary>>(
                "legacy_from_identity_binary",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.legacy_from_identity_binary },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.legacy_from_identity_binary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "legacy_from_steam_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.legacy_from_steam_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.legacy_from_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_gameserver_relay_session_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.legacy_gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.legacy_gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_relay_session_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.to_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.to_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_relay_session_id",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.from_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.from_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "forward_target_relay_routing_token",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.forward_target_relay_routing_token },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.forward_target_relay_routing_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "forward_target_revision",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.forward_target_revision },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.forward_target_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgSteamDatagramConnectionClosed_ERelayMode>>(
                "relay_mode",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.relay_mode },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.relay_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "debug",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.debug },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.debug },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reason_code",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.reason_code },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.reason_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "routing_secret",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.routing_secret },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.routing_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "not_primary_session",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.not_primary_session },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.not_primary_session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "not_primary_transport",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.not_primary_transport },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.not_primary_transport },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutingSummary>>(
                "p2p_routing_summary",
                |m: &CMsgSteamDatagramConnectionClosed| { &m.p2p_routing_summary },
                |m: &mut CMsgSteamDatagramConnectionClosed| { &mut m.p2p_routing_summary },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionClosed>(
                "CMsgSteamDatagramConnectionClosed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionClosed {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionClosed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionClosed::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionClosed {
    fn clear(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.from_identity_string.clear();
        self.legacy_from_identity_binary.clear();
        self.legacy_from_steam_id = ::std::option::Option::None;
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
        self.to_relay_session_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.forward_target_relay_routing_token.clear();
        self.forward_target_revision = ::std::option::Option::None;
        self.relay_mode = ::std::option::Option::None;
        self.debug.clear();
        self.reason_code = ::std::option::Option::None;
        self.routing_secret = ::std::option::Option::None;
        self.not_primary_session = ::std::option::Option::None;
        self.not_primary_transport = ::std::option::Option::None;
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.p2p_routing_summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionClosed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionClosed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionClosed_ERelayMode {
    None = 0,
    EndToEnd = 1,
    ClosedByPeer = 2,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionClosed_ERelayMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionClosed_ERelayMode> {
        match value {
            0 => ::std::option::Option::Some(CMsgSteamDatagramConnectionClosed_ERelayMode::None),
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionClosed_ERelayMode::EndToEnd),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionClosed_ERelayMode::ClosedByPeer),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionClosed_ERelayMode] = &[
            CMsgSteamDatagramConnectionClosed_ERelayMode::None,
            CMsgSteamDatagramConnectionClosed_ERelayMode::EndToEnd,
            CMsgSteamDatagramConnectionClosed_ERelayMode::ClosedByPeer,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionClosed_ERelayMode>("CMsgSteamDatagramConnectionClosed.ERelayMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionClosed_ERelayMode {
}

impl ::std::default::Default for CMsgSteamDatagramConnectionClosed_ERelayMode {
    fn default() -> Self {
        CMsgSteamDatagramConnectionClosed_ERelayMode::None
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionClosed_ERelayMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNoConnection {
    // message fields
    to_connection_id: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    legacy_gameserver_relay_session_id: ::std::option::Option<u32>,
    to_relay_session_id: ::std::option::Option<u32>,
    from_relay_session_id: ::std::option::Option<u32>,
    from_identity_string: ::protobuf::SingularField<::std::string::String>,
    legacy_from_steam_id: ::std::option::Option<u64>,
    end_to_end: ::std::option::Option<bool>,
    not_primary_session: ::std::option::Option<bool>,
    not_primary_transport: ::std::option::Option<bool>,
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub p2p_routing_summary: ::protobuf::SingularPtrField<CMsgSteamDatagramP2PRoutingSummary>,
    routing_secret: ::std::option::Option<u64>,
    dummy_pad: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoConnection {
    fn default() -> &'a CMsgSteamDatagramNoConnection {
        <CMsgSteamDatagramNoConnection as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoConnection {
    pub fn new() -> CMsgSteamDatagramNoConnection {
        ::std::default::Default::default()
    }

    // optional fixed32 to_connection_id = 5;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 6;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_gameserver_relay_session_id = 2;


    pub fn get_legacy_gameserver_relay_session_id(&self) -> u32 {
        self.legacy_gameserver_relay_session_id.unwrap_or(0)
    }
    pub fn clear_legacy_gameserver_relay_session_id(&mut self) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_relay_session_id(&self) -> bool {
        self.legacy_gameserver_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_relay_session_id(&mut self, v: u32) {
        self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_relay_session_id = 9;


    pub fn get_to_relay_session_id(&self) -> u32 {
        self.to_relay_session_id.unwrap_or(0)
    }
    pub fn clear_to_relay_session_id(&mut self) {
        self.to_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_to_relay_session_id(&self) -> bool {
        self.to_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_relay_session_id(&mut self, v: u32) {
        self.to_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 10;


    pub fn get_from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }
    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional string from_identity_string = 7;


    pub fn get_from_identity_string(&self) -> &str {
        match self.from_identity_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_from_identity_string(&mut self) {
        self.from_identity_string.clear();
    }

    pub fn has_from_identity_string(&self) -> bool {
        self.from_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_identity_string(&mut self, v: ::std::string::String) {
        self.from_identity_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_identity_string(&mut self) -> &mut ::std::string::String {
        if self.from_identity_string.is_none() {
            self.from_identity_string.set_default();
        }
        self.from_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_identity_string(&mut self) -> ::std::string::String {
        self.from_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 legacy_from_steam_id = 3;


    pub fn get_legacy_from_steam_id(&self) -> u64 {
        self.legacy_from_steam_id.unwrap_or(0)
    }
    pub fn clear_legacy_from_steam_id(&mut self) {
        self.legacy_from_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_from_steam_id(&self) -> bool {
        self.legacy_from_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_from_steam_id(&mut self, v: u64) {
        self.legacy_from_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool end_to_end = 4;


    pub fn get_end_to_end(&self) -> bool {
        self.end_to_end.unwrap_or(false)
    }
    pub fn clear_end_to_end(&mut self) {
        self.end_to_end = ::std::option::Option::None;
    }

    pub fn has_end_to_end(&self) -> bool {
        self.end_to_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_to_end(&mut self, v: bool) {
        self.end_to_end = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_session = 12;


    pub fn get_not_primary_session(&self) -> bool {
        self.not_primary_session.unwrap_or(false)
    }
    pub fn clear_not_primary_session(&mut self) {
        self.not_primary_session = ::std::option::Option::None;
    }

    pub fn has_not_primary_session(&self) -> bool {
        self.not_primary_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_session(&mut self, v: bool) {
        self.not_primary_session = ::std::option::Option::Some(v);
    }

    // optional bool not_primary_transport = 15;


    pub fn get_not_primary_transport(&self) -> bool {
        self.not_primary_transport.unwrap_or(false)
    }
    pub fn clear_not_primary_transport(&mut self) {
        self.not_primary_transport = ::std::option::Option::None;
    }

    pub fn has_not_primary_transport(&self) -> bool {
        self.not_primary_transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_not_primary_transport(&mut self, v: bool) {
        self.not_primary_transport = ::std::option::Option::Some(v);
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 13;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 14;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 16;


    pub fn get_p2p_routing_summary(&self) -> &CMsgSteamDatagramP2PRoutingSummary {
        self.p2p_routing_summary.as_ref().unwrap_or_else(|| <CMsgSteamDatagramP2PRoutingSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2p_routing_summary(&mut self) {
        self.p2p_routing_summary.clear();
    }

    pub fn has_p2p_routing_summary(&self) -> bool {
        self.p2p_routing_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2p_routing_summary(&mut self, v: CMsgSteamDatagramP2PRoutingSummary) {
        self.p2p_routing_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2p_routing_summary(&mut self) -> &mut CMsgSteamDatagramP2PRoutingSummary {
        if self.p2p_routing_summary.is_none() {
            self.p2p_routing_summary.set_default();
        }
        self.p2p_routing_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2p_routing_summary(&mut self) -> CMsgSteamDatagramP2PRoutingSummary {
        self.p2p_routing_summary.take().unwrap_or_else(|| CMsgSteamDatagramP2PRoutingSummary::new())
    }

    // optional fixed64 routing_secret = 11;


    pub fn get_routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }
    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }

    // optional fixed32 dummy_pad = 1023;


    pub fn get_dummy_pad(&self) -> u32 {
        self.dummy_pad.unwrap_or(0)
    }
    pub fn clear_dummy_pad(&mut self) {
        self.dummy_pad = ::std::option::Option::None;
    }

    pub fn has_dummy_pad(&self) -> bool {
        self.dummy_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_pad(&mut self, v: u32) {
        self.dummy_pad = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoConnection {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2p_routing_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_gameserver_relay_session_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_relay_session_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_relay_session_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.from_identity_string)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.legacy_from_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.end_to_end = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_primary_session = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_primary_transport = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2p_routing_summary)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.routing_secret = ::std::option::Option::Some(tmp);
                },
                1023 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.dummy_pad = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.to_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.from_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.to_relay_session_id {
            my_size += 5;
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 5;
        }
        if let Some(ref v) = self.from_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.legacy_from_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.end_to_end {
            my_size += 2;
        }
        if let Some(v) = self.not_primary_session {
            my_size += 2;
        }
        if let Some(v) = self.not_primary_transport {
            my_size += 2;
        }
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2p_routing_summary.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.routing_secret {
            my_size += 9;
        }
        if let Some(v) = self.dummy_pad {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.legacy_gameserver_relay_session_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.to_relay_session_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(ref v) = self.from_identity_string.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.legacy_from_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.end_to_end {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.not_primary_session {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.not_primary_transport {
            os.write_bool(15, v)?;
        }
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2p_routing_summary.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.dummy_pad {
            os.write_fixed32(1023, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNoConnection {
        CMsgSteamDatagramNoConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.to_connection_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.from_connection_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_gameserver_relay_session_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.legacy_gameserver_relay_session_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.legacy_gameserver_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_relay_session_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.to_relay_session_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.to_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_relay_session_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.from_relay_session_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.from_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_identity_string",
                |m: &CMsgSteamDatagramNoConnection| { &m.from_identity_string },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.from_identity_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "legacy_from_steam_id",
                |m: &CMsgSteamDatagramNoConnection| { &m.legacy_from_steam_id },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.legacy_from_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "end_to_end",
                |m: &CMsgSteamDatagramNoConnection| { &m.end_to_end },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.end_to_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "not_primary_session",
                |m: &CMsgSteamDatagramNoConnection| { &m.not_primary_session },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.not_primary_session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "not_primary_transport",
                |m: &CMsgSteamDatagramNoConnection| { &m.not_primary_transport },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.not_primary_transport },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramNoConnection| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramNoConnection| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutingSummary>>(
                "p2p_routing_summary",
                |m: &CMsgSteamDatagramNoConnection| { &m.p2p_routing_summary },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.p2p_routing_summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "routing_secret",
                |m: &CMsgSteamDatagramNoConnection| { &m.routing_secret },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.routing_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "dummy_pad",
                |m: &CMsgSteamDatagramNoConnection| { &m.dummy_pad },
                |m: &mut CMsgSteamDatagramNoConnection| { &mut m.dummy_pad },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNoConnection>(
                "CMsgSteamDatagramNoConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoConnection {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNoConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNoConnection::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNoConnection {
    fn clear(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.legacy_gameserver_relay_session_id = ::std::option::Option::None;
        self.to_relay_session_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.from_identity_string.clear();
        self.legacy_from_steam_id = ::std::option::Option::None;
        self.end_to_end = ::std::option::Option::None;
        self.not_primary_session = ::std::option::Option::None;
        self.not_primary_transport = ::std::option::Option::None;
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.p2p_routing_summary.clear();
        self.routing_secret = ::std::option::Option::None;
        self.dummy_pad = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNoConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverSessionRequest {
    // message fields
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    challenge_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    network_config_version: ::std::option::Option<u32>,
    protocol_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionRequest {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionRequest {
        <CMsgSteamDatagramGameserverSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionRequest {
    pub fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        ::std::default::Default::default()
    }

    // optional bytes ticket = 1;


    pub fn get_ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 challenge_time = 3;


    pub fn get_challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }
    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 5;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 8;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 6;


    pub fn get_network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }
    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 7;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.challenge_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_config_version = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.challenge_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.network_config_version {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ticket.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.challenge_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        CMsgSteamDatagramGameserverSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ticket",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.ticket },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.ticket },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "challenge_time",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge_time },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.server_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_config_version",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.network_config_version },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.network_config_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.protocol_version },
                |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.protocol_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverSessionRequest>(
                "CMsgSteamDatagramGameserverSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverSessionRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverSessionRequest {
    fn clear(&mut self) {
        self.ticket.clear();
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameserverSessionEstablished {
    // message fields
    connection_id: ::std::option::Option<u32>,
    gameserver_identity_string: ::protobuf::SingularField<::std::string::String>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    seq_num_r2c: ::std::option::Option<u32>,
    dummy_legacy_identity_binary: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    legacy_gameserver_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionEstablished {
        <CMsgSteamDatagramGameserverSessionEstablished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionEstablished {
    pub fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional string gameserver_identity_string = 2;


    pub fn get_gameserver_identity_string(&self) -> &str {
        match self.gameserver_identity_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gameserver_identity_string(&mut self) {
        self.gameserver_identity_string.clear();
    }

    pub fn has_gameserver_identity_string(&self) -> bool {
        self.gameserver_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_identity_string(&mut self, v: ::std::string::String) {
        self.gameserver_identity_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gameserver_identity_string(&mut self) -> &mut ::std::string::String {
        if self.gameserver_identity_string.is_none() {
            self.gameserver_identity_string.set_default();
        }
        self.gameserver_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_gameserver_identity_string(&mut self) -> ::std::string::String {
        self.gameserver_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seconds_until_shutdown = 4;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 6;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional bytes dummy_legacy_identity_binary = 7;


    pub fn get_dummy_legacy_identity_binary(&self) -> &[u8] {
        match self.dummy_legacy_identity_binary.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_dummy_legacy_identity_binary(&mut self) {
        self.dummy_legacy_identity_binary.clear();
    }

    pub fn has_dummy_legacy_identity_binary(&self) -> bool {
        self.dummy_legacy_identity_binary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy_legacy_identity_binary(&mut self, v: ::std::vec::Vec<u8>) {
        self.dummy_legacy_identity_binary = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dummy_legacy_identity_binary(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dummy_legacy_identity_binary.is_none() {
            self.dummy_legacy_identity_binary.set_default();
        }
        self.dummy_legacy_identity_binary.as_mut().unwrap()
    }

    // Take field
    pub fn take_dummy_legacy_identity_binary(&mut self) -> ::std::vec::Vec<u8> {
        self.dummy_legacy_identity_binary.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 legacy_gameserver_steamid = 3;


    pub fn get_legacy_gameserver_steamid(&self) -> u64 {
        self.legacy_gameserver_steamid.unwrap_or(0)
    }
    pub fn clear_legacy_gameserver_steamid(&mut self) {
        self.legacy_gameserver_steamid = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_steamid(&self) -> bool {
        self.legacy_gameserver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_steamid(&mut self, v: u64) {
        self.legacy_gameserver_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionEstablished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gameserver_identity_string)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.dummy_legacy_identity_binary)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.legacy_gameserver_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(ref v) = self.gameserver_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dummy_legacy_identity_binary.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.legacy_gameserver_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.gameserver_identity_string.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.dummy_legacy_identity_binary.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.legacy_gameserver_steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        CMsgSteamDatagramGameserverSessionEstablished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.connection_id },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gameserver_identity_string",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.gameserver_identity_string },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.gameserver_identity_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.seq_num_r2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dummy_legacy_identity_binary",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.dummy_legacy_identity_binary },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.dummy_legacy_identity_binary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "legacy_gameserver_steamid",
                |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.legacy_gameserver_steamid },
                |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.legacy_gameserver_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameserverSessionEstablished>(
                "CMsgSteamDatagramGameserverSessionEstablished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionEstablished {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameserverSessionEstablished> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameserverSessionEstablished::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameserverSessionEstablished {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.gameserver_identity_string.clear();
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.dummy_legacy_identity_binary.clear();
        self.legacy_gameserver_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameserverSessionEstablished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionEstablished {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
    // message fields
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    seq_num_c2r: ::std::option::Option<u32>,
    seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsClientToRouter {
        <CMsgSteamDatagramConnectionStatsClientToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // repeated fixed32 ack_relay = 4;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 legacy_ack_e2e = 5;


    pub fn get_legacy_ack_e2e(&self) -> &[u32] {
        &self.legacy_ack_e2e
    }
    pub fn clear_legacy_ack_e2e(&mut self) {
        self.legacy_ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_ack_e2e
    }

    // Take field
    pub fn take_legacy_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 6;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 8;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 9;


    pub fn get_seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }
    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 10;


    pub fn get_seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }
    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.legacy_ack_e2e)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_c2r = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_e2e = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.legacy_ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(4, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(5, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        CMsgSteamDatagramConnectionStatsClientToRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.legacy_ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.legacy_ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_c2r",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_c2r },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_c2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_e2e",
                |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_e2e },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsClientToRouter>(
                "CMsgSteamDatagramConnectionStatsClientToRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsClientToRouter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsClientToRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsClientToRouter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
    NOT_PRIMARY_SESSION = 8,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsClientToRouter_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_IMMEDIATE),
            8 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsClientToRouter_Flags::NOT_PRIMARY_SESSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsClientToRouter_Flags] = &[
            CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_IMMEDIATE,
            CMsgSteamDatagramConnectionStatsClientToRouter_Flags::NOT_PRIMARY_SESSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsClientToRouter_Flags>("CMsgSteamDatagramConnectionStatsClientToRouter.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsClientToRouter_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
    // message fields
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    migrate_request_ip: ::std::option::Option<u32>,
    migrate_request_port: ::std::option::Option<u32>,
    scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    seq_num_r2c: ::std::option::Option<u32>,
    seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToClient {
        <CMsgSteamDatagramConnectionStatsRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional uint32 seconds_until_shutdown = 6;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 10;


    pub fn get_migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }
    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 11;


    pub fn get_migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }
    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 12;


    pub fn get_scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }
    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // repeated fixed32 ack_relay = 13;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 legacy_ack_e2e = 14;


    pub fn get_legacy_ack_e2e(&self) -> &[u32] {
        &self.legacy_ack_e2e
    }
    pub fn clear_legacy_ack_e2e(&mut self) {
        self.legacy_ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_ack_e2e
    }

    // Take field
    pub fn take_legacy_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 15;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 8;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 9;


    pub fn get_seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }
    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.migrate_request_ip = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.migrate_request_port = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.legacy_ack_e2e)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_e2e = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 5;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.legacy_ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(12, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(13, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(14, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        CMsgSteamDatagramConnectionStatsRouterToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "migrate_request_ip",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.migrate_request_ip },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.migrate_request_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "migrate_request_port",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.migrate_request_port },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.migrate_request_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scoring_penalty_relay_cluster",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.scoring_penalty_relay_cluster },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.scoring_penalty_relay_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.legacy_ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.legacy_ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_r2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_e2e },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToClient>(
                "CMsgSteamDatagramConnectionStatsRouterToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToClient {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsRouterToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsRouterToClient::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsRouterToClient_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsRouterToClient_Flags] = &[
            CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToClient_Flags>("CMsgSteamDatagramConnectionStatsRouterToClient.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsRouterToClient_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
    // message fields
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    seq_num_r2s: ::std::option::Option<u32>,
    seq_num_e2e: ::std::option::Option<u32>,
    client_identity_string: ::protobuf::SingularField<::std::string::String>,
    legacy_client_steam_id: ::std::option::Option<u64>,
    relay_session_id: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    routing_secret: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToServer {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToServer {
        <CMsgSteamDatagramConnectionStatsRouterToServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToServer {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // repeated fixed32 ack_relay = 10;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 legacy_ack_e2e = 11;


    pub fn get_legacy_ack_e2e(&self) -> &[u32] {
        &self.legacy_ack_e2e
    }
    pub fn clear_legacy_ack_e2e(&mut self) {
        self.legacy_ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_ack_e2e
    }

    // Take field
    pub fn take_legacy_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 12;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2s = 5;


    pub fn get_seq_num_r2s(&self) -> u32 {
        self.seq_num_r2s.unwrap_or(0)
    }
    pub fn clear_seq_num_r2s(&mut self) {
        self.seq_num_r2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2s(&self) -> bool {
        self.seq_num_r2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2s(&mut self, v: u32) {
        self.seq_num_r2s = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 6;


    pub fn get_seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }
    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    // optional string client_identity_string = 15;


    pub fn get_client_identity_string(&self) -> &str {
        match self.client_identity_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_identity_string(&mut self) {
        self.client_identity_string.clear();
    }

    pub fn has_client_identity_string(&self) -> bool {
        self.client_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_identity_string(&mut self, v: ::std::string::String) {
        self.client_identity_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_identity_string(&mut self) -> &mut ::std::string::String {
        if self.client_identity_string.is_none() {
            self.client_identity_string.set_default();
        }
        self.client_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_identity_string(&mut self) -> ::std::string::String {
        self.client_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 legacy_client_steam_id = 7;


    pub fn get_legacy_client_steam_id(&self) -> u64 {
        self.legacy_client_steam_id.unwrap_or(0)
    }
    pub fn clear_legacy_client_steam_id(&mut self) {
        self.legacy_client_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_client_steam_id(&self) -> bool {
        self.legacy_client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_steam_id(&mut self, v: u64) {
        self.legacy_client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 8;


    pub fn get_relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }
    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 9;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 13;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 routing_secret = 14;


    pub fn get_routing_secret(&self) -> u64 {
        self.routing_secret.unwrap_or(0)
    }
    pub fn clear_routing_secret(&mut self) {
        self.routing_secret = ::std::option::Option::None;
    }

    pub fn has_routing_secret(&self) -> bool {
        self.routing_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_secret(&mut self, v: u64) {
        self.routing_secret = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.legacy_ack_e2e)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2s = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_e2e = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_identity_string)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.legacy_client_steam_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_session_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.routing_secret = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.legacy_ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_r2s {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.client_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.legacy_client_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.routing_secret {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(10, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(11, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.seq_num_r2s {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.client_identity_string.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.legacy_client_steam_id {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.routing_secret {
            os.write_fixed64(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        CMsgSteamDatagramConnectionStatsRouterToServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.legacy_ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.legacy_ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2s",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_r2s },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_r2s },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_e2e",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_identity_string",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_identity_string },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_identity_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "legacy_client_steam_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.legacy_client_steam_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.legacy_client_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "relay_session_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.server_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "routing_secret",
                |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.routing_secret },
                |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.routing_secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToServer>(
                "CMsgSteamDatagramConnectionStatsRouterToServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToServer {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsRouterToServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsRouterToServer::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_r2s = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.client_identity_string.clear();
        self.legacy_client_steam_id = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.routing_secret = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsRouterToServer_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsRouterToServer_Flags] = &[
            CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsRouterToServer_Flags>("CMsgSteamDatagramConnectionStatsRouterToServer.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsRouterToServer_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
    // message fields
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    seq_num_s2r: ::std::option::Option<u32>,
    seq_num_e2e: ::std::option::Option<u32>,
    relay_session_id: ::std::option::Option<u32>,
    client_connection_id: ::std::option::Option<u32>,
    server_connection_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsServerToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsServerToRouter {
        <CMsgSteamDatagramConnectionStatsServerToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsServerToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // repeated fixed32 ack_relay = 8;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 legacy_ack_e2e = 9;


    pub fn get_legacy_ack_e2e(&self) -> &[u32] {
        &self.legacy_ack_e2e
    }
    pub fn clear_legacy_ack_e2e(&mut self) {
        self.legacy_ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_ack_e2e
    }

    // Take field
    pub fn take_legacy_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 10;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2r = 3;


    pub fn get_seq_num_s2r(&self) -> u32 {
        self.seq_num_s2r.unwrap_or(0)
    }
    pub fn clear_seq_num_s2r(&mut self) {
        self.seq_num_s2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2r(&self) -> bool {
        self.seq_num_s2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2r(&mut self, v: u32) {
        self.seq_num_s2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 4;


    pub fn get_seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }
    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_session_id = 6;


    pub fn get_relay_session_id(&self) -> u32 {
        self.relay_session_id.unwrap_or(0)
    }
    pub fn clear_relay_session_id(&mut self) {
        self.relay_session_id = ::std::option::Option::None;
    }

    pub fn has_relay_session_id(&self) -> bool {
        self.relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_session_id(&mut self, v: u32) {
        self.relay_session_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 7;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_connection_id = 11;


    pub fn get_server_connection_id(&self) -> u32 {
        self.server_connection_id.unwrap_or(0)
    }
    pub fn clear_server_connection_id(&mut self) {
        self.server_connection_id = ::std::option::Option::None;
    }

    pub fn has_server_connection_id(&self) -> bool {
        self.server_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_connection_id(&mut self, v: u32) {
        self.server_connection_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.legacy_ack_e2e)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_s2r = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_e2e = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.relay_session_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.server_connection_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.legacy_ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_s2r {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.relay_session_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.server_connection_id {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(8, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(9, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.seq_num_s2r {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.relay_session_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.server_connection_id {
            os.write_fixed32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        CMsgSteamDatagramConnectionStatsServerToRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.legacy_ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.legacy_ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_s2r",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_s2r },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_s2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_e2e",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "relay_session_id",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "server_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.server_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.server_connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsServerToRouter>(
                "CMsgSteamDatagramConnectionStatsServerToRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsServerToRouter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsServerToRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsServerToRouter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.seq_num_s2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.relay_session_id = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.server_connection_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsServerToRouter_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_IMMEDIATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsServerToRouter_Flags] = &[
            CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_IMMEDIATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsServerToRouter_Flags>("CMsgSteamDatagramConnectionStatsServerToRouter.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsServerToRouter_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PSessionRequestBody {
    // message fields
    challenge_time: ::std::option::Option<u32>,
    challenge: ::std::option::Option<u64>,
    client_connection_id: ::std::option::Option<u32>,
    legacy_peer_steam_id: ::std::option::Option<u64>,
    peer_identity_string: ::protobuf::SingularField<::std::string::String>,
    peer_connection_id: ::std::option::Option<u32>,
    protocol_version: ::std::option::Option<u32>,
    network_config_version: ::std::option::Option<u32>,
    unused_public_ip: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequestBody {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequestBody {
        <CMsgSteamDatagramP2PSessionRequestBody as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequestBody {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        ::std::default::Default::default()
    }

    // optional fixed32 challenge_time = 1;


    pub fn get_challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }
    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 2;


    pub fn get_challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }
    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_connection_id = 3;


    pub fn get_client_connection_id(&self) -> u32 {
        self.client_connection_id.unwrap_or(0)
    }
    pub fn clear_client_connection_id(&mut self) {
        self.client_connection_id = ::std::option::Option::None;
    }

    pub fn has_client_connection_id(&self) -> bool {
        self.client_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_connection_id(&mut self, v: u32) {
        self.client_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_peer_steam_id = 4;


    pub fn get_legacy_peer_steam_id(&self) -> u64 {
        self.legacy_peer_steam_id.unwrap_or(0)
    }
    pub fn clear_legacy_peer_steam_id(&mut self) {
        self.legacy_peer_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_peer_steam_id(&self) -> bool {
        self.legacy_peer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_peer_steam_id(&mut self, v: u64) {
        self.legacy_peer_steam_id = ::std::option::Option::Some(v);
    }

    // optional string peer_identity_string = 11;


    pub fn get_peer_identity_string(&self) -> &str {
        match self.peer_identity_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_peer_identity_string(&mut self) {
        self.peer_identity_string.clear();
    }

    pub fn has_peer_identity_string(&self) -> bool {
        self.peer_identity_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_identity_string(&mut self, v: ::std::string::String) {
        self.peer_identity_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_identity_string(&mut self) -> &mut ::std::string::String {
        if self.peer_identity_string.is_none() {
            self.peer_identity_string.set_default();
        }
        self.peer_identity_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_peer_identity_string(&mut self) -> ::std::string::String {
        self.peer_identity_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 peer_connection_id = 5;


    pub fn get_peer_connection_id(&self) -> u32 {
        self.peer_connection_id.unwrap_or(0)
    }
    pub fn clear_peer_connection_id(&mut self) {
        self.peer_connection_id = ::std::option::Option::None;
    }

    pub fn has_peer_connection_id(&self) -> bool {
        self.peer_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peer_connection_id(&mut self, v: u32) {
        self.peer_connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 8;


    pub fn get_protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }
    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // optional uint32 network_config_version = 9;


    pub fn get_network_config_version(&self) -> u32 {
        self.network_config_version.unwrap_or(0)
    }
    pub fn clear_network_config_version(&mut self) {
        self.network_config_version = ::std::option::Option::None;
    }

    pub fn has_network_config_version(&self) -> bool {
        self.network_config_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config_version(&mut self, v: u32) {
        self.network_config_version = ::std::option::Option::Some(v);
    }

    // optional fixed32 unused_public_ip = 10;


    pub fn get_unused_public_ip(&self) -> u32 {
        self.unused_public_ip.unwrap_or(0)
    }
    pub fn clear_unused_public_ip(&mut self) {
        self.unused_public_ip = ::std::option::Option::None;
    }

    pub fn has_unused_public_ip(&self) -> bool {
        self.unused_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused_public_ip(&mut self, v: u32) {
        self.unused_public_ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionRequestBody {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.challenge_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.challenge = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.client_connection_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.legacy_peer_steam_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.peer_identity_string)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.peer_connection_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_config_version = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.unused_public_ip = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_time {
            my_size += 5;
        }
        if let Some(v) = self.challenge {
            my_size += 9;
        }
        if let Some(v) = self.client_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.legacy_peer_steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.peer_identity_string.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.peer_connection_id {
            my_size += 5;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.network_config_version {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unused_public_ip {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.challenge_time {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_connection_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_peer_steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(ref v) = self.peer_identity_string.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.peer_connection_id {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.network_config_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.unused_public_ip {
            os.write_fixed32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequestBody {
        CMsgSteamDatagramP2PSessionRequestBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "challenge_time",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.challenge_time },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.challenge_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "challenge",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.challenge },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.challenge },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "client_connection_id",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.client_connection_id },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.client_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "legacy_peer_steam_id",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.legacy_peer_steam_id },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.legacy_peer_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peer_identity_string",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.peer_identity_string },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.peer_identity_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "peer_connection_id",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.peer_connection_id },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.peer_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_version",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.protocol_version },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.protocol_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_config_version",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.network_config_version },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.network_config_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "unused_public_ip",
                |m: &CMsgSteamDatagramP2PSessionRequestBody| { &m.unused_public_ip },
                |m: &mut CMsgSteamDatagramP2PSessionRequestBody| { &mut m.unused_public_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PSessionRequestBody>(
                "CMsgSteamDatagramP2PSessionRequestBody",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequestBody {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PSessionRequestBody> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PSessionRequestBody::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PSessionRequestBody {
    fn clear(&mut self) {
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_connection_id = ::std::option::Option::None;
        self.legacy_peer_steam_id = ::std::option::Option::None;
        self.peer_identity_string.clear();
        self.peer_connection_id = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.network_config_version = ::std::option::Option::None;
        self.unused_public_ip = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PSessionRequestBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionRequestBody {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PSessionRequest {
    // message fields
    pub cert: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
    body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionRequest {
    fn default() -> &'a CMsgSteamDatagramP2PSessionRequest {
        <CMsgSteamDatagramP2PSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionRequest {
    pub fn new() -> CMsgSteamDatagramP2PSessionRequest {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramCertificateSigned cert = 1;


    pub fn get_cert(&self) -> &super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cert(&mut self) {
        self.cert.clear();
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned) {
        self.cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        if self.cert.is_none() {
            self.cert.set_default();
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned {
        self.cert.take().unwrap_or_else(|| super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned::new())
    }

    // optional bytes body = 2;


    pub fn get_body(&self) -> &[u8] {
        match self.body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        self.body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cert)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.body)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cert.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PSessionRequest {
        CMsgSteamDatagramP2PSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>>(
                "cert",
                |m: &CMsgSteamDatagramP2PSessionRequest| { &m.cert },
                |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &CMsgSteamDatagramP2PSessionRequest| { &m.body },
                |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &CMsgSteamDatagramP2PSessionRequest| { &m.signature },
                |m: &mut CMsgSteamDatagramP2PSessionRequest| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PSessionRequest>(
                "CMsgSteamDatagramP2PSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PSessionRequest::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PSessionRequest {
    fn clear(&mut self) {
        self.cert.clear();
        self.body.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PSessionEstablished {
    // message fields
    connection_id: ::std::option::Option<u32>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    relay_routing_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    seq_num_r2c: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramP2PSessionEstablished {
        <CMsgSteamDatagramP2PSessionEstablished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PSessionEstablished {
    pub fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 3;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional bytes relay_routing_token = 4;


    pub fn get_relay_routing_token(&self) -> &[u8] {
        match self.relay_routing_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_relay_routing_token(&mut self) {
        self.relay_routing_token.clear();
    }

    pub fn has_relay_routing_token(&self) -> bool {
        self.relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.relay_routing_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.relay_routing_token.is_none() {
            self.relay_routing_token.set_default();
        }
        self.relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 seq_num_r2c = 5;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PSessionEstablished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.relay_routing_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.relay_routing_token.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PSessionEstablished {
        CMsgSteamDatagramP2PSessionEstablished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.connection_id },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "relay_routing_token",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.relay_routing_token },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.relay_routing_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramP2PSessionEstablished| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramP2PSessionEstablished| { &mut m.seq_num_r2c },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PSessionEstablished>(
                "CMsgSteamDatagramP2PSessionEstablished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PSessionEstablished {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PSessionEstablished> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PSessionEstablished::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PSessionEstablished {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.relay_routing_token.clear();
        self.seq_num_r2c = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PSessionEstablished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PSessionEstablished {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    // message fields
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub p2p_routing_summary: ::protobuf::SingularPtrField<CMsgSteamDatagramP2PRoutingSummary>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    forward_target_relay_routing_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    forward_target_revision: ::std::option::Option<u32>,
    routes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ack_peer_routes_revision: ::std::option::Option<u32>,
    connection_id: ::std::option::Option<u32>,
    seq_num_c2r: ::std::option::Option<u32>,
    seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        <CMsgSteamDatagramConnectionStatsP2PClientToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramP2PRoutingSummary p2p_routing_summary = 14;


    pub fn get_p2p_routing_summary(&self) -> &CMsgSteamDatagramP2PRoutingSummary {
        self.p2p_routing_summary.as_ref().unwrap_or_else(|| <CMsgSteamDatagramP2PRoutingSummary as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2p_routing_summary(&mut self) {
        self.p2p_routing_summary.clear();
    }

    pub fn has_p2p_routing_summary(&self) -> bool {
        self.p2p_routing_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2p_routing_summary(&mut self, v: CMsgSteamDatagramP2PRoutingSummary) {
        self.p2p_routing_summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2p_routing_summary(&mut self) -> &mut CMsgSteamDatagramP2PRoutingSummary {
        if self.p2p_routing_summary.is_none() {
            self.p2p_routing_summary.set_default();
        }
        self.p2p_routing_summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2p_routing_summary(&mut self) -> CMsgSteamDatagramP2PRoutingSummary {
        self.p2p_routing_summary.take().unwrap_or_else(|| CMsgSteamDatagramP2PRoutingSummary::new())
    }

    // repeated fixed32 ack_relay = 3;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 legacy_ack_e2e = 4;


    pub fn get_legacy_ack_e2e(&self) -> &[u32] {
        &self.legacy_ack_e2e
    }
    pub fn clear_legacy_ack_e2e(&mut self) {
        self.legacy_ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_ack_e2e
    }

    // Take field
    pub fn take_legacy_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 5;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes forward_target_relay_routing_token = 6;


    pub fn get_forward_target_relay_routing_token(&self) -> &[u8] {
        match self.forward_target_relay_routing_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_forward_target_relay_routing_token(&mut self) {
        self.forward_target_relay_routing_token.clear();
    }

    pub fn has_forward_target_relay_routing_token(&self) -> bool {
        self.forward_target_relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.forward_target_relay_routing_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward_target_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.forward_target_relay_routing_token.is_none() {
            self.forward_target_relay_routing_token.set_default();
        }
        self.forward_target_relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_forward_target_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.forward_target_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 forward_target_revision = 7;


    pub fn get_forward_target_revision(&self) -> u32 {
        self.forward_target_revision.unwrap_or(0)
    }
    pub fn clear_forward_target_revision(&mut self) {
        self.forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_forward_target_revision(&self) -> bool {
        self.forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forward_target_revision(&mut self, v: u32) {
        self.forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional bytes routes = 8;


    pub fn get_routes(&self) -> &[u8] {
        match self.routes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<u8>) {
        self.routes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<u8> {
        self.routes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_peer_routes_revision = 9;


    pub fn get_ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }
    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 10;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 11;


    pub fn get_seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }
    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 12;


    pub fn get_seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }
    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2p_routing_summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2p_routing_summary)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.legacy_ack_e2e)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.forward_target_relay_routing_token)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.forward_target_revision = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.routes)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_peer_routes_revision = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_c2r = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_e2e = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2p_routing_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.legacy_ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.forward_target_relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.forward_target_revision {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2p_routing_summary.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(3, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(4, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.forward_target_relay_routing_token.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.forward_target_revision {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.routes.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        CMsgSteamDatagramConnectionStatsP2PClientToRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutingSummary>>(
                "p2p_routing_summary",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.p2p_routing_summary },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.p2p_routing_summary },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.legacy_ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.legacy_ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "forward_target_relay_routing_token",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.forward_target_relay_routing_token },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.forward_target_relay_routing_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "forward_target_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.forward_target_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.forward_target_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "routes",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.routes },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_peer_routes_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.ack_peer_routes_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.ack_peer_routes_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_c2r",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.seq_num_c2r },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.seq_num_c2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &m.seq_num_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PClientToRouter| { &mut m.seq_num_e2e },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PClientToRouter>(
                "CMsgSteamDatagramConnectionStatsP2PClientToRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PClientToRouter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsP2PClientToRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsP2PClientToRouter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.p2p_routing_summary.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.forward_target_relay_routing_token.clear();
        self.forward_target_revision = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PClientToRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
    NOT_PRIMARY_SESSION = 8,
    NOT_PRIMARY_TRANSPORT_E2E = 16,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_IMMEDIATE),
            8 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::NOT_PRIMARY_SESSION),
            16 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::NOT_PRIMARY_TRANSPORT_E2E),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags] = &[
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_IMMEDIATE,
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::NOT_PRIMARY_SESSION,
            CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::NOT_PRIMARY_TRANSPORT_E2E,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags>("CMsgSteamDatagramConnectionStatsP2PClientToRouter.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    // message fields
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    migrate_request_ip: ::std::option::Option<u32>,
    migrate_request_port: ::std::option::Option<u32>,
    scoring_penalty_relay_cluster: ::std::option::Option<u32>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    ack_forward_target_revision: ::std::option::Option<u32>,
    routes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ack_peer_routes_revision: ::std::option::Option<u32>,
    connection_id: ::std::option::Option<u32>,
    seq_num_r2c: ::std::option::Option<u32>,
    seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        <CMsgSteamDatagramConnectionStatsP2PRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional uint32 seconds_until_shutdown = 3;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 migrate_request_ip = 4;


    pub fn get_migrate_request_ip(&self) -> u32 {
        self.migrate_request_ip.unwrap_or(0)
    }
    pub fn clear_migrate_request_ip(&mut self) {
        self.migrate_request_ip = ::std::option::Option::None;
    }

    pub fn has_migrate_request_ip(&self) -> bool {
        self.migrate_request_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_ip(&mut self, v: u32) {
        self.migrate_request_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 migrate_request_port = 5;


    pub fn get_migrate_request_port(&self) -> u32 {
        self.migrate_request_port.unwrap_or(0)
    }
    pub fn clear_migrate_request_port(&mut self) {
        self.migrate_request_port = ::std::option::Option::None;
    }

    pub fn has_migrate_request_port(&self) -> bool {
        self.migrate_request_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_migrate_request_port(&mut self, v: u32) {
        self.migrate_request_port = ::std::option::Option::Some(v);
    }

    // optional uint32 scoring_penalty_relay_cluster = 6;


    pub fn get_scoring_penalty_relay_cluster(&self) -> u32 {
        self.scoring_penalty_relay_cluster.unwrap_or(0)
    }
    pub fn clear_scoring_penalty_relay_cluster(&mut self) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
    }

    pub fn has_scoring_penalty_relay_cluster(&self) -> bool {
        self.scoring_penalty_relay_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scoring_penalty_relay_cluster(&mut self, v: u32) {
        self.scoring_penalty_relay_cluster = ::std::option::Option::Some(v);
    }

    // repeated fixed32 ack_relay = 7;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 legacy_ack_e2e = 8;


    pub fn get_legacy_ack_e2e(&self) -> &[u32] {
        &self.legacy_ack_e2e
    }
    pub fn clear_legacy_ack_e2e(&mut self) {
        self.legacy_ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_ack_e2e
    }

    // Take field
    pub fn take_legacy_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 9;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_forward_target_revision = 10;


    pub fn get_ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }
    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional bytes routes = 11;


    pub fn get_routes(&self) -> &[u8] {
        match self.routes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<u8>) {
        self.routes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<u8> {
        self.routes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_peer_routes_revision = 12;


    pub fn get_ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }
    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id = 13;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 14;


    pub fn get_seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }
    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 15;


    pub fn get_seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }
    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.migrate_request_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.migrate_request_port = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scoring_penalty_relay_cluster = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.legacy_ack_e2e)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_forward_target_revision = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.routes)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_peer_routes_revision = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2c = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_e2e = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.migrate_request_ip {
            my_size += 5;
        }
        if let Some(v) = self.migrate_request_port {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.legacy_ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.migrate_request_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.migrate_request_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.scoring_penalty_relay_cluster {
            os.write_uint32(6, v)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(7, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(8, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.routes.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.connection_id {
            os.write_fixed32(13, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        CMsgSteamDatagramConnectionStatsP2PRouterToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "migrate_request_ip",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.migrate_request_ip },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.migrate_request_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "migrate_request_port",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.migrate_request_port },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.migrate_request_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scoring_penalty_relay_cluster",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.scoring_penalty_relay_cluster },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.scoring_penalty_relay_cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.legacy_ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.legacy_ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_forward_target_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_forward_target_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_forward_target_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "routes",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.routes },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_peer_routes_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.ack_peer_routes_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.ack_peer_routes_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2c",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seq_num_r2c },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seq_num_r2c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &m.seq_num_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToClient| { &mut m.seq_num_e2e },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PRouterToClient>(
                "CMsgSteamDatagramConnectionStatsP2PRouterToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PRouterToClient {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsP2PRouterToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsP2PRouterToClient::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.migrate_request_ip = ::std::option::Option::None;
        self.migrate_request_port = ::std::option::Option::None;
        self.scoring_penalty_relay_cluster = ::std::option::Option::None;
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.connection_id = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
    NOT_PRIMARY_TRANSPORT_E2E = 16,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_IMMEDIATE),
            16 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::NOT_PRIMARY_TRANSPORT_E2E),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags] = &[
            CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_IMMEDIATE,
            CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::NOT_PRIMARY_TRANSPORT_E2E,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags>("CMsgSteamDatagramConnectionStatsP2PRouterToClient.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PBadRouteRouterToClient {
    // message fields
    connection_id: ::std::option::Option<u32>,
    failed_relay_routing_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ack_forward_target_revision: ::std::option::Option<u32>,
    kludge_pad: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn default() -> &'a CMsgSteamDatagramP2PBadRouteRouterToClient {
        <CMsgSteamDatagramP2PBadRouteRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PBadRouteRouterToClient {
    pub fn new() -> CMsgSteamDatagramP2PBadRouteRouterToClient {
        ::std::default::Default::default()
    }

    // optional fixed32 connection_id = 1;


    pub fn get_connection_id(&self) -> u32 {
        self.connection_id.unwrap_or(0)
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id = ::std::option::Option::None;
    }

    pub fn has_connection_id(&self) -> bool {
        self.connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: u32) {
        self.connection_id = ::std::option::Option::Some(v);
    }

    // optional bytes failed_relay_routing_token = 2;


    pub fn get_failed_relay_routing_token(&self) -> &[u8] {
        match self.failed_relay_routing_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_failed_relay_routing_token(&mut self) {
        self.failed_relay_routing_token.clear();
    }

    pub fn has_failed_relay_routing_token(&self) -> bool {
        self.failed_relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.failed_relay_routing_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failed_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.failed_relay_routing_token.is_none() {
            self.failed_relay_routing_token.set_default();
        }
        self.failed_relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_failed_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.failed_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_forward_target_revision = 3;


    pub fn get_ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }
    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional fixed64 kludge_pad = 99;


    pub fn get_kludge_pad(&self) -> u64 {
        self.kludge_pad.unwrap_or(0)
    }
    pub fn clear_kludge_pad(&mut self) {
        self.kludge_pad = ::std::option::Option::None;
    }

    pub fn has_kludge_pad(&self) -> bool {
        self.kludge_pad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kludge_pad(&mut self, v: u64) {
        self.kludge_pad = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.connection_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.failed_relay_routing_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_forward_target_revision = ::std::option::Option::Some(tmp);
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.kludge_pad = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.connection_id {
            my_size += 5;
        }
        if let Some(ref v) = self.failed_relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kludge_pad {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(ref v) = self.failed_relay_routing_token.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.kludge_pad {
            os.write_fixed64(99, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PBadRouteRouterToClient {
        CMsgSteamDatagramP2PBadRouteRouterToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "connection_id",
                |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.connection_id },
                |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "failed_relay_routing_token",
                |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.failed_relay_routing_token },
                |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.failed_relay_routing_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_forward_target_revision",
                |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.ack_forward_target_revision },
                |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.ack_forward_target_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "kludge_pad",
                |m: &CMsgSteamDatagramP2PBadRouteRouterToClient| { &m.kludge_pad },
                |m: &mut CMsgSteamDatagramP2PBadRouteRouterToClient| { &mut m.kludge_pad },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PBadRouteRouterToClient>(
                "CMsgSteamDatagramP2PBadRouteRouterToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PBadRouteRouterToClient {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PBadRouteRouterToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PBadRouteRouterToClient::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn clear(&mut self) {
        self.connection_id = ::std::option::Option::None;
        self.failed_relay_routing_token.clear();
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.kludge_pad = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PBadRouteRouterToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRoutes {
    // message fields
    pub relay_clusters: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster>,
    pub routes: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route>,
    revision: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes {
        <CMsgSteamDatagramP2PRoutes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes {
    pub fn new() -> CMsgSteamDatagramP2PRoutes {
        ::std::default::Default::default()
    }

    // repeated .CMsgSteamDatagramP2PRoutes.RelayCluster relay_clusters = 1;


    pub fn get_relay_clusters(&self) -> &[CMsgSteamDatagramP2PRoutes_RelayCluster] {
        &self.relay_clusters
    }
    pub fn clear_relay_clusters(&mut self) {
        self.relay_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_relay_clusters(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster>) {
        self.relay_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relay_clusters(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster> {
        &mut self.relay_clusters
    }

    // Take field
    pub fn take_relay_clusters(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_RelayCluster> {
        ::std::mem::replace(&mut self.relay_clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgSteamDatagramP2PRoutes.Route routes = 2;


    pub fn get_routes(&self) -> &[CMsgSteamDatagramP2PRoutes_Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramP2PRoutes_Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    // optional uint32 revision = 3;


    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutes {
    fn is_initialized(&self) -> bool {
        for v in &self.relay_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relay_clusters)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.relay_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.relay_clusters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.routes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.revision {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRoutes {
        CMsgSteamDatagramP2PRoutes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutes_RelayCluster>>(
                "relay_clusters",
                |m: &CMsgSteamDatagramP2PRoutes| { &m.relay_clusters },
                |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.relay_clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramP2PRoutes_Route>>(
                "routes",
                |m: &CMsgSteamDatagramP2PRoutes| { &m.routes },
                |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &CMsgSteamDatagramP2PRoutes| { &m.revision },
                |m: &mut CMsgSteamDatagramP2PRoutes| { &mut m.revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRoutes>(
                "CMsgSteamDatagramP2PRoutes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRoutes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRoutes::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRoutes {
    fn clear(&mut self) {
        self.relay_clusters.clear();
        self.routes.clear();
        self.revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRoutes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRoutes_RelayCluster {
    // message fields
    pop_id: ::std::option::Option<u32>,
    ping_ms: ::std::option::Option<u32>,
    score_penalty: ::std::option::Option<u32>,
    session_relay_routing_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes_RelayCluster {
        <CMsgSteamDatagramP2PRoutes_RelayCluster as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes_RelayCluster {
    pub fn new() -> CMsgSteamDatagramP2PRoutes_RelayCluster {
        ::std::default::Default::default()
    }

    // optional fixed32 pop_id = 1;


    pub fn get_pop_id(&self) -> u32 {
        self.pop_id.unwrap_or(0)
    }
    pub fn clear_pop_id(&mut self) {
        self.pop_id = ::std::option::Option::None;
    }

    pub fn has_pop_id(&self) -> bool {
        self.pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pop_id(&mut self, v: u32) {
        self.pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ms = 2;


    pub fn get_ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }
    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 score_penalty = 3;


    pub fn get_score_penalty(&self) -> u32 {
        self.score_penalty.unwrap_or(0)
    }
    pub fn clear_score_penalty(&mut self) {
        self.score_penalty = ::std::option::Option::None;
    }

    pub fn has_score_penalty(&self) -> bool {
        self.score_penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_penalty(&mut self, v: u32) {
        self.score_penalty = ::std::option::Option::Some(v);
    }

    // optional bytes session_relay_routing_token = 4;


    pub fn get_session_relay_routing_token(&self) -> &[u8] {
        match self.session_relay_routing_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_session_relay_routing_token(&mut self) {
        self.session_relay_routing_token.clear();
    }

    pub fn has_session_relay_routing_token(&self) -> bool {
        self.session_relay_routing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_relay_routing_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_relay_routing_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_relay_routing_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.session_relay_routing_token.is_none() {
            self.session_relay_routing_token.set_default();
        }
        self.session_relay_routing_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_relay_routing_token(&mut self) -> ::std::vec::Vec<u8> {
        self.session_relay_routing_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.pop_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ms = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_penalty = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.session_relay_routing_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pop_id {
            my_size += 5;
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_penalty {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.session_relay_routing_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pop_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.score_penalty {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.session_relay_routing_token.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRoutes_RelayCluster {
        CMsgSteamDatagramP2PRoutes_RelayCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "pop_id",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.pop_id },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ms",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.ping_ms },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_penalty",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.score_penalty },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.score_penalty },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "session_relay_routing_token",
                |m: &CMsgSteamDatagramP2PRoutes_RelayCluster| { &m.session_relay_routing_token },
                |m: &mut CMsgSteamDatagramP2PRoutes_RelayCluster| { &mut m.session_relay_routing_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRoutes_RelayCluster>(
                "CMsgSteamDatagramP2PRoutes.RelayCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes_RelayCluster {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRoutes_RelayCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRoutes_RelayCluster::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn clear(&mut self) {
        self.pop_id = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.score_penalty = ::std::option::Option::None;
        self.session_relay_routing_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutes_RelayCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramP2PRoutes_Route {
    // message fields
    my_pop_id: ::std::option::Option<u32>,
    your_pop_id: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramP2PRoutes_Route {
    fn default() -> &'a CMsgSteamDatagramP2PRoutes_Route {
        <CMsgSteamDatagramP2PRoutes_Route as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramP2PRoutes_Route {
    pub fn new() -> CMsgSteamDatagramP2PRoutes_Route {
        ::std::default::Default::default()
    }

    // optional fixed32 my_pop_id = 1;


    pub fn get_my_pop_id(&self) -> u32 {
        self.my_pop_id.unwrap_or(0)
    }
    pub fn clear_my_pop_id(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
    }

    pub fn has_my_pop_id(&self) -> bool {
        self.my_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_pop_id(&mut self, v: u32) {
        self.my_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_pop_id = 2;


    pub fn get_your_pop_id(&self) -> u32 {
        self.your_pop_id.unwrap_or(0)
    }
    pub fn clear_your_pop_id(&mut self) {
        self.your_pop_id = ::std::option::Option::None;
    }

    pub fn has_your_pop_id(&self) -> bool {
        self.your_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_pop_id(&mut self, v: u32) {
        self.your_pop_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 3;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramP2PRoutes_Route {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.my_pop_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_pop_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.my_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.your_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.my_pop_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.your_pop_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramP2PRoutes_Route {
        CMsgSteamDatagramP2PRoutes_Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "my_pop_id",
                |m: &CMsgSteamDatagramP2PRoutes_Route| { &m.my_pop_id },
                |m: &mut CMsgSteamDatagramP2PRoutes_Route| { &mut m.my_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_pop_id",
                |m: &CMsgSteamDatagramP2PRoutes_Route| { &m.your_pop_id },
                |m: &mut CMsgSteamDatagramP2PRoutes_Route| { &mut m.your_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CMsgSteamDatagramP2PRoutes_Route| { &m.score },
                |m: &mut CMsgSteamDatagramP2PRoutes_Route| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramP2PRoutes_Route>(
                "CMsgSteamDatagramP2PRoutes.Route",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramP2PRoutes_Route {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramP2PRoutes_Route> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramP2PRoutes_Route::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramP2PRoutes_Route {
    fn clear(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
        self.your_pop_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramP2PRoutes_Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramP2PRoutes_Route {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameServerSample {
    // message fields
    ipv4: ::std::option::Option<u32>,
    port: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameServerSample {
    fn default() -> &'a CMsgSteamDatagramGameServerSample {
        <CMsgSteamDatagramGameServerSample as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameServerSample {
    pub fn new() -> CMsgSteamDatagramGameServerSample {
        ::std::default::Default::default()
    }

    // optional fixed32 ipv4 = 1;


    pub fn get_ipv4(&self) -> u32 {
        self.ipv4.unwrap_or(0)
    }
    pub fn clear_ipv4(&mut self) {
        self.ipv4 = ::std::option::Option::None;
    }

    pub fn has_ipv4(&self) -> bool {
        self.ipv4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4(&mut self, v: u32) {
        self.ipv4 = ::std::option::Option::Some(v);
    }

    // optional uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameServerSample {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ipv4 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ipv4 {
            my_size += 5;
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ipv4 {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameServerSample {
        CMsgSteamDatagramGameServerSample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ipv4",
                |m: &CMsgSteamDatagramGameServerSample| { &m.ipv4 },
                |m: &mut CMsgSteamDatagramGameServerSample| { &mut m.ipv4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &CMsgSteamDatagramGameServerSample| { &m.port },
                |m: &mut CMsgSteamDatagramGameServerSample| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameServerSample>(
                "CMsgSteamDatagramGameServerSample",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameServerSample {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameServerSample> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameServerSample::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameServerSample {
    fn clear(&mut self) {
        self.ipv4 = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameServerSample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameServerSample {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramGameServerSampleDataCenter {
    // message fields
    datacenter_id: ::std::option::Option<u32>,
    pub servers: ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameServerSampleDataCenter {
    fn default() -> &'a CMsgSteamDatagramGameServerSampleDataCenter {
        <CMsgSteamDatagramGameServerSampleDataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameServerSampleDataCenter {
    pub fn new() -> CMsgSteamDatagramGameServerSampleDataCenter {
        ::std::default::Default::default()
    }

    // optional fixed32 datacenter_id = 1;


    pub fn get_datacenter_id(&self) -> u32 {
        self.datacenter_id.unwrap_or(0)
    }
    pub fn clear_datacenter_id(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
    }

    pub fn has_datacenter_id(&self) -> bool {
        self.datacenter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datacenter_id(&mut self, v: u32) {
        self.datacenter_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramGameServerSample servers = 3;


    pub fn get_servers(&self) -> &[CMsgSteamDatagramGameServerSample] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameServerSampleDataCenter {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.datacenter_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.datacenter_id {
            my_size += 5;
        }
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.datacenter_id {
            os.write_fixed32(1, v)?;
        }
        for v in &self.servers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramGameServerSampleDataCenter {
        CMsgSteamDatagramGameServerSampleDataCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "datacenter_id",
                |m: &CMsgSteamDatagramGameServerSampleDataCenter| { &m.datacenter_id },
                |m: &mut CMsgSteamDatagramGameServerSampleDataCenter| { &mut m.datacenter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramGameServerSample>>(
                "servers",
                |m: &CMsgSteamDatagramGameServerSampleDataCenter| { &m.servers },
                |m: &mut CMsgSteamDatagramGameServerSampleDataCenter| { &mut m.servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramGameServerSampleDataCenter>(
                "CMsgSteamDatagramGameServerSampleDataCenter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameServerSampleDataCenter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramGameServerSampleDataCenter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramGameServerSampleDataCenter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramGameServerSampleDataCenter {
    fn clear(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramGameServerSampleDataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameServerSampleDataCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRelayToRelayPing {
    // message fields
    request_timestamp: ::std::option::Option<u32>,
    request_date: ::std::option::Option<u32>,
    my_pop_id: ::std::option::Option<u32>,
    your_pop_id: ::std::option::Option<u32>,
    checksum: ::std::option::Option<u32>,
    pub data_centers: ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSampleDataCenter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRelayToRelayPing {
    fn default() -> &'a CMsgSteamDatagramRelayToRelayPing {
        <CMsgSteamDatagramRelayToRelayPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRelayToRelayPing {
    pub fn new() -> CMsgSteamDatagramRelayToRelayPing {
        ::std::default::Default::default()
    }

    // optional fixed32 request_timestamp = 1;


    pub fn get_request_timestamp(&self) -> u32 {
        self.request_timestamp.unwrap_or(0)
    }
    pub fn clear_request_timestamp(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
    }

    pub fn has_request_timestamp(&self) -> bool {
        self.request_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_timestamp(&mut self, v: u32) {
        self.request_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 request_date = 2;


    pub fn get_request_date(&self) -> u32 {
        self.request_date.unwrap_or(0)
    }
    pub fn clear_request_date(&mut self) {
        self.request_date = ::std::option::Option::None;
    }

    pub fn has_request_date(&self) -> bool {
        self.request_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_date(&mut self, v: u32) {
        self.request_date = ::std::option::Option::Some(v);
    }

    // optional fixed32 my_pop_id = 3;


    pub fn get_my_pop_id(&self) -> u32 {
        self.my_pop_id.unwrap_or(0)
    }
    pub fn clear_my_pop_id(&mut self) {
        self.my_pop_id = ::std::option::Option::None;
    }

    pub fn has_my_pop_id(&self) -> bool {
        self.my_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_pop_id(&mut self, v: u32) {
        self.my_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_pop_id = 4;


    pub fn get_your_pop_id(&self) -> u32 {
        self.your_pop_id.unwrap_or(0)
    }
    pub fn clear_your_pop_id(&mut self) {
        self.your_pop_id = ::std::option::Option::None;
    }

    pub fn has_your_pop_id(&self) -> bool {
        self.your_pop_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_pop_id(&mut self, v: u32) {
        self.your_pop_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 checksum = 5;


    pub fn get_checksum(&self) -> u32 {
        self.checksum.unwrap_or(0)
    }
    pub fn clear_checksum(&mut self) {
        self.checksum = ::std::option::Option::None;
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: u32) {
        self.checksum = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramGameServerSampleDataCenter data_centers = 6;


    pub fn get_data_centers(&self) -> &[CMsgSteamDatagramGameServerSampleDataCenter] {
        &self.data_centers
    }
    pub fn clear_data_centers(&mut self) {
        self.data_centers.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_centers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSampleDataCenter>) {
        self.data_centers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_centers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSampleDataCenter> {
        &mut self.data_centers
    }

    // Take field
    pub fn take_data_centers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSampleDataCenter> {
        ::std::mem::replace(&mut self.data_centers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRelayToRelayPing {
    fn is_initialized(&self) -> bool {
        for v in &self.data_centers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.request_timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.request_date = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.my_pop_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.your_pop_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.checksum = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_centers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.request_date {
            my_size += 5;
        }
        if let Some(v) = self.my_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.your_pop_id {
            my_size += 5;
        }
        if let Some(v) = self.checksum {
            my_size += 5;
        }
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_timestamp {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.request_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.my_pop_id {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.your_pop_id {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.checksum {
            os.write_fixed32(5, v)?;
        }
        for v in &self.data_centers {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRelayToRelayPing {
        CMsgSteamDatagramRelayToRelayPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "request_timestamp",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.request_timestamp },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.request_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "request_date",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.request_date },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.request_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "my_pop_id",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.my_pop_id },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.my_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "your_pop_id",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.your_pop_id },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.your_pop_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "checksum",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.checksum },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.checksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramGameServerSampleDataCenter>>(
                "data_centers",
                |m: &CMsgSteamDatagramRelayToRelayPing| { &m.data_centers },
                |m: &mut CMsgSteamDatagramRelayToRelayPing| { &mut m.data_centers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRelayToRelayPing>(
                "CMsgSteamDatagramRelayToRelayPing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRelayToRelayPing {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRelayToRelayPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRelayToRelayPing::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRelayToRelayPing {
    fn clear(&mut self) {
        self.request_timestamp = ::std::option::Option::None;
        self.request_date = ::std::option::Option::None;
        self.my_pop_id = ::std::option::Option::None;
        self.your_pop_id = ::std::option::Option::None;
        self.checksum = ::std::option::Option::None;
        self.data_centers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRelayToRelayPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRelayToRelayPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramDataCenterState {
    // message fields
    pub data_centers: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState {
    fn default() -> &'a CMsgSteamDatagramDataCenterState {
        <CMsgSteamDatagramDataCenterState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState {
    pub fn new() -> CMsgSteamDatagramDataCenterState {
        ::std::default::Default::default()
    }

    // repeated .CMsgSteamDatagramDataCenterState.DataCenter data_centers = 1;


    pub fn get_data_centers(&self) -> &[CMsgSteamDatagramDataCenterState_DataCenter] {
        &self.data_centers
    }
    pub fn clear_data_centers(&mut self) {
        self.data_centers.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_centers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter>) {
        self.data_centers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_centers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter> {
        &mut self.data_centers
    }

    // Take field
    pub fn take_data_centers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_DataCenter> {
        ::std::mem::replace(&mut self.data_centers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState {
    fn is_initialized(&self) -> bool {
        for v in &self.data_centers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_centers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data_centers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDataCenterState {
        CMsgSteamDatagramDataCenterState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramDataCenterState_DataCenter>>(
                "data_centers",
                |m: &CMsgSteamDatagramDataCenterState| { &m.data_centers },
                |m: &mut CMsgSteamDatagramDataCenterState| { &mut m.data_centers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDataCenterState>(
                "CMsgSteamDatagramDataCenterState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDataCenterState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDataCenterState::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDataCenterState {
    fn clear(&mut self) {
        self.data_centers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDataCenterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramDataCenterState_Server {
    // message fields
    address: ::protobuf::SingularField<::std::string::String>,
    ping_ms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState_Server {
    fn default() -> &'a CMsgSteamDatagramDataCenterState_Server {
        <CMsgSteamDatagramDataCenterState_Server as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState_Server {
    pub fn new() -> CMsgSteamDatagramDataCenterState_Server {
        ::std::default::Default::default()
    }

    // optional string address = 1;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping_ms = 2;


    pub fn get_ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }
    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState_Server {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDataCenterState_Server {
        CMsgSteamDatagramDataCenterState_Server::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &CMsgSteamDatagramDataCenterState_Server| { &m.address },
                |m: &mut CMsgSteamDatagramDataCenterState_Server| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping_ms",
                |m: &CMsgSteamDatagramDataCenterState_Server| { &m.ping_ms },
                |m: &mut CMsgSteamDatagramDataCenterState_Server| { &mut m.ping_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDataCenterState_Server>(
                "CMsgSteamDatagramDataCenterState.Server",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState_Server {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDataCenterState_Server> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDataCenterState_Server::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDataCenterState_Server {
    fn clear(&mut self) {
        self.address.clear();
        self.ping_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDataCenterState_Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState_Server {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramDataCenterState_DataCenter {
    // message fields
    code: ::protobuf::SingularField<::std::string::String>,
    pub server_sample: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>,
    pub relay_sample: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState_DataCenter {
    fn default() -> &'a CMsgSteamDatagramDataCenterState_DataCenter {
        <CMsgSteamDatagramDataCenterState_DataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState_DataCenter {
    pub fn new() -> CMsgSteamDatagramDataCenterState_DataCenter {
        ::std::default::Default::default()
    }

    // optional string code = 1;


    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgSteamDatagramDataCenterState.Server server_sample = 2;


    pub fn get_server_sample(&self) -> &[CMsgSteamDatagramDataCenterState_Server] {
        &self.server_sample
    }
    pub fn clear_server_sample(&mut self) {
        self.server_sample.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_sample(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>) {
        self.server_sample = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_sample(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        &mut self.server_sample
    }

    // Take field
    pub fn take_server_sample(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        ::std::mem::replace(&mut self.server_sample, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgSteamDatagramDataCenterState.Server relay_sample = 3;


    pub fn get_relay_sample(&self) -> &[CMsgSteamDatagramDataCenterState_Server] {
        &self.relay_sample
    }
    pub fn clear_relay_sample(&mut self) {
        self.relay_sample.clear();
    }

    // Param is passed by value, moved
    pub fn set_relay_sample(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server>) {
        self.relay_sample = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relay_sample(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        &mut self.relay_sample
    }

    // Take field
    pub fn take_relay_sample(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramDataCenterState_Server> {
        ::std::mem::replace(&mut self.relay_sample, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState_DataCenter {
    fn is_initialized(&self) -> bool {
        for v in &self.server_sample {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relay_sample {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.code)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.server_sample)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relay_sample)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.server_sample {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relay_sample {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.code.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.server_sample {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.relay_sample {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramDataCenterState_DataCenter {
        CMsgSteamDatagramDataCenterState_DataCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code",
                |m: &CMsgSteamDatagramDataCenterState_DataCenter| { &m.code },
                |m: &mut CMsgSteamDatagramDataCenterState_DataCenter| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramDataCenterState_Server>>(
                "server_sample",
                |m: &CMsgSteamDatagramDataCenterState_DataCenter| { &m.server_sample },
                |m: &mut CMsgSteamDatagramDataCenterState_DataCenter| { &mut m.server_sample },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramDataCenterState_Server>>(
                "relay_sample",
                |m: &CMsgSteamDatagramDataCenterState_DataCenter| { &m.relay_sample },
                |m: &mut CMsgSteamDatagramDataCenterState_DataCenter| { &mut m.relay_sample },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramDataCenterState_DataCenter>(
                "CMsgSteamDatagramDataCenterState.DataCenter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState_DataCenter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramDataCenterState_DataCenter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramDataCenterState_DataCenter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramDataCenterState_DataCenter {
    fn clear(&mut self) {
        self.code.clear();
        self.server_sample.clear();
        self.relay_sample.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramDataCenterState_DataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState_DataCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterHealth {
    // message fields
    cpu_load: ::std::option::Option<f32>,
    cpu_load_raw: ::std::option::Option<f32>,
    active_sessions: ::std::option::Option<u32>,
    data_pkts_sec: ::std::option::Option<u32>,
    other_pkts_sec: ::std::option::Option<u32>,
    seconds_until_shutdown: ::std::option::Option<u32>,
    cpu_cost_per_user: ::std::option::Option<f32>,
    cpu_cost_per_packet: ::std::option::Option<f32>,
    pub data_centers: ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter>,
    magic: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterHealth {
    fn default() -> &'a CMsgSteamDatagramRouterHealth {
        <CMsgSteamDatagramRouterHealth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterHealth {
    pub fn new() -> CMsgSteamDatagramRouterHealth {
        ::std::default::Default::default()
    }

    // optional float cpu_load = 1;


    pub fn get_cpu_load(&self) -> f32 {
        self.cpu_load.unwrap_or(0.)
    }
    pub fn clear_cpu_load(&mut self) {
        self.cpu_load = ::std::option::Option::None;
    }

    pub fn has_cpu_load(&self) -> bool {
        self.cpu_load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_load(&mut self, v: f32) {
        self.cpu_load = ::std::option::Option::Some(v);
    }

    // optional float cpu_load_raw = 10;


    pub fn get_cpu_load_raw(&self) -> f32 {
        self.cpu_load_raw.unwrap_or(0.)
    }
    pub fn clear_cpu_load_raw(&mut self) {
        self.cpu_load_raw = ::std::option::Option::None;
    }

    pub fn has_cpu_load_raw(&self) -> bool {
        self.cpu_load_raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_load_raw(&mut self, v: f32) {
        self.cpu_load_raw = ::std::option::Option::Some(v);
    }

    // optional uint32 active_sessions = 2;


    pub fn get_active_sessions(&self) -> u32 {
        self.active_sessions.unwrap_or(0)
    }
    pub fn clear_active_sessions(&mut self) {
        self.active_sessions = ::std::option::Option::None;
    }

    pub fn has_active_sessions(&self) -> bool {
        self.active_sessions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_sessions(&mut self, v: u32) {
        self.active_sessions = ::std::option::Option::Some(v);
    }

    // optional uint32 data_pkts_sec = 3;


    pub fn get_data_pkts_sec(&self) -> u32 {
        self.data_pkts_sec.unwrap_or(0)
    }
    pub fn clear_data_pkts_sec(&mut self) {
        self.data_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_data_pkts_sec(&self) -> bool {
        self.data_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_pkts_sec(&mut self, v: u32) {
        self.data_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 other_pkts_sec = 4;


    pub fn get_other_pkts_sec(&self) -> u32 {
        self.other_pkts_sec.unwrap_or(0)
    }
    pub fn clear_other_pkts_sec(&mut self) {
        self.other_pkts_sec = ::std::option::Option::None;
    }

    pub fn has_other_pkts_sec(&self) -> bool {
        self.other_pkts_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_pkts_sec(&mut self, v: u32) {
        self.other_pkts_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;


    pub fn get_seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_user = 8;


    pub fn get_cpu_cost_per_user(&self) -> f32 {
        self.cpu_cost_per_user.unwrap_or(0.)
    }
    pub fn clear_cpu_cost_per_user(&mut self) {
        self.cpu_cost_per_user = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_user(&self) -> bool {
        self.cpu_cost_per_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_user(&mut self, v: f32) {
        self.cpu_cost_per_user = ::std::option::Option::Some(v);
    }

    // optional float cpu_cost_per_packet = 9;


    pub fn get_cpu_cost_per_packet(&self) -> f32 {
        self.cpu_cost_per_packet.unwrap_or(0.)
    }
    pub fn clear_cpu_cost_per_packet(&mut self) {
        self.cpu_cost_per_packet = ::std::option::Option::None;
    }

    pub fn has_cpu_cost_per_packet(&self) -> bool {
        self.cpu_cost_per_packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_cost_per_packet(&mut self, v: f32) {
        self.cpu_cost_per_packet = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramRouterHealth.DataCenter data_centers = 6;


    pub fn get_data_centers(&self) -> &[CMsgSteamDatagramRouterHealth_DataCenter] {
        &self.data_centers
    }
    pub fn clear_data_centers(&mut self) {
        self.data_centers.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_centers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter>) {
        self.data_centers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_centers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter> {
        &mut self.data_centers
    }

    // Take field
    pub fn take_data_centers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramRouterHealth_DataCenter> {
        ::std::mem::replace(&mut self.data_centers, ::protobuf::RepeatedField::new())
    }

    // optional fixed64 magic = 7;


    pub fn get_magic(&self) -> u64 {
        self.magic.unwrap_or(0)
    }
    pub fn clear_magic(&mut self) {
        self.magic = ::std::option::Option::None;
    }

    pub fn has_magic(&self) -> bool {
        self.magic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magic(&mut self, v: u64) {
        self.magic = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterHealth {
    fn is_initialized(&self) -> bool {
        for v in &self.data_centers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_load = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_load_raw = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_sessions = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_pkts_sec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.other_pkts_sec = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_until_shutdown = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_cost_per_user = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpu_cost_per_packet = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_centers)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.magic = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_load {
            my_size += 5;
        }
        if let Some(v) = self.cpu_load_raw {
            my_size += 5;
        }
        if let Some(v) = self.active_sessions {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data_pkts_sec {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.other_pkts_sec {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cpu_cost_per_user {
            my_size += 5;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            my_size += 5;
        }
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.magic {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cpu_load {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.cpu_load_raw {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.active_sessions {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data_pkts_sec {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.other_pkts_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cpu_cost_per_user {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.cpu_cost_per_packet {
            os.write_float(9, v)?;
        }
        for v in &self.data_centers {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.magic {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterHealth {
        CMsgSteamDatagramRouterHealth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cpu_load",
                |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_load },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_load },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cpu_load_raw",
                |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_load_raw },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_load_raw },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_sessions",
                |m: &CMsgSteamDatagramRouterHealth| { &m.active_sessions },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.active_sessions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_pkts_sec",
                |m: &CMsgSteamDatagramRouterHealth| { &m.data_pkts_sec },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.data_pkts_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "other_pkts_sec",
                |m: &CMsgSteamDatagramRouterHealth| { &m.other_pkts_sec },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.other_pkts_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_until_shutdown",
                |m: &CMsgSteamDatagramRouterHealth| { &m.seconds_until_shutdown },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.seconds_until_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cpu_cost_per_user",
                |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_cost_per_user },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_cost_per_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cpu_cost_per_packet",
                |m: &CMsgSteamDatagramRouterHealth| { &m.cpu_cost_per_packet },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.cpu_cost_per_packet },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramRouterHealth_DataCenter>>(
                "data_centers",
                |m: &CMsgSteamDatagramRouterHealth| { &m.data_centers },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.data_centers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "magic",
                |m: &CMsgSteamDatagramRouterHealth| { &m.magic },
                |m: &mut CMsgSteamDatagramRouterHealth| { &mut m.magic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterHealth>(
                "CMsgSteamDatagramRouterHealth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterHealth {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterHealth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterHealth::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterHealth {
    fn clear(&mut self) {
        self.cpu_load = ::std::option::Option::None;
        self.cpu_load_raw = ::std::option::Option::None;
        self.active_sessions = ::std::option::Option::None;
        self.data_pkts_sec = ::std::option::Option::None;
        self.other_pkts_sec = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.cpu_cost_per_user = ::std::option::Option::None;
        self.cpu_cost_per_packet = ::std::option::Option::None;
        self.data_centers.clear();
        self.magic = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterHealth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterHealth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramRouterHealth_DataCenter {
    // message fields
    datacenter_id: ::std::option::Option<u32>,
    state: ::std::option::Option<u32>,
    pub servers: ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterHealth_DataCenter {
    fn default() -> &'a CMsgSteamDatagramRouterHealth_DataCenter {
        <CMsgSteamDatagramRouterHealth_DataCenter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterHealth_DataCenter {
    pub fn new() -> CMsgSteamDatagramRouterHealth_DataCenter {
        ::std::default::Default::default()
    }

    // optional fixed32 datacenter_id = 1;


    pub fn get_datacenter_id(&self) -> u32 {
        self.datacenter_id.unwrap_or(0)
    }
    pub fn clear_datacenter_id(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
    }

    pub fn has_datacenter_id(&self) -> bool {
        self.datacenter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datacenter_id(&mut self, v: u32) {
        self.datacenter_id = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 2;


    pub fn get_state(&self) -> u32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSteamDatagramGameServerSample servers = 3;


    pub fn get_servers(&self) -> &[CMsgSteamDatagramGameServerSample] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CMsgSteamDatagramGameServerSample> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterHealth_DataCenter {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.datacenter_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.datacenter_id {
            my_size += 5;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.datacenter_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(2, v)?;
        }
        for v in &self.servers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramRouterHealth_DataCenter {
        CMsgSteamDatagramRouterHealth_DataCenter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "datacenter_id",
                |m: &CMsgSteamDatagramRouterHealth_DataCenter| { &m.datacenter_id },
                |m: &mut CMsgSteamDatagramRouterHealth_DataCenter| { &mut m.datacenter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "state",
                |m: &CMsgSteamDatagramRouterHealth_DataCenter| { &m.state },
                |m: &mut CMsgSteamDatagramRouterHealth_DataCenter| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSteamDatagramGameServerSample>>(
                "servers",
                |m: &CMsgSteamDatagramRouterHealth_DataCenter| { &m.servers },
                |m: &mut CMsgSteamDatagramRouterHealth_DataCenter| { &mut m.servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramRouterHealth_DataCenter>(
                "CMsgSteamDatagramRouterHealth.DataCenter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterHealth_DataCenter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramRouterHealth_DataCenter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramRouterHealth_DataCenter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramRouterHealth_DataCenter {
    fn clear(&mut self) {
        self.datacenter_id = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramRouterHealth_DataCenter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterHealth_DataCenter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    // message fields
    pub quality_relay: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub quality_e2e: ::protobuf::SingularPtrField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    pub ack_relay: ::std::vec::Vec<u32>,
    pub legacy_ack_e2e: ::std::vec::Vec<u32>,
    flags: ::std::option::Option<u32>,
    ack_forward_target_revision: ::std::option::Option<u32>,
    routes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ack_peer_routes_revision: ::std::option::Option<u32>,
    from_connection_id: ::std::option::Option<u32>,
    to_connection_id: ::std::option::Option<u32>,
    from_relay_session_id: ::std::option::Option<u32>,
    seq_num_nonce: ::std::option::Option<u32>,
    to_relay_session_id: ::std::option::Option<u32>,
    seq_num_r2r: ::std::option::Option<u32>,
    seq_num_e2e: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        <CMsgSteamDatagramConnectionStatsP2PRouterToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_relay = 1;


    pub fn get_quality_relay(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_relay(&mut self) {
        self.quality_relay.clear();
    }

    pub fn has_quality_relay(&self) -> bool {
        self.quality_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_relay(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_relay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_relay(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_relay.is_none() {
            self.quality_relay.set_default();
        }
        self.quality_relay.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_relay(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_relay.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // optional .CMsgSteamDatagramConnectionQuality quality_e2e = 2;


    pub fn get_quality_e2e(&self) -> &super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.as_ref().unwrap_or_else(|| <super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quality_e2e(&mut self) {
        self.quality_e2e.clear();
    }

    pub fn has_quality_e2e(&self) -> bool {
        self.quality_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_e2e(&mut self, v: super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality) {
        self.quality_e2e = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_e2e(&mut self) -> &mut super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        if self.quality_e2e.is_none() {
            self.quality_e2e.set_default();
        }
        self.quality_e2e.as_mut().unwrap()
    }

    // Take field
    pub fn take_quality_e2e(&mut self) -> super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality {
        self.quality_e2e.take().unwrap_or_else(|| super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality::new())
    }

    // repeated fixed32 ack_relay = 3;


    pub fn get_ack_relay(&self) -> &[u32] {
        &self.ack_relay
    }
    pub fn clear_ack_relay(&mut self) {
        self.ack_relay.clear();
    }

    // Param is passed by value, moved
    pub fn set_ack_relay(&mut self, v: ::std::vec::Vec<u32>) {
        self.ack_relay = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ack_relay(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.ack_relay
    }

    // Take field
    pub fn take_ack_relay(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ack_relay, ::std::vec::Vec::new())
    }

    // repeated fixed32 legacy_ack_e2e = 4;


    pub fn get_legacy_ack_e2e(&self) -> &[u32] {
        &self.legacy_ack_e2e
    }
    pub fn clear_legacy_ack_e2e(&mut self) {
        self.legacy_ack_e2e.clear();
    }

    // Param is passed by value, moved
    pub fn set_legacy_ack_e2e(&mut self, v: ::std::vec::Vec<u32>) {
        self.legacy_ack_e2e = v;
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_ack_e2e(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.legacy_ack_e2e
    }

    // Take field
    pub fn take_legacy_ack_e2e(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.legacy_ack_e2e, ::std::vec::Vec::new())
    }

    // optional uint32 flags = 5;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 ack_forward_target_revision = 6;


    pub fn get_ack_forward_target_revision(&self) -> u32 {
        self.ack_forward_target_revision.unwrap_or(0)
    }
    pub fn clear_ack_forward_target_revision(&mut self) {
        self.ack_forward_target_revision = ::std::option::Option::None;
    }

    pub fn has_ack_forward_target_revision(&self) -> bool {
        self.ack_forward_target_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_forward_target_revision(&mut self, v: u32) {
        self.ack_forward_target_revision = ::std::option::Option::Some(v);
    }

    // optional bytes routes = 7;


    pub fn get_routes(&self) -> &[u8] {
        match self.routes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    pub fn has_routes(&self) -> bool {
        self.routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::std::vec::Vec<u8>) {
        self.routes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.routes.is_none() {
            self.routes.set_default();
        }
        self.routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_routes(&mut self) -> ::std::vec::Vec<u8> {
        self.routes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ack_peer_routes_revision = 8;


    pub fn get_ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }
    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_connection_id = 21;


    pub fn get_from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }
    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_connection_id = 24;


    pub fn get_to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }
    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_relay_session_id = 22;


    pub fn get_from_relay_session_id(&self) -> u32 {
        self.from_relay_session_id.unwrap_or(0)
    }
    pub fn clear_from_relay_session_id(&mut self) {
        self.from_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_from_relay_session_id(&self) -> bool {
        self.from_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_relay_session_id(&mut self, v: u32) {
        self.from_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_nonce = 28;


    pub fn get_seq_num_nonce(&self) -> u32 {
        self.seq_num_nonce.unwrap_or(0)
    }
    pub fn clear_seq_num_nonce(&mut self) {
        self.seq_num_nonce = ::std::option::Option::None;
    }

    pub fn has_seq_num_nonce(&self) -> bool {
        self.seq_num_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_nonce(&mut self, v: u32) {
        self.seq_num_nonce = ::std::option::Option::Some(v);
    }

    // optional fixed32 to_relay_session_id = 25;


    pub fn get_to_relay_session_id(&self) -> u32 {
        self.to_relay_session_id.unwrap_or(0)
    }
    pub fn clear_to_relay_session_id(&mut self) {
        self.to_relay_session_id = ::std::option::Option::None;
    }

    pub fn has_to_relay_session_id(&self) -> bool {
        self.to_relay_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_relay_session_id(&mut self, v: u32) {
        self.to_relay_session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2r = 26;


    pub fn get_seq_num_r2r(&self) -> u32 {
        self.seq_num_r2r.unwrap_or(0)
    }
    pub fn clear_seq_num_r2r(&mut self) {
        self.seq_num_r2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2r(&self) -> bool {
        self.seq_num_r2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2r(&mut self, v: u32) {
        self.seq_num_r2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_e2e = 27;


    pub fn get_seq_num_e2e(&self) -> u32 {
        self.seq_num_e2e.unwrap_or(0)
    }
    pub fn clear_seq_num_e2e(&mut self) {
        self.seq_num_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_num_e2e(&self) -> bool {
        self.seq_num_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_e2e(&mut self, v: u32) {
        self.seq_num_e2e = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.quality_relay {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_e2e {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_relay)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quality_e2e)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.ack_relay)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.legacy_ack_e2e)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_forward_target_revision = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.routes)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ack_peer_routes_revision = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_connection_id = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_connection_id = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.from_relay_session_id = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_nonce = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.to_relay_session_id = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_r2r = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seq_num_e2e = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.quality_relay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.ack_relay.len() as u32;
        my_size += 5 * self.legacy_ack_e2e.len() as u32;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ack_forward_target_revision {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_connection_id {
            my_size += 6;
        }
        if let Some(v) = self.to_connection_id {
            my_size += 6;
        }
        if let Some(v) = self.from_relay_session_id {
            my_size += 6;
        }
        if let Some(v) = self.seq_num_nonce {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.to_relay_session_id {
            my_size += 6;
        }
        if let Some(v) = self.seq_num_r2r {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seq_num_e2e {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.quality_relay.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quality_e2e.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ack_relay {
            os.write_fixed32(3, *v)?;
        };
        for v in &self.legacy_ack_e2e {
            os.write_fixed32(4, *v)?;
        };
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ack_forward_target_revision {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.routes.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(21, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(24, v)?;
        }
        if let Some(v) = self.from_relay_session_id {
            os.write_fixed32(22, v)?;
        }
        if let Some(v) = self.seq_num_nonce {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.to_relay_session_id {
            os.write_fixed32(25, v)?;
        }
        if let Some(v) = self.seq_num_r2r {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.seq_num_e2e {
            os.write_uint32(27, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        CMsgSteamDatagramConnectionStatsP2PRouterToRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.quality_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.quality_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>>(
                "quality_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.quality_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.quality_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ack_relay",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.ack_relay },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.ack_relay },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "legacy_ack_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.legacy_ack_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.legacy_ack_e2e },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.flags },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_forward_target_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.ack_forward_target_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.ack_forward_target_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "routes",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.routes },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ack_peer_routes_revision",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.ack_peer_routes_revision },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.ack_peer_routes_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.from_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.from_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_connection_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.to_connection_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.to_connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "from_relay_session_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.from_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.from_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_nonce",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.seq_num_nonce },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.seq_num_nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "to_relay_session_id",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.to_relay_session_id },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.to_relay_session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_r2r",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.seq_num_r2r },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.seq_num_r2r },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seq_num_e2e",
                |m: &CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &m.seq_num_e2e },
                |m: &mut CMsgSteamDatagramConnectionStatsP2PRouterToRouter| { &mut m.seq_num_e2e },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PRouterToRouter>(
                "CMsgSteamDatagramConnectionStatsP2PRouterToRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramConnectionStatsP2PRouterToRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramConnectionStatsP2PRouterToRouter::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn clear(&mut self) {
        self.quality_relay.clear();
        self.quality_e2e.clear();
        self.ack_relay.clear();
        self.legacy_ack_e2e.clear();
        self.flags = ::std::option::Option::None;
        self.ack_forward_target_revision = ::std::option::Option::None;
        self.routes.clear();
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.from_relay_session_id = ::std::option::Option::None;
        self.seq_num_nonce = ::std::option::Option::None;
        self.to_relay_session_id = ::std::option::Option::None;
        self.seq_num_r2r = ::std::option::Option::None;
        self.seq_num_e2e = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
    ACK_REQUEST_RELAY = 1,
    ACK_REQUEST_E2E = 2,
    ACK_REQUEST_IMMEDIATE = 4,
    NOT_PRIMARY_TRANSPORT_E2E = 16,
}

impl ::protobuf::ProtobufEnum for CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags> {
        match value {
            1 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::ACK_REQUEST_RELAY),
            2 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::ACK_REQUEST_E2E),
            4 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::ACK_REQUEST_IMMEDIATE),
            16 => ::std::option::Option::Some(CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::NOT_PRIMARY_TRANSPORT_E2E),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags] = &[
            CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::ACK_REQUEST_RELAY,
            CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::ACK_REQUEST_E2E,
            CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::ACK_REQUEST_IMMEDIATE,
            CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::NOT_PRIMARY_TRANSPORT_E2E,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags>("CMsgSteamDatagramConnectionStatsP2PRouterToRouter.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
    fn default() -> Self {
        CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags::ACK_REQUEST_RELAY
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    // message fields
    client_id: ::protobuf::SingularField<::std::string::String>,
    app_id: ::std::option::Option<u32>,
    protocol_ver: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn default() -> &'a CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        <CMsgSteamDatagramNetworkNextRouterPingRequestExtraData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    pub fn new() -> CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        ::std::default::Default::default()
    }

    // optional string client_id = 3;


    pub fn get_client_id(&self) -> &str {
        match self.client_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        if self.client_id.is_none() {
            self.client_id.set_default();
        }
        self.client_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        self.client_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 4;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_ver = 5;


    pub fn get_protocol_ver(&self) -> u32 {
        self.protocol_ver.unwrap_or(0)
    }
    pub fn clear_protocol_ver(&mut self) {
        self.protocol_ver = ::std::option::Option::None;
    }

    pub fn has_protocol_ver(&self) -> bool {
        self.protocol_ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_ver(&mut self, v: u32) {
        self.protocol_ver = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_ver = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.client_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.protocol_ver {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.client_id.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.protocol_ver {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        CMsgSteamDatagramNetworkNextRouterPingRequestExtraData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &m.client_id },
                |m: &mut CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &m.app_id },
                |m: &mut CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "protocol_ver",
                |m: &CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &m.protocol_ver },
                |m: &mut CMsgSteamDatagramNetworkNextRouterPingRequestExtraData| { &mut m.protocol_ver },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNetworkNextRouterPingRequestExtraData>(
                "CMsgSteamDatagramNetworkNextRouterPingRequestExtraData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNetworkNextRouterPingRequestExtraData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNetworkNextRouterPingRequestExtraData::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn clear(&mut self) {
        self.client_id.clear();
        self.app_id = ::std::option::Option::None;
        self.protocol_ver = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNetworkNextRouterPingRequestExtraData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn default() -> &'a CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        <CMsgSteamDatagramNetworkNextRouterPingReplyExtraData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    pub fn new() -> CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        CMsgSteamDatagramNetworkNextRouterPingReplyExtraData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSteamDatagramNetworkNextRouterPingReplyExtraData>(
                "CMsgSteamDatagramNetworkNextRouterPingReplyExtraData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
        static instance: ::protobuf::rt::LazyV2<CMsgSteamDatagramNetworkNextRouterPingReplyExtraData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSteamDatagramNetworkNextRouterPingReplyExtraData::new)
    }
}

impl ::protobuf::Clear for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNetworkNextRouterPingReplyExtraData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ESteamDatagramMsgID {
    k_ESteamDatagramMsg_Invalid = 0,
    k_ESteamDatagramMsg_RouterPingRequest = 1,
    k_ESteamDatagramMsg_RouterPingReply = 2,
    k_ESteamDatagramMsg_GameserverPingRequest = 3,
    k_ESteamDatagramMsg_LegacyGameserverPingReply = 4,
    k_ESteamDatagramMsg_GameserverSessionRequest = 5,
    k_ESteamDatagramMsg_GameserverSessionEstablished = 6,
    k_ESteamDatagramMsg_NoSession = 7,
    k_ESteamDatagramMsg_Diagnostic = 8,
    k_ESteamDatagramMsg_DataClientToRouter = 9,
    k_ESteamDatagramMsg_DataRouterToServer = 10,
    k_ESteamDatagramMsg_DataServerToRouter = 11,
    k_ESteamDatagramMsg_DataRouterToClient = 12,
    k_ESteamDatagramMsg_Stats = 13,
    k_ESteamDatagramMsg_ClientPingSampleRequest = 14,
    k_ESteamDatagramMsg_ClientPingSampleReply = 15,
    k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16,
    k_ESteamDatagramMsg_RelayHealth = 17,
    k_ESteamDatagramMsg_ConnectRequest = 18,
    k_ESteamDatagramMsg_ConnectOK = 19,
    k_ESteamDatagramMsg_ConnectionClosed = 20,
    k_ESteamDatagramMsg_NoConnection = 21,
    k_ESteamDatagramMsg_RelayToRelayPingRequest = 22,
    k_ESteamDatagramMsg_RelayToRelayPingReply = 23,
    k_ESteamDatagramMsg_P2PSessionRequest = 24,
    k_ESteamDatagramMsg_P2PSessionEstablished = 25,
    k_ESteamDatagramMsg_P2PStatsClient = 26,
    k_ESteamDatagramMsg_P2PStatsRelay = 27,
    k_ESteamDatagramMsg_P2PBadRoute = 28,
    k_ESteamDatagramMsg_GameserverPingReply = 29,
    k_ESteamDatagramMsg_GameserverRegistration = 30,
}

impl ::protobuf::ProtobufEnum for ESteamDatagramMsgID {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDatagramMsgID> {
        match value {
            0 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid),
            1 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest),
            2 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply),
            3 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest),
            4 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_LegacyGameserverPingReply),
            5 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest),
            6 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished),
            7 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession),
            8 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic),
            9 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter),
            10 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer),
            11 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter),
            12 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient),
            13 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats),
            14 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest),
            15 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply),
            16 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary),
            17 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth),
            18 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest),
            19 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK),
            20 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed),
            21 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection),
            22 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest),
            23 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply),
            24 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest),
            25 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished),
            26 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsClient),
            27 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsRelay),
            28 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PBadRoute),
            29 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply),
            30 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverRegistration),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ESteamDatagramMsgID] = &[
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_LegacyGameserverPingReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayHealth,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectOK,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ConnectionClosed,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_NoConnection,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RelayToRelayPingReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionRequest,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PSessionEstablished,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsClient,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PStatsRelay,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_P2PBadRoute,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverRegistration,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ESteamDatagramMsgID>("ESteamDatagramMsgID", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ESteamDatagramMsgID {
}

impl ::std::default::Default for ESteamDatagramMsgID {
    fn default() -> Self {
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for ESteamDatagramMsgID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20steamdatagram_messages_sdr.proto\x1a+steamnetworkingsockets_messag\
    es_certs.proto\x1a%steamnetworkingsockets_messages.proto\"\xd3\x08\n\x20\
    CMsgSteamDatagramRouterPingReply\x12)\n\x10client_timestamp\x18\x01\x20\
    \x01(\x07R\x0fclientTimestamp\x128\n\x16latency_datacenter_ids\x18\x02\
    \x20\x03(\x07R\x14latencyDatacenterIdsB\x02\x10\x01\x12*\n\x0flatency_pi\
    ng_ms\x18\x03\x20\x03(\rR\rlatencyPingMsB\x02\x10\x01\x12$\n\x0eyour_pub\
    lic_ip\x18\x04\x20\x01(\x07R\x0cyourPublicIp\x12(\n\x10your_public_port\
    \x18\x0b\x20\x01(\x07R\x0eyourPublicPort\x12\x1f\n\x0bserver_time\x18\
    \x05\x20\x01(\x07R\nserverTime\x12\x1c\n\tchallenge\x18\x06\x20\x01(\x06\
    R\tchallenge\x124\n\x16seconds_until_shutdown\x18\x07\x20\x01(\rR\x14sec\
    ondsUntilShutdown\x12#\n\rclient_cookie\x18\x08\x20\x01(\x07R\x0cclientC\
    ookie\x12A\n\x1dscoring_penalty_relay_cluster\x18\t\x20\x01(\rR\x1ascori\
    ngPenaltyRelayCluster\x12\x14\n\x05flags\x18\x0c\x20\x01(\rR\x05flags\
    \x12[\n\x10route_exceptions\x18\n\x20\x03(\x0b20.CMsgSteamDatagramRouter\
    PingReply.RouteExceptionR\x0frouteExceptions\x12Q\n\ralt_addresses\x18\r\
    \x20\x03(\x0b2,.CMsgSteamDatagramRouterPingReply.AltAddressR\x0caltAddre\
    sses\x1af\n\x0eRouteException\x12$\n\x0edata_center_id\x18\x01\x20\x01(\
    \x07R\x0cdataCenterId\x12\x14\n\x05flags\x18\x02\x20\x01(\rR\x05flags\
    \x12\x18\n\x07penalty\x18\x03\x20\x01(\rR\x07penalty\x1a\xf4\x01\n\nAltA\
    ddress\x12\x12\n\x04ipv4\x18\x01\x20\x01(\x07R\x04ipv4\x12\x12\n\x04port\
    \x18\x02\x20\x01(\rR\x04port\x12\x18\n\x07penalty\x18\x03\x20\x01(\rR\
    \x07penalty\x12b\n\x08protocol\x18\x04\x20\x01(\x0e25.CMsgSteamDatagramR\
    outerPingReply.AltAddress.Protocol:\x0fDefaultProtocolR\x08protocol\x12\
    \x0e\n\x02id\x18\x05\x20\x01(\tR\x02id\"0\n\x08Protocol\x12\x13\n\x0fDef\
    aultProtocol\x10\0\x12\x0f\n\x0bNetworkNext\x10\x01\"L\n\x05Flags\x12\
    \x20\n\x1cFLAG_MAYBE_MORE_DATA_CENTERS\x10\x01\x12!\n\x1dFLAG_MAYBE_MORE\
    _ALT_ADDRESSES\x10\x02\"\xe2\x01\n&CMsgSteamDatagramGameserverPingReques\
    t\x12$\n\x0eyour_public_ip\x18\x01\x20\x01(\x07R\x0cyourPublicIp\x12(\n\
    \x10your_public_port\x18\x05\x20\x01(\x07R\x0eyourPublicPort\x12\x1f\n\
    \x0bserver_time\x18\x02\x20\x01(\x07R\nserverTime\x12\x1c\n\tchallenge\
    \x18\x03\x20\x01(\x06R\tchallenge\x12)\n\x10router_timestamp\x18\x04\x20\
    \x01(\x07R\x0frouterTimestamp\"t\n*CMsgSteamDatagramLegacyGameserverPing\
    Reply\x12)\n\x10router_timestamp\x18\x04\x20\x01(\x07R\x0frouterTimestam\
    p\x12\x1b\n\tdummy_pad\x18c\x20\x01(\x06R\x08dummyPad\"\xd9\x02\n$CMsgSt\
    eamDatagramGameserverPingReply\x127\n\x04cert\x18\x01\x20\x01(\x0b2#.CMs\
    gSteamDatagramCertificateSignedR\x04cert\x12\x1f\n\x0bsigned_data\x18\
    \x02\x20\x01(\x0cR\nsignedData\x12\x1c\n\tsignature\x18\x03\x20\x01(\x0c\
    R\tsignature\x1a\xb8\x01\n\nSignedData\x12%\n\x0echallenge_time\x18\x02\
    \x20\x01(\x07R\rchallengeTime\x12\x1c\n\tchallenge\x18\x03\x20\x01(\x06R\
    \tchallenge\x12)\n\x10router_timestamp\x18\x04\x20\x01(\x07R\x0frouterTi\
    mestamp\x12$\n\x0edata_center_id\x18\x05\x20\x01(\x07R\x0cdataCenterId\
    \x12\x14\n\x05appid\x18\x06\x20\x01(\rR\x05appid\"\x93\x02\n'CMsgSteamDa\
    tagramNoSessionRelayToClient\x12#\n\rconnection_id\x18\x07\x20\x01(\x07R\
    \x0cconnectionId\x12$\n\x0eyour_public_ip\x18\x02\x20\x01(\x07R\x0cyourP\
    ublicIp\x12(\n\x10your_public_port\x18\x06\x20\x01(\x07R\x0eyourPublicPo\
    rt\x12\x1f\n\x0bserver_time\x18\x03\x20\x01(\x07R\nserverTime\x12\x1c\n\
    \tchallenge\x18\x04\x20\x01(\x06R\tchallenge\x124\n\x16seconds_until_shu\
    tdown\x18\x05\x20\x01(\rR\x14secondsUntilShutdown\"\xde\x01\n%CMsgSteamD\
    atagramNoSessionRelayToPeer\x125\n\x17legacy_relay_session_id\x18\x01\
    \x20\x01(\rR\x14legacyRelaySessionId\x121\n\x15from_relay_session_id\x18\
    \x02\x20\x01(\x07R\x12fromRelaySessionId\x12,\n\x12from_connection_id\
    \x18\x07\x20\x01(\x07R\x10fromConnectionId\x12\x1d\n\nkludge_pad\x18c\
    \x20\x01(\x06R\tkludgePad\"O\n(CMsgSteamDatagramClientPingSampleRequest\
    \x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\"\x9a\n\n&C\
    MsgSteamDatagramClientPingSampleReply\x12#\n\rconnection_id\x18\x01\x20\
    \x01(\x07R\x0cconnectionId\x12'\n\x0foverride_active\x18\x04\x20\x01(\
    \x08R\x0eoverrideActive\x12?\n\x04pops\x18\x02\x20\x03(\x0b2+.CMsgSteamD\
    atagramClientPingSampleReply.POPR\x04pops\x12h\n\x13legacy_data_centers\
    \x18\x03\x20\x03(\x0b28.CMsgSteamDatagramClientPingSampleReply.LegacyDat\
    aCenterR\x11legacyDataCenters\x1a\xdd\x06\n\x03POP\x12\x15\n\x06pop_id\
    \x18\x01\x20\x01(\x07R\x05popId\x121\n\x15default_front_ping_ms\x18\x02\
    \x20\x01(\rR\x12defaultFrontPingMs\x12'\n\x0fcluster_penalty\x18\x04\x20\
    \x01(\rR\x0eclusterPenalty\x12[\n\ralt_addresses\x18\x07\x20\x03(\x0b26.\
    CMsgSteamDatagramClientPingSampleReply.POP.AltAddressR\x0caltAddresses\
    \x12-\n\x13default_e2e_ping_ms\x18\x03\x20\x01(\rR\x10defaultE2ePingMs\
    \x12*\n\x11default_e2e_score\x18\x05\x20\x01(\rR\x0fdefaultE2eScore\x127\
    \n\x19p2p_via_peer_relay_pop_id\x18\x06\x20\x01(\x07R\x14p2pViaPeerRelay\
    PopId\x12%\n\x0fbest_dc_ping_ms\x18\t\x20\x01(\rR\x0cbestDcPingMs\x12\"\
    \n\rbest_dc_score\x18\n\x20\x01(\rR\x0bbestDcScore\x125\n\x18best_dc_via\
    _relay_pop_id\x18\x0b\x20\x01(\x07R\x13bestDcViaRelayPopId\x12+\n\x12def\
    ault_dc_ping_ms\x18\x0c\x20\x01(\rR\x0fdefaultDcPingMs\x12(\n\x10default\
    _dc_score\x18\r\x20\x01(\rR\x0edefaultDcScore\x12;\n\x1bdefault_dc_via_r\
    elay_pop_id\x18\x0e\x20\x01(\x07R\x16defaultDcViaRelayPopId\x12%\n\x0fte\
    st_dc_ping_ms\x18\x0f\x20\x01(\rR\x0ctestDcPingMs\x12\"\n\rtest_dc_score\
    \x18\x10\x20\x01(\rR\x0btestDcScore\x125\n\x18test_dc_via_relay_pop_id\
    \x18\x11\x20\x01(\x07R\x13testDcViaRelayPopId\x1aZ\n\nAltAddress\x12\x0e\
    \n\x02id\x18\x01\x20\x01(\tR\x02id\x12\"\n\rfront_ping_ms\x18\x02\x20\
    \x01(\rR\x0bfrontPingMs\x12\x18\n\x07penalty\x18\x03\x20\x01(\rR\x07pena\
    lty\x1a\x96\x01\n\x10LegacyDataCenter\x12$\n\x0edata_center_id\x18\x01\
    \x20\x01(\x07R\x0cdataCenterId\x125\n\x18best_dc_via_relay_pop_id\x18\
    \x02\x20\x01(\x07R\x13bestDcViaRelayPopId\x12%\n\x0fbest_dc_ping_ms\x18\
    \x03\x20\x01(\rR\x0cbestDcPingMs\"\xef\x06\n&CMsgSteamDatagramClientSwit\
    chedPrimary\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\
    \x12\x17\n\x07from_ip\x18\x02\x20\x01(\x07R\x06fromIp\x12\x1b\n\tfrom_po\
    rt\x18\x03\x20\x01(\rR\x08fromPort\x12.\n\x13from_router_cluster\x18\x04\
    \x20\x01(\x07R\x11fromRouterCluster\x12(\n\x10from_active_time\x18\x05\
    \x20\x01(\rR\x0efromActiveTime\x127\n\x18from_active_packets_recv\x18\
    \x06\x20\x01(\rR\x15fromActivePacketsRecv\x12.\n\x13from_dropped_reason\
    \x18\x07\x20\x01(\tR\x11fromDroppedReason\x12\x15\n\x06gap_ms\x18\x08\
    \x20\x01(\rR\x05gapMs\x12_\n\x10from_quality_now\x18\t\x20\x01(\x0b25.CM\
    sgSteamDatagramClientSwitchedPrimary.RouterQualityR\x0efromQualityNow\
    \x12[\n\x0eto_quality_now\x18\n\x20\x01(\x0b25.CMsgSteamDatagramClientSw\
    itchedPrimary.RouterQualityR\x0ctoQualityNow\x12a\n\x11from_quality_then\
    \x18\x0b\x20\x01(\x0b25.CMsgSteamDatagramClientSwitchedPrimary.RouterQua\
    lityR\x0ffromQualityThen\x12]\n\x0fto_quality_then\x18\x0c\x20\x01(\x0b2\
    5.CMsgSteamDatagramClientSwitchedPrimary.RouterQualityR\rtoQualityThen\
    \x1a\x8f\x01\n\rRouterQuality\x12\x14\n\x05score\x18\x01\x20\x01(\rR\x05\
    score\x12\x1d\n\nfront_ping\x18\x02\x20\x01(\rR\tfrontPing\x12\x1b\n\tba\
    ck_ping\x18\x03\x20\x01(\rR\x08backPing\x12,\n\x12seconds_until_down\x18\
    \x04\x20\x01(\rR\x10secondsUntilDown\"\xc0\x03\n\x1fCMsgSteamDatagramCon\
    nectRequest\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\
    \x12!\n\x0cmy_timestamp\x18\x04\x20\x01(\x06R\x0bmyTimestamp\x12\x1e\n\
    \x0bping_est_ms\x18\x05\x20\x01(\rR\tpingEstMs\x12!\n\x0cvirtual_port\
    \x18\t\x20\x01(\rR\x0bvirtualPort\x12=\n\x1bgameserver_relay_session_id\
    \x18\x02\x20\x01(\rR\x18gameserverRelaySessionId\x12>\n\x05crypt\x18\x06\
    \x20\x01(\x0b2(.CMsgSteamDatagramSessionCryptInfoSignedR\x05crypt\x127\n\
    \x04cert\x18\x07\x20\x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04c\
    ert\x12%\n\x0erouting_secret\x18\n\x20\x01(\x06R\rroutingSecret\x123\n\
    \x16legacy_client_steam_id\x18\x03\x20\x01(\x06R\x13legacyClientSteamId\
    \"\x87\x03\n\x1aCMsgSteamDatagramConnectOK\x120\n\x14client_connection_i\
    d\x18\x01\x20\x01(\x07R\x12clientConnectionId\x120\n\x14server_connectio\
    n_id\x18\x07\x20\x01(\x07R\x12serverConnectionId\x12%\n\x0eyour_timestam\
    p\x18\x03\x20\x01(\x06R\ryourTimestamp\x12&\n\x0fdelay_time_usec\x18\x04\
    \x20\x01(\rR\rdelayTimeUsec\x12=\n\x1bgameserver_relay_session_id\x18\
    \x02\x20\x01(\rR\x18gameserverRelaySessionId\x12>\n\x05crypt\x18\x05\x20\
    \x01(\x0b2(.CMsgSteamDatagramSessionCryptInfoSignedR\x05crypt\x127\n\x04\
    cert\x18\x06\x20\x01(\x0b2#.CMsgSteamDatagramCertificateSignedR\x04cert\
    \"\x91\x03\n'CMsgSteamNetworkingP2PSDRRoutingSummary\x12!\n\x0cinitial_p\
    ing\x18\x01\x20\x01(\rR\x0binitialPing\x127\n\x18initial_ping_front_loca\
    l\x18\x02\x20\x01(\rR\x15initialPingFrontLocal\x129\n\x19initial_ping_fr\
    ont_remote\x18\x03\x20\x01(\rR\x16initialPingFrontRemote\x12#\n\rinitial\
    _score\x18\x04\x20\x01(\rR\x0cinitialScore\x12*\n\x11initial_pop_local\
    \x18\x05\x20\x01(\x07R\x0finitialPopLocal\x12,\n\x12initial_pop_remote\
    \x18\x06\x20\x01(\x07R\x10initialPopRemote\x12%\n\x0enegotiation_ms\x18\
    \x07\x20\x01(\rR\rnegotiationMs\x12)\n\x10selected_seconds\x18\x08\x20\
    \x01(\rR\x0fselectedSeconds\"\x99\x01\n\"CMsgSteamDatagramP2PRoutingSumm\
    ary\x127\n\x03ice\x18\x02\x20\x01(\x0b2%.CMsgSteamNetworkingICESessionSu\
    mmaryR\x03ice\x12:\n\x03sdr\x18\x03\x20\x01(\x0b2(.CMsgSteamNetworkingP2\
    PSDRRoutingSummaryR\x03sdr\"\xac\t\n!CMsgSteamDatagramConnectionClosed\
    \x12(\n\x10to_connection_id\x18\x07\x20\x01(\x07R\x0etoConnectionId\x12,\
    \n\x12from_connection_id\x18\x08\x20\x01(\x07R\x10fromConnectionId\x120\
    \n\x14from_identity_string\x18\x0f\x20\x01(\tR\x12fromIdentityString\x12\
    g\n\x1blegacy_from_identity_binary\x18\r\x20\x01(\x0b2(.CMsgSteamNetwork\
    ingIdentityLegacyBinaryR\x18legacyFromIdentityBinary\x12/\n\x14legacy_fr\
    om_steam_id\x18\x03\x20\x01(\x06R\x11legacyFromSteamId\x12J\n\"legacy_ga\
    meserver_relay_session_id\x18\x02\x20\x01(\rR\x1elegacyGameserverRelaySe\
    ssionId\x12-\n\x13to_relay_session_id\x18\t\x20\x01(\x07R\x10toRelaySess\
    ionId\x121\n\x15from_relay_session_id\x18\n\x20\x01(\x07R\x12fromRelaySe\
    ssionId\x12J\n\"forward_target_relay_routing_token\x18\x0b\x20\x01(\x0cR\
    \x1eforwardTargetRelayRoutingToken\x126\n\x17forward_target_revision\x18\
    \x0c\x20\x01(\rR\x15forwardTargetRevision\x12R\n\nrelay_mode\x18\x04\x20\
    \x01(\x0e2-.CMsgSteamDatagramConnectionClosed.ERelayMode:\x04NoneR\trela\
    yMode\x12\x14\n\x05debug\x18\x05\x20\x01(\tR\x05debug\x12\x1f\n\x0breaso\
    n_code\x18\x06\x20\x01(\rR\nreasonCode\x12%\n\x0erouting_secret\x18\x0e\
    \x20\x01(\x06R\rroutingSecret\x12.\n\x13not_primary_session\x18\x10\x20\
    \x01(\x08R\x11notPrimarySession\x122\n\x15not_primary_transport\x18\x13\
    \x20\x01(\x08R\x13notPrimaryTransport\x12H\n\rquality_relay\x18\x11\x20\
    \x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x0cqualityRelay\x12D\n\
    \x0bquality_e2e\x18\x12\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualit\
    yR\nqualityE2e\x12S\n\x13p2p_routing_summary\x18\x15\x20\x01(\x0b2#.CMsg\
    SteamDatagramP2PRoutingSummaryR\x11p2pRoutingSummary\"6\n\nERelayMode\
    \x12\x08\n\x04None\x10\0\x12\x0c\n\x08EndToEnd\x10\x01\x12\x10\n\x0cClos\
    edByPeer\x10\x02\"\xb4\x06\n\x1dCMsgSteamDatagramNoConnection\x12(\n\x10\
    to_connection_id\x18\x05\x20\x01(\x07R\x0etoConnectionId\x12,\n\x12from_\
    connection_id\x18\x06\x20\x01(\x07R\x10fromConnectionId\x12J\n\"legacy_g\
    ameserver_relay_session_id\x18\x02\x20\x01(\rR\x1elegacyGameserverRelayS\
    essionId\x12-\n\x13to_relay_session_id\x18\t\x20\x01(\x07R\x10toRelaySes\
    sionId\x121\n\x15from_relay_session_id\x18\n\x20\x01(\x07R\x12fromRelayS\
    essionId\x120\n\x14from_identity_string\x18\x07\x20\x01(\tR\x12fromIdent\
    ityString\x12/\n\x14legacy_from_steam_id\x18\x03\x20\x01(\x06R\x11legacy\
    FromSteamId\x12\x1c\n\nend_to_end\x18\x04\x20\x01(\x08R\x08endToEnd\x12.\
    \n\x13not_primary_session\x18\x0c\x20\x01(\x08R\x11notPrimarySession\x12\
    2\n\x15not_primary_transport\x18\x0f\x20\x01(\x08R\x13notPrimaryTranspor\
    t\x12H\n\rquality_relay\x18\r\x20\x01(\x0b2#.CMsgSteamDatagramConnection\
    QualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x0e\x20\x01(\x0b2#.CM\
    sgSteamDatagramConnectionQualityR\nqualityE2e\x12S\n\x13p2p_routing_summ\
    ary\x18\x10\x20\x01(\x0b2#.CMsgSteamDatagramP2PRoutingSummaryR\x11p2pRou\
    tingSummary\x12%\n\x0erouting_secret\x18\x0b\x20\x01(\x06R\rroutingSecre\
    t\x12\x1c\n\tdummy_pad\x18\xff\x07\x20\x01(\x07R\x08dummyPad\"\xcd\x02\n\
    )CMsgSteamDatagramGameserverSessionRequest\x12\x16\n\x06ticket\x18\x01\
    \x20\x01(\x0cR\x06ticket\x12%\n\x0echallenge_time\x18\x03\x20\x01(\x07R\
    \rchallengeTime\x12\x1c\n\tchallenge\x18\x04\x20\x01(\x06R\tchallenge\
    \x120\n\x14client_connection_id\x18\x05\x20\x01(\x07R\x12clientConnectio\
    nId\x120\n\x14server_connection_id\x18\x08\x20\x01(\x07R\x12serverConnec\
    tionId\x124\n\x16network_config_version\x18\x06\x20\x01(\rR\x14networkCo\
    nfigVersion\x12)\n\x10protocol_version\x18\x07\x20\x01(\rR\x0fprotocolVe\
    rsion\"\xe5\x02\n-CMsgSteamDatagramGameserverSessionEstablished\x12#\n\r\
    connection_id\x18\x01\x20\x01(\x07R\x0cconnectionId\x12<\n\x1agameserver\
    _identity_string\x18\x02\x20\x01(\tR\x18gameserverIdentityString\x124\n\
    \x16seconds_until_shutdown\x18\x04\x20\x01(\rR\x14secondsUntilShutdown\
    \x12\x1e\n\x0bseq_num_r2c\x18\x06\x20\x01(\rR\tseqNumR2c\x12?\n\x1cdummy\
    _legacy_identity_binary\x18\x07\x20\x01(\x0cR\x19dummyLegacyIdentityBina\
    ry\x12:\n\x19legacy_gameserver_steamid\x18\x03\x20\x01(\x06R\x17legacyGa\
    meserverSteamid\"\xf4\x03\n.CMsgSteamDatagramConnectionStatsClientToRout\
    er\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnect\
    ionQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#\
    .CMsgSteamDatagramConnectionQualityR\nqualityE2e\x12\x1b\n\tack_relay\
    \x18\x04\x20\x03(\x07R\x08ackRelay\x12$\n\x0elegacy_ack_e2e\x18\x05\x20\
    \x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05flags\x18\x06\x20\x01(\rR\x05fla\
    gs\x120\n\x14client_connection_id\x18\x08\x20\x01(\x07R\x12clientConnect\
    ionId\x12\x1e\n\x0bseq_num_c2r\x18\t\x20\x01(\rR\tseqNumC2r\x12\x1e\n\
    \x0bseq_num_e2e\x18\n\x20\x01(\rR\tseqNumE2e\"g\n\x05Flags\x12\x15\n\x11\
    ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\
    \x15ACK_REQUEST_IMMEDIATE\x10\x04\x12\x17\n\x13NOT_PRIMARY_SESSION\x10\
    \x08\"\xb4\x05\n.CMsgSteamDatagramConnectionStatsRouterToClient\x12H\n\r\
    quality_relay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\
    \x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#.CMsgSteamD\
    atagramConnectionQualityR\nqualityE2e\x124\n\x16seconds_until_shutdown\
    \x18\x06\x20\x01(\rR\x14secondsUntilShutdown\x12,\n\x12migrate_request_i\
    p\x18\n\x20\x01(\x07R\x10migrateRequestIp\x120\n\x14migrate_request_port\
    \x18\x0b\x20\x01(\rR\x12migrateRequestPort\x12A\n\x1dscoring_penalty_rel\
    ay_cluster\x18\x0c\x20\x01(\rR\x1ascoringPenaltyRelayCluster\x12\x1b\n\t\
    ack_relay\x18\r\x20\x03(\x07R\x08ackRelay\x12$\n\x0elegacy_ack_e2e\x18\
    \x0e\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05flags\x18\x0f\x20\x01(\r\
    R\x05flags\x120\n\x14client_connection_id\x18\x07\x20\x01(\x07R\x12clien\
    tConnectionId\x12\x1e\n\x0bseq_num_r2c\x18\x08\x20\x01(\rR\tseqNumR2c\
    \x12\x1e\n\x0bseq_num_e2e\x18\t\x20\x01(\rR\tseqNumE2e\"N\n\x05Flags\x12\
    \x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\
    \x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\"\xc9\x05\n.CMsgSteamDatagra\
    mConnectionStatsRouterToServer\x12H\n\rquality_relay\x18\x01\x20\x01(\
    \x0b2#.CMsgSteamDatagramConnectionQualityR\x0cqualityRelay\x12D\n\x0bqua\
    lity_e2e\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\nqua\
    lityE2e\x12\x1b\n\tack_relay\x18\n\x20\x03(\x07R\x08ackRelay\x12$\n\x0el\
    egacy_ack_e2e\x18\x0b\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05flags\
    \x18\x0c\x20\x01(\rR\x05flags\x12\x1e\n\x0bseq_num_r2s\x18\x05\x20\x01(\
    \rR\tseqNumR2s\x12\x1e\n\x0bseq_num_e2e\x18\x06\x20\x01(\rR\tseqNumE2e\
    \x124\n\x16client_identity_string\x18\x0f\x20\x01(\tR\x14clientIdentityS\
    tring\x123\n\x16legacy_client_steam_id\x18\x07\x20\x01(\x06R\x13legacyCl\
    ientSteamId\x12(\n\x10relay_session_id\x18\x08\x20\x01(\rR\x0erelaySessi\
    onId\x120\n\x14client_connection_id\x18\t\x20\x01(\x07R\x12clientConnect\
    ionId\x120\n\x14server_connection_id\x18\r\x20\x01(\x07R\x12serverConnec\
    tionId\x12%\n\x0erouting_secret\x18\x0e\x20\x01(\x06R\rroutingSecret\"N\
    \n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQU\
    EST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\"\xb7\x04\n.C\
    MsgSteamDatagramConnectionStatsServerToRouter\x12H\n\rquality_relay\x18\
    \x01\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x0cqualityRelay\
    \x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectio\
    nQualityR\nqualityE2e\x12\x1b\n\tack_relay\x18\x08\x20\x03(\x07R\x08ackR\
    elay\x12$\n\x0elegacy_ack_e2e\x18\t\x20\x03(\x07R\x0clegacyAckE2e\x12\
    \x14\n\x05flags\x18\n\x20\x01(\rR\x05flags\x12\x1e\n\x0bseq_num_s2r\x18\
    \x03\x20\x01(\rR\tseqNumS2r\x12\x1e\n\x0bseq_num_e2e\x18\x04\x20\x01(\rR\
    \tseqNumE2e\x12(\n\x10relay_session_id\x18\x06\x20\x01(\rR\x0erelaySessi\
    onId\x120\n\x14client_connection_id\x18\x07\x20\x01(\x07R\x12clientConne\
    ctionId\x120\n\x14server_connection_id\x18\x0b\x20\x01(\x07R\x12serverCo\
    nnectionId\"N\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\
    \n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\
    \"\xbb\x03\n&CMsgSteamDatagramP2PSessionRequestBody\x12%\n\x0echallenge_\
    time\x18\x01\x20\x01(\x07R\rchallengeTime\x12\x1c\n\tchallenge\x18\x02\
    \x20\x01(\x06R\tchallenge\x120\n\x14client_connection_id\x18\x03\x20\x01\
    (\x07R\x12clientConnectionId\x12/\n\x14legacy_peer_steam_id\x18\x04\x20\
    \x01(\x06R\x11legacyPeerSteamId\x120\n\x14peer_identity_string\x18\x0b\
    \x20\x01(\tR\x12peerIdentityString\x12,\n\x12peer_connection_id\x18\x05\
    \x20\x01(\x07R\x10peerConnectionId\x12)\n\x10protocol_version\x18\x08\
    \x20\x01(\rR\x0fprotocolVersion\x124\n\x16network_config_version\x18\t\
    \x20\x01(\rR\x14networkConfigVersion\x12(\n\x10unused_public_ip\x18\n\
    \x20\x01(\x07R\x0eunusedPublicIp\"\x8f\x01\n\"CMsgSteamDatagramP2PSessio\
    nRequest\x127\n\x04cert\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramCertific\
    ateSignedR\x04cert\x12\x12\n\x04body\x18\x02\x20\x01(\x0cR\x04body\x12\
    \x1c\n\tsignature\x18\x03\x20\x01(\x0cR\tsignature\"\xd3\x01\n&CMsgSteam\
    DatagramP2PSessionEstablished\x12#\n\rconnection_id\x18\x01\x20\x01(\x07\
    R\x0cconnectionId\x124\n\x16seconds_until_shutdown\x18\x03\x20\x01(\rR\
    \x14secondsUntilShutdown\x12.\n\x13relay_routing_token\x18\x04\x20\x01(\
    \x0cR\x11relayRoutingToken\x12\x1e\n\x0bseq_num_r2c\x18\x05\x20\x01(\rR\
    \tseqNumR2c\"\xb4\x06\n1CMsgSteamDatagramConnectionStatsP2PClientToRoute\
    r\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConnecti\
    onQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\x02\x20\x01(\x0b2#.\
    CMsgSteamDatagramConnectionQualityR\nqualityE2e\x12S\n\x13p2p_routing_su\
    mmary\x18\x0e\x20\x01(\x0b2#.CMsgSteamDatagramP2PRoutingSummaryR\x11p2pR\
    outingSummary\x12\x1b\n\tack_relay\x18\x03\x20\x03(\x07R\x08ackRelay\x12\
    $\n\x0elegacy_ack_e2e\x18\x04\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\n\
    \x05flags\x18\x05\x20\x01(\rR\x05flags\x12J\n\"forward_target_relay_rout\
    ing_token\x18\x06\x20\x01(\x0cR\x1eforwardTargetRelayRoutingToken\x126\n\
    \x17forward_target_revision\x18\x07\x20\x01(\rR\x15forwardTargetRevision\
    \x12\x16\n\x06routes\x18\x08\x20\x01(\x0cR\x06routes\x127\n\x18ack_peer_\
    routes_revision\x18\t\x20\x01(\rR\x15ackPeerRoutesRevision\x12#\n\rconne\
    ction_id\x18\n\x20\x01(\x07R\x0cconnectionId\x12\x1e\n\x0bseq_num_c2r\
    \x18\x0b\x20\x01(\rR\tseqNumC2r\x12\x1e\n\x0bseq_num_e2e\x18\x0c\x20\x01\
    (\rR\tseqNumE2e\"\x86\x01\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\
    \x01\x12\x13\n\x0fACK_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMED\
    IATE\x10\x04\x12\x17\n\x13NOT_PRIMARY_SESSION\x10\x08\x12\x1d\n\x19NOT_P\
    RIMARY_TRANSPORT_E2E\x10\x10\"\xd9\x06\n1CMsgSteamDatagramConnectionStat\
    sP2PRouterToClient\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMsgStea\
    mDatagramConnectionQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\x18\
    \x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\nqualityE2e\x124\
    \n\x16seconds_until_shutdown\x18\x03\x20\x01(\rR\x14secondsUntilShutdown\
    \x12,\n\x12migrate_request_ip\x18\x04\x20\x01(\x07R\x10migrateRequestIp\
    \x120\n\x14migrate_request_port\x18\x05\x20\x01(\rR\x12migrateRequestPor\
    t\x12A\n\x1dscoring_penalty_relay_cluster\x18\x06\x20\x01(\rR\x1ascoring\
    PenaltyRelayCluster\x12\x1b\n\tack_relay\x18\x07\x20\x03(\x07R\x08ackRel\
    ay\x12$\n\x0elegacy_ack_e2e\x18\x08\x20\x03(\x07R\x0clegacyAckE2e\x12\
    \x14\n\x05flags\x18\t\x20\x01(\rR\x05flags\x12=\n\x1back_forward_target_\
    revision\x18\n\x20\x01(\rR\x18ackForwardTargetRevision\x12\x16\n\x06rout\
    es\x18\x0b\x20\x01(\x0cR\x06routes\x127\n\x18ack_peer_routes_revision\
    \x18\x0c\x20\x01(\rR\x15ackPeerRoutesRevision\x12#\n\rconnection_id\x18\
    \r\x20\x01(\x07R\x0cconnectionId\x12\x1e\n\x0bseq_num_r2c\x18\x0e\x20\
    \x01(\rR\tseqNumR2c\x12\x1e\n\x0bseq_num_e2e\x18\x0f\x20\x01(\rR\tseqNum\
    E2e\"m\n\x05Flags\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fAC\
    K_REQUEST_E2E\x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\x12\x1d\
    \n\x19NOT_PRIMARY_TRANSPORT_E2E\x10\x10\"\xec\x01\n*CMsgSteamDatagramP2P\
    BadRouteRouterToClient\x12#\n\rconnection_id\x18\x01\x20\x01(\x07R\x0cco\
    nnectionId\x12;\n\x1afailed_relay_routing_token\x18\x02\x20\x01(\x0cR\
    \x17failedRelayRoutingToken\x12=\n\x1back_forward_target_revision\x18\
    \x03\x20\x01(\rR\x18ackForwardTargetRevision\x12\x1d\n\nkludge_pad\x18c\
    \x20\x01(\x06R\tkludgePad\"\xc4\x03\n\x1aCMsgSteamDatagramP2PRoutes\x12O\
    \n\x0erelay_clusters\x18\x01\x20\x03(\x0b2(.CMsgSteamDatagramP2PRoutes.R\
    elayClusterR\rrelayClusters\x129\n\x06routes\x18\x02\x20\x03(\x0b2!.CMsg\
    SteamDatagramP2PRoutes.RouteR\x06routes\x12\x1a\n\x08revision\x18\x03\
    \x20\x01(\rR\x08revision\x1a\xa2\x01\n\x0cRelayCluster\x12\x15\n\x06pop_\
    id\x18\x01\x20\x01(\x07R\x05popId\x12\x17\n\x07ping_ms\x18\x02\x20\x01(\
    \rR\x06pingMs\x12#\n\rscore_penalty\x18\x03\x20\x01(\rR\x0cscorePenalty\
    \x12=\n\x1bsession_relay_routing_token\x18\x04\x20\x01(\x0cR\x18sessionR\
    elayRoutingToken\x1aY\n\x05Route\x12\x1a\n\tmy_pop_id\x18\x01\x20\x01(\
    \x07R\x07myPopId\x12\x1e\n\x0byour_pop_id\x18\x02\x20\x01(\x07R\tyourPop\
    Id\x12\x14\n\x05score\x18\x03\x20\x01(\rR\x05score\"K\n!CMsgSteamDatagra\
    mGameServerSample\x12\x12\n\x04ipv4\x18\x01\x20\x01(\x07R\x04ipv4\x12\
    \x12\n\x04port\x18\x02\x20\x01(\rR\x04port\"\x90\x01\n+CMsgSteamDatagram\
    GameServerSampleDataCenter\x12#\n\rdatacenter_id\x18\x01\x20\x01(\x07R\
    \x0cdatacenterId\x12<\n\x07servers\x18\x03\x20\x03(\x0b2\".CMsgSteamData\
    gramGameServerSampleR\x07servers\"\x9c\x02\n!CMsgSteamDatagramRelayToRel\
    ayPing\x12+\n\x11request_timestamp\x18\x01\x20\x01(\x07R\x10requestTimes\
    tamp\x12!\n\x0crequest_date\x18\x02\x20\x01(\x07R\x0brequestDate\x12\x1a\
    \n\tmy_pop_id\x18\x03\x20\x01(\x07R\x07myPopId\x12\x1e\n\x0byour_pop_id\
    \x18\x04\x20\x01(\x07R\tyourPopId\x12\x1a\n\x08checksum\x18\x05\x20\x01(\
    \x07R\x08checksum\x12O\n\x0cdata_centers\x18\x06\x20\x03(\x0b2,.CMsgStea\
    mDatagramGameServerSampleDataCenterR\x0bdataCenters\"\xef\x02\n\x20CMsgS\
    teamDatagramDataCenterState\x12O\n\x0cdata_centers\x18\x01\x20\x03(\x0b2\
    ,.CMsgSteamDatagramDataCenterState.DataCenterR\x0bdataCenters\x1a;\n\x06\
    Server\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x17\n\x07\
    ping_ms\x18\x02\x20\x01(\rR\x06pingMs\x1a\xbc\x01\n\nDataCenter\x12\x12\
    \n\x04code\x18\x01\x20\x01(\tR\x04code\x12M\n\rserver_sample\x18\x02\x20\
    \x03(\x0b2(.CMsgSteamDatagramDataCenterState.ServerR\x0cserverSample\x12\
    K\n\x0crelay_sample\x18\x03\x20\x03(\x0b2(.CMsgSteamDatagramDataCenterSt\
    ate.ServerR\x0brelaySample\"\xcb\x04\n\x1dCMsgSteamDatagramRouterHealth\
    \x12\x19\n\x08cpu_load\x18\x01\x20\x01(\x02R\x07cpuLoad\x12\x20\n\x0ccpu\
    _load_raw\x18\n\x20\x01(\x02R\ncpuLoadRaw\x12'\n\x0factive_sessions\x18\
    \x02\x20\x01(\rR\x0eactiveSessions\x12\"\n\rdata_pkts_sec\x18\x03\x20\
    \x01(\rR\x0bdataPktsSec\x12$\n\x0eother_pkts_sec\x18\x04\x20\x01(\rR\x0c\
    otherPktsSec\x124\n\x16seconds_until_shutdown\x18\x05\x20\x01(\rR\x14sec\
    ondsUntilShutdown\x12)\n\x11cpu_cost_per_user\x18\x08\x20\x01(\x02R\x0ec\
    puCostPerUser\x12-\n\x13cpu_cost_per_packet\x18\t\x20\x01(\x02R\x10cpuCo\
    stPerPacket\x12L\n\x0cdata_centers\x18\x06\x20\x03(\x0b2).CMsgSteamDatag\
    ramRouterHealth.DataCenterR\x0bdataCenters\x12\x14\n\x05magic\x18\x07\
    \x20\x01(\x06R\x05magic\x1a\x85\x01\n\nDataCenter\x12#\n\rdatacenter_id\
    \x18\x01\x20\x01(\x07R\x0cdatacenterId\x12\x14\n\x05state\x18\x02\x20\
    \x01(\rR\x05state\x12<\n\x07servers\x18\x03\x20\x03(\x0b2\".CMsgSteamDat\
    agramGameServerSampleR\x07servers\"\xb9\x06\n1CMsgSteamDatagramConnectio\
    nStatsP2PRouterToRouter\x12H\n\rquality_relay\x18\x01\x20\x01(\x0b2#.CMs\
    gSteamDatagramConnectionQualityR\x0cqualityRelay\x12D\n\x0bquality_e2e\
    \x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\nqualityE2e\
    \x12\x1b\n\tack_relay\x18\x03\x20\x03(\x07R\x08ackRelay\x12$\n\x0elegacy\
    _ack_e2e\x18\x04\x20\x03(\x07R\x0clegacyAckE2e\x12\x14\n\x05flags\x18\
    \x05\x20\x01(\rR\x05flags\x12=\n\x1back_forward_target_revision\x18\x06\
    \x20\x01(\rR\x18ackForwardTargetRevision\x12\x16\n\x06routes\x18\x07\x20\
    \x01(\x0cR\x06routes\x127\n\x18ack_peer_routes_revision\x18\x08\x20\x01(\
    \rR\x15ackPeerRoutesRevision\x12,\n\x12from_connection_id\x18\x15\x20\
    \x01(\x07R\x10fromConnectionId\x12(\n\x10to_connection_id\x18\x18\x20\
    \x01(\x07R\x0etoConnectionId\x121\n\x15from_relay_session_id\x18\x16\x20\
    \x01(\x07R\x12fromRelaySessionId\x12\"\n\rseq_num_nonce\x18\x1c\x20\x01(\
    \rR\x0bseqNumNonce\x12-\n\x13to_relay_session_id\x18\x19\x20\x01(\x07R\
    \x10toRelaySessionId\x12\x1e\n\x0bseq_num_r2r\x18\x1a\x20\x01(\rR\tseqNu\
    mR2r\x12\x1e\n\x0bseq_num_e2e\x18\x1b\x20\x01(\rR\tseqNumE2e\"m\n\x05Fla\
    gs\x12\x15\n\x11ACK_REQUEST_RELAY\x10\x01\x12\x13\n\x0fACK_REQUEST_E2E\
    \x10\x02\x12\x19\n\x15ACK_REQUEST_IMMEDIATE\x10\x04\x12\x1d\n\x19NOT_PRI\
    MARY_TRANSPORT_E2E\x10\x10\"\x8f\x01\n6CMsgSteamDatagramNetworkNextRoute\
    rPingRequestExtraData\x12\x1b\n\tclient_id\x18\x03\x20\x01(\tR\x08client\
    Id\x12\x15\n\x06app_id\x18\x04\x20\x01(\rR\x05appId\x12!\n\x0cprotocol_v\
    er\x18\x05\x20\x01(\rR\x0bprotocolVer\"6\n4CMsgSteamDatagramNetworkNextR\
    outerPingReplyExtraData*\xcc\n\n\x13ESteamDatagramMsgID\x12\x1f\n\x1bk_E\
    SteamDatagramMsg_Invalid\x10\0\x12)\n%k_ESteamDatagramMsg_RouterPingRequ\
    est\x10\x01\x12'\n#k_ESteamDatagramMsg_RouterPingReply\x10\x02\x12-\n)k_\
    ESteamDatagramMsg_GameserverPingRequest\x10\x03\x121\n-k_ESteamDatagramM\
    sg_LegacyGameserverPingReply\x10\x04\x120\n,k_ESteamDatagramMsg_Gameserv\
    erSessionRequest\x10\x05\x124\n0k_ESteamDatagramMsg_GameserverSessionEst\
    ablished\x10\x06\x12!\n\x1dk_ESteamDatagramMsg_NoSession\x10\x07\x12\"\n\
    \x1ek_ESteamDatagramMsg_Diagnostic\x10\x08\x12*\n&k_ESteamDatagramMsg_Da\
    taClientToRouter\x10\t\x12*\n&k_ESteamDatagramMsg_DataRouterToServer\x10\
    \n\x12*\n&k_ESteamDatagramMsg_DataServerToRouter\x10\x0b\x12*\n&k_ESteam\
    DatagramMsg_DataRouterToClient\x10\x0c\x12\x1d\n\x19k_ESteamDatagramMsg_\
    Stats\x10\r\x12/\n+k_ESteamDatagramMsg_ClientPingSampleRequest\x10\x0e\
    \x12-\n)k_ESteamDatagramMsg_ClientPingSampleReply\x10\x0f\x125\n1k_EStea\
    mDatagramMsg_ClientToRouterSwitchedPrimary\x10\x10\x12#\n\x1fk_ESteamDat\
    agramMsg_RelayHealth\x10\x11\x12&\n\"k_ESteamDatagramMsg_ConnectRequest\
    \x10\x12\x12!\n\x1dk_ESteamDatagramMsg_ConnectOK\x10\x13\x12(\n$k_ESteam\
    DatagramMsg_ConnectionClosed\x10\x14\x12$\n\x20k_ESteamDatagramMsg_NoCon\
    nection\x10\x15\x12/\n+k_ESteamDatagramMsg_RelayToRelayPingRequest\x10\
    \x16\x12-\n)k_ESteamDatagramMsg_RelayToRelayPingReply\x10\x17\x12)\n%k_E\
    SteamDatagramMsg_P2PSessionRequest\x10\x18\x12-\n)k_ESteamDatagramMsg_P2\
    PSessionEstablished\x10\x19\x12&\n\"k_ESteamDatagramMsg_P2PStatsClient\
    \x10\x1a\x12%\n!k_ESteamDatagramMsg_P2PStatsRelay\x10\x1b\x12#\n\x1fk_ES\
    teamDatagramMsg_P2PBadRoute\x10\x1c\x12+\n'k_ESteamDatagramMsg_Gameserve\
    rPingReply\x10\x1d\x12.\n*k_ESteamDatagramMsg_GameserverRegistration\x10\
    \x1eB\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
