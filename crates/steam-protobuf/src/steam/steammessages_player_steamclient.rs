// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `steammessages_player.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetMutualFriendsForIncomingInvites_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn default() -> &'a CPlayer_GetMutualFriendsForIncomingInvites_Request {
        <CPlayer_GetMutualFriendsForIncomingInvites_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMutualFriendsForIncomingInvites_Request {
    pub fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Request {
        CPlayer_GetMutualFriendsForIncomingInvites_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetMutualFriendsForIncomingInvites_Request>(
                "CPlayer_GetMutualFriendsForIncomingInvites_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetMutualFriendsForIncomingInvites_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetMutualFriendsForIncomingInvites_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetMutualFriendsForIncomingInvites_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMutualFriendsForIncomingInvites_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMutualFriendsForIncomingInvites_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_IncomingInviteMutualFriendList {
    // message fields
    steamid: ::std::option::Option<u64>,
    pub mutual_friend_account_ids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IncomingInviteMutualFriendList {
    fn default() -> &'a CPlayer_IncomingInviteMutualFriendList {
        <CPlayer_IncomingInviteMutualFriendList as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IncomingInviteMutualFriendList {
    pub fn new() -> CPlayer_IncomingInviteMutualFriendList {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_IncomingInviteMutualFriendList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.mutual_friend_account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        for value in &self.mutual_friend_account_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        for v in &self.mutual_friend_account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IncomingInviteMutualFriendList {
        CPlayer_IncomingInviteMutualFriendList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CPlayer_IncomingInviteMutualFriendList| { &m.steamid },
                |m: &mut CPlayer_IncomingInviteMutualFriendList| { &mut m.steamid },
                CPlayer_IncomingInviteMutualFriendList::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "mutual_friend_account_ids",
                |m: &CPlayer_IncomingInviteMutualFriendList| { &m.mutual_friend_account_ids },
                |m: &mut CPlayer_IncomingInviteMutualFriendList| { &mut m.mutual_friend_account_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_IncomingInviteMutualFriendList>(
                "CPlayer_IncomingInviteMutualFriendList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_IncomingInviteMutualFriendList {
        static instance: ::protobuf::rt::Lazy<CPlayer_IncomingInviteMutualFriendList> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_IncomingInviteMutualFriendList::new)
    }
}

impl ::protobuf::Clear for CPlayer_IncomingInviteMutualFriendList {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.mutual_friend_account_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IncomingInviteMutualFriendList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IncomingInviteMutualFriendList {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetMutualFriendsForIncomingInvites_Response {
    // message fields
    pub incoming_invite_mutual_friends_lists: ::protobuf::RepeatedField<CPlayer_IncomingInviteMutualFriendList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn default() -> &'a CPlayer_GetMutualFriendsForIncomingInvites_Response {
        <CPlayer_GetMutualFriendsForIncomingInvites_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetMutualFriendsForIncomingInvites_Response {
    pub fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.incoming_invite_mutual_friends_lists {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.incoming_invite_mutual_friends_lists)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.incoming_invite_mutual_friends_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.incoming_invite_mutual_friends_lists {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetMutualFriendsForIncomingInvites_Response {
        CPlayer_GetMutualFriendsForIncomingInvites_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CPlayer_IncomingInviteMutualFriendList>>(
                "incoming_invite_mutual_friends_lists",
                |m: &CPlayer_GetMutualFriendsForIncomingInvites_Response| { &m.incoming_invite_mutual_friends_lists },
                |m: &mut CPlayer_GetMutualFriendsForIncomingInvites_Response| { &mut m.incoming_invite_mutual_friends_lists },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetMutualFriendsForIncomingInvites_Response>(
                "CPlayer_GetMutualFriendsForIncomingInvites_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetMutualFriendsForIncomingInvites_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetMutualFriendsForIncomingInvites_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetMutualFriendsForIncomingInvites_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn clear(&mut self) {
        self.incoming_invite_mutual_friends_lists.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetMutualFriendsForIncomingInvites_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetMutualFriendsForIncomingInvites_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetFriendsGameplayInfo_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Request {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Request {
        <CPlayer_GetFriendsGameplayInfo_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Request {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Request {
        CPlayer_GetFriendsGameplayInfo_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPlayer_GetFriendsGameplayInfo_Request| { &m.appid },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Request| { &mut m.appid },
                CPlayer_GetFriendsGameplayInfo_Request::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsGameplayInfo_Request>(
                "CPlayer_GetFriendsGameplayInfo_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetFriendsGameplayInfo_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetFriendsGameplayInfo_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetFriendsGameplayInfo_Response {
    // message fields
    pub your_info: ::protobuf::SingularPtrField<cplayer_get_friends_gameplay_info_response::OwnGameplayInfo>,
    pub in_game: ::protobuf::RepeatedField<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>,
    pub played_recently: ::protobuf::RepeatedField<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>,
    pub played_ever: ::protobuf::RepeatedField<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>,
    pub owns: ::protobuf::RepeatedField<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>,
    pub in_wishlist: ::protobuf::RepeatedField<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsGameplayInfo_Response {
    fn default() -> &'a CPlayer_GetFriendsGameplayInfo_Response {
        <CPlayer_GetFriendsGameplayInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsGameplayInfo_Response {
    pub fn new() -> CPlayer_GetFriendsGameplayInfo_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsGameplayInfo_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.your_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_game {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.played_recently {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.played_ever {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owns {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.in_wishlist {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<cplayer_get_friends_gameplay_info_response::OwnGameplayInfo, _>(wire_type, is, &mut self.your_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.in_game)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.played_recently)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.played_ever)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.owns)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.in_wishlist)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.your_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.in_game {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.played_recently {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.played_ever {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.owns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.in_wishlist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.your_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.in_game {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.played_recently {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.played_ever {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.owns {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.in_wishlist {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsGameplayInfo_Response {
        CPlayer_GetFriendsGameplayInfo_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_gameplay_info_response::OwnGameplayInfo>, _>(
                "your_info",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.your_info },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.your_info },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>>(
                "in_game",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.in_game },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.in_game },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>>(
                "played_recently",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.played_recently },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.played_recently },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>>(
                "played_ever",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.played_ever },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.played_ever },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>>(
                "owns",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.owns },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.owns },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_gameplay_info_response::FriendsGameplayInfo>>(
                "in_wishlist",
                |m: &CPlayer_GetFriendsGameplayInfo_Response| { &m.in_wishlist },
                |m: &mut CPlayer_GetFriendsGameplayInfo_Response| { &mut m.in_wishlist },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsGameplayInfo_Response>(
                "CPlayer_GetFriendsGameplayInfo_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsGameplayInfo_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetFriendsGameplayInfo_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetFriendsGameplayInfo_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsGameplayInfo_Response {
    fn clear(&mut self) {
        self.your_info.clear();
        self.in_game.clear();
        self.played_recently.clear();
        self.played_ever.clear();
        self.owns.clear();
        self.in_wishlist.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsGameplayInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsGameplayInfo_Response {
}

/// Nested message and enums of message `CPlayer_GetFriendsGameplayInfo_Response`
pub mod cplayer_get_friends_gameplay_info_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct FriendsGameplayInfo {
        // message fields
        steamid: ::std::option::Option<u64>,
        minutes_played: ::std::option::Option<u32>,
        minutes_played_forever: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a FriendsGameplayInfo {
        fn default() -> &'a FriendsGameplayInfo {
            <FriendsGameplayInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendsGameplayInfo {
        pub fn new() -> FriendsGameplayInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn get_steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint32 minutes_played = 2;

        pub fn get_minutes_played(&self) -> u32 {
            self.minutes_played.unwrap_or(0)
        }

        pub fn clear_minutes_played(&mut self) {
            self.minutes_played = ::std::option::Option::None;
        }

        pub fn has_minutes_played(&self) -> bool {
            self.minutes_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_played(&mut self, v: u32) {
            self.minutes_played = ::std::option::Option::Some(v);
        }

        // optional uint32 minutes_played_forever = 3;

        pub fn get_minutes_played_forever(&self) -> u32 {
            self.minutes_played_forever.unwrap_or(0)
        }

        pub fn clear_minutes_played_forever(&mut self) {
            self.minutes_played_forever = ::std::option::Option::None;
        }

        pub fn has_minutes_played_forever(&self) -> bool {
            self.minutes_played_forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_played_forever(&mut self, v: u32) {
            self.minutes_played_forever = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for FriendsGameplayInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_played_forever = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 9;
            }
            if let Some(v) = self.minutes_played {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.minutes_played_forever {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.minutes_played {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.minutes_played_forever {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> FriendsGameplayInfo {
            FriendsGameplayInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid",
                    |m: &FriendsGameplayInfo| { &m.steamid },
                    |m: &mut FriendsGameplayInfo| { &mut m.steamid },
                    FriendsGameplayInfo::get_steamid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "minutes_played",
                    |m: &FriendsGameplayInfo| { &m.minutes_played },
                    |m: &mut FriendsGameplayInfo| { &mut m.minutes_played },
                    FriendsGameplayInfo::get_minutes_played,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "minutes_played_forever",
                    |m: &FriendsGameplayInfo| { &m.minutes_played_forever },
                    |m: &mut FriendsGameplayInfo| { &mut m.minutes_played_forever },
                    FriendsGameplayInfo::get_minutes_played_forever,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FriendsGameplayInfo>(
                    "CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static FriendsGameplayInfo {
            static instance: ::protobuf::rt::Lazy<FriendsGameplayInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(FriendsGameplayInfo::new)
        }
    }

    impl ::protobuf::Clear for FriendsGameplayInfo {
        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.minutes_played = ::std::option::Option::None;
            self.minutes_played_forever = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for FriendsGameplayInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendsGameplayInfo {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct OwnGameplayInfo {
        // message fields
        steamid: ::std::option::Option<u64>,
        minutes_played: ::std::option::Option<u32>,
        minutes_played_forever: ::std::option::Option<u32>,
        in_wishlist: ::std::option::Option<bool>,
        owned: ::std::option::Option<bool>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a OwnGameplayInfo {
        fn default() -> &'a OwnGameplayInfo {
            <OwnGameplayInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl OwnGameplayInfo {
        pub fn new() -> OwnGameplayInfo {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn get_steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint32 minutes_played = 2;

        pub fn get_minutes_played(&self) -> u32 {
            self.minutes_played.unwrap_or(0)
        }

        pub fn clear_minutes_played(&mut self) {
            self.minutes_played = ::std::option::Option::None;
        }

        pub fn has_minutes_played(&self) -> bool {
            self.minutes_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_played(&mut self, v: u32) {
            self.minutes_played = ::std::option::Option::Some(v);
        }

        // optional uint32 minutes_played_forever = 3;

        pub fn get_minutes_played_forever(&self) -> u32 {
            self.minutes_played_forever.unwrap_or(0)
        }

        pub fn clear_minutes_played_forever(&mut self) {
            self.minutes_played_forever = ::std::option::Option::None;
        }

        pub fn has_minutes_played_forever(&self) -> bool {
            self.minutes_played_forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_played_forever(&mut self, v: u32) {
            self.minutes_played_forever = ::std::option::Option::Some(v);
        }

        // optional bool in_wishlist = 4;

        pub fn get_in_wishlist(&self) -> bool {
            self.in_wishlist.unwrap_or(false)
        }

        pub fn clear_in_wishlist(&mut self) {
            self.in_wishlist = ::std::option::Option::None;
        }

        pub fn has_in_wishlist(&self) -> bool {
            self.in_wishlist.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_wishlist(&mut self, v: bool) {
            self.in_wishlist = ::std::option::Option::Some(v);
        }

        // optional bool owned = 5;

        pub fn get_owned(&self) -> bool {
            self.owned.unwrap_or(false)
        }

        pub fn clear_owned(&mut self) {
            self.owned = ::std::option::Option::None;
        }

        pub fn has_owned(&self) -> bool {
            self.owned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_owned(&mut self, v: bool) {
            self.owned = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for OwnGameplayInfo {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_played_forever = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.in_wishlist = ::std::option::Option::Some(is.read_bool()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.owned = ::std::option::Option::Some(is.read_bool()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 9;
            }
            if let Some(v) = self.minutes_played {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.minutes_played_forever {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.in_wishlist {
                my_size += 2;
            }
            if let Some(v) = self.owned {
                my_size += 2;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.minutes_played {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.minutes_played_forever {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.in_wishlist {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.owned {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> OwnGameplayInfo {
            OwnGameplayInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid",
                    |m: &OwnGameplayInfo| { &m.steamid },
                    |m: &mut OwnGameplayInfo| { &mut m.steamid },
                    OwnGameplayInfo::get_steamid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "minutes_played",
                    |m: &OwnGameplayInfo| { &m.minutes_played },
                    |m: &mut OwnGameplayInfo| { &mut m.minutes_played },
                    OwnGameplayInfo::get_minutes_played,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "minutes_played_forever",
                    |m: &OwnGameplayInfo| { &m.minutes_played_forever },
                    |m: &mut OwnGameplayInfo| { &mut m.minutes_played_forever },
                    OwnGameplayInfo::get_minutes_played_forever,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "in_wishlist",
                    |m: &OwnGameplayInfo| { &m.in_wishlist },
                    |m: &mut OwnGameplayInfo| { &mut m.in_wishlist },
                    OwnGameplayInfo::get_in_wishlist,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "owned",
                    |m: &OwnGameplayInfo| { &m.owned },
                    |m: &mut OwnGameplayInfo| { &mut m.owned },
                    OwnGameplayInfo::get_owned,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OwnGameplayInfo>(
                    "CPlayer_GetFriendsGameplayInfo_Response.OwnGameplayInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static OwnGameplayInfo {
            static instance: ::protobuf::rt::Lazy<OwnGameplayInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(OwnGameplayInfo::new)
        }
    }

    impl ::protobuf::Clear for OwnGameplayInfo {
        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.minutes_played = ::std::option::Option::None;
            self.minutes_played_forever = ::std::option::Option::None;
            self.in_wishlist = ::std::option::Option::None;
            self.owned = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for OwnGameplayInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OwnGameplayInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetFriendsAppsActivity_Request {
    // message fields
    news_language: ::protobuf::SingularField<::std::string::String>,
    request_flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Request {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Request {
        <CPlayer_GetFriendsAppsActivity_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Request {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Request {
        ::std::default::Default::default()
    }

    // optional string news_language = 1;

    pub fn get_news_language(&self) -> &str {
        match self.news_language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_news_language(&mut self) {
        self.news_language.clear();
    }

    pub fn has_news_language(&self) -> bool {
        self.news_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_news_language(&mut self, v: ::std::string::String) {
        self.news_language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_news_language(&mut self) -> &mut ::std::string::String {
        if self.news_language.is_none() {
            self.news_language.set_default();
        }
        self.news_language.as_mut().unwrap()
    }

    // Take field
    pub fn take_news_language(&mut self) -> ::std::string::String {
        self.news_language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 request_flags = 2;

    pub fn get_request_flags(&self) -> u32 {
        self.request_flags.unwrap_or(0)
    }

    pub fn clear_request_flags(&mut self) {
        self.request_flags = ::std::option::Option::None;
    }

    pub fn has_request_flags(&self) -> bool {
        self.request_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_flags(&mut self, v: u32) {
        self.request_flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.news_language)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.news_language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.request_flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.news_language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.request_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Request {
        CPlayer_GetFriendsAppsActivity_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "news_language",
                |m: &CPlayer_GetFriendsAppsActivity_Request| { &m.news_language },
                |m: &mut CPlayer_GetFriendsAppsActivity_Request| { &mut m.news_language },
                CPlayer_GetFriendsAppsActivity_Request::get_news_language,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "request_flags",
                |m: &CPlayer_GetFriendsAppsActivity_Request| { &m.request_flags },
                |m: &mut CPlayer_GetFriendsAppsActivity_Request| { &mut m.request_flags },
                CPlayer_GetFriendsAppsActivity_Request::get_request_flags,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsAppsActivity_Request>(
                "CPlayer_GetFriendsAppsActivity_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetFriendsAppsActivity_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetFriendsAppsActivity_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Request {
    fn clear(&mut self) {
        self.news_language.clear();
        self.request_flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetFriendsAppsActivity_Response {
    // message fields
    pub trending: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    pub recent_purchases: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    pub unowned: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    pub popular: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    pub dont_forget: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    pub being_discussed: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    pub new_to_group: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    pub returned_to_group: ::protobuf::RepeatedField<cplayer_get_friends_apps_activity_response::AppFriendsInfo>,
    active_friend_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetFriendsAppsActivity_Response {
    fn default() -> &'a CPlayer_GetFriendsAppsActivity_Response {
        <CPlayer_GetFriendsAppsActivity_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetFriendsAppsActivity_Response {
    pub fn new() -> CPlayer_GetFriendsAppsActivity_Response {
        ::std::default::Default::default()
    }

    // optional uint32 active_friend_count = 9;

    pub fn get_active_friend_count(&self) -> u32 {
        self.active_friend_count.unwrap_or(0u32)
    }

    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetFriendsAppsActivity_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.trending {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recent_purchases {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unowned {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.popular {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dont_forget {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.being_discussed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_to_group {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.returned_to_group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.trending)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.recent_purchases)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.unowned)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.popular)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.dont_forget)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.being_discussed)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.new_to_group)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.returned_to_group)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.active_friend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trending {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.recent_purchases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.unowned {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.popular {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dont_forget {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.being_discussed {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.new_to_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.returned_to_group {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.active_friend_count {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trending {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.recent_purchases {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.unowned {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.popular {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.dont_forget {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.being_discussed {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.new_to_group {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.returned_to_group {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.active_friend_count {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetFriendsAppsActivity_Response {
        CPlayer_GetFriendsAppsActivity_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "trending",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.trending },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.trending },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "recent_purchases",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.recent_purchases },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.recent_purchases },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "unowned",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.unowned },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.unowned },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "popular",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.popular },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.popular },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "dont_forget",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.dont_forget },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.dont_forget },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "being_discussed",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.being_discussed },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.being_discussed },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "new_to_group",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.new_to_group },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.new_to_group },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_friends_apps_activity_response::AppFriendsInfo>>(
                "returned_to_group",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.returned_to_group },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.returned_to_group },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "active_friend_count",
                |m: &CPlayer_GetFriendsAppsActivity_Response| { &m.active_friend_count },
                |m: &mut CPlayer_GetFriendsAppsActivity_Response| { &mut m.active_friend_count },
                CPlayer_GetFriendsAppsActivity_Response::get_active_friend_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetFriendsAppsActivity_Response>(
                "CPlayer_GetFriendsAppsActivity_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetFriendsAppsActivity_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetFriendsAppsActivity_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetFriendsAppsActivity_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetFriendsAppsActivity_Response {
    fn clear(&mut self) {
        self.trending.clear();
        self.recent_purchases.clear();
        self.unowned.clear();
        self.popular.clear();
        self.dont_forget.clear();
        self.being_discussed.clear();
        self.new_to_group.clear();
        self.returned_to_group.clear();
        self.active_friend_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetFriendsAppsActivity_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetFriendsAppsActivity_Response {
}

/// Nested message and enums of message `CPlayer_GetFriendsAppsActivity_Response`
pub mod cplayer_get_friends_apps_activity_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct FriendPlayTime {
        // message fields
        steamid: ::std::option::Option<u64>,
        minutes_played_this_week: ::std::option::Option<u32>,
        minutes_played_two_weeks: ::std::option::Option<u32>,
        minutes_played_forever: ::std::option::Option<u32>,
        event_count: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a FriendPlayTime {
        fn default() -> &'a FriendPlayTime {
            <FriendPlayTime as ::protobuf::Message>::default_instance()
        }
    }

    impl FriendPlayTime {
        pub fn new() -> FriendPlayTime {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn get_steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint32 minutes_played_this_week = 2;

        pub fn get_minutes_played_this_week(&self) -> u32 {
            self.minutes_played_this_week.unwrap_or(0)
        }

        pub fn clear_minutes_played_this_week(&mut self) {
            self.minutes_played_this_week = ::std::option::Option::None;
        }

        pub fn has_minutes_played_this_week(&self) -> bool {
            self.minutes_played_this_week.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_played_this_week(&mut self, v: u32) {
            self.minutes_played_this_week = ::std::option::Option::Some(v);
        }

        // optional uint32 minutes_played_two_weeks = 3;

        pub fn get_minutes_played_two_weeks(&self) -> u32 {
            self.minutes_played_two_weeks.unwrap_or(0)
        }

        pub fn clear_minutes_played_two_weeks(&mut self) {
            self.minutes_played_two_weeks = ::std::option::Option::None;
        }

        pub fn has_minutes_played_two_weeks(&self) -> bool {
            self.minutes_played_two_weeks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_played_two_weeks(&mut self, v: u32) {
            self.minutes_played_two_weeks = ::std::option::Option::Some(v);
        }

        // optional uint32 minutes_played_forever = 4;

        pub fn get_minutes_played_forever(&self) -> u32 {
            self.minutes_played_forever.unwrap_or(0)
        }

        pub fn clear_minutes_played_forever(&mut self) {
            self.minutes_played_forever = ::std::option::Option::None;
        }

        pub fn has_minutes_played_forever(&self) -> bool {
            self.minutes_played_forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_minutes_played_forever(&mut self, v: u32) {
            self.minutes_played_forever = ::std::option::Option::Some(v);
        }

        // optional uint32 event_count = 5;

        pub fn get_event_count(&self) -> u32 {
            self.event_count.unwrap_or(0)
        }

        pub fn clear_event_count(&mut self) {
            self.event_count = ::std::option::Option::None;
        }

        pub fn has_event_count(&self) -> bool {
            self.event_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_count(&mut self, v: u32) {
            self.event_count = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for FriendPlayTime {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_played_this_week = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_played_two_weeks = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.minutes_played_forever = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.event_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 9;
            }
            if let Some(v) = self.minutes_played_this_week {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.minutes_played_two_weeks {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.minutes_played_forever {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.event_count {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.minutes_played_this_week {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.minutes_played_two_weeks {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.minutes_played_forever {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.event_count {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> FriendPlayTime {
            FriendPlayTime::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                    "steamid",
                    |m: &FriendPlayTime| { &m.steamid },
                    |m: &mut FriendPlayTime| { &mut m.steamid },
                    FriendPlayTime::get_steamid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "minutes_played_this_week",
                    |m: &FriendPlayTime| { &m.minutes_played_this_week },
                    |m: &mut FriendPlayTime| { &mut m.minutes_played_this_week },
                    FriendPlayTime::get_minutes_played_this_week,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "minutes_played_two_weeks",
                    |m: &FriendPlayTime| { &m.minutes_played_two_weeks },
                    |m: &mut FriendPlayTime| { &mut m.minutes_played_two_weeks },
                    FriendPlayTime::get_minutes_played_two_weeks,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "minutes_played_forever",
                    |m: &FriendPlayTime| { &m.minutes_played_forever },
                    |m: &mut FriendPlayTime| { &mut m.minutes_played_forever },
                    FriendPlayTime::get_minutes_played_forever,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "event_count",
                    |m: &FriendPlayTime| { &m.event_count },
                    |m: &mut FriendPlayTime| { &mut m.event_count },
                    FriendPlayTime::get_event_count,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FriendPlayTime>(
                    "CPlayer_GetFriendsAppsActivity_Response.FriendPlayTime",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static FriendPlayTime {
            static instance: ::protobuf::rt::Lazy<FriendPlayTime> = ::protobuf::rt::Lazy::INIT;
            instance.get(FriendPlayTime::new)
        }
    }

    impl ::protobuf::Clear for FriendPlayTime {
        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.minutes_played_this_week = ::std::option::Option::None;
            self.minutes_played_two_weeks = ::std::option::Option::None;
            self.minutes_played_forever = ::std::option::Option::None;
            self.event_count = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for FriendPlayTime {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FriendPlayTime {
    }

    #[derive(PartialEq,Clone,Default)]
    pub struct AppFriendsInfo {
        // message fields
        appid: ::std::option::Option<u32>,
        pub friends: ::protobuf::RepeatedField<FriendPlayTime>,
        display_order: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AppFriendsInfo {
        fn default() -> &'a AppFriendsInfo {
            <AppFriendsInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl AppFriendsInfo {
        pub fn new() -> AppFriendsInfo {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 display_order = 3;

        pub fn get_display_order(&self) -> u32 {
            self.display_order.unwrap_or(0)
        }

        pub fn clear_display_order(&mut self) {
            self.display_order = ::std::option::Option::None;
        }

        pub fn has_display_order(&self) -> bool {
            self.display_order.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display_order(&mut self, v: u32) {
            self.display_order = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AppFriendsInfo {
        fn is_initialized(&self) -> bool {
            for v in &self.friends {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.friends)?;
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.display_order = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            for value in &self.friends {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
            };
            if let Some(v) = self.display_order {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.friends {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.display_order {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AppFriendsInfo {
            AppFriendsInfo::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &AppFriendsInfo| { &m.appid },
                    |m: &mut AppFriendsInfo| { &mut m.appid },
                    AppFriendsInfo::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<FriendPlayTime>>(
                    "friends",
                    |m: &AppFriendsInfo| { &m.friends },
                    |m: &mut AppFriendsInfo| { &mut m.friends },
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "display_order",
                    |m: &AppFriendsInfo| { &m.display_order },
                    |m: &mut AppFriendsInfo| { &mut m.display_order },
                    AppFriendsInfo::get_display_order,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppFriendsInfo>(
                    "CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfo",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AppFriendsInfo {
            static instance: ::protobuf::rt::Lazy<AppFriendsInfo> = ::protobuf::rt::Lazy::INIT;
            instance.get(AppFriendsInfo::new)
        }
    }

    impl ::protobuf::Clear for AppFriendsInfo {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.friends.clear();
            self.display_order = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AppFriendsInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppFriendsInfo {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetGameBadgeLevels_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Request {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Request {
        <CPlayer_GetGameBadgeLevels_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Request {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Request {
        CPlayer_GetGameBadgeLevels_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPlayer_GetGameBadgeLevels_Request| { &m.appid },
                |m: &mut CPlayer_GetGameBadgeLevels_Request| { &mut m.appid },
                CPlayer_GetGameBadgeLevels_Request::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetGameBadgeLevels_Request>(
                "CPlayer_GetGameBadgeLevels_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetGameBadgeLevels_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetGameBadgeLevels_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetGameBadgeLevels_Response {
    // message fields
    player_level: ::std::option::Option<u32>,
    pub badges: ::protobuf::RepeatedField<cplayer_get_game_badge_levels_response::Badge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetGameBadgeLevels_Response {
    fn default() -> &'a CPlayer_GetGameBadgeLevels_Response {
        <CPlayer_GetGameBadgeLevels_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetGameBadgeLevels_Response {
    pub fn new() -> CPlayer_GetGameBadgeLevels_Response {
        ::std::default::Default::default()
    }

    // optional uint32 player_level = 1;

    pub fn get_player_level(&self) -> u32 {
        self.player_level.unwrap_or(0)
    }

    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: u32) {
        self.player_level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetGameBadgeLevels_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.badges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.player_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.badges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.badges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.badges {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetGameBadgeLevels_Response {
        CPlayer_GetGameBadgeLevels_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "player_level",
                |m: &CPlayer_GetGameBadgeLevels_Response| { &m.player_level },
                |m: &mut CPlayer_GetGameBadgeLevels_Response| { &mut m.player_level },
                CPlayer_GetGameBadgeLevels_Response::get_player_level,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_game_badge_levels_response::Badge>>(
                "badges",
                |m: &CPlayer_GetGameBadgeLevels_Response| { &m.badges },
                |m: &mut CPlayer_GetGameBadgeLevels_Response| { &mut m.badges },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetGameBadgeLevels_Response>(
                "CPlayer_GetGameBadgeLevels_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetGameBadgeLevels_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetGameBadgeLevels_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetGameBadgeLevels_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetGameBadgeLevels_Response {
    fn clear(&mut self) {
        self.player_level = ::std::option::Option::None;
        self.badges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetGameBadgeLevels_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetGameBadgeLevels_Response {
}

/// Nested message and enums of message `CPlayer_GetGameBadgeLevels_Response`
pub mod cplayer_get_game_badge_levels_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Badge {
        // message fields
        level: ::std::option::Option<i32>,
        series: ::std::option::Option<i32>,
        border_color: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Badge {
        fn default() -> &'a Badge {
            <Badge as ::protobuf::Message>::default_instance()
        }
    }

    impl Badge {
        pub fn new() -> Badge {
            ::std::default::Default::default()
        }

        // optional int32 level = 1;

        pub fn get_level(&self) -> i32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: i32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional int32 series = 2;

        pub fn get_series(&self) -> i32 {
            self.series.unwrap_or(0)
        }

        pub fn clear_series(&mut self) {
            self.series = ::std::option::Option::None;
        }

        pub fn has_series(&self) -> bool {
            self.series.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series(&mut self, v: i32) {
            self.series = ::std::option::Option::Some(v);
        }

        // optional uint32 border_color = 3;

        pub fn get_border_color(&self) -> u32 {
            self.border_color.unwrap_or(0)
        }

        pub fn clear_border_color(&mut self) {
            self.border_color = ::std::option::Option::None;
        }

        pub fn has_border_color(&self) -> bool {
            self.border_color.is_some()
        }

        // Param is passed by value, moved
        pub fn set_border_color(&mut self, v: u32) {
            self.border_color = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Badge {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.series = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.border_color = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.level {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.series {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.border_color {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.level {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.series {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.border_color {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Badge {
            Badge::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "level",
                    |m: &Badge| { &m.level },
                    |m: &mut Badge| { &mut m.level },
                    Badge::get_level,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "series",
                    |m: &Badge| { &m.series },
                    |m: &mut Badge| { &mut m.series },
                    Badge::get_series,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "border_color",
                    |m: &Badge| { &m.border_color },
                    |m: &mut Badge| { &mut m.border_color },
                    Badge::get_border_color,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Badge>(
                    "CPlayer_GetGameBadgeLevels_Response.Badge",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Badge {
            static instance: ::protobuf::rt::Lazy<Badge> = ::protobuf::rt::Lazy::INIT;
            instance.get(Badge::new)
        }
    }

    impl ::protobuf::Clear for Badge {
        fn clear(&mut self) {
            self.level = ::std::option::Option::None;
            self.series = ::std::option::Option::None;
            self.border_color = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Badge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Badge {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetEmoticonList_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Request {
    fn default() -> &'a CPlayer_GetEmoticonList_Request {
        <CPlayer_GetEmoticonList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Request {
    pub fn new() -> CPlayer_GetEmoticonList_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Request {
        CPlayer_GetEmoticonList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetEmoticonList_Request>(
                "CPlayer_GetEmoticonList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetEmoticonList_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetEmoticonList_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetEmoticonList_Response {
    // message fields
    pub emoticons: ::protobuf::RepeatedField<cplayer_get_emoticon_list_response::Emoticon>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetEmoticonList_Response {
    fn default() -> &'a CPlayer_GetEmoticonList_Response {
        <CPlayer_GetEmoticonList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetEmoticonList_Response {
    pub fn new() -> CPlayer_GetEmoticonList_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetEmoticonList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.emoticons {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.emoticons)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.emoticons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.emoticons {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetEmoticonList_Response {
        CPlayer_GetEmoticonList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_emoticon_list_response::Emoticon>>(
                "emoticons",
                |m: &CPlayer_GetEmoticonList_Response| { &m.emoticons },
                |m: &mut CPlayer_GetEmoticonList_Response| { &mut m.emoticons },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetEmoticonList_Response>(
                "CPlayer_GetEmoticonList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetEmoticonList_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetEmoticonList_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetEmoticonList_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetEmoticonList_Response {
    fn clear(&mut self) {
        self.emoticons.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetEmoticonList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetEmoticonList_Response {
}

/// Nested message and enums of message `CPlayer_GetEmoticonList_Response`
pub mod cplayer_get_emoticon_list_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Emoticon {
        // message fields
        name: ::protobuf::SingularField<::std::string::String>,
        count: ::std::option::Option<i32>,
        time_last_used: ::std::option::Option<u32>,
        use_count: ::std::option::Option<u32>,
        time_received: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Emoticon {
        fn default() -> &'a Emoticon {
            <Emoticon as ::protobuf::Message>::default_instance()
        }
    }

    impl Emoticon {
        pub fn new() -> Emoticon {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn get_name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name.clear();
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name.set_default();
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 count = 2;

        pub fn get_count(&self) -> i32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: i32) {
            self.count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_used = 3;

        pub fn get_time_last_used(&self) -> u32 {
            self.time_last_used.unwrap_or(0)
        }

        pub fn clear_time_last_used(&mut self) {
            self.time_last_used = ::std::option::Option::None;
        }

        pub fn has_time_last_used(&self) -> bool {
            self.time_last_used.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_used(&mut self, v: u32) {
            self.time_last_used = ::std::option::Option::Some(v);
        }

        // optional uint32 use_count = 4;

        pub fn get_use_count(&self) -> u32 {
            self.use_count.unwrap_or(0)
        }

        pub fn clear_use_count(&mut self) {
            self.use_count = ::std::option::Option::None;
        }

        pub fn has_use_count(&self) -> bool {
            self.use_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use_count(&mut self, v: u32) {
            self.use_count = ::std::option::Option::Some(v);
        }

        // optional uint32 time_received = 5;

        pub fn get_time_received(&self) -> u32 {
            self.time_received.unwrap_or(0)
        }

        pub fn clear_time_received(&mut self) {
            self.time_received = ::std::option::Option::None;
        }

        pub fn has_time_received(&self) -> bool {
            self.time_received.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_received(&mut self, v: u32) {
            self.time_received = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Emoticon {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_last_used = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.use_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.time_received = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.count {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.time_last_used {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.use_count {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.time_received {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.time_last_used {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.use_count {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_received {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Emoticon {
            Emoticon::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "name",
                    |m: &Emoticon| { &m.name },
                    |m: &mut Emoticon| { &mut m.name },
                    Emoticon::get_name,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "count",
                    |m: &Emoticon| { &m.count },
                    |m: &mut Emoticon| { &mut m.count },
                    Emoticon::get_count,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_last_used",
                    |m: &Emoticon| { &m.time_last_used },
                    |m: &mut Emoticon| { &mut m.time_last_used },
                    Emoticon::get_time_last_used,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "use_count",
                    |m: &Emoticon| { &m.use_count },
                    |m: &mut Emoticon| { &mut m.use_count },
                    Emoticon::get_use_count,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "time_received",
                    |m: &Emoticon| { &m.time_received },
                    |m: &mut Emoticon| { &mut m.time_received },
                    Emoticon::get_time_received,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Emoticon>(
                    "CPlayer_GetEmoticonList_Response.Emoticon",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Emoticon {
            static instance: ::protobuf::rt::Lazy<Emoticon> = ::protobuf::rt::Lazy::INIT;
            instance.get(Emoticon::new)
        }
    }

    impl ::protobuf::Clear for Emoticon {
        fn clear(&mut self) {
            self.name.clear();
            self.count = ::std::option::Option::None;
            self.time_last_used = ::std::option::Option::None;
            self.use_count = ::std::option::Option::None;
            self.time_received = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Emoticon {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Emoticon {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetAchievementsProgress_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    language: ::protobuf::SingularField<::std::string::String>,
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAchievementsProgress_Request {
    fn default() -> &'a CPlayer_GetAchievementsProgress_Request {
        <CPlayer_GetAchievementsProgress_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAchievementsProgress_Request {
    pub fn new() -> CPlayer_GetAchievementsProgress_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string language = 2;

    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_GetAchievementsProgress_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.appids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.appids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAchievementsProgress_Request {
        CPlayer_GetAchievementsProgress_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "steamid",
                |m: &CPlayer_GetAchievementsProgress_Request| { &m.steamid },
                |m: &mut CPlayer_GetAchievementsProgress_Request| { &mut m.steamid },
                CPlayer_GetAchievementsProgress_Request::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "language",
                |m: &CPlayer_GetAchievementsProgress_Request| { &m.language },
                |m: &mut CPlayer_GetAchievementsProgress_Request| { &mut m.language },
                CPlayer_GetAchievementsProgress_Request::get_language,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "appids",
                |m: &CPlayer_GetAchievementsProgress_Request| { &m.appids },
                |m: &mut CPlayer_GetAchievementsProgress_Request| { &mut m.appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetAchievementsProgress_Request>(
                "CPlayer_GetAchievementsProgress_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAchievementsProgress_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetAchievementsProgress_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetAchievementsProgress_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAchievementsProgress_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.language.clear();
        self.appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAchievementsProgress_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAchievementsProgress_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetAchievementsProgress_Response {
    // message fields
    pub achievement_progress: ::protobuf::RepeatedField<cplayer_get_achievements_progress_response::AchievementProgress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetAchievementsProgress_Response {
    fn default() -> &'a CPlayer_GetAchievementsProgress_Response {
        <CPlayer_GetAchievementsProgress_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetAchievementsProgress_Response {
    pub fn new() -> CPlayer_GetAchievementsProgress_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetAchievementsProgress_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.achievement_progress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.achievement_progress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.achievement_progress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.achievement_progress {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetAchievementsProgress_Response {
        CPlayer_GetAchievementsProgress_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_achievements_progress_response::AchievementProgress>>(
                "achievement_progress",
                |m: &CPlayer_GetAchievementsProgress_Response| { &m.achievement_progress },
                |m: &mut CPlayer_GetAchievementsProgress_Response| { &mut m.achievement_progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetAchievementsProgress_Response>(
                "CPlayer_GetAchievementsProgress_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetAchievementsProgress_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetAchievementsProgress_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetAchievementsProgress_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetAchievementsProgress_Response {
    fn clear(&mut self) {
        self.achievement_progress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetAchievementsProgress_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetAchievementsProgress_Response {
}

/// Nested message and enums of message `CPlayer_GetAchievementsProgress_Response`
pub mod cplayer_get_achievements_progress_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct AchievementProgress {
        // message fields
        appid: ::std::option::Option<u32>,
        unlocked: ::std::option::Option<u32>,
        total: ::std::option::Option<u32>,
        percentage: ::std::option::Option<f32>,
        all_unlocked: ::std::option::Option<bool>,
        cache_time: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a AchievementProgress {
        fn default() -> &'a AchievementProgress {
            <AchievementProgress as ::protobuf::Message>::default_instance()
        }
    }

    impl AchievementProgress {
        pub fn new() -> AchievementProgress {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn get_appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 unlocked = 2;

        pub fn get_unlocked(&self) -> u32 {
            self.unlocked.unwrap_or(0)
        }

        pub fn clear_unlocked(&mut self) {
            self.unlocked = ::std::option::Option::None;
        }

        pub fn has_unlocked(&self) -> bool {
            self.unlocked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unlocked(&mut self, v: u32) {
            self.unlocked = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 3;

        pub fn get_total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional float percentage = 4;

        pub fn get_percentage(&self) -> f32 {
            self.percentage.unwrap_or(0.)
        }

        pub fn clear_percentage(&mut self) {
            self.percentage = ::std::option::Option::None;
        }

        pub fn has_percentage(&self) -> bool {
            self.percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_percentage(&mut self, v: f32) {
            self.percentage = ::std::option::Option::Some(v);
        }

        // optional bool all_unlocked = 5;

        pub fn get_all_unlocked(&self) -> bool {
            self.all_unlocked.unwrap_or(false)
        }

        pub fn clear_all_unlocked(&mut self) {
            self.all_unlocked = ::std::option::Option::None;
        }

        pub fn has_all_unlocked(&self) -> bool {
            self.all_unlocked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_all_unlocked(&mut self, v: bool) {
            self.all_unlocked = ::std::option::Option::Some(v);
        }

        // optional uint32 cache_time = 6;

        pub fn get_cache_time(&self) -> u32 {
            self.cache_time.unwrap_or(0)
        }

        pub fn clear_cache_time(&mut self) {
            self.cache_time = ::std::option::Option::None;
        }

        pub fn has_cache_time(&self) -> bool {
            self.cache_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cache_time(&mut self, v: u32) {
            self.cache_time = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for AchievementProgress {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.unlocked = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.all_unlocked = ::std::option::Option::Some(is.read_bool()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.cache_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.unlocked {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.total {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.percentage {
                my_size += 5;
            }
            if let Some(v) = self.all_unlocked {
                my_size += 2;
            }
            if let Some(v) = self.cache_time {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.unlocked {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.percentage {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.all_unlocked {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.cache_time {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> AchievementProgress {
            AchievementProgress::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "appid",
                    |m: &AchievementProgress| { &m.appid },
                    |m: &mut AchievementProgress| { &mut m.appid },
                    AchievementProgress::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "unlocked",
                    |m: &AchievementProgress| { &m.unlocked },
                    |m: &mut AchievementProgress| { &mut m.unlocked },
                    AchievementProgress::get_unlocked,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "total",
                    |m: &AchievementProgress| { &m.total },
                    |m: &mut AchievementProgress| { &mut m.total },
                    AchievementProgress::get_total,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                    "percentage",
                    |m: &AchievementProgress| { &m.percentage },
                    |m: &mut AchievementProgress| { &mut m.percentage },
                    AchievementProgress::get_percentage,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                    "all_unlocked",
                    |m: &AchievementProgress| { &m.all_unlocked },
                    |m: &mut AchievementProgress| { &mut m.all_unlocked },
                    AchievementProgress::get_all_unlocked,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "cache_time",
                    |m: &AchievementProgress| { &m.cache_time },
                    |m: &mut AchievementProgress| { &mut m.cache_time },
                    AchievementProgress::get_cache_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AchievementProgress>(
                    "CPlayer_GetAchievementsProgress_Response.AchievementProgress",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static AchievementProgress {
            static instance: ::protobuf::rt::Lazy<AchievementProgress> = ::protobuf::rt::Lazy::INIT;
            instance.get(AchievementProgress::new)
        }
    }

    impl ::protobuf::Clear for AchievementProgress {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.unlocked = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.percentage = ::std::option::Option::None;
            self.all_unlocked = ::std::option::Option::None;
            self.cache_time = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for AchievementProgress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AchievementProgress {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_PostStatusToFriends_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PostStatusToFriends_Request {
    fn default() -> &'a CPlayer_PostStatusToFriends_Request {
        <CPlayer_PostStatusToFriends_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PostStatusToFriends_Request {
    pub fn new() -> CPlayer_PostStatusToFriends_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 2;

    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CPlayer_PostStatusToFriends_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status_text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PostStatusToFriends_Request {
        CPlayer_PostStatusToFriends_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPlayer_PostStatusToFriends_Request| { &m.appid },
                |m: &mut CPlayer_PostStatusToFriends_Request| { &mut m.appid },
                CPlayer_PostStatusToFriends_Request::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "status_text",
                |m: &CPlayer_PostStatusToFriends_Request| { &m.status_text },
                |m: &mut CPlayer_PostStatusToFriends_Request| { &mut m.status_text },
                CPlayer_PostStatusToFriends_Request::get_status_text,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PostStatusToFriends_Request>(
                "CPlayer_PostStatusToFriends_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PostStatusToFriends_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_PostStatusToFriends_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_PostStatusToFriends_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_PostStatusToFriends_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.status_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PostStatusToFriends_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PostStatusToFriends_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_PostStatusToFriends_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PostStatusToFriends_Response {
    fn default() -> &'a CPlayer_PostStatusToFriends_Response {
        <CPlayer_PostStatusToFriends_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PostStatusToFriends_Response {
    pub fn new() -> CPlayer_PostStatusToFriends_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_PostStatusToFriends_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PostStatusToFriends_Response {
        CPlayer_PostStatusToFriends_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PostStatusToFriends_Response>(
                "CPlayer_PostStatusToFriends_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PostStatusToFriends_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_PostStatusToFriends_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_PostStatusToFriends_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_PostStatusToFriends_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PostStatusToFriends_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PostStatusToFriends_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetPostedStatus_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    postid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPostedStatus_Request {
    fn default() -> &'a CPlayer_GetPostedStatus_Request {
        <CPlayer_GetPostedStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPostedStatus_Request {
    pub fn new() -> CPlayer_GetPostedStatus_Request {
        ::std::default::Default::default()
    }

    // optional uint64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 postid = 2;

    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }

    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetPostedStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.postid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.postid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPostedStatus_Request {
        CPlayer_GetPostedStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "steamid",
                |m: &CPlayer_GetPostedStatus_Request| { &m.steamid },
                |m: &mut CPlayer_GetPostedStatus_Request| { &mut m.steamid },
                CPlayer_GetPostedStatus_Request::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "postid",
                |m: &CPlayer_GetPostedStatus_Request| { &m.postid },
                |m: &mut CPlayer_GetPostedStatus_Request| { &mut m.postid },
                CPlayer_GetPostedStatus_Request::get_postid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPostedStatus_Request>(
                "CPlayer_GetPostedStatus_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPostedStatus_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetPostedStatus_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetPostedStatus_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPostedStatus_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.postid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPostedStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPostedStatus_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetPostedStatus_Response {
    // message fields
    accountid: ::std::option::Option<u32>,
    postid: ::std::option::Option<u64>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    deleted: ::std::option::Option<bool>,
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPostedStatus_Response {
    fn default() -> &'a CPlayer_GetPostedStatus_Response {
        <CPlayer_GetPostedStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPostedStatus_Response {
    pub fn new() -> CPlayer_GetPostedStatus_Response {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 postid = 2;

    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }

    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;

    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool deleted = 4;

    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 5;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetPostedStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.postid = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.postid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.status_text.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPostedStatus_Response {
        CPlayer_GetPostedStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "accountid",
                |m: &CPlayer_GetPostedStatus_Response| { &m.accountid },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.accountid },
                CPlayer_GetPostedStatus_Response::get_accountid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "postid",
                |m: &CPlayer_GetPostedStatus_Response| { &m.postid },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.postid },
                CPlayer_GetPostedStatus_Response::get_postid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "status_text",
                |m: &CPlayer_GetPostedStatus_Response| { &m.status_text },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.status_text },
                CPlayer_GetPostedStatus_Response::get_status_text,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "deleted",
                |m: &CPlayer_GetPostedStatus_Response| { &m.deleted },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.deleted },
                CPlayer_GetPostedStatus_Response::get_deleted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPlayer_GetPostedStatus_Response| { &m.appid },
                |m: &mut CPlayer_GetPostedStatus_Response| { &mut m.appid },
                CPlayer_GetPostedStatus_Response::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPostedStatus_Response>(
                "CPlayer_GetPostedStatus_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPostedStatus_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetPostedStatus_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetPostedStatus_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPostedStatus_Response {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.postid = ::std::option::Option::None;
        self.status_text.clear();
        self.deleted = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPostedStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPostedStatus_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_DeletePostedStatus_Request {
    // message fields
    postid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_DeletePostedStatus_Request {
    fn default() -> &'a CPlayer_DeletePostedStatus_Request {
        <CPlayer_DeletePostedStatus_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_DeletePostedStatus_Request {
    pub fn new() -> CPlayer_DeletePostedStatus_Request {
        ::std::default::Default::default()
    }

    // optional uint64 postid = 1;

    pub fn get_postid(&self) -> u64 {
        self.postid.unwrap_or(0)
    }

    pub fn clear_postid(&mut self) {
        self.postid = ::std::option::Option::None;
    }

    pub fn has_postid(&self) -> bool {
        self.postid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postid(&mut self, v: u64) {
        self.postid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_DeletePostedStatus_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.postid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.postid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.postid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_DeletePostedStatus_Request {
        CPlayer_DeletePostedStatus_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "postid",
                |m: &CPlayer_DeletePostedStatus_Request| { &m.postid },
                |m: &mut CPlayer_DeletePostedStatus_Request| { &mut m.postid },
                CPlayer_DeletePostedStatus_Request::get_postid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_DeletePostedStatus_Request>(
                "CPlayer_DeletePostedStatus_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_DeletePostedStatus_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_DeletePostedStatus_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_DeletePostedStatus_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_DeletePostedStatus_Request {
    fn clear(&mut self) {
        self.postid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_DeletePostedStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_DeletePostedStatus_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_DeletePostedStatus_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_DeletePostedStatus_Response {
    fn default() -> &'a CPlayer_DeletePostedStatus_Response {
        <CPlayer_DeletePostedStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_DeletePostedStatus_Response {
    pub fn new() -> CPlayer_DeletePostedStatus_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_DeletePostedStatus_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_DeletePostedStatus_Response {
        CPlayer_DeletePostedStatus_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_DeletePostedStatus_Response>(
                "CPlayer_DeletePostedStatus_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_DeletePostedStatus_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_DeletePostedStatus_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_DeletePostedStatus_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_DeletePostedStatus_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_DeletePostedStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_DeletePostedStatus_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetLastPlayedTimes_Request {
    // message fields
    min_last_played: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Request {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Request {
        <CPlayer_GetLastPlayedTimes_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Request {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Request {
        ::std::default::Default::default()
    }

    // optional uint32 min_last_played = 1;

    pub fn get_min_last_played(&self) -> u32 {
        self.min_last_played.unwrap_or(0)
    }

    pub fn clear_min_last_played(&mut self) {
        self.min_last_played = ::std::option::Option::None;
    }

    pub fn has_min_last_played(&self) -> bool {
        self.min_last_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_last_played(&mut self, v: u32) {
        self.min_last_played = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.min_last_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.min_last_played {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.min_last_played {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Request {
        CPlayer_GetLastPlayedTimes_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "min_last_played",
                |m: &CPlayer_GetLastPlayedTimes_Request| { &m.min_last_played },
                |m: &mut CPlayer_GetLastPlayedTimes_Request| { &mut m.min_last_played },
                CPlayer_GetLastPlayedTimes_Request::get_min_last_played,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetLastPlayedTimes_Request>(
                "CPlayer_GetLastPlayedTimes_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetLastPlayedTimes_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetLastPlayedTimes_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Request {
    fn clear(&mut self) {
        self.min_last_played = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetLastPlayedTimes_Response {
    // message fields
    pub games: ::protobuf::RepeatedField<cplayer_get_last_played_times_response::Game>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetLastPlayedTimes_Response {
    fn default() -> &'a CPlayer_GetLastPlayedTimes_Response {
        <CPlayer_GetLastPlayedTimes_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetLastPlayedTimes_Response {
    pub fn new() -> CPlayer_GetLastPlayedTimes_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetLastPlayedTimes_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetLastPlayedTimes_Response {
        CPlayer_GetLastPlayedTimes_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_last_played_times_response::Game>>(
                "games",
                |m: &CPlayer_GetLastPlayedTimes_Response| { &m.games },
                |m: &mut CPlayer_GetLastPlayedTimes_Response| { &mut m.games },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetLastPlayedTimes_Response>(
                "CPlayer_GetLastPlayedTimes_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetLastPlayedTimes_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetLastPlayedTimes_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetLastPlayedTimes_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetLastPlayedTimes_Response {
    fn clear(&mut self) {
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetLastPlayedTimes_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetLastPlayedTimes_Response {
}

/// Nested message and enums of message `CPlayer_GetLastPlayedTimes_Response`
pub mod cplayer_get_last_played_times_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct Game {
        // message fields
        appid: ::std::option::Option<i32>,
        last_playtime: ::std::option::Option<u32>,
        playtime_2weeks: ::std::option::Option<i32>,
        playtime_forever: ::std::option::Option<i32>,
        first_playtime: ::std::option::Option<u32>,
        playtime_windows_forever: ::std::option::Option<i32>,
        playtime_mac_forever: ::std::option::Option<i32>,
        playtime_linux_forever: ::std::option::Option<i32>,
        first_windows_playtime: ::std::option::Option<u32>,
        first_mac_playtime: ::std::option::Option<u32>,
        first_linux_playtime: ::std::option::Option<u32>,
        last_windows_playtime: ::std::option::Option<u32>,
        last_mac_playtime: ::std::option::Option<u32>,
        last_linux_playtime: ::std::option::Option<u32>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Game {
        fn default() -> &'a Game {
            <Game as ::protobuf::Message>::default_instance()
        }
    }

    impl Game {
        pub fn new() -> Game {
            ::std::default::Default::default()
        }

        // optional int32 appid = 1;

        pub fn get_appid(&self) -> i32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: i32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 last_playtime = 2;

        pub fn get_last_playtime(&self) -> u32 {
            self.last_playtime.unwrap_or(0)
        }

        pub fn clear_last_playtime(&mut self) {
            self.last_playtime = ::std::option::Option::None;
        }

        pub fn has_last_playtime(&self) -> bool {
            self.last_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_playtime(&mut self, v: u32) {
            self.last_playtime = ::std::option::Option::Some(v);
        }

        // optional int32 playtime_2weeks = 3;

        pub fn get_playtime_2weeks(&self) -> i32 {
            self.playtime_2weeks.unwrap_or(0)
        }

        pub fn clear_playtime_2weeks(&mut self) {
            self.playtime_2weeks = ::std::option::Option::None;
        }

        pub fn has_playtime_2weeks(&self) -> bool {
            self.playtime_2weeks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime_2weeks(&mut self, v: i32) {
            self.playtime_2weeks = ::std::option::Option::Some(v);
        }

        // optional int32 playtime_forever = 4;

        pub fn get_playtime_forever(&self) -> i32 {
            self.playtime_forever.unwrap_or(0)
        }

        pub fn clear_playtime_forever(&mut self) {
            self.playtime_forever = ::std::option::Option::None;
        }

        pub fn has_playtime_forever(&self) -> bool {
            self.playtime_forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime_forever(&mut self, v: i32) {
            self.playtime_forever = ::std::option::Option::Some(v);
        }

        // optional uint32 first_playtime = 5;

        pub fn get_first_playtime(&self) -> u32 {
            self.first_playtime.unwrap_or(0)
        }

        pub fn clear_first_playtime(&mut self) {
            self.first_playtime = ::std::option::Option::None;
        }

        pub fn has_first_playtime(&self) -> bool {
            self.first_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_playtime(&mut self, v: u32) {
            self.first_playtime = ::std::option::Option::Some(v);
        }

        // optional int32 playtime_windows_forever = 6;

        pub fn get_playtime_windows_forever(&self) -> i32 {
            self.playtime_windows_forever.unwrap_or(0)
        }

        pub fn clear_playtime_windows_forever(&mut self) {
            self.playtime_windows_forever = ::std::option::Option::None;
        }

        pub fn has_playtime_windows_forever(&self) -> bool {
            self.playtime_windows_forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime_windows_forever(&mut self, v: i32) {
            self.playtime_windows_forever = ::std::option::Option::Some(v);
        }

        // optional int32 playtime_mac_forever = 7;

        pub fn get_playtime_mac_forever(&self) -> i32 {
            self.playtime_mac_forever.unwrap_or(0)
        }

        pub fn clear_playtime_mac_forever(&mut self) {
            self.playtime_mac_forever = ::std::option::Option::None;
        }

        pub fn has_playtime_mac_forever(&self) -> bool {
            self.playtime_mac_forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime_mac_forever(&mut self, v: i32) {
            self.playtime_mac_forever = ::std::option::Option::Some(v);
        }

        // optional int32 playtime_linux_forever = 8;

        pub fn get_playtime_linux_forever(&self) -> i32 {
            self.playtime_linux_forever.unwrap_or(0)
        }

        pub fn clear_playtime_linux_forever(&mut self) {
            self.playtime_linux_forever = ::std::option::Option::None;
        }

        pub fn has_playtime_linux_forever(&self) -> bool {
            self.playtime_linux_forever.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime_linux_forever(&mut self, v: i32) {
            self.playtime_linux_forever = ::std::option::Option::Some(v);
        }

        // optional uint32 first_windows_playtime = 9;

        pub fn get_first_windows_playtime(&self) -> u32 {
            self.first_windows_playtime.unwrap_or(0)
        }

        pub fn clear_first_windows_playtime(&mut self) {
            self.first_windows_playtime = ::std::option::Option::None;
        }

        pub fn has_first_windows_playtime(&self) -> bool {
            self.first_windows_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_windows_playtime(&mut self, v: u32) {
            self.first_windows_playtime = ::std::option::Option::Some(v);
        }

        // optional uint32 first_mac_playtime = 10;

        pub fn get_first_mac_playtime(&self) -> u32 {
            self.first_mac_playtime.unwrap_or(0)
        }

        pub fn clear_first_mac_playtime(&mut self) {
            self.first_mac_playtime = ::std::option::Option::None;
        }

        pub fn has_first_mac_playtime(&self) -> bool {
            self.first_mac_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_mac_playtime(&mut self, v: u32) {
            self.first_mac_playtime = ::std::option::Option::Some(v);
        }

        // optional uint32 first_linux_playtime = 11;

        pub fn get_first_linux_playtime(&self) -> u32 {
            self.first_linux_playtime.unwrap_or(0)
        }

        pub fn clear_first_linux_playtime(&mut self) {
            self.first_linux_playtime = ::std::option::Option::None;
        }

        pub fn has_first_linux_playtime(&self) -> bool {
            self.first_linux_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_linux_playtime(&mut self, v: u32) {
            self.first_linux_playtime = ::std::option::Option::Some(v);
        }

        // optional uint32 last_windows_playtime = 12;

        pub fn get_last_windows_playtime(&self) -> u32 {
            self.last_windows_playtime.unwrap_or(0)
        }

        pub fn clear_last_windows_playtime(&mut self) {
            self.last_windows_playtime = ::std::option::Option::None;
        }

        pub fn has_last_windows_playtime(&self) -> bool {
            self.last_windows_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_windows_playtime(&mut self, v: u32) {
            self.last_windows_playtime = ::std::option::Option::Some(v);
        }

        // optional uint32 last_mac_playtime = 13;

        pub fn get_last_mac_playtime(&self) -> u32 {
            self.last_mac_playtime.unwrap_or(0)
        }

        pub fn clear_last_mac_playtime(&mut self) {
            self.last_mac_playtime = ::std::option::Option::None;
        }

        pub fn has_last_mac_playtime(&self) -> bool {
            self.last_mac_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_mac_playtime(&mut self, v: u32) {
            self.last_mac_playtime = ::std::option::Option::Some(v);
        }

        // optional uint32 last_linux_playtime = 14;

        pub fn get_last_linux_playtime(&self) -> u32 {
            self.last_linux_playtime.unwrap_or(0)
        }

        pub fn clear_last_linux_playtime(&mut self) {
            self.last_linux_playtime = ::std::option::Option::None;
        }

        pub fn has_last_linux_playtime(&self) -> bool {
            self.last_linux_playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_linux_playtime(&mut self, v: u32) {
            self.last_linux_playtime = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Game {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.appid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.playtime_2weeks = ::std::option::Option::Some(is.read_int32()?);
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.playtime_forever = ::std::option::Option::Some(is.read_int32()?);
                    },
                    5 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.first_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    6 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.playtime_windows_forever = ::std::option::Option::Some(is.read_int32()?);
                    },
                    7 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.playtime_mac_forever = ::std::option::Option::Some(is.read_int32()?);
                    },
                    8 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.playtime_linux_forever = ::std::option::Option::Some(is.read_int32()?);
                    },
                    9 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.first_windows_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    10 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.first_mac_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    11 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.first_linux_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    12 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_windows_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    13 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_mac_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    14 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.last_linux_playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.last_playtime {
                my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.playtime_2weeks {
                my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.playtime_forever {
                my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.first_playtime {
                my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.playtime_windows_forever {
                my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.playtime_mac_forever {
                my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.playtime_linux_forever {
                my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.first_windows_playtime {
                my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.first_mac_playtime {
                my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.first_linux_playtime {
                my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.last_windows_playtime {
                my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.last_mac_playtime {
                my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
            }
            if let Some(v) = self.last_linux_playtime {
                my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.appid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.last_playtime {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.playtime_2weeks {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.playtime_forever {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.first_playtime {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.playtime_windows_forever {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.playtime_mac_forever {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.playtime_linux_forever {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.first_windows_playtime {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.first_mac_playtime {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.first_linux_playtime {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.last_windows_playtime {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.last_mac_playtime {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.last_linux_playtime {
                os.write_uint32(14, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Game {
            Game::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "appid",
                    |m: &Game| { &m.appid },
                    |m: &mut Game| { &mut m.appid },
                    Game::get_appid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_playtime",
                    |m: &Game| { &m.last_playtime },
                    |m: &mut Game| { &mut m.last_playtime },
                    Game::get_last_playtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "playtime_2weeks",
                    |m: &Game| { &m.playtime_2weeks },
                    |m: &mut Game| { &mut m.playtime_2weeks },
                    Game::get_playtime_2weeks,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "playtime_forever",
                    |m: &Game| { &m.playtime_forever },
                    |m: &mut Game| { &mut m.playtime_forever },
                    Game::get_playtime_forever,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "first_playtime",
                    |m: &Game| { &m.first_playtime },
                    |m: &mut Game| { &mut m.first_playtime },
                    Game::get_first_playtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "playtime_windows_forever",
                    |m: &Game| { &m.playtime_windows_forever },
                    |m: &mut Game| { &mut m.playtime_windows_forever },
                    Game::get_playtime_windows_forever,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "playtime_mac_forever",
                    |m: &Game| { &m.playtime_mac_forever },
                    |m: &mut Game| { &mut m.playtime_mac_forever },
                    Game::get_playtime_mac_forever,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                    "playtime_linux_forever",
                    |m: &Game| { &m.playtime_linux_forever },
                    |m: &mut Game| { &mut m.playtime_linux_forever },
                    Game::get_playtime_linux_forever,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "first_windows_playtime",
                    |m: &Game| { &m.first_windows_playtime },
                    |m: &mut Game| { &mut m.first_windows_playtime },
                    Game::get_first_windows_playtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "first_mac_playtime",
                    |m: &Game| { &m.first_mac_playtime },
                    |m: &mut Game| { &mut m.first_mac_playtime },
                    Game::get_first_mac_playtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "first_linux_playtime",
                    |m: &Game| { &m.first_linux_playtime },
                    |m: &mut Game| { &mut m.first_linux_playtime },
                    Game::get_first_linux_playtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_windows_playtime",
                    |m: &Game| { &m.last_windows_playtime },
                    |m: &mut Game| { &mut m.last_windows_playtime },
                    Game::get_last_windows_playtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_mac_playtime",
                    |m: &Game| { &m.last_mac_playtime },
                    |m: &mut Game| { &mut m.last_mac_playtime },
                    Game::get_last_mac_playtime,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                    "last_linux_playtime",
                    |m: &Game| { &m.last_linux_playtime },
                    |m: &mut Game| { &mut m.last_linux_playtime },
                    Game::get_last_linux_playtime,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Game>(
                    "CPlayer_GetLastPlayedTimes_Response.Game",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Game {
            static instance: ::protobuf::rt::Lazy<Game> = ::protobuf::rt::Lazy::INIT;
            instance.get(Game::new)
        }
    }

    impl ::protobuf::Clear for Game {
        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.last_playtime = ::std::option::Option::None;
            self.playtime_2weeks = ::std::option::Option::None;
            self.playtime_forever = ::std::option::Option::None;
            self.first_playtime = ::std::option::Option::None;
            self.playtime_windows_forever = ::std::option::Option::None;
            self.playtime_mac_forever = ::std::option::Option::None;
            self.playtime_linux_forever = ::std::option::Option::None;
            self.first_windows_playtime = ::std::option::Option::None;
            self.first_mac_playtime = ::std::option::Option::None;
            self.first_linux_playtime = ::std::option::Option::None;
            self.last_windows_playtime = ::std::option::Option::None;
            self.last_mac_playtime = ::std::option::Option::None;
            self.last_linux_playtime = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Game {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Game {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_AcceptSSA_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AcceptSSA_Request {
    fn default() -> &'a CPlayer_AcceptSSA_Request {
        <CPlayer_AcceptSSA_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AcceptSSA_Request {
    pub fn new() -> CPlayer_AcceptSSA_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_AcceptSSA_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AcceptSSA_Request {
        CPlayer_AcceptSSA_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AcceptSSA_Request>(
                "CPlayer_AcceptSSA_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AcceptSSA_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_AcceptSSA_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_AcceptSSA_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_AcceptSSA_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AcceptSSA_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AcceptSSA_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_AcceptSSA_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AcceptSSA_Response {
    fn default() -> &'a CPlayer_AcceptSSA_Response {
        <CPlayer_AcceptSSA_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AcceptSSA_Response {
    pub fn new() -> CPlayer_AcceptSSA_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_AcceptSSA_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AcceptSSA_Response {
        CPlayer_AcceptSSA_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AcceptSSA_Response>(
                "CPlayer_AcceptSSA_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AcceptSSA_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_AcceptSSA_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_AcceptSSA_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_AcceptSSA_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AcceptSSA_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AcceptSSA_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetNicknameList_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Request {
    fn default() -> &'a CPlayer_GetNicknameList_Request {
        <CPlayer_GetNicknameList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Request {
    pub fn new() -> CPlayer_GetNicknameList_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Request {
        CPlayer_GetNicknameList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNicknameList_Request>(
                "CPlayer_GetNicknameList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetNicknameList_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetNicknameList_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetNicknameList_Response {
    // message fields
    pub nicknames: ::protobuf::RepeatedField<cplayer_get_nickname_list_response::PlayerNickname>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNicknameList_Response {
    fn default() -> &'a CPlayer_GetNicknameList_Response {
        <CPlayer_GetNicknameList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNicknameList_Response {
    pub fn new() -> CPlayer_GetNicknameList_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetNicknameList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.nicknames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.nicknames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nicknames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nicknames {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNicknameList_Response {
        CPlayer_GetNicknameList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_nickname_list_response::PlayerNickname>>(
                "nicknames",
                |m: &CPlayer_GetNicknameList_Response| { &m.nicknames },
                |m: &mut CPlayer_GetNicknameList_Response| { &mut m.nicknames },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNicknameList_Response>(
                "CPlayer_GetNicknameList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNicknameList_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetNicknameList_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetNicknameList_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNicknameList_Response {
    fn clear(&mut self) {
        self.nicknames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNicknameList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNicknameList_Response {
}

/// Nested message and enums of message `CPlayer_GetNicknameList_Response`
pub mod cplayer_get_nickname_list_response {
    #[derive(PartialEq,Clone,Default)]
    pub struct PlayerNickname {
        // message fields
        accountid: ::std::option::Option<u32>,
        nickname: ::protobuf::SingularField<::std::string::String>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a PlayerNickname {
        fn default() -> &'a PlayerNickname {
            <PlayerNickname as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerNickname {
        pub fn new() -> PlayerNickname {
            ::std::default::Default::default()
        }

        // optional fixed32 accountid = 1;

        pub fn get_accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional string nickname = 2;

        pub fn get_nickname(&self) -> &str {
            match self.nickname.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_nickname(&mut self) {
            self.nickname.clear();
        }

        pub fn has_nickname(&self) -> bool {
            self.nickname.is_some()
        }

        // Param is passed by value, moved
        pub fn set_nickname(&mut self, v: ::std::string::String) {
            self.nickname = ::protobuf::SingularField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
            if self.nickname.is_none() {
                self.nickname.set_default();
            }
            self.nickname.as_mut().unwrap()
        }

        // Take field
        pub fn take_nickname(&mut self) -> ::std::string::String {
            self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for PlayerNickname {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.accountid = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    2 => {
                        ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += 5;
            }
            if let Some(v) = self.nickname.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let Some(v) = self.accountid {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.nickname.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> PlayerNickname {
            PlayerNickname::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                    "accountid",
                    |m: &PlayerNickname| { &m.accountid },
                    |m: &mut PlayerNickname| { &mut m.accountid },
                    PlayerNickname::get_accountid,
                ));
                fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                    "nickname",
                    |m: &PlayerNickname| { &m.nickname },
                    |m: &mut PlayerNickname| { &mut m.nickname },
                    PlayerNickname::get_nickname,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlayerNickname>(
                    "CPlayer_GetNicknameList_Response.PlayerNickname",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static PlayerNickname {
            static instance: ::protobuf::rt::Lazy<PlayerNickname> = ::protobuf::rt::Lazy::INIT;
            instance.get(PlayerNickname::new)
        }
    }

    impl ::protobuf::Clear for PlayerNickname {
        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.nickname.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for PlayerNickname {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerNickname {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetPerFriendPreferences_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPerFriendPreferences_Request {
    fn default() -> &'a CPlayer_GetPerFriendPreferences_Request {
        <CPlayer_GetPerFriendPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPerFriendPreferences_Request {
    pub fn new() -> CPlayer_GetPerFriendPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPerFriendPreferences_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPerFriendPreferences_Request {
        CPlayer_GetPerFriendPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPerFriendPreferences_Request>(
                "CPlayer_GetPerFriendPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPerFriendPreferences_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetPerFriendPreferences_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetPerFriendPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPerFriendPreferences_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPerFriendPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPerFriendPreferences_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct PerFriendPreferences {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    notifications_showingame: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ENotificationSetting>>,
    notifications_showonline: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ENotificationSetting>>,
    notifications_showmessages: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ENotificationSetting>>,
    sounds_showingame: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ENotificationSetting>>,
    sounds_showonline: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ENotificationSetting>>,
    sounds_showmessages: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ENotificationSetting>>,
    notifications_sendmobile: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ENotificationSetting>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerFriendPreferences {
    fn default() -> &'a PerFriendPreferences {
        <PerFriendPreferences as ::protobuf::Message>::default_instance()
    }
}

impl PerFriendPreferences {
    pub fn new() -> PerFriendPreferences {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;

    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ENotificationSetting notifications_showingame = 3;

    pub fn get_notifications_showingame(&self) -> ENotificationSetting {
        match self.notifications_showingame {
            Some(e) => e.enum_value_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            None => ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
        }
    }

    pub fn clear_notifications_showingame(&mut self) {
        self.notifications_showingame = ::std::option::Option::None;
    }

    pub fn has_notifications_showingame(&self) -> bool {
        self.notifications_showingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showingame(&mut self, v: ENotificationSetting) {
        self.notifications_showingame = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .ENotificationSetting notifications_showonline = 4;

    pub fn get_notifications_showonline(&self) -> ENotificationSetting {
        match self.notifications_showonline {
            Some(e) => e.enum_value_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            None => ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
        }
    }

    pub fn clear_notifications_showonline(&mut self) {
        self.notifications_showonline = ::std::option::Option::None;
    }

    pub fn has_notifications_showonline(&self) -> bool {
        self.notifications_showonline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showonline(&mut self, v: ENotificationSetting) {
        self.notifications_showonline = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .ENotificationSetting notifications_showmessages = 5;

    pub fn get_notifications_showmessages(&self) -> ENotificationSetting {
        match self.notifications_showmessages {
            Some(e) => e.enum_value_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            None => ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
        }
    }

    pub fn clear_notifications_showmessages(&mut self) {
        self.notifications_showmessages = ::std::option::Option::None;
    }

    pub fn has_notifications_showmessages(&self) -> bool {
        self.notifications_showmessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_showmessages(&mut self, v: ENotificationSetting) {
        self.notifications_showmessages = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .ENotificationSetting sounds_showingame = 6;

    pub fn get_sounds_showingame(&self) -> ENotificationSetting {
        match self.sounds_showingame {
            Some(e) => e.enum_value_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            None => ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
        }
    }

    pub fn clear_sounds_showingame(&mut self) {
        self.sounds_showingame = ::std::option::Option::None;
    }

    pub fn has_sounds_showingame(&self) -> bool {
        self.sounds_showingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showingame(&mut self, v: ENotificationSetting) {
        self.sounds_showingame = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .ENotificationSetting sounds_showonline = 7;

    pub fn get_sounds_showonline(&self) -> ENotificationSetting {
        match self.sounds_showonline {
            Some(e) => e.enum_value_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            None => ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
        }
    }

    pub fn clear_sounds_showonline(&mut self) {
        self.sounds_showonline = ::std::option::Option::None;
    }

    pub fn has_sounds_showonline(&self) -> bool {
        self.sounds_showonline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showonline(&mut self, v: ENotificationSetting) {
        self.sounds_showonline = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .ENotificationSetting sounds_showmessages = 8;

    pub fn get_sounds_showmessages(&self) -> ENotificationSetting {
        match self.sounds_showmessages {
            Some(e) => e.enum_value_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            None => ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
        }
    }

    pub fn clear_sounds_showmessages(&mut self) {
        self.sounds_showmessages = ::std::option::Option::None;
    }

    pub fn has_sounds_showmessages(&self) -> bool {
        self.sounds_showmessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sounds_showmessages(&mut self, v: ENotificationSetting) {
        self.sounds_showmessages = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .ENotificationSetting notifications_sendmobile = 9;

    pub fn get_notifications_sendmobile(&self) -> ENotificationSetting {
        match self.notifications_sendmobile {
            Some(e) => e.enum_value_or(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            None => ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
        }
    }

    pub fn clear_notifications_sendmobile(&mut self) {
        self.notifications_sendmobile = ::std::option::Option::None;
    }

    pub fn has_notifications_sendmobile(&self) -> bool {
        self.notifications_sendmobile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifications_sendmobile(&mut self, v: ENotificationSetting) {
        self.notifications_sendmobile = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for PerFriendPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.accountid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.notifications_showingame = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.notifications_showonline = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.notifications_showmessages = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sounds_showingame = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sounds_showonline = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sounds_showmessages = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.notifications_sendmobile = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.notifications_showingame {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
        }
        if let Some(v) = self.notifications_showonline {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, v);
        }
        if let Some(v) = self.notifications_showmessages {
            my_size += ::protobuf::rt::enum_or_unknown_size(5, v);
        }
        if let Some(v) = self.sounds_showingame {
            my_size += ::protobuf::rt::enum_or_unknown_size(6, v);
        }
        if let Some(v) = self.sounds_showonline {
            my_size += ::protobuf::rt::enum_or_unknown_size(7, v);
        }
        if let Some(v) = self.sounds_showmessages {
            my_size += ::protobuf::rt::enum_or_unknown_size(8, v);
        }
        if let Some(v) = self.notifications_sendmobile {
            my_size += ::protobuf::rt::enum_or_unknown_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.notifications_showingame {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.notifications_showonline {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.notifications_showmessages {
            os.write_enum(5, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sounds_showingame {
            os.write_enum(6, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sounds_showonline {
            os.write_enum(7, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sounds_showmessages {
            os.write_enum(8, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.notifications_sendmobile {
            os.write_enum(9, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerFriendPreferences {
        PerFriendPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "accountid",
                |m: &PerFriendPreferences| { &m.accountid },
                |m: &mut PerFriendPreferences| { &mut m.accountid },
                PerFriendPreferences::get_accountid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "nickname",
                |m: &PerFriendPreferences| { &m.nickname },
                |m: &mut PerFriendPreferences| { &mut m.nickname },
                PerFriendPreferences::get_nickname,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ENotificationSetting>(
                "notifications_showingame",
                |m: &PerFriendPreferences| { &m.notifications_showingame },
                |m: &mut PerFriendPreferences| { &mut m.notifications_showingame },
                ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ENotificationSetting>(
                "notifications_showonline",
                |m: &PerFriendPreferences| { &m.notifications_showonline },
                |m: &mut PerFriendPreferences| { &mut m.notifications_showonline },
                ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ENotificationSetting>(
                "notifications_showmessages",
                |m: &PerFriendPreferences| { &m.notifications_showmessages },
                |m: &mut PerFriendPreferences| { &mut m.notifications_showmessages },
                ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ENotificationSetting>(
                "sounds_showingame",
                |m: &PerFriendPreferences| { &m.sounds_showingame },
                |m: &mut PerFriendPreferences| { &mut m.sounds_showingame },
                ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ENotificationSetting>(
                "sounds_showonline",
                |m: &PerFriendPreferences| { &m.sounds_showonline },
                |m: &mut PerFriendPreferences| { &mut m.sounds_showonline },
                ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ENotificationSetting>(
                "sounds_showmessages",
                |m: &PerFriendPreferences| { &m.sounds_showmessages },
                |m: &mut PerFriendPreferences| { &mut m.sounds_showmessages },
                ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ENotificationSetting>(
                "notifications_sendmobile",
                |m: &PerFriendPreferences| { &m.notifications_sendmobile },
                |m: &mut PerFriendPreferences| { &mut m.notifications_sendmobile },
                ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<PerFriendPreferences>(
                "PerFriendPreferences",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PerFriendPreferences {
        static instance: ::protobuf::rt::Lazy<PerFriendPreferences> = ::protobuf::rt::Lazy::INIT;
        instance.get(PerFriendPreferences::new)
    }
}

impl ::protobuf::Clear for PerFriendPreferences {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.notifications_showingame = ::std::option::Option::None;
        self.notifications_showonline = ::std::option::Option::None;
        self.notifications_showmessages = ::std::option::Option::None;
        self.sounds_showingame = ::std::option::Option::None;
        self.sounds_showonline = ::std::option::Option::None;
        self.sounds_showmessages = ::std::option::Option::None;
        self.notifications_sendmobile = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerFriendPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerFriendPreferences {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetPerFriendPreferences_Response {
    // message fields
    pub preferences: ::protobuf::RepeatedField<PerFriendPreferences>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPerFriendPreferences_Response {
    fn default() -> &'a CPlayer_GetPerFriendPreferences_Response {
        <CPlayer_GetPerFriendPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPerFriendPreferences_Response {
    pub fn new() -> CPlayer_GetPerFriendPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPerFriendPreferences_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.preferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.preferences {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPerFriendPreferences_Response {
        CPlayer_GetPerFriendPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<PerFriendPreferences>>(
                "preferences",
                |m: &CPlayer_GetPerFriendPreferences_Response| { &m.preferences },
                |m: &mut CPlayer_GetPerFriendPreferences_Response| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPerFriendPreferences_Response>(
                "CPlayer_GetPerFriendPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPerFriendPreferences_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetPerFriendPreferences_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetPerFriendPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPerFriendPreferences_Response {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPerFriendPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPerFriendPreferences_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_SetPerFriendPreferences_Request {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<PerFriendPreferences>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetPerFriendPreferences_Request {
    fn default() -> &'a CPlayer_SetPerFriendPreferences_Request {
        <CPlayer_SetPerFriendPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetPerFriendPreferences_Request {
    pub fn new() -> CPlayer_SetPerFriendPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetPerFriendPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<PerFriendPreferences, _>(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetPerFriendPreferences_Request {
        CPlayer_SetPerFriendPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<PerFriendPreferences>, _>(
                "preferences",
                |m: &CPlayer_SetPerFriendPreferences_Request| { &m.preferences },
                |m: &mut CPlayer_SetPerFriendPreferences_Request| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetPerFriendPreferences_Request>(
                "CPlayer_SetPerFriendPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetPerFriendPreferences_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_SetPerFriendPreferences_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_SetPerFriendPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetPerFriendPreferences_Request {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetPerFriendPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetPerFriendPreferences_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_SetPerFriendPreferences_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetPerFriendPreferences_Response {
    fn default() -> &'a CPlayer_SetPerFriendPreferences_Response {
        <CPlayer_SetPerFriendPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetPerFriendPreferences_Response {
    pub fn new() -> CPlayer_SetPerFriendPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetPerFriendPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetPerFriendPreferences_Response {
        CPlayer_SetPerFriendPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetPerFriendPreferences_Response>(
                "CPlayer_SetPerFriendPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetPerFriendPreferences_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_SetPerFriendPreferences_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_SetPerFriendPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetPerFriendPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetPerFriendPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetPerFriendPreferences_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_AddFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AddFriend_Request {
    fn default() -> &'a CPlayer_AddFriend_Request {
        <CPlayer_AddFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AddFriend_Request {
    pub fn new() -> CPlayer_AddFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_AddFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AddFriend_Request {
        CPlayer_AddFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CPlayer_AddFriend_Request| { &m.steamid },
                |m: &mut CPlayer_AddFriend_Request| { &mut m.steamid },
                CPlayer_AddFriend_Request::get_steamid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AddFriend_Request>(
                "CPlayer_AddFriend_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AddFriend_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_AddFriend_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_AddFriend_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_AddFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AddFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AddFriend_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_AddFriend_Response {
    // message fields
    invite_sent: ::std::option::Option<bool>,
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_AddFriend_Response {
    fn default() -> &'a CPlayer_AddFriend_Response {
        <CPlayer_AddFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_AddFriend_Response {
    pub fn new() -> CPlayer_AddFriend_Response {
        ::std::default::Default::default()
    }

    // optional bool invite_sent = 1;

    pub fn get_invite_sent(&self) -> bool {
        self.invite_sent.unwrap_or(false)
    }

    pub fn clear_invite_sent(&mut self) {
        self.invite_sent = ::std::option::Option::None;
    }

    pub fn has_invite_sent(&self) -> bool {
        self.invite_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_sent(&mut self, v: bool) {
        self.invite_sent = ::std::option::Option::Some(v);
    }

    // optional uint32 friend_relationship = 2;

    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }

    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_AddFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.invite_sent = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.friend_relationship = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.invite_sent {
            my_size += 2;
        }
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.invite_sent {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.friend_relationship {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_AddFriend_Response {
        CPlayer_AddFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "invite_sent",
                |m: &CPlayer_AddFriend_Response| { &m.invite_sent },
                |m: &mut CPlayer_AddFriend_Response| { &mut m.invite_sent },
                CPlayer_AddFriend_Response::get_invite_sent,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "friend_relationship",
                |m: &CPlayer_AddFriend_Response| { &m.friend_relationship },
                |m: &mut CPlayer_AddFriend_Response| { &mut m.friend_relationship },
                CPlayer_AddFriend_Response::get_friend_relationship,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_AddFriend_Response>(
                "CPlayer_AddFriend_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_AddFriend_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_AddFriend_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_AddFriend_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_AddFriend_Response {
    fn clear(&mut self) {
        self.invite_sent = ::std::option::Option::None;
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_AddFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_AddFriend_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_RemoveFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_RemoveFriend_Request {
    fn default() -> &'a CPlayer_RemoveFriend_Request {
        <CPlayer_RemoveFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_RemoveFriend_Request {
    pub fn new() -> CPlayer_RemoveFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_RemoveFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_RemoveFriend_Request {
        CPlayer_RemoveFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CPlayer_RemoveFriend_Request| { &m.steamid },
                |m: &mut CPlayer_RemoveFriend_Request| { &mut m.steamid },
                CPlayer_RemoveFriend_Request::get_steamid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_RemoveFriend_Request>(
                "CPlayer_RemoveFriend_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_RemoveFriend_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_RemoveFriend_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_RemoveFriend_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_RemoveFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_RemoveFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_RemoveFriend_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_RemoveFriend_Response {
    // message fields
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_RemoveFriend_Response {
    fn default() -> &'a CPlayer_RemoveFriend_Response {
        <CPlayer_RemoveFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_RemoveFriend_Response {
    pub fn new() -> CPlayer_RemoveFriend_Response {
        ::std::default::Default::default()
    }

    // optional uint32 friend_relationship = 1;

    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }

    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_RemoveFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.friend_relationship = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_relationship {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_RemoveFriend_Response {
        CPlayer_RemoveFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "friend_relationship",
                |m: &CPlayer_RemoveFriend_Response| { &m.friend_relationship },
                |m: &mut CPlayer_RemoveFriend_Response| { &mut m.friend_relationship },
                CPlayer_RemoveFriend_Response::get_friend_relationship,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_RemoveFriend_Response>(
                "CPlayer_RemoveFriend_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_RemoveFriend_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_RemoveFriend_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_RemoveFriend_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_RemoveFriend_Response {
    fn clear(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_RemoveFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_RemoveFriend_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_IgnoreFriend_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    unignore: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IgnoreFriend_Request {
    fn default() -> &'a CPlayer_IgnoreFriend_Request {
        <CPlayer_IgnoreFriend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IgnoreFriend_Request {
    pub fn new() -> CPlayer_IgnoreFriend_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool unignore = 2;

    pub fn get_unignore(&self) -> bool {
        self.unignore.unwrap_or(false)
    }

    pub fn clear_unignore(&mut self) {
        self.unignore = ::std::option::Option::None;
    }

    pub fn has_unignore(&self) -> bool {
        self.unignore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unignore(&mut self, v: bool) {
        self.unignore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_IgnoreFriend_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.unignore = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.unignore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unignore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IgnoreFriend_Request {
        CPlayer_IgnoreFriend_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed64, _>(
                "steamid",
                |m: &CPlayer_IgnoreFriend_Request| { &m.steamid },
                |m: &mut CPlayer_IgnoreFriend_Request| { &mut m.steamid },
                CPlayer_IgnoreFriend_Request::get_steamid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "unignore",
                |m: &CPlayer_IgnoreFriend_Request| { &m.unignore },
                |m: &mut CPlayer_IgnoreFriend_Request| { &mut m.unignore },
                CPlayer_IgnoreFriend_Request::get_unignore,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_IgnoreFriend_Request>(
                "CPlayer_IgnoreFriend_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_IgnoreFriend_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_IgnoreFriend_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_IgnoreFriend_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_IgnoreFriend_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unignore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IgnoreFriend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IgnoreFriend_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_IgnoreFriend_Response {
    // message fields
    friend_relationship: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_IgnoreFriend_Response {
    fn default() -> &'a CPlayer_IgnoreFriend_Response {
        <CPlayer_IgnoreFriend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_IgnoreFriend_Response {
    pub fn new() -> CPlayer_IgnoreFriend_Response {
        ::std::default::Default::default()
    }

    // optional uint32 friend_relationship = 1;

    pub fn get_friend_relationship(&self) -> u32 {
        self.friend_relationship.unwrap_or(0)
    }

    pub fn clear_friend_relationship(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
    }

    pub fn has_friend_relationship(&self) -> bool {
        self.friend_relationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_relationship(&mut self, v: u32) {
        self.friend_relationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_IgnoreFriend_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.friend_relationship = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_relationship {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_relationship {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_IgnoreFriend_Response {
        CPlayer_IgnoreFriend_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "friend_relationship",
                |m: &CPlayer_IgnoreFriend_Response| { &m.friend_relationship },
                |m: &mut CPlayer_IgnoreFriend_Response| { &mut m.friend_relationship },
                CPlayer_IgnoreFriend_Response::get_friend_relationship,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_IgnoreFriend_Response>(
                "CPlayer_IgnoreFriend_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_IgnoreFriend_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_IgnoreFriend_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_IgnoreFriend_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_IgnoreFriend_Response {
    fn clear(&mut self) {
        self.friend_relationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_IgnoreFriend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_IgnoreFriend_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetCommunityPreferences_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetCommunityPreferences_Request {
    fn default() -> &'a CPlayer_GetCommunityPreferences_Request {
        <CPlayer_GetCommunityPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetCommunityPreferences_Request {
    pub fn new() -> CPlayer_GetCommunityPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetCommunityPreferences_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetCommunityPreferences_Request {
        CPlayer_GetCommunityPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetCommunityPreferences_Request>(
                "CPlayer_GetCommunityPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetCommunityPreferences_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetCommunityPreferences_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetCommunityPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetCommunityPreferences_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetCommunityPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetCommunityPreferences_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_CommunityPreferences {
    // message fields
    hide_adult_content_violence: ::std::option::Option<bool>,
    hide_adult_content_sex: ::std::option::Option<bool>,
    parenthesize_nicknames: ::std::option::Option<bool>,
    timestamp_updated: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_CommunityPreferences {
    fn default() -> &'a CPlayer_CommunityPreferences {
        <CPlayer_CommunityPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_CommunityPreferences {
    pub fn new() -> CPlayer_CommunityPreferences {
        ::std::default::Default::default()
    }

    // optional bool hide_adult_content_violence = 1;

    pub fn get_hide_adult_content_violence(&self) -> bool {
        self.hide_adult_content_violence.unwrap_or(true)
    }

    pub fn clear_hide_adult_content_violence(&mut self) {
        self.hide_adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_hide_adult_content_violence(&self) -> bool {
        self.hide_adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_adult_content_violence(&mut self, v: bool) {
        self.hide_adult_content_violence = ::std::option::Option::Some(v);
    }

    // optional bool hide_adult_content_sex = 2;

    pub fn get_hide_adult_content_sex(&self) -> bool {
        self.hide_adult_content_sex.unwrap_or(true)
    }

    pub fn clear_hide_adult_content_sex(&mut self) {
        self.hide_adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_hide_adult_content_sex(&self) -> bool {
        self.hide_adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide_adult_content_sex(&mut self, v: bool) {
        self.hide_adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional bool parenthesize_nicknames = 4;

    pub fn get_parenthesize_nicknames(&self) -> bool {
        self.parenthesize_nicknames.unwrap_or(false)
    }

    pub fn clear_parenthesize_nicknames(&mut self) {
        self.parenthesize_nicknames = ::std::option::Option::None;
    }

    pub fn has_parenthesize_nicknames(&self) -> bool {
        self.parenthesize_nicknames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parenthesize_nicknames(&mut self, v: bool) {
        self.parenthesize_nicknames = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 3;

    pub fn get_timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_CommunityPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hide_adult_content_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hide_adult_content_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parenthesize_nicknames = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hide_adult_content_violence {
            my_size += 2;
        }
        if let Some(v) = self.hide_adult_content_sex {
            my_size += 2;
        }
        if let Some(v) = self.parenthesize_nicknames {
            my_size += 2;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hide_adult_content_violence {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.hide_adult_content_sex {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.parenthesize_nicknames {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_CommunityPreferences {
        CPlayer_CommunityPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "hide_adult_content_violence",
                |m: &CPlayer_CommunityPreferences| { &m.hide_adult_content_violence },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.hide_adult_content_violence },
                CPlayer_CommunityPreferences::get_hide_adult_content_violence,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "hide_adult_content_sex",
                |m: &CPlayer_CommunityPreferences| { &m.hide_adult_content_sex },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.hide_adult_content_sex },
                CPlayer_CommunityPreferences::get_hide_adult_content_sex,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "parenthesize_nicknames",
                |m: &CPlayer_CommunityPreferences| { &m.parenthesize_nicknames },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.parenthesize_nicknames },
                CPlayer_CommunityPreferences::get_parenthesize_nicknames,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "timestamp_updated",
                |m: &CPlayer_CommunityPreferences| { &m.timestamp_updated },
                |m: &mut CPlayer_CommunityPreferences| { &mut m.timestamp_updated },
                CPlayer_CommunityPreferences::get_timestamp_updated,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_CommunityPreferences>(
                "CPlayer_CommunityPreferences",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_CommunityPreferences {
        static instance: ::protobuf::rt::Lazy<CPlayer_CommunityPreferences> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_CommunityPreferences::new)
    }
}

impl ::protobuf::Clear for CPlayer_CommunityPreferences {
    fn clear(&mut self) {
        self.hide_adult_content_violence = ::std::option::Option::None;
        self.hide_adult_content_sex = ::std::option::Option::None;
        self.parenthesize_nicknames = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_CommunityPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_CommunityPreferences {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetCommunityPreferences_Response {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetCommunityPreferences_Response {
    fn default() -> &'a CPlayer_GetCommunityPreferences_Response {
        <CPlayer_GetCommunityPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetCommunityPreferences_Response {
    pub fn new() -> CPlayer_GetCommunityPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetCommunityPreferences_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CPlayer_CommunityPreferences, _>(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetCommunityPreferences_Response {
        CPlayer_GetCommunityPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>, _>(
                "preferences",
                |m: &CPlayer_GetCommunityPreferences_Response| { &m.preferences },
                |m: &mut CPlayer_GetCommunityPreferences_Response| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetCommunityPreferences_Response>(
                "CPlayer_GetCommunityPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetCommunityPreferences_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetCommunityPreferences_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetCommunityPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetCommunityPreferences_Response {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetCommunityPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetCommunityPreferences_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_SetCommunityPreferences_Request {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetCommunityPreferences_Request {
    fn default() -> &'a CPlayer_SetCommunityPreferences_Request {
        <CPlayer_SetCommunityPreferences_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetCommunityPreferences_Request {
    pub fn new() -> CPlayer_SetCommunityPreferences_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetCommunityPreferences_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CPlayer_CommunityPreferences, _>(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetCommunityPreferences_Request {
        CPlayer_SetCommunityPreferences_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>, _>(
                "preferences",
                |m: &CPlayer_SetCommunityPreferences_Request| { &m.preferences },
                |m: &mut CPlayer_SetCommunityPreferences_Request| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetCommunityPreferences_Request>(
                "CPlayer_SetCommunityPreferences_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetCommunityPreferences_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_SetCommunityPreferences_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_SetCommunityPreferences_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetCommunityPreferences_Request {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetCommunityPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetCommunityPreferences_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_SetCommunityPreferences_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_SetCommunityPreferences_Response {
    fn default() -> &'a CPlayer_SetCommunityPreferences_Response {
        <CPlayer_SetCommunityPreferences_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_SetCommunityPreferences_Response {
    pub fn new() -> CPlayer_SetCommunityPreferences_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_SetCommunityPreferences_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_SetCommunityPreferences_Response {
        CPlayer_SetCommunityPreferences_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_SetCommunityPreferences_Response>(
                "CPlayer_SetCommunityPreferences_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_SetCommunityPreferences_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_SetCommunityPreferences_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_SetCommunityPreferences_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_SetCommunityPreferences_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_SetCommunityPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_SetCommunityPreferences_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetNewSteamAnnouncementState_Request {
    // message fields
    language: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNewSteamAnnouncementState_Request {
    fn default() -> &'a CPlayer_GetNewSteamAnnouncementState_Request {
        <CPlayer_GetNewSteamAnnouncementState_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNewSteamAnnouncementState_Request {
    pub fn new() -> CPlayer_GetNewSteamAnnouncementState_Request {
        ::std::default::Default::default()
    }

    // optional int32 language = 1;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetNewSteamAnnouncementState_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.language {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNewSteamAnnouncementState_Request {
        CPlayer_GetNewSteamAnnouncementState_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "language",
                |m: &CPlayer_GetNewSteamAnnouncementState_Request| { &m.language },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Request| { &mut m.language },
                CPlayer_GetNewSteamAnnouncementState_Request::get_language,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNewSteamAnnouncementState_Request>(
                "CPlayer_GetNewSteamAnnouncementState_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNewSteamAnnouncementState_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetNewSteamAnnouncementState_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetNewSteamAnnouncementState_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNewSteamAnnouncementState_Request {
    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNewSteamAnnouncementState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNewSteamAnnouncementState_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetNewSteamAnnouncementState_Response {
    // message fields
    state: ::std::option::Option<i32>,
    announcement_headline: ::protobuf::SingularField<::std::string::String>,
    announcement_url: ::protobuf::SingularField<::std::string::String>,
    time_posted: ::std::option::Option<u32>,
    announcement_gid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetNewSteamAnnouncementState_Response {
    fn default() -> &'a CPlayer_GetNewSteamAnnouncementState_Response {
        <CPlayer_GetNewSteamAnnouncementState_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetNewSteamAnnouncementState_Response {
    pub fn new() -> CPlayer_GetNewSteamAnnouncementState_Response {
        ::std::default::Default::default()
    }

    // optional int32 state = 1;

    pub fn get_state(&self) -> i32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string announcement_headline = 2;

    pub fn get_announcement_headline(&self) -> &str {
        match self.announcement_headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_announcement_headline(&mut self) {
        self.announcement_headline.clear();
    }

    pub fn has_announcement_headline(&self) -> bool {
        self.announcement_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_headline(&mut self, v: ::std::string::String) {
        self.announcement_headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_headline(&mut self) -> &mut ::std::string::String {
        if self.announcement_headline.is_none() {
            self.announcement_headline.set_default();
        }
        self.announcement_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_headline(&mut self) -> ::std::string::String {
        self.announcement_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement_url = 3;

    pub fn get_announcement_url(&self) -> &str {
        match self.announcement_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_announcement_url(&mut self) {
        self.announcement_url.clear();
    }

    pub fn has_announcement_url(&self) -> bool {
        self.announcement_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_url(&mut self, v: ::std::string::String) {
        self.announcement_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_url(&mut self) -> &mut ::std::string::String {
        if self.announcement_url.is_none() {
            self.announcement_url.set_default();
        }
        self.announcement_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_url(&mut self) -> ::std::string::String {
        self.announcement_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_posted = 4;

    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }

    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }

    // optional uint64 announcement_gid = 5;

    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }

    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetNewSteamAnnouncementState_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.state = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_headline)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_posted = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.announcement_gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_headline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.announcement_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.announcement_headline.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.announcement_url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetNewSteamAnnouncementState_Response {
        CPlayer_GetNewSteamAnnouncementState_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "state",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.state },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.state },
                CPlayer_GetNewSteamAnnouncementState_Response::get_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "announcement_headline",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_headline },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_headline },
                CPlayer_GetNewSteamAnnouncementState_Response::get_announcement_headline,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "announcement_url",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_url },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_url },
                CPlayer_GetNewSteamAnnouncementState_Response::get_announcement_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_posted",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.time_posted },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.time_posted },
                CPlayer_GetNewSteamAnnouncementState_Response::get_time_posted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "announcement_gid",
                |m: &CPlayer_GetNewSteamAnnouncementState_Response| { &m.announcement_gid },
                |m: &mut CPlayer_GetNewSteamAnnouncementState_Response| { &mut m.announcement_gid },
                CPlayer_GetNewSteamAnnouncementState_Response::get_announcement_gid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetNewSteamAnnouncementState_Response>(
                "CPlayer_GetNewSteamAnnouncementState_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetNewSteamAnnouncementState_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetNewSteamAnnouncementState_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetNewSteamAnnouncementState_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetNewSteamAnnouncementState_Response {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.announcement_headline.clear();
        self.announcement_url.clear();
        self.time_posted = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetNewSteamAnnouncementState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetNewSteamAnnouncementState_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_UpdateSteamAnnouncementLastRead_Request {
    // message fields
    announcement_gid: ::std::option::Option<u64>,
    time_posted: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn default() -> &'a CPlayer_UpdateSteamAnnouncementLastRead_Request {
        <CPlayer_UpdateSteamAnnouncementLastRead_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_UpdateSteamAnnouncementLastRead_Request {
    pub fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Request {
        ::std::default::Default::default()
    }

    // optional uint64 announcement_gid = 1;

    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }

    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 time_posted = 2;

    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }

    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.announcement_gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_posted = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.announcement_gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Request {
        CPlayer_UpdateSteamAnnouncementLastRead_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "announcement_gid",
                |m: &CPlayer_UpdateSteamAnnouncementLastRead_Request| { &m.announcement_gid },
                |m: &mut CPlayer_UpdateSteamAnnouncementLastRead_Request| { &mut m.announcement_gid },
                CPlayer_UpdateSteamAnnouncementLastRead_Request::get_announcement_gid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_posted",
                |m: &CPlayer_UpdateSteamAnnouncementLastRead_Request| { &m.time_posted },
                |m: &mut CPlayer_UpdateSteamAnnouncementLastRead_Request| { &mut m.time_posted },
                CPlayer_UpdateSteamAnnouncementLastRead_Request::get_time_posted,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_UpdateSteamAnnouncementLastRead_Request>(
                "CPlayer_UpdateSteamAnnouncementLastRead_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_UpdateSteamAnnouncementLastRead_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_UpdateSteamAnnouncementLastRead_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_UpdateSteamAnnouncementLastRead_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn clear(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
        self.time_posted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_UpdateSteamAnnouncementLastRead_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_UpdateSteamAnnouncementLastRead_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_UpdateSteamAnnouncementLastRead_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn default() -> &'a CPlayer_UpdateSteamAnnouncementLastRead_Response {
        <CPlayer_UpdateSteamAnnouncementLastRead_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_UpdateSteamAnnouncementLastRead_Response {
    pub fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_UpdateSteamAnnouncementLastRead_Response {
        CPlayer_UpdateSteamAnnouncementLastRead_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_UpdateSteamAnnouncementLastRead_Response>(
                "CPlayer_UpdateSteamAnnouncementLastRead_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_UpdateSteamAnnouncementLastRead_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_UpdateSteamAnnouncementLastRead_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_UpdateSteamAnnouncementLastRead_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_UpdateSteamAnnouncementLastRead_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_UpdateSteamAnnouncementLastRead_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetPrivacySettings_Request {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPrivacySettings_Request {
    fn default() -> &'a CPlayer_GetPrivacySettings_Request {
        <CPlayer_GetPrivacySettings_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPrivacySettings_Request {
    pub fn new() -> CPlayer_GetPrivacySettings_Request {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPrivacySettings_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPrivacySettings_Request {
        CPlayer_GetPrivacySettings_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPrivacySettings_Request>(
                "CPlayer_GetPrivacySettings_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPrivacySettings_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetPrivacySettings_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetPrivacySettings_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPrivacySettings_Request {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPrivacySettings_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPrivacySettings_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPrivacySettings {
    // message fields
    privacy_state: ::std::option::Option<i32>,
    privacy_state_inventory: ::std::option::Option<i32>,
    privacy_state_gifts: ::std::option::Option<i32>,
    privacy_state_ownedgames: ::std::option::Option<i32>,
    privacy_state_playtime: ::std::option::Option<i32>,
    privacy_state_friendslist: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPrivacySettings {
    fn default() -> &'a CPrivacySettings {
        <CPrivacySettings as ::protobuf::Message>::default_instance()
    }
}

impl CPrivacySettings {
    pub fn new() -> CPrivacySettings {
        ::std::default::Default::default()
    }

    // optional int32 privacy_state = 1;

    pub fn get_privacy_state(&self) -> i32 {
        self.privacy_state.unwrap_or(0)
    }

    pub fn clear_privacy_state(&mut self) {
        self.privacy_state = ::std::option::Option::None;
    }

    pub fn has_privacy_state(&self) -> bool {
        self.privacy_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state(&mut self, v: i32) {
        self.privacy_state = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_inventory = 2;

    pub fn get_privacy_state_inventory(&self) -> i32 {
        self.privacy_state_inventory.unwrap_or(0)
    }

    pub fn clear_privacy_state_inventory(&mut self) {
        self.privacy_state_inventory = ::std::option::Option::None;
    }

    pub fn has_privacy_state_inventory(&self) -> bool {
        self.privacy_state_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_inventory(&mut self, v: i32) {
        self.privacy_state_inventory = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_gifts = 3;

    pub fn get_privacy_state_gifts(&self) -> i32 {
        self.privacy_state_gifts.unwrap_or(0)
    }

    pub fn clear_privacy_state_gifts(&mut self) {
        self.privacy_state_gifts = ::std::option::Option::None;
    }

    pub fn has_privacy_state_gifts(&self) -> bool {
        self.privacy_state_gifts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_gifts(&mut self, v: i32) {
        self.privacy_state_gifts = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_ownedgames = 4;

    pub fn get_privacy_state_ownedgames(&self) -> i32 {
        self.privacy_state_ownedgames.unwrap_or(0)
    }

    pub fn clear_privacy_state_ownedgames(&mut self) {
        self.privacy_state_ownedgames = ::std::option::Option::None;
    }

    pub fn has_privacy_state_ownedgames(&self) -> bool {
        self.privacy_state_ownedgames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_ownedgames(&mut self, v: i32) {
        self.privacy_state_ownedgames = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_playtime = 5;

    pub fn get_privacy_state_playtime(&self) -> i32 {
        self.privacy_state_playtime.unwrap_or(0)
    }

    pub fn clear_privacy_state_playtime(&mut self) {
        self.privacy_state_playtime = ::std::option::Option::None;
    }

    pub fn has_privacy_state_playtime(&self) -> bool {
        self.privacy_state_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_playtime(&mut self, v: i32) {
        self.privacy_state_playtime = ::std::option::Option::Some(v);
    }

    // optional int32 privacy_state_friendslist = 6;

    pub fn get_privacy_state_friendslist(&self) -> i32 {
        self.privacy_state_friendslist.unwrap_or(0)
    }

    pub fn clear_privacy_state_friendslist(&mut self) {
        self.privacy_state_friendslist = ::std::option::Option::None;
    }

    pub fn has_privacy_state_friendslist(&self) -> bool {
        self.privacy_state_friendslist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacy_state_friendslist(&mut self, v: i32) {
        self.privacy_state_friendslist = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPrivacySettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy_state = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy_state_inventory = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy_state_gifts = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy_state_ownedgames = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy_state_playtime = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.privacy_state_friendslist = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.privacy_state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_inventory {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_gifts {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_ownedgames {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_playtime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.privacy_state_friendslist {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.privacy_state {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.privacy_state_inventory {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.privacy_state_gifts {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.privacy_state_ownedgames {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.privacy_state_playtime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.privacy_state_friendslist {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPrivacySettings {
        CPrivacySettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "privacy_state",
                |m: &CPrivacySettings| { &m.privacy_state },
                |m: &mut CPrivacySettings| { &mut m.privacy_state },
                CPrivacySettings::get_privacy_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "privacy_state_inventory",
                |m: &CPrivacySettings| { &m.privacy_state_inventory },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_inventory },
                CPrivacySettings::get_privacy_state_inventory,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "privacy_state_gifts",
                |m: &CPrivacySettings| { &m.privacy_state_gifts },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_gifts },
                CPrivacySettings::get_privacy_state_gifts,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "privacy_state_ownedgames",
                |m: &CPrivacySettings| { &m.privacy_state_ownedgames },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_ownedgames },
                CPrivacySettings::get_privacy_state_ownedgames,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "privacy_state_playtime",
                |m: &CPrivacySettings| { &m.privacy_state_playtime },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_playtime },
                CPrivacySettings::get_privacy_state_playtime,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "privacy_state_friendslist",
                |m: &CPrivacySettings| { &m.privacy_state_friendslist },
                |m: &mut CPrivacySettings| { &mut m.privacy_state_friendslist },
                CPrivacySettings::get_privacy_state_friendslist,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPrivacySettings>(
                "CPrivacySettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPrivacySettings {
        static instance: ::protobuf::rt::Lazy<CPrivacySettings> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPrivacySettings::new)
    }
}

impl ::protobuf::Clear for CPrivacySettings {
    fn clear(&mut self) {
        self.privacy_state = ::std::option::Option::None;
        self.privacy_state_inventory = ::std::option::Option::None;
        self.privacy_state_gifts = ::std::option::Option::None;
        self.privacy_state_ownedgames = ::std::option::Option::None;
        self.privacy_state_playtime = ::std::option::Option::None;
        self.privacy_state_friendslist = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPrivacySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPrivacySettings {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetPrivacySettings_Response {
    // message fields
    pub privacy_settings: ::protobuf::SingularPtrField<CPrivacySettings>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetPrivacySettings_Response {
    fn default() -> &'a CPlayer_GetPrivacySettings_Response {
        <CPlayer_GetPrivacySettings_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetPrivacySettings_Response {
    pub fn new() -> CPlayer_GetPrivacySettings_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_GetPrivacySettings_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.privacy_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CPrivacySettings, _>(wire_type, is, &mut self.privacy_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.privacy_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.privacy_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetPrivacySettings_Response {
        CPlayer_GetPrivacySettings_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CPrivacySettings>, _>(
                "privacy_settings",
                |m: &CPlayer_GetPrivacySettings_Response| { &m.privacy_settings },
                |m: &mut CPlayer_GetPrivacySettings_Response| { &mut m.privacy_settings },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetPrivacySettings_Response>(
                "CPlayer_GetPrivacySettings_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetPrivacySettings_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetPrivacySettings_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetPrivacySettings_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetPrivacySettings_Response {
    fn clear(&mut self) {
        self.privacy_settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetPrivacySettings_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetPrivacySettings_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetDurationControl_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetDurationControl_Request {
    fn default() -> &'a CPlayer_GetDurationControl_Request {
        <CPlayer_GetDurationControl_Request as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetDurationControl_Request {
    pub fn new() -> CPlayer_GetDurationControl_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetDurationControl_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetDurationControl_Request {
        CPlayer_GetDurationControl_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CPlayer_GetDurationControl_Request| { &m.appid },
                |m: &mut CPlayer_GetDurationControl_Request| { &mut m.appid },
                CPlayer_GetDurationControl_Request::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetDurationControl_Request>(
                "CPlayer_GetDurationControl_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetDurationControl_Request {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetDurationControl_Request> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetDurationControl_Request::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetDurationControl_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetDurationControl_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetDurationControl_Request {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_GetDurationControl_Response {
    // message fields
    is_enabled: ::std::option::Option<bool>,
    seconds: ::std::option::Option<i32>,
    seconds_today: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_GetDurationControl_Response {
    fn default() -> &'a CPlayer_GetDurationControl_Response {
        <CPlayer_GetDurationControl_Response as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_GetDurationControl_Response {
    pub fn new() -> CPlayer_GetDurationControl_Response {
        ::std::default::Default::default()
    }

    // optional bool is_enabled = 1;

    pub fn get_is_enabled(&self) -> bool {
        self.is_enabled.unwrap_or(false)
    }

    pub fn clear_is_enabled(&mut self) {
        self.is_enabled = ::std::option::Option::None;
    }

    pub fn has_is_enabled(&self) -> bool {
        self.is_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_enabled(&mut self, v: bool) {
        self.is_enabled = ::std::option::Option::Some(v);
    }

    // optional int32 seconds = 2;

    pub fn get_seconds(&self) -> i32 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 seconds_today = 3;

    pub fn get_seconds_today(&self) -> i32 {
        self.seconds_today.unwrap_or(0)
    }

    pub fn clear_seconds_today(&mut self) {
        self.seconds_today = ::std::option::Option::None;
    }

    pub fn has_seconds_today(&self) -> bool {
        self.seconds_today.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_today(&mut self, v: i32) {
        self.seconds_today = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_GetDurationControl_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.seconds_today = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_enabled {
            my_size += 2;
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_today {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.seconds_today {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_GetDurationControl_Response {
        CPlayer_GetDurationControl_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_enabled",
                |m: &CPlayer_GetDurationControl_Response| { &m.is_enabled },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.is_enabled },
                CPlayer_GetDurationControl_Response::get_is_enabled,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "seconds",
                |m: &CPlayer_GetDurationControl_Response| { &m.seconds },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.seconds },
                CPlayer_GetDurationControl_Response::get_seconds,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "seconds_today",
                |m: &CPlayer_GetDurationControl_Response| { &m.seconds_today },
                |m: &mut CPlayer_GetDurationControl_Response| { &mut m.seconds_today },
                CPlayer_GetDurationControl_Response::get_seconds_today,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_GetDurationControl_Response>(
                "CPlayer_GetDurationControl_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_GetDurationControl_Response {
        static instance: ::protobuf::rt::Lazy<CPlayer_GetDurationControl_Response> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_GetDurationControl_Response::new)
    }
}

impl ::protobuf::Clear for CPlayer_GetDurationControl_Response {
    fn clear(&mut self) {
        self.is_enabled = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.seconds_today = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_GetDurationControl_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_GetDurationControl_Response {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_LastPlayedTimes_Notification {
    // message fields
    pub games: ::protobuf::RepeatedField<cplayer_get_last_played_times_response::Game>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_LastPlayedTimes_Notification {
    fn default() -> &'a CPlayer_LastPlayedTimes_Notification {
        <CPlayer_LastPlayedTimes_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_LastPlayedTimes_Notification {
    pub fn new() -> CPlayer_LastPlayedTimes_Notification {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_LastPlayedTimes_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.games {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.games)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.games {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_LastPlayedTimes_Notification {
        CPlayer_LastPlayedTimes_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<cplayer_get_last_played_times_response::Game>>(
                "games",
                |m: &CPlayer_LastPlayedTimes_Notification| { &m.games },
                |m: &mut CPlayer_LastPlayedTimes_Notification| { &mut m.games },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_LastPlayedTimes_Notification>(
                "CPlayer_LastPlayedTimes_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_LastPlayedTimes_Notification {
        static instance: ::protobuf::rt::Lazy<CPlayer_LastPlayedTimes_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_LastPlayedTimes_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_LastPlayedTimes_Notification {
    fn clear(&mut self) {
        self.games.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_LastPlayedTimes_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_LastPlayedTimes_Notification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_FriendNicknameChanged_Notification {
    // message fields
    accountid: ::std::option::Option<u32>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    is_echo_to_self: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_FriendNicknameChanged_Notification {
    fn default() -> &'a CPlayer_FriendNicknameChanged_Notification {
        <CPlayer_FriendNicknameChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_FriendNicknameChanged_Notification {
    pub fn new() -> CPlayer_FriendNicknameChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;

    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_echo_to_self = 3;

    pub fn get_is_echo_to_self(&self) -> bool {
        self.is_echo_to_self.unwrap_or(false)
    }

    pub fn clear_is_echo_to_self(&mut self) {
        self.is_echo_to_self = ::std::option::Option::None;
    }

    pub fn has_is_echo_to_self(&self) -> bool {
        self.is_echo_to_self.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_echo_to_self(&mut self, v: bool) {
        self.is_echo_to_self = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_FriendNicknameChanged_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.accountid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_echo_to_self = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_echo_to_self {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.nickname.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_echo_to_self {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_FriendNicknameChanged_Notification {
        CPlayer_FriendNicknameChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "accountid",
                |m: &CPlayer_FriendNicknameChanged_Notification| { &m.accountid },
                |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.accountid },
                CPlayer_FriendNicknameChanged_Notification::get_accountid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "nickname",
                |m: &CPlayer_FriendNicknameChanged_Notification| { &m.nickname },
                |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.nickname },
                CPlayer_FriendNicknameChanged_Notification::get_nickname,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "is_echo_to_self",
                |m: &CPlayer_FriendNicknameChanged_Notification| { &m.is_echo_to_self },
                |m: &mut CPlayer_FriendNicknameChanged_Notification| { &mut m.is_echo_to_self },
                CPlayer_FriendNicknameChanged_Notification::get_is_echo_to_self,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_FriendNicknameChanged_Notification>(
                "CPlayer_FriendNicknameChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_FriendNicknameChanged_Notification {
        static instance: ::protobuf::rt::Lazy<CPlayer_FriendNicknameChanged_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_FriendNicknameChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_FriendNicknameChanged_Notification {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.nickname.clear();
        self.is_echo_to_self = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_FriendNicknameChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_FriendNicknameChanged_Notification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_NewSteamAnnouncementState_Notification {
    // message fields
    state: ::std::option::Option<i32>,
    announcement_headline: ::protobuf::SingularField<::std::string::String>,
    announcement_url: ::protobuf::SingularField<::std::string::String>,
    time_posted: ::std::option::Option<u32>,
    announcement_gid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_NewSteamAnnouncementState_Notification {
    fn default() -> &'a CPlayer_NewSteamAnnouncementState_Notification {
        <CPlayer_NewSteamAnnouncementState_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_NewSteamAnnouncementState_Notification {
    pub fn new() -> CPlayer_NewSteamAnnouncementState_Notification {
        ::std::default::Default::default()
    }

    // optional int32 state = 1;

    pub fn get_state(&self) -> i32 {
        self.state.unwrap_or(0)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: i32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string announcement_headline = 2;

    pub fn get_announcement_headline(&self) -> &str {
        match self.announcement_headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_announcement_headline(&mut self) {
        self.announcement_headline.clear();
    }

    pub fn has_announcement_headline(&self) -> bool {
        self.announcement_headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_headline(&mut self, v: ::std::string::String) {
        self.announcement_headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_headline(&mut self) -> &mut ::std::string::String {
        if self.announcement_headline.is_none() {
            self.announcement_headline.set_default();
        }
        self.announcement_headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_headline(&mut self) -> ::std::string::String {
        self.announcement_headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement_url = 3;

    pub fn get_announcement_url(&self) -> &str {
        match self.announcement_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_announcement_url(&mut self) {
        self.announcement_url.clear();
    }

    pub fn has_announcement_url(&self) -> bool {
        self.announcement_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_url(&mut self, v: ::std::string::String) {
        self.announcement_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_url(&mut self) -> &mut ::std::string::String {
        if self.announcement_url.is_none() {
            self.announcement_url.set_default();
        }
        self.announcement_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_url(&mut self) -> ::std::string::String {
        self.announcement_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 time_posted = 4;

    pub fn get_time_posted(&self) -> u32 {
        self.time_posted.unwrap_or(0)
    }

    pub fn clear_time_posted(&mut self) {
        self.time_posted = ::std::option::Option::None;
    }

    pub fn has_time_posted(&self) -> bool {
        self.time_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_posted(&mut self, v: u32) {
        self.time_posted = ::std::option::Option::Some(v);
    }

    // optional uint64 announcement_gid = 5;

    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }

    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_NewSteamAnnouncementState_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.state = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_headline)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.announcement_url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.time_posted = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.announcement_gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_headline.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.announcement_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.time_posted {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.announcement_gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.announcement_headline.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.announcement_url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.time_posted {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_NewSteamAnnouncementState_Notification {
        CPlayer_NewSteamAnnouncementState_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "state",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.state },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.state },
                CPlayer_NewSteamAnnouncementState_Notification::get_state,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "announcement_headline",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_headline },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_headline },
                CPlayer_NewSteamAnnouncementState_Notification::get_announcement_headline,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "announcement_url",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_url },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_url },
                CPlayer_NewSteamAnnouncementState_Notification::get_announcement_url,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "time_posted",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.time_posted },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.time_posted },
                CPlayer_NewSteamAnnouncementState_Notification::get_time_posted,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "announcement_gid",
                |m: &CPlayer_NewSteamAnnouncementState_Notification| { &m.announcement_gid },
                |m: &mut CPlayer_NewSteamAnnouncementState_Notification| { &mut m.announcement_gid },
                CPlayer_NewSteamAnnouncementState_Notification::get_announcement_gid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_NewSteamAnnouncementState_Notification>(
                "CPlayer_NewSteamAnnouncementState_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_NewSteamAnnouncementState_Notification {
        static instance: ::protobuf::rt::Lazy<CPlayer_NewSteamAnnouncementState_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_NewSteamAnnouncementState_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_NewSteamAnnouncementState_Notification {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.announcement_headline.clear();
        self.announcement_url.clear();
        self.time_posted = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_NewSteamAnnouncementState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_NewSteamAnnouncementState_Notification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_CommunityPreferencesChanged_Notification {
    // message fields
    pub preferences: ::protobuf::SingularPtrField<CPlayer_CommunityPreferences>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_CommunityPreferencesChanged_Notification {
    fn default() -> &'a CPlayer_CommunityPreferencesChanged_Notification {
        <CPlayer_CommunityPreferencesChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_CommunityPreferencesChanged_Notification {
    pub fn new() -> CPlayer_CommunityPreferencesChanged_Notification {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_CommunityPreferencesChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CPlayer_CommunityPreferences, _>(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_CommunityPreferencesChanged_Notification {
        CPlayer_CommunityPreferencesChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CPlayer_CommunityPreferences>, _>(
                "preferences",
                |m: &CPlayer_CommunityPreferencesChanged_Notification| { &m.preferences },
                |m: &mut CPlayer_CommunityPreferencesChanged_Notification| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_CommunityPreferencesChanged_Notification>(
                "CPlayer_CommunityPreferencesChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_CommunityPreferencesChanged_Notification {
        static instance: ::protobuf::rt::Lazy<CPlayer_CommunityPreferencesChanged_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_CommunityPreferencesChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_CommunityPreferencesChanged_Notification {
    fn clear(&mut self) {
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_CommunityPreferencesChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_CommunityPreferencesChanged_Notification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_PerFriendPreferencesChanged_Notification {
    // message fields
    accountid: ::std::option::Option<u32>,
    pub preferences: ::protobuf::SingularPtrField<PerFriendPreferences>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PerFriendPreferencesChanged_Notification {
    fn default() -> &'a CPlayer_PerFriendPreferencesChanged_Notification {
        <CPlayer_PerFriendPreferencesChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PerFriendPreferencesChanged_Notification {
    pub fn new() -> CPlayer_PerFriendPreferencesChanged_Notification {
        ::std::default::Default::default()
    }

    // optional fixed32 accountid = 1;

    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPlayer_PerFriendPreferencesChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.preferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.accountid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<PerFriendPreferences, _>(wire_type, is, &mut self.preferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += 5;
        }
        if let Some(v) = self.preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.preferences.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PerFriendPreferencesChanged_Notification {
        CPlayer_PerFriendPreferencesChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFixed32, _>(
                "accountid",
                |m: &CPlayer_PerFriendPreferencesChanged_Notification| { &m.accountid },
                |m: &mut CPlayer_PerFriendPreferencesChanged_Notification| { &mut m.accountid },
                CPlayer_PerFriendPreferencesChanged_Notification::get_accountid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<PerFriendPreferences>, _>(
                "preferences",
                |m: &CPlayer_PerFriendPreferencesChanged_Notification| { &m.preferences },
                |m: &mut CPlayer_PerFriendPreferencesChanged_Notification| { &mut m.preferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PerFriendPreferencesChanged_Notification>(
                "CPlayer_PerFriendPreferencesChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PerFriendPreferencesChanged_Notification {
        static instance: ::protobuf::rt::Lazy<CPlayer_PerFriendPreferencesChanged_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_PerFriendPreferencesChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_PerFriendPreferencesChanged_Notification {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.preferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PerFriendPreferencesChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PerFriendPreferencesChanged_Notification {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPlayer_PrivacySettingsChanged_Notification {
    // message fields
    pub privacy_settings: ::protobuf::SingularPtrField<CPrivacySettings>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPlayer_PrivacySettingsChanged_Notification {
    fn default() -> &'a CPlayer_PrivacySettingsChanged_Notification {
        <CPlayer_PrivacySettingsChanged_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CPlayer_PrivacySettingsChanged_Notification {
    pub fn new() -> CPlayer_PrivacySettingsChanged_Notification {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPlayer_PrivacySettingsChanged_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.privacy_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CPrivacySettings, _>(wire_type, is, &mut self.privacy_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.privacy_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.privacy_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPlayer_PrivacySettingsChanged_Notification {
        CPlayer_PrivacySettingsChanged_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CPrivacySettings>, _>(
                "privacy_settings",
                |m: &CPlayer_PrivacySettingsChanged_Notification| { &m.privacy_settings },
                |m: &mut CPlayer_PrivacySettingsChanged_Notification| { &mut m.privacy_settings },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CPlayer_PrivacySettingsChanged_Notification>(
                "CPlayer_PrivacySettingsChanged_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPlayer_PrivacySettingsChanged_Notification {
        static instance: ::protobuf::rt::Lazy<CPlayer_PrivacySettingsChanged_Notification> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPlayer_PrivacySettingsChanged_Notification::new)
    }
}

impl ::protobuf::Clear for CPlayer_PrivacySettingsChanged_Notification {
    fn clear(&mut self) {
        self.privacy_settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPlayer_PrivacySettingsChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPlayer_PrivacySettingsChanged_Notification {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ENotificationSetting {
    k_ENotificationSettingNotifyUseDefault = 0,
    k_ENotificationSettingAlways = 1,
    k_ENotificationSettingNever = 2,
}

impl ::protobuf::ProtobufEnum for ENotificationSetting {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENotificationSetting> {
        match value {
            0 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingNotifyUseDefault),
            1 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingAlways),
            2 => ::std::option::Option::Some(ENotificationSetting::k_ENotificationSettingNever),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ENotificationSetting] = &[
            ENotificationSetting::k_ENotificationSettingNotifyUseDefault,
            ENotificationSetting::k_ENotificationSettingAlways,
            ENotificationSetting::k_ENotificationSettingNever,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<ENotificationSetting>("ENotificationSetting", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for ENotificationSetting {
    fn default() -> Self {
        ENotificationSetting::k_ENotificationSettingNotifyUseDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for ENotificationSetting {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&steammessages_player.steamclient.proto\x1a,steammessages_unified_base\
    .steamclient.proto\"4\n2CPlayer_GetMutualFriendsForIncomingInvites_Reque\
    st\"}\n&CPlayer_IncomingInviteMutualFriendList\x12\x18\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamid\x129\n\x19mutual_friend_account_ids\x18\
    \x02\x20\x03(\rR\x16mutualFriendAccountIds\"\xae\x01\n3CPlayer_GetMutual\
    FriendsForIncomingInvites_Response\x12w\n$incoming_invite_mutual_friends\
    _lists\x18\x01\x20\x03(\x0b2'.CPlayer_IncomingInviteMutualFriendListR\
    \x20incomingInviteMutualFriendsLists\">\n&CPlayer_GetFriendsGameplayInfo\
    _Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\x9f\x07\n'CPl\
    ayer_GetFriendsGameplayInfo_Response\x12U\n\tyour_info\x18\x01\x20\x01(\
    \x0b28.CPlayer_GetFriendsGameplayInfo_Response.OwnGameplayInfoR\x08yourI\
    nfo\x12U\n\x07in_game\x18\x02\x20\x03(\x0b2<.CPlayer_GetFriendsGameplayI\
    nfo_Response.FriendsGameplayInfoR\x06inGame\x12e\n\x0fplayed_recently\
    \x18\x03\x20\x03(\x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsG\
    ameplayInfoR\x0eplayedRecently\x12]\n\x0bplayed_ever\x18\x04\x20\x03(\
    \x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayInfoR\npla\
    yedEver\x12P\n\x04owns\x18\x05\x20\x03(\x0b2<.CPlayer_GetFriendsGameplay\
    Info_Response.FriendsGameplayInfoR\x04owns\x12]\n\x0bin_wishlist\x18\x06\
    \x20\x03(\x0b2<.CPlayer_GetFriendsGameplayInfo_Response.FriendsGameplayI\
    nfoR\ninWishlist\x1a\x8c\x01\n\x13FriendsGameplayInfo\x12\x18\n\x07steam\
    id\x18\x01\x20\x01(\x06R\x07steamid\x12%\n\x0eminutes_played\x18\x02\x20\
    \x01(\rR\rminutesPlayed\x124\n\x16minutes_played_forever\x18\x03\x20\x01\
    (\rR\x14minutesPlayedForever\x1a\xbf\x01\n\x0fOwnGameplayInfo\x12\x18\n\
    \x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12%\n\x0eminutes_played\
    \x18\x02\x20\x01(\rR\rminutesPlayed\x124\n\x16minutes_played_forever\x18\
    \x03\x20\x01(\rR\x14minutesPlayedForever\x12\x1f\n\x0bin_wishlist\x18\
    \x04\x20\x01(\x08R\ninWishlist\x12\x14\n\x05owned\x18\x05\x20\x01(\x08R\
    \x05owned\"\xa3\x02\n&CPlayer_GetFriendsAppsActivity_Request\x12\x8f\x01\
    \n\rnews_language\x18\x01\x20\x01(\tR\x0cnewsLanguageBj\x82\xb5\x18fLang\
    uage\x20for\x20which\x20to\x20query\x20about\x20news\x20items\x20(for\
    \x20the\x20being_discussed\x20results).\x20DEPRECATED\x20AND\x20UNUSED.\
    \x12g\n\rrequest_flags\x18\x02\x20\x01(\rR\x0crequestFlagsBB\x82\xb5\x18\
    >Flags\x20describing\x20the\x20request;\x20see\x20EGetFriendsAppsActivit\
    yFlags\"\x96\x15\n'CPlayer_GetFriendsAppsActivity_Response\x12\xc2\x01\n\
    \x08trending\x18\x01\x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_Respo\
    nse.AppFriendsInfoR\x08trendingBm\x82\xb5\x18iApps\x20that\x20friends\
    \x20have\x20played\x20more\x20this\x20week\x20than\x20last,\x20with\x20l\
    ist\x20of\x20friends\x20who've\x20played\x20more\x20this\x20week\x12\xc5\
    \x01\n\x10recent_purchases\x18\x02\x20\x03(\x0b27.CPlayer_GetFriendsApps\
    Activity_Response.AppFriendsInfoR\x0frecentPurchasesBa\x82\xb5\x18]Apps\
    \x20friends\x20have\x20played\x20in\x20the\x20past\x20two\x20weeks\x20fo\
    r\x20which\x20the\x20user\x20recently\x20acquired\x20a\x20license\x12\
    \xa7\x01\n\x07unowned\x18\x03\x20\x03(\x0b27.CPlayer_GetFriendsAppsActiv\
    ity_Response.AppFriendsInfoR\x07unownedBT\x82\xb5\x18PApps\x20friends\
    \x20have\x20played\x20in\x20the\x20past\x20two\x20weeks\x20for\x20which\
    \x20the\x20user\x20has\x20no\x20license\x12\xb8\x01\n\x07popular\x18\x04\
    \x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\
    \x07popularBe\x82\xb5\x18aApps\x20friends\x20have\x20played\x20in\x20the\
    \x20past\x20two\x20weeks,\x20for\x20which\x20the\x20user\x20has\x20a\x20\
    license,\x20sorted\x20by\x20count\x12\xd2\x01\n\x0bdont_forget\x18\x05\
    \x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFriendsInfoR\
    \ndontForgetBx\x82\xb5\x18tApps\x20friends\x20have\x20played\x20in\x20th\
    e\x20past\x20two\x20weeks\x20which\x20the\x20user\x20has\x20neither\x20p\
    urchased\x20nor\x20played\x20in\x20the\x20past\x20two\x20weeks\x12\xd1\
    \x01\n\x0fbeing_discussed\x18\x06\x20\x03(\x0b27.CPlayer_GetFriendsAppsA\
    ctivity_Response.AppFriendsInfoR\x0ebeingDiscussedBo\x82\xb5\x18kOwned\
    \x20apps\x20that\x20friends\x20have\x20posted\x20status\x20or\x20screens\
    hots\x20for\x20in\x20the\x20past\x20two\x20weeks.\x20DEPRECATED\x20AND\
    \x20UNUSED.\x12\xa0\x01\n\x0cnew_to_group\x18\x07\x20\x03(\x0b27.CPlayer\
    _GetFriendsAppsActivity_Response.AppFriendsInfoR\nnewToGroupBE\x82\xb5\
    \x18AOwned\x20apps\x20that\x20none\x20of\x20your\x20friends\x20had\x20pl\
    ayed\x20prior\x20to\x202\x20weeks.\x12\xaa\x01\n\x11returned_to_group\
    \x18\x08\x20\x03(\x0b27.CPlayer_GetFriendsAppsActivity_Response.AppFrien\
    dsInfoR\x0freturnedToGroupBE\x82\xb5\x18AOwned\x20apps\x20that\x20friend\
    s\x20hadn't\x20played\x20for\x20a\x20while,\x20but\x20are\x20again.\x12y\
    \n\x13active_friend_count\x18\t\x20\x01(\r:\x010R\x11activeFriendCountBF\
    \x82\xb5\x18BNumber\x20of\x20friends\x20with\x20non-trivial\x20activity\
    \x20in\x20the\x20past\x20two\x20weeks.\x1a\xec\x04\n\x0eFriendPlayTime\
    \x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x8a\x01\n\x18\
    minutes_played_this_week\x18\x02\x20\x01(\rR\x15minutesPlayedThisWeekBQ\
    \x82\xb5\x18MMinutes\x20this\x20friend\x20played\x20the\x20game\x20(from\
    \x20the\x20enclosing\x20structure)\x20this\x20week.\x12\x94\x01\n\x18min\
    utes_played_two_weeks\x18\x03\x20\x01(\rR\x15minutesPlayedTwoWeeksB[\x82\
    \xb5\x18WMinutes\x20this\x20friend\x20played\x20the\x20game\x20(from\x20\
    the\x20enclosing\x20structure)\x20in\x20the\x20past\x202\x20weeks.\x12\
    \x86\x01\n\x16minutes_played_forever\x18\x04\x20\x01(\rR\x14minutesPlaye\
    dForeverBP\x82\xb5\x18LMinutes\x20this\x20friend\x20played\x20the\x20gam\
    e\x20(from\x20the\x20enclosing\x20structure)\x20all\x20time.\x12\x92\x01\
    \n\x0bevent_count\x18\x05\x20\x01(\rR\neventCountBq\x82\xb5\x18mNumber\
    \x20of\x20events\x20involving\x20this\x20user\x20&\x20app.\x20(Only\x20s\
    et\x20for\x20results\x20in\x20being_discussed.)\x20DEPRECATED\x20AND\x20\
    UNUSED.\x1a\x95\x03\n\x0eAppFriendsInfo\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\x12\xd2\x01\n\x07friends\x18\x02\x20\x03(\x0b27.CPlaye\
    r_GetFriendsAppsActivity_Response.FriendPlayTimeR\x07friendsB\x7f\x82\
    \xb5\x18{Friends\x20(w/\x20playtime)\x20that\x20meet\x20a\x20specific\
    \x20criteria\x20--\x20e.g.\x20for\x20trending,\x20only\x20includes\x20fr\
    iends\x20w/\x20more\x20playtime\x20this\x20week.\x12\x97\x01\n\rdisplay_\
    order\x18\x03\x20\x01(\rR\x0cdisplayOrderBr\x82\xb5\x18nIndex\x20indicat\
    ing\x20the\x20order\x20in\x20which\x20this\x20app\x20should\x20be\x20dis\
    played,\x20relative\x20to\x20other\x20apps\x20in\x20the\x20same\x20respo\
    nse.\":\n\"CPlayer_GetGameBadgeLevels_Request\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\"\xe6\x01\n#CPlayer_GetGameBadgeLevels_Response\
    \x12!\n\x0cplayer_level\x18\x01\x20\x01(\rR\x0bplayerLevel\x12B\n\x06bad\
    ges\x18\x02\x20\x03(\x0b2*.CPlayer_GetGameBadgeLevels_Response.BadgeR\
    \x06badges\x1aX\n\x05Badge\x12\x14\n\x05level\x18\x01\x20\x01(\x05R\x05l\
    evel\x12\x16\n\x06series\x18\x02\x20\x01(\x05R\x06series\x12!\n\x0cborde\
    r_color\x18\x03\x20\x01(\rR\x0bborderColor\"!\n\x1fCPlayer_GetEmoticonLi\
    st_Request\"\x8b\x02\n\x20CPlayer_GetEmoticonList_Response\x12H\n\temoti\
    cons\x18\x01\x20\x03(\x0b2*.CPlayer_GetEmoticonList_Response.EmoticonR\t\
    emoticons\x1a\x9c\x01\n\x08Emoticon\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12$\n\x0eti\
    me_last_used\x18\x03\x20\x01(\rR\x0ctimeLastUsed\x12\x1b\n\tuse_count\
    \x18\x04\x20\x01(\rR\x08useCount\x12#\n\rtime_received\x18\x05\x20\x01(\
    \rR\x0ctimeReceived\"w\n'CPlayer_GetAchievementsProgress_Request\x12\x18\
    \n\x07steamid\x18\x01\x20\x01(\x04R\x07steamid\x12\x1a\n\x08language\x18\
    \x02\x20\x01(\tR\x08language\x12\x16\n\x06appids\x18\x03\x20\x03(\rR\x06\
    appids\"\xde\x02\n(CPlayer_GetAchievementsProgress_Response\x12p\n\x14ac\
    hievement_progress\x18\x01\x20\x03(\x0b2=.CPlayer_GetAchievementsProgres\
    s_Response.AchievementProgressR\x13achievementProgress\x1a\xbf\x01\n\x13\
    AchievementProgress\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x1a\n\x08unlocked\x18\x02\x20\x01(\rR\x08unlocked\x12\x14\n\x05total\
    \x18\x03\x20\x01(\rR\x05total\x12\x1e\n\npercentage\x18\x04\x20\x01(\x02\
    R\npercentage\x12!\n\x0call_unlocked\x18\x05\x20\x01(\x08R\x0ballUnlocke\
    d\x12\x1d\n\ncache_time\x18\x06\x20\x01(\rR\tcacheTime\"\\\n#CPlayer_Pos\
    tStatusToFriends_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12\x1f\n\x0bstatus_text\x18\x02\x20\x01(\tR\nstatusText\"&\n$CPlayer_P\
    ostStatusToFriends_Response\"v\n\x1fCPlayer_GetPostedStatus_Request\x12;\
    \n\x07steamid\x18\x01\x20\x01(\x04R\x07steamidB!\x82\xb5\x18\x1dThe\x20p\
    layer\x20we're\x20asking\x20about\x12\x16\n\x06postid\x18\x02\x20\x01(\
    \x04R\x06postid\"\xa9\x01\n\x20CPlayer_GetPostedStatus_Response\x12\x1c\
    \n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x16\n\x06postid\x18\x02\
    \x20\x01(\x04R\x06postid\x12\x1f\n\x0bstatus_text\x18\x03\x20\x01(\tR\ns\
    tatusText\x12\x18\n\x07deleted\x18\x04\x20\x01(\x08R\x07deleted\x12\x14\
    \n\x05appid\x18\x05\x20\x01(\rR\x05appid\"<\n\"CPlayer_DeletePostedStatu\
    s_Request\x12\x16\n\x06postid\x18\x01\x20\x01(\x04R\x06postid\"%\n#CPlay\
    er_DeletePostedStatus_Response\"\x91\x01\n\"CPlayer_GetLastPlayedTimes_R\
    equest\x12k\n\x0fmin_last_played\x18\x01\x20\x01(\rR\rminLastPlayedBC\
    \x82\xb5\x18?The\x20most\x20recent\x20last-played\x20time\x20the\x20clie\
    nt\x20already\x20knows\x20about\"\xed\x05\n#CPlayer_GetLastPlayedTimes_R\
    esponse\x12?\n\x05games\x18\x01\x20\x03(\x0b2).CPlayer_GetLastPlayedTime\
    s_Response.GameR\x05games\x1a\x84\x05\n\x04Game\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\x05R\x05appid\x12#\n\rlast_playtime\x18\x02\x20\x01(\rR\
    \x0clastPlaytime\x12'\n\x0fplaytime_2weeks\x18\x03\x20\x01(\x05R\x0eplay\
    time2weeks\x12)\n\x10playtime_forever\x18\x04\x20\x01(\x05R\x0fplaytimeF\
    orever\x12%\n\x0efirst_playtime\x18\x05\x20\x01(\rR\rfirstPlaytime\x128\
    \n\x18playtime_windows_forever\x18\x06\x20\x01(\x05R\x16playtimeWindowsF\
    orever\x120\n\x14playtime_mac_forever\x18\x07\x20\x01(\x05R\x12playtimeM\
    acForever\x124\n\x16playtime_linux_forever\x18\x08\x20\x01(\x05R\x14play\
    timeLinuxForever\x124\n\x16first_windows_playtime\x18\t\x20\x01(\rR\x14f\
    irstWindowsPlaytime\x12,\n\x12first_mac_playtime\x18\n\x20\x01(\rR\x10fi\
    rstMacPlaytime\x120\n\x14first_linux_playtime\x18\x0b\x20\x01(\rR\x12fir\
    stLinuxPlaytime\x122\n\x15last_windows_playtime\x18\x0c\x20\x01(\rR\x13l\
    astWindowsPlaytime\x12*\n\x11last_mac_playtime\x18\r\x20\x01(\rR\x0flast\
    MacPlaytime\x12.\n\x13last_linux_playtime\x18\x0e\x20\x01(\rR\x11lastLin\
    uxPlaytime\"\x1b\n\x19CPlayer_AcceptSSA_Request\"\x1c\n\x1aCPlayer_Accep\
    tSSA_Response\"!\n\x1fCPlayer_GetNicknameList_Request\"\xbe\x01\n\x20CPl\
    ayer_GetNicknameList_Response\x12N\n\tnicknames\x18\x01\x20\x03(\x0b20.C\
    Player_GetNicknameList_Response.PlayerNicknameR\tnicknames\x1aJ\n\x0ePla\
    yerNickname\x12\x1c\n\taccountid\x18\x01\x20\x01(\x07R\taccountid\x12\
    \x1a\n\x08nickname\x18\x02\x20\x01(\tR\x08nickname\")\n'CPlayer_GetPerFr\
    iendPreferences_Request\"\x84\x07\n\x14PerFriendPreferences\x12\x1c\n\ta\
    ccountid\x18\x01\x20\x01(\x07R\taccountid\x12\x1a\n\x08nickname\x18\x02\
    \x20\x01(\tR\x08nickname\x12x\n\x18notifications_showingame\x18\x03\x20\
    \x01(\x0e2\x15.ENotificationSetting:&k_ENotificationSettingNotifyUseDefa\
    ultR\x17notificationsShowingame\x12x\n\x18notifications_showonline\x18\
    \x04\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENotificationSettingNotif\
    yUseDefaultR\x17notificationsShowonline\x12|\n\x1anotifications_showmess\
    ages\x18\x05\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENotificationSett\
    ingNotifyUseDefaultR\x19notificationsShowmessages\x12j\n\x11sounds_showi\
    ngame\x18\x06\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENotificationSet\
    tingNotifyUseDefaultR\x10soundsShowingame\x12j\n\x11sounds_showonline\
    \x18\x07\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENotificationSettingN\
    otifyUseDefaultR\x10soundsShowonline\x12n\n\x13sounds_showmessages\x18\
    \x08\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENotificationSettingNotif\
    yUseDefaultR\x12soundsShowmessages\x12x\n\x18notifications_sendmobile\
    \x18\t\x20\x01(\x0e2\x15.ENotificationSetting:&k_ENotificationSettingNot\
    ifyUseDefaultR\x17notificationsSendmobile\"c\n(CPlayer_GetPerFriendPrefe\
    rences_Response\x127\n\x0bpreferences\x18\x01\x20\x03(\x0b2\x15.PerFrien\
    dPreferencesR\x0bpreferences\"b\n'CPlayer_SetPerFriendPreferences_Reques\
    t\x127\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x15.PerFriendPreferencesR\
    \x0bpreferences\"*\n(CPlayer_SetPerFriendPreferences_Response\"l\n\x19CP\
    layer_AddFriend_Request\x12O\n\x07steamid\x18\x01\x20\x01(\x06R\x07steam\
    idB5\x82\xb5\x181Steam\x20ID\x20of\x20user\x20to\x20whom\x20to\x20send\
    \x20a\x20friend\x20invite.\"\x96\x02\n\x1aCPlayer_AddFriend_Response\x12\
    [\n\x0binvite_sent\x18\x01\x20\x01(\x08R\ninviteSentB:\x82\xb5\x186True\
    \x20if\x20the\x20operation\x20was\x20successful,\x20false\x20otherwise.\
    \x12\x9a\x01\n\x13friend_relationship\x18\x02\x20\x01(\rR\x12friendRelat\
    ionshipBi\x82\xb5\x18ethe\x20resulting\x20relationship.\x20\x20Depending\
    \x20on\x20state,\x20may\x20move\x20directly\x20to\x20friends\x20rather\
    \x20than\x20invite\x20sent\"[\n\x1cCPlayer_RemoveFriend_Request\x12;\n\
    \x07steamid\x18\x01\x20\x01(\x06R\x07steamidB!\x82\xb5\x18\x1dSteam\x20I\
    D\x20of\x20friend\x20to\x20remove.\"p\n\x1dCPlayer_RemoveFriend_Response\
    \x12O\n\x13friend_relationship\x18\x01\x20\x01(\rR\x12friendRelationship\
    B\x1e\x82\xb5\x18\x1athe\x20resulting\x20relationship\"\x92\x01\n\x1cCPl\
    ayer_IgnoreFriend_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07\
    steamid\x12X\n\x08unignore\x18\x02\x20\x01(\x08R\x08unignoreB<\x82\xb5\
    \x188If\x20set,\x20remove\x20from\x20ignore/block\x20list\x20instead\x20\
    of\x20adding\x20\"p\n\x1dCPlayer_IgnoreFriend_Response\x12O\n\x13friend_\
    relationship\x18\x01\x20\x01(\rR\x12friendRelationshipB\x1e\x82\xb5\x18\
    \x1athe\x20resulting\x20relationship\")\n'CPlayer_GetCommunityPreference\
    s_Request\"\x89\x02\n\x1cCPlayer_CommunityPreferences\x12C\n\x1bhide_adu\
    lt_content_violence\x18\x01\x20\x01(\x08:\x04trueR\x18hideAdultContentVi\
    olence\x129\n\x16hide_adult_content_sex\x18\x02\x20\x01(\x08:\x04trueR\
    \x13hideAdultContentSex\x12<\n\x16parenthesize_nicknames\x18\x04\x20\x01\
    (\x08:\x05falseR\x15parenthesizeNicknames\x12+\n\x11timestamp_updated\
    \x18\x03\x20\x01(\rR\x10timestampUpdated\"k\n(CPlayer_GetCommunityPrefer\
    ences_Response\x12?\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x1d.CPlayer_C\
    ommunityPreferencesR\x0bpreferences\"j\n'CPlayer_SetCommunityPreferences\
    _Request\x12?\n\x0bpreferences\x18\x01\x20\x01(\x0b2\x1d.CPlayer_Communi\
    tyPreferencesR\x0bpreferences\"*\n(CPlayer_SetCommunityPreferences_Respo\
    nse\"J\n,CPlayer_GetNewSteamAnnouncementState_Request\x12\x1a\n\x08langu\
    age\x18\x01\x20\x01(\x05R\x08language\"\xf1\x01\n-CPlayer_GetNewSteamAnn\
    ouncementState_Response\x12\x14\n\x05state\x18\x01\x20\x01(\x05R\x05stat\
    e\x123\n\x15announcement_headline\x18\x02\x20\x01(\tR\x14announcementHea\
    dline\x12)\n\x10announcement_url\x18\x03\x20\x01(\tR\x0fannouncementUrl\
    \x12\x1f\n\x0btime_posted\x18\x04\x20\x01(\rR\ntimePosted\x12)\n\x10anno\
    uncement_gid\x18\x05\x20\x01(\x04R\x0fannouncementGid\"}\n/CPlayer_Updat\
    eSteamAnnouncementLastRead_Request\x12)\n\x10announcement_gid\x18\x01\
    \x20\x01(\x04R\x0fannouncementGid\x12\x1f\n\x0btime_posted\x18\x02\x20\
    \x01(\rR\ntimePosted\"2\n0CPlayer_UpdateSteamAnnouncementLastRead_Respon\
    se\"$\n\"CPlayer_GetPrivacySettings_Request\"\xcb\x02\n\x10CPrivacySetti\
    ngs\x12#\n\rprivacy_state\x18\x01\x20\x01(\x05R\x0cprivacyState\x126\n\
    \x17privacy_state_inventory\x18\x02\x20\x01(\x05R\x15privacyStateInvento\
    ry\x12.\n\x13privacy_state_gifts\x18\x03\x20\x01(\x05R\x11privacyStateGi\
    fts\x128\n\x18privacy_state_ownedgames\x18\x04\x20\x01(\x05R\x16privacyS\
    tateOwnedgames\x124\n\x16privacy_state_playtime\x18\x05\x20\x01(\x05R\
    \x14privacyStatePlaytime\x12:\n\x19privacy_state_friendslist\x18\x06\x20\
    \x01(\x05R\x17privacyStateFriendslist\"c\n#CPlayer_GetPrivacySettings_Re\
    sponse\x12<\n\x10privacy_settings\x18\x01\x20\x01(\x0b2\x11.CPrivacySett\
    ingsR\x0fprivacySettings\":\n\"CPlayer_GetDurationControl_Request\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\x83\x01\n#CPlayer_GetDura\
    tionControl_Response\x12\x1d\n\nis_enabled\x18\x01\x20\x01(\x08R\tisEnab\
    led\x12\x18\n\x07seconds\x18\x02\x20\x01(\x05R\x07seconds\x12#\n\rsecond\
    s_today\x18\x03\x20\x01(\x05R\x0csecondsToday\"g\n$CPlayer_LastPlayedTim\
    es_Notification\x12?\n\x05games\x18\x01\x20\x03(\x0b2).CPlayer_GetLastPl\
    ayedTimes_Response.GameR\x05games\"\x8d\x01\n*CPlayer_FriendNicknameChan\
    ged_Notification\x12\x1c\n\taccountid\x18\x01\x20\x01(\x07R\taccountid\
    \x12\x1a\n\x08nickname\x18\x02\x20\x01(\tR\x08nickname\x12%\n\x0fis_echo\
    _to_self\x18\x03\x20\x01(\x08R\x0cisEchoToSelf\"\xf2\x01\n.CPlayer_NewSt\
    eamAnnouncementState_Notification\x12\x14\n\x05state\x18\x01\x20\x01(\
    \x05R\x05state\x123\n\x15announcement_headline\x18\x02\x20\x01(\tR\x14an\
    nouncementHeadline\x12)\n\x10announcement_url\x18\x03\x20\x01(\tR\x0fann\
    ouncementUrl\x12\x1f\n\x0btime_posted\x18\x04\x20\x01(\rR\ntimePosted\
    \x12)\n\x10announcement_gid\x18\x05\x20\x01(\x04R\x0fannouncementGid\"s\
    \n0CPlayer_CommunityPreferencesChanged_Notification\x12?\n\x0bpreference\
    s\x18\x01\x20\x01(\x0b2\x1d.CPlayer_CommunityPreferencesR\x0bpreferences\
    \"\x89\x01\n0CPlayer_PerFriendPreferencesChanged_Notification\x12\x1c\n\
    \taccountid\x18\x01\x20\x01(\x07R\taccountid\x127\n\x0bpreferences\x18\
    \x02\x20\x01(\x0b2\x15.PerFriendPreferencesR\x0bpreferences\"k\n+CPlayer\
    _PrivacySettingsChanged_Notification\x12<\n\x10privacy_settings\x18\x01\
    \x20\x01(\x0b2\x11.CPrivacySettingsR\x0fprivacySettings*\x85\x01\n\x14EN\
    otificationSetting\x12*\n&k_ENotificationSettingNotifyUseDefault\x10\0\
    \x12\x20\n\x1ck_ENotificationSettingAlways\x10\x01\x12\x1f\n\x1bk_ENotif\
    icationSettingNever\x10\x022\xf4\x1d\n\x06Player\x12\xef\x01\n\"GetMutua\
    lFriendsForIncomingInvites\x123.CPlayer_GetMutualFriendsForIncomingInvit\
    es_Request\x1a4.CPlayer_GetMutualFriendsForIncomingInvites_Response\"^\
    \x82\xb5\x18ZGet\x20me\x20the\x20mutual\x20friends\x20for\x20each\x20of\
    \x20my\x20pending\x20incoming\x20invites\x20(individuals\x20and\x20clans\
    ).\x12\xb8\x01\n\x16GetFriendsGameplayInfo\x12'.CPlayer_GetFriendsGamepl\
    ayInfo_Request\x1a(.CPlayer_GetFriendsGameplayInfo_Response\"K\x82\xb5\
    \x18GGet\x20a\x20list\x20of\x20friends\x20who\x20are\x20playing,\x20have\
    \x20played,\x20own,\x20or\x20want\x20a\x20game\x12\xae\x01\n\x16GetFrien\
    dsAppsActivity\x12'.CPlayer_GetFriendsAppsActivity_Request\x1a(.CPlayer_\
    GetFriendsAppsActivity_Response\"A\x82\xb5\x18=Get\x20lists\x20of\x20app\
    s\x20friends\x20are\x20active\x20in,\x20in\x20a\x20variety\x20of\x20ways\
    \x12\xb6\x01\n\x12GetGameBadgeLevels\x12#.CPlayer_GetGameBadgeLevels_Req\
    uest\x1a$.CPlayer_GetGameBadgeLevels_Response\"U\x82\xb5\x18QReturns\x20\
    the\x20Steam\x20Level\x20of\x20a\x20user,\x20the\x20Badge\x20level\x20fo\
    r\x20the\x20game,\x20and\x20if\x20it's\x20foil\x12\x91\x01\n\x0fGetEmoti\
    conList\x12\x20.CPlayer_GetEmoticonList_Request\x1a!.CPlayer_GetEmoticon\
    List_Response\"9\x82\xb5\x185Gets\x20a\x20list\x20of\x20the\x20emoticons\
    \x20a\x20user\x20has\x20with\x20metadata\x12\xb9\x01\n\x17GetAchievement\
    sProgress\x12(.CPlayer_GetAchievementsProgress_Request\x1a).CPlayer_GetA\
    chievementsProgress_Response\"I\x82\xb5\x18EGets\x20the\x20achievement\
    \x20completion\x20stats\x20for\x20the\x20specified\x20list\x20of\x20apps\
    .\x12\x91\x01\n\x13PostStatusToFriends\x12$.CPlayer_PostStatusToFriends_\
    Request\x1a%.CPlayer_PostStatusToFriends_Response\"-\x82\xb5\x18)Posts\
    \x20custom\x20status\x20text\x20into\x20the\x20blotter\x12\x86\x01\n\x0f\
    GetPostedStatus\x12\x20.CPlayer_GetPostedStatus_Request\x1a!.CPlayer_Get\
    PostedStatus_Response\".\x82\xb5\x18*Gets\x20a\x20posted\x20status\x20te\
    xt\x20for\x20a\x20user\x20by\x20id\x12\x92\x01\n\x12DeletePostedStatus\
    \x12#.CPlayer_DeletePostedStatus_Request\x1a$.CPlayer_DeletePostedStatus\
    _Response\"1\x82\xb5\x18-Deletes\x20a\x20posted\x20status\x20text\x20for\
    \x20a\x20user\x20by\x20id\x12\x95\x01\n\x18ClientGetLastPlayedTimes\x12#\
    .CPlayer_GetLastPlayedTimes_Request\x1a$.CPlayer_GetLastPlayedTimes_Resp\
    onse\".\x82\xb5\x18*Gets\x20the\x20last-played\x20times\x20for\x20the\
    \x20account\x12c\n\tAcceptSSA\x12\x1a.CPlayer_AcceptSSA_Request\x1a\x1b.\
    CPlayer_AcceptSSA_Response\"\x1d\x82\xb5\x18\x19User\x20is\x20accepting\
    \x20the\x20SSA\x12\x94\x01\n\x0fGetNicknameList\x12\x20.CPlayer_GetNickn\
    ameList_Request\x1a!.CPlayer_GetNicknameList_Response\"<\x82\xb5\x188Get\
    s\x20the\x20list\x20of\x20nicknames\x20this\x20user\x20has\x20for\x20oth\
    er\x20users\x12\xbd\x01\n\x17GetPerFriendPreferences\x12(.CPlayer_GetPer\
    FriendPreferences_Request\x1a).CPlayer_GetPerFriendPreferences_Response\
    \"M\x82\xb5\x18IGets\x20the\x20list\x20of\x20per-friend\x20preferences\
    \x20this\x20user\x20has\x20set\x20for\x20other\x20users\x12\xb7\x01\n\
    \x17SetPerFriendPreferences\x12(.CPlayer_SetPerFriendPreferences_Request\
    \x1a).CPlayer_SetPerFriendPreferences_Response\"G\x82\xb5\x18CSets\x20th\
    e\x20logged\x20in\x20user's\x20per-friend\x20preferences\x20for\x20the\
    \x20given\x20user\x12s\n\tAddFriend\x12\x1a.CPlayer_AddFriend_Request\
    \x1a\x1b.CPlayer_AddFriend_Response\"-\x82\xb5\x18)Invites\x20another\
    \x20Steam\x20user\x20to\x20be\x20a\x20friend\x12\x82\x01\n\x0cRemoveFrie\
    nd\x12\x1d.CPlayer_RemoveFriend_Request\x1a\x1e.CPlayer_RemoveFriend_Res\
    ponse\"3\x82\xb5\x18/Removes\x20a\x20friend\x20or\x20ignores\x20a\x20fri\
    end\x20suggestion\x12\xa6\x01\n\x0cIgnoreFriend\x12\x1d.CPlayer_IgnoreFr\
    iend_Request\x1a\x1e.CPlayer_IgnoreFriend_Response\"W\x82\xb5\x18SBlocks\
    \x20or\x20unblocks\x20communication\x20with\x20the\x20user.\x20\x20Despi\
    te\x20name,\x20can\x20be\x20a\x20non-friend.\x12\x9e\x01\n\x17GetCommuni\
    tyPreferences\x12(.CPlayer_GetCommunityPreferences_Request\x1a).CPlayer_\
    GetCommunityPreferences_Response\".\x82\xb5\x18*Returns\x20the\x20player\
    's\x20community\x20preferences\x12\x9b\x01\n\x17SetCommunityPreferences\
    \x12(.CPlayer_SetCommunityPreferences_Request\x1a).CPlayer_SetCommunityP\
    references_Response\"+\x82\xb5\x18'Sets\x20the\x20player's\x20community\
    \x20preferences\x12\xde\x01\n\x1cGetNewSteamAnnouncementState\x12-.CPlay\
    er_GetNewSteamAnnouncementState_Request\x1a..CPlayer_GetNewSteamAnnounce\
    mentState_Response\"_\x82\xb5\x18[Calculates\x20and\x20returns\x20what\
    \x20to\x20display\x20for\x20UI\x20that\x20renders\x20new\x20steam\x20ann\
    ouncement\x20available\x12\xbc\x01\n\x1fUpdateSteamAnnouncementLastRead\
    \x120.CPlayer_UpdateSteamAnnouncementLastRead_Request\x1a1.CPlayer_Updat\
    eSteamAnnouncementLastRead_Response\"4\x82\xb5\x180Marks\x20latest\x20an\
    nouncement\x20timestamp\x20read\x20by\x20user\x12\x82\x01\n\x12GetPrivac\
    ySettings\x12#.CPlayer_GetPrivacySettings_Request\x1a$.CPlayer_GetPrivac\
    ySettings_Response\"!\x82\xb5\x18\x1dGet\x20current\x20privacy\x20settin\
    gs.\x12\x8c\x01\n\x12GetDurationControl\x12#.CPlayer_GetDurationControl_\
    Request\x1a$.CPlayer_GetDurationControl_Response\"+\x82\xb5\x18'Get\x20g\
    ameplay\x20duration\x20control\x20settings.\x1a-\x82\xb5\x18)A\x20servic\
    e\x20for\x20accessing\x20Steam\x20player\x20data2\xa3\x08\n\x0cPlayerCli\
    ent\x12\x8c\x01\n\x15NotifyLastPlayedTimes\x12%.CPlayer_LastPlayedTimes_\
    Notification\x1a\x0b.NoResponse\"?\x82\xb5\x18;Notification\x20from\x20s\
    erver\x20to\x20client\x20of\x20more\x20recent\x20play\x20time\x12\xa4\
    \x01\n\x1bNotifyFriendNicknameChanged\x12+.CPlayer_FriendNicknameChanged\
    _Notification\x1a\x0b.NoResponse\"K\x82\xb5\x18GNotification\x20from\x20\
    server\x20to\x20client\x20that\x20a\x20friend's\x20nickname\x20has\x20ch\
    anged\x12\xa4\x01\n\x1fNotifyNewSteamAnnouncementState\x12/.CPlayer_NewS\
    teamAnnouncementState_Notification\x1a\x0b.NoResponse\"C\x82\xb5\x18?Not\
    ifies\x20client\x20of\x20changes\x20to\x20steam\x20announcement\x20state\
    \x20for\x20user\x12\xb9\x01\n!NotifyCommunityPreferencesChanged\x121.CPl\
    ayer_CommunityPreferencesChanged_Notification\x1a\x0b.NoResponse\"T\x82\
    \xb5\x18PNotification\x20from\x20server\x20to\x20client\x20that\x20their\
    \x20community\x20preferences\x20have\x20changed\x12\xaa\x01\n!NotifyPerF\
    riendPreferencesChanged\x121.CPlayer_PerFriendPreferencesChanged_Notific\
    ation\x1a\x0b.NoResponse\"E\x82\xb5\x18ANotification\x20from\x20server\
    \x20that\x20per-friend\x20preferences\x20have\x20changed\x12\x9c\x01\n#N\
    otifyPrivacyPrivacySettingsChanged\x12,.CPlayer_PrivacySettingsChanged_N\
    otification\x1a\x0b.NoResponse\":\x82\xb5\x186Notification\x20from\x20se\
    rver\x20that\x20privacy\x20settings\x20changed\x1a.\xc0\xb5\x18\x02\x82\
    \xb5\x18&Steam\x20player\x20data\x20client\x20notificationsB\x03\x80\x01\
    \x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
