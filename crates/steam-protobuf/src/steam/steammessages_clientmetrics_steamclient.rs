// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_clientmetrics.steamclient.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_AppInterfaceCreation {
    // message fields
    raw_version: ::protobuf::SingularField<::std::string::String>,
    requested_interface_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceCreation {
    fn default() -> &'a CClientMetrics_AppInterfaceCreation {
        <CClientMetrics_AppInterfaceCreation as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceCreation {
    pub fn new() -> CClientMetrics_AppInterfaceCreation {
        ::std::default::Default::default()
    }

    // optional string raw_version = 1;


    pub fn get_raw_version(&self) -> &str {
        match self.raw_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_raw_version(&mut self) {
        self.raw_version.clear();
    }

    pub fn has_raw_version(&self) -> bool {
        self.raw_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_version(&mut self, v: ::std::string::String) {
        self.raw_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_version(&mut self) -> &mut ::std::string::String {
        if self.raw_version.is_none() {
            self.raw_version.set_default();
        }
        self.raw_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_version(&mut self) -> ::std::string::String {
        self.raw_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string requested_interface_type = 2;


    pub fn get_requested_interface_type(&self) -> &str {
        match self.requested_interface_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_requested_interface_type(&mut self) {
        self.requested_interface_type.clear();
    }

    pub fn has_requested_interface_type(&self) -> bool {
        self.requested_interface_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requested_interface_type(&mut self, v: ::std::string::String) {
        self.requested_interface_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requested_interface_type(&mut self) -> &mut ::std::string::String {
        if self.requested_interface_type.is_none() {
            self.requested_interface_type.set_default();
        }
        self.requested_interface_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_requested_interface_type(&mut self) -> ::std::string::String {
        self.requested_interface_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceCreation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.raw_version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.requested_interface_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.requested_interface_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.requested_interface_type.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceCreation {
        CClientMetrics_AppInterfaceCreation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "raw_version",
                    |m: &CClientMetrics_AppInterfaceCreation| { &m.raw_version },
                    |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.raw_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "requested_interface_type",
                    |m: &CClientMetrics_AppInterfaceCreation| { &m.requested_interface_type },
                    |m: &mut CClientMetrics_AppInterfaceCreation| { &mut m.requested_interface_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_AppInterfaceCreation>(
                    "CClientMetrics_AppInterfaceCreation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceCreation {
        static mut instance: ::protobuf::lazy::Lazy<CClientMetrics_AppInterfaceCreation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientMetrics_AppInterfaceCreation,
        };
        unsafe {
            instance.get(CClientMetrics_AppInterfaceCreation::new)
        }
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceCreation {
    fn clear(&mut self) {
        self.raw_version.clear();
        self.requested_interface_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceCreation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_AppInterfaceMethodCounts {
    // message fields
    interface_name: ::protobuf::SingularField<::std::string::String>,
    method_name: ::protobuf::SingularField<::std::string::String>,
    call_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceMethodCounts {
    fn default() -> &'a CClientMetrics_AppInterfaceMethodCounts {
        <CClientMetrics_AppInterfaceMethodCounts as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceMethodCounts {
    pub fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        ::std::default::Default::default()
    }

    // optional string interface_name = 1;


    pub fn get_interface_name(&self) -> &str {
        match self.interface_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_interface_name(&mut self) {
        self.interface_name.clear();
    }

    pub fn has_interface_name(&self) -> bool {
        self.interface_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_name(&mut self, v: ::std::string::String) {
        self.interface_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interface_name(&mut self) -> &mut ::std::string::String {
        if self.interface_name.is_none() {
            self.interface_name.set_default();
        }
        self.interface_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_interface_name(&mut self) -> ::std::string::String {
        self.interface_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string method_name = 2;


    pub fn get_method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name.set_default();
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 call_count = 3;


    pub fn get_call_count(&self) -> u32 {
        self.call_count.unwrap_or(0)
    }
    pub fn clear_call_count(&mut self) {
        self.call_count = ::std::option::Option::None;
    }

    pub fn has_call_count(&self) -> bool {
        self.call_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_count(&mut self, v: u32) {
        self.call_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceMethodCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.interface_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.method_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.call_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.interface_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.call_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.interface_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.method_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.call_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceMethodCounts {
        CClientMetrics_AppInterfaceMethodCounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "interface_name",
                    |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.interface_name },
                    |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.interface_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "method_name",
                    |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.method_name },
                    |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.method_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "call_count",
                    |m: &CClientMetrics_AppInterfaceMethodCounts| { &m.call_count },
                    |m: &mut CClientMetrics_AppInterfaceMethodCounts| { &mut m.call_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_AppInterfaceMethodCounts>(
                    "CClientMetrics_AppInterfaceMethodCounts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceMethodCounts {
        static mut instance: ::protobuf::lazy::Lazy<CClientMetrics_AppInterfaceMethodCounts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientMetrics_AppInterfaceMethodCounts,
        };
        unsafe {
            instance.get(CClientMetrics_AppInterfaceMethodCounts::new)
        }
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceMethodCounts {
    fn clear(&mut self) {
        self.interface_name.clear();
        self.method_name.clear();
        self.call_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceMethodCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceMethodCounts {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_AppInterfaceStats_Notification {
    // message fields
    game_id: ::std::option::Option<u64>,
    interfaces_created: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation>,
    methods_called: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts>,
    session_length_seconds: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_AppInterfaceStats_Notification {
    fn default() -> &'a CClientMetrics_AppInterfaceStats_Notification {
        <CClientMetrics_AppInterfaceStats_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_AppInterfaceStats_Notification {
    pub fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 game_id = 1;


    pub fn get_game_id(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_AppInterfaceCreation interfaces_created = 2;


    pub fn get_interfaces_created(&self) -> &[CClientMetrics_AppInterfaceCreation] {
        &self.interfaces_created
    }
    pub fn clear_interfaces_created(&mut self) {
        self.interfaces_created.clear();
    }

    // Param is passed by value, moved
    pub fn set_interfaces_created(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation>) {
        self.interfaces_created = v;
    }

    // Mutable pointer to the field.
    pub fn mut_interfaces_created(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation> {
        &mut self.interfaces_created
    }

    // Take field
    pub fn take_interfaces_created(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_AppInterfaceCreation> {
        ::std::mem::replace(&mut self.interfaces_created, ::protobuf::RepeatedField::new())
    }

    // repeated .CClientMetrics_AppInterfaceMethodCounts methods_called = 3;


    pub fn get_methods_called(&self) -> &[CClientMetrics_AppInterfaceMethodCounts] {
        &self.methods_called
    }
    pub fn clear_methods_called(&mut self) {
        self.methods_called.clear();
    }

    // Param is passed by value, moved
    pub fn set_methods_called(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts>) {
        self.methods_called = v;
    }

    // Mutable pointer to the field.
    pub fn mut_methods_called(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts> {
        &mut self.methods_called
    }

    // Take field
    pub fn take_methods_called(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_AppInterfaceMethodCounts> {
        ::std::mem::replace(&mut self.methods_called, ::protobuf::RepeatedField::new())
    }

    // optional uint32 session_length_seconds = 4;


    pub fn get_session_length_seconds(&self) -> u32 {
        self.session_length_seconds.unwrap_or(0)
    }
    pub fn clear_session_length_seconds(&mut self) {
        self.session_length_seconds = ::std::option::Option::None;
    }

    pub fn has_session_length_seconds(&self) -> bool {
        self.session_length_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_seconds(&mut self, v: u32) {
        self.session_length_seconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_AppInterfaceStats_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.interfaces_created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.methods_called {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.interfaces_created)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.methods_called)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session_length_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.interfaces_created {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.methods_called {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.session_length_seconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.interfaces_created {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.methods_called {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.session_length_seconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_AppInterfaceStats_Notification {
        CClientMetrics_AppInterfaceStats_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "game_id",
                    |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.game_id },
                    |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.game_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_AppInterfaceCreation>>(
                    "interfaces_created",
                    |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.interfaces_created },
                    |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.interfaces_created },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_AppInterfaceMethodCounts>>(
                    "methods_called",
                    |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.methods_called },
                    |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.methods_called },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "session_length_seconds",
                    |m: &CClientMetrics_AppInterfaceStats_Notification| { &m.session_length_seconds },
                    |m: &mut CClientMetrics_AppInterfaceStats_Notification| { &mut m.session_length_seconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_AppInterfaceStats_Notification>(
                    "CClientMetrics_AppInterfaceStats_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClientMetrics_AppInterfaceStats_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CClientMetrics_AppInterfaceStats_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientMetrics_AppInterfaceStats_Notification,
        };
        unsafe {
            instance.get(CClientMetrics_AppInterfaceStats_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CClientMetrics_AppInterfaceStats_Notification {
    fn clear(&mut self) {
        self.game_id = ::std::option::Option::None;
        self.interfaces_created.clear();
        self.methods_called.clear();
        self.session_length_seconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_AppInterfaceStats_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_AppInterfaceStats_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_IPv6Connectivity_Result {
    // message fields
    protocol_tested: ::std::option::Option<u32>,
    connectivity_state: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Result {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Result {
        <CClientMetrics_IPv6Connectivity_Result as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Result {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Result {
        ::std::default::Default::default()
    }

    // optional uint32 protocol_tested = 1;


    pub fn get_protocol_tested(&self) -> u32 {
        self.protocol_tested.unwrap_or(0)
    }
    pub fn clear_protocol_tested(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
    }

    pub fn has_protocol_tested(&self) -> bool {
        self.protocol_tested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_tested(&mut self, v: u32) {
        self.protocol_tested = ::std::option::Option::Some(v);
    }

    // optional uint32 connectivity_state = 2;


    pub fn get_connectivity_state(&self) -> u32 {
        self.connectivity_state.unwrap_or(0)
    }
    pub fn clear_connectivity_state(&mut self) {
        self.connectivity_state = ::std::option::Option::None;
    }

    pub fn has_connectivity_state(&self) -> bool {
        self.connectivity_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectivity_state(&mut self, v: u32) {
        self.connectivity_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.protocol_tested = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connectivity_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_tested {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.connectivity_state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_tested {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connectivity_state {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Result {
        CClientMetrics_IPv6Connectivity_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "protocol_tested",
                    |m: &CClientMetrics_IPv6Connectivity_Result| { &m.protocol_tested },
                    |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.protocol_tested },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "connectivity_state",
                    |m: &CClientMetrics_IPv6Connectivity_Result| { &m.connectivity_state },
                    |m: &mut CClientMetrics_IPv6Connectivity_Result| { &mut m.connectivity_state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_IPv6Connectivity_Result>(
                    "CClientMetrics_IPv6Connectivity_Result",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Result {
        static mut instance: ::protobuf::lazy::Lazy<CClientMetrics_IPv6Connectivity_Result> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientMetrics_IPv6Connectivity_Result,
        };
        unsafe {
            instance.get(CClientMetrics_IPv6Connectivity_Result::new)
        }
    }
}

impl ::protobuf::Clear for CClientMetrics_IPv6Connectivity_Result {
    fn clear(&mut self) {
        self.protocol_tested = ::std::option::Option::None;
        self.connectivity_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_IPv6Connectivity_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClientMetrics_IPv6Connectivity_Notification {
    // message fields
    cell_id: ::std::option::Option<u32>,
    results: ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientMetrics_IPv6Connectivity_Notification {
    fn default() -> &'a CClientMetrics_IPv6Connectivity_Notification {
        <CClientMetrics_IPv6Connectivity_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CClientMetrics_IPv6Connectivity_Notification {
    pub fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // repeated .CClientMetrics_IPv6Connectivity_Result results = 2;


    pub fn get_results(&self) -> &[CClientMetrics_IPv6Connectivity_Result] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<CClientMetrics_IPv6Connectivity_Result> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CClientMetrics_IPv6Connectivity_Notification {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientMetrics_IPv6Connectivity_Notification {
        CClientMetrics_IPv6Connectivity_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cell_id",
                    |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.cell_id },
                    |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.cell_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CClientMetrics_IPv6Connectivity_Result>>(
                    "results",
                    |m: &CClientMetrics_IPv6Connectivity_Notification| { &m.results },
                    |m: &mut CClientMetrics_IPv6Connectivity_Notification| { &mut m.results },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CClientMetrics_IPv6Connectivity_Notification>(
                    "CClientMetrics_IPv6Connectivity_Notification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CClientMetrics_IPv6Connectivity_Notification {
        static mut instance: ::protobuf::lazy::Lazy<CClientMetrics_IPv6Connectivity_Notification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CClientMetrics_IPv6Connectivity_Notification,
        };
        unsafe {
            instance.get(CClientMetrics_IPv6Connectivity_Notification::new)
        }
    }
}

impl ::protobuf::Clear for CClientMetrics_IPv6Connectivity_Notification {
    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientMetrics_IPv6Connectivity_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientMetrics_IPv6Connectivity_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-steammessages_clientmetrics.steamclient.proto\x1a,steammessages_unifi\
    ed_base.steamclient.proto\"\x80\x01\n#CClientMetrics_AppInterfaceCreatio\
    n\x12\x1f\n\x0braw_version\x18\x01\x20\x01(\tR\nrawVersion\x128\n\x18req\
    uested_interface_type\x18\x02\x20\x01(\tR\x16requestedInterfaceType\"\
    \x90\x01\n'CClientMetrics_AppInterfaceMethodCounts\x12%\n\x0einterface_n\
    ame\x18\x01\x20\x01(\tR\rinterfaceName\x12\x1f\n\x0bmethod_name\x18\x02\
    \x20\x01(\tR\nmethodName\x12\x1d\n\ncall_count\x18\x03\x20\x01(\rR\tcall\
    Count\"\xa4\x02\n-CClientMetrics_AppInterfaceStats_Notification\x12\x17\
    \n\x07game_id\x18\x01\x20\x01(\x04R\x06gameId\x12S\n\x12interfaces_creat\
    ed\x18\x02\x20\x03(\x0b2$.CClientMetrics_AppInterfaceCreationR\x11interf\
    acesCreated\x12O\n\x0emethods_called\x18\x03\x20\x03(\x0b2(.CClientMetri\
    cs_AppInterfaceMethodCountsR\rmethodsCalled\x124\n\x16session_length_sec\
    onds\x18\x04\x20\x01(\rR\x14sessionLengthSeconds\"\x80\x01\n&CClientMetr\
    ics_IPv6Connectivity_Result\x12'\n\x0fprotocol_tested\x18\x01\x20\x01(\r\
    R\x0eprotocolTested\x12-\n\x12connectivity_state\x18\x02\x20\x01(\rR\x11\
    connectivityState\"\x8a\x01\n,CClientMetrics_IPv6Connectivity_Notificati\
    on\x12\x17\n\x07cell_id\x18\x01\x20\x01(\rR\x06cellId\x12A\n\x07results\
    \x18\x02\x20\x03(\x0b2'.CClientMetrics_IPv6Connectivity_ResultR\x07resul\
    ts2\xf4\x01\n\rClientMetrics\x12\\\n\x1dClientAppInterfaceStatsReport\
    \x12..CClientMetrics_AppInterfaceStats_Notification\x1a\x0b.NoResponse\
    \x12Z\n\x1cClientIPv6ConnectivityReport\x12-.CClientMetrics_IPv6Connecti\
    vity_Notification\x1a\x0b.NoResponse\x1a)\x82\xb5\x18%A\x20service\x20fo\
    r\x20client-reported\x20metricsB\x03\x80\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
