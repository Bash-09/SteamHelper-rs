// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `stream.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct CDiscoveryPingRequest {
    // message fields
    sequence: ::std::option::Option<u32>,
    packet_size_requested: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingRequest {
    fn default() -> &'a CDiscoveryPingRequest {
        <CDiscoveryPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CDiscoveryPingRequest {
    pub fn new() -> CDiscoveryPingRequest {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;


    pub fn get_sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_requested = 2;


    pub fn get_packet_size_requested(&self) -> u32 {
        self.packet_size_requested.unwrap_or(0)
    }
    pub fn clear_packet_size_requested(&mut self) {
        self.packet_size_requested = ::std::option::Option::None;
    }

    pub fn has_packet_size_requested(&self) -> bool {
        self.packet_size_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_requested(&mut self, v: u32) {
        self.packet_size_requested = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDiscoveryPingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequence = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packet_size_requested = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packet_size_requested {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_requested {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDiscoveryPingRequest {
        CDiscoveryPingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sequence",
                |m: &CDiscoveryPingRequest| { &m.sequence },
                |m: &mut CDiscoveryPingRequest| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packet_size_requested",
                |m: &CDiscoveryPingRequest| { &m.packet_size_requested },
                |m: &mut CDiscoveryPingRequest| { &mut m.packet_size_requested },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CDiscoveryPingRequest>(
                "CDiscoveryPingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDiscoveryPingRequest {
        static instance: ::protobuf::rt::LazyV2<CDiscoveryPingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CDiscoveryPingRequest::new)
    }
}

impl ::protobuf::Clear for CDiscoveryPingRequest {
    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_requested = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDiscoveryPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDiscoveryPingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDiscoveryPingResponse {
    // message fields
    sequence: ::std::option::Option<u32>,
    packet_size_received: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingResponse {
    fn default() -> &'a CDiscoveryPingResponse {
        <CDiscoveryPingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CDiscoveryPingResponse {
    pub fn new() -> CDiscoveryPingResponse {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;


    pub fn get_sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_received = 2;


    pub fn get_packet_size_received(&self) -> u32 {
        self.packet_size_received.unwrap_or(0)
    }
    pub fn clear_packet_size_received(&mut self) {
        self.packet_size_received = ::std::option::Option::None;
    }

    pub fn has_packet_size_received(&self) -> bool {
        self.packet_size_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_received(&mut self, v: u32) {
        self.packet_size_received = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDiscoveryPingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sequence = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packet_size_received = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packet_size_received {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_received {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDiscoveryPingResponse {
        CDiscoveryPingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sequence",
                |m: &CDiscoveryPingResponse| { &m.sequence },
                |m: &mut CDiscoveryPingResponse| { &mut m.sequence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packet_size_received",
                |m: &CDiscoveryPingResponse| { &m.packet_size_received },
                |m: &mut CDiscoveryPingResponse| { &mut m.packet_size_received },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CDiscoveryPingResponse>(
                "CDiscoveryPingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDiscoveryPingResponse {
        static instance: ::protobuf::rt::LazyV2<CDiscoveryPingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CDiscoveryPingResponse::new)
    }
}

impl ::protobuf::Clear for CDiscoveryPingResponse {
    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_received = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDiscoveryPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDiscoveryPingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientHandshakeInfo {
    // message fields
    network_test: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingClientHandshakeInfo {
    fn default() -> &'a CStreamingClientHandshakeInfo {
        <CStreamingClientHandshakeInfo as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientHandshakeInfo {
    pub fn new() -> CStreamingClientHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 network_test = 2;


    pub fn get_network_test(&self) -> i32 {
        self.network_test.unwrap_or(0)
    }
    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: i32) {
        self.network_test = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientHandshakeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.network_test = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.network_test {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.network_test {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingClientHandshakeInfo {
        CStreamingClientHandshakeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "network_test",
                |m: &CStreamingClientHandshakeInfo| { &m.network_test },
                |m: &mut CStreamingClientHandshakeInfo| { &mut m.network_test },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingClientHandshakeInfo>(
                "CStreamingClientHandshakeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingClientHandshakeInfo {
        static instance: ::protobuf::rt::LazyV2<CStreamingClientHandshakeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingClientHandshakeInfo::new)
    }
}

impl ::protobuf::Clear for CStreamingClientHandshakeInfo {
    fn clear(&mut self) {
        self.network_test = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientHandshakeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientHandshakeMsg {
    // message fields
    pub info: ::protobuf::SingularPtrField<CStreamingClientHandshakeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientHandshakeMsg {
    fn default() -> &'a CClientHandshakeMsg {
        <CClientHandshakeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CClientHandshakeMsg {
    pub fn new() -> CClientHandshakeMsg {
        ::std::default::Default::default()
    }

    // required .CStreamingClientHandshakeInfo info = 1;


    pub fn get_info(&self) -> &CStreamingClientHandshakeInfo {
        self.info.as_ref().unwrap_or_else(|| <CStreamingClientHandshakeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CStreamingClientHandshakeInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CStreamingClientHandshakeInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CStreamingClientHandshakeInfo {
        self.info.take().unwrap_or_else(|| CStreamingClientHandshakeInfo::new())
    }
}

impl ::protobuf::Message for CClientHandshakeMsg {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientHandshakeMsg {
        CClientHandshakeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientHandshakeInfo>>(
                "info",
                |m: &CClientHandshakeMsg| { &m.info },
                |m: &mut CClientHandshakeMsg| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClientHandshakeMsg>(
                "CClientHandshakeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientHandshakeMsg {
        static instance: ::protobuf::rt::LazyV2<CClientHandshakeMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClientHandshakeMsg::new)
    }
}

impl ::protobuf::Clear for CClientHandshakeMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientHandshakeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingServerHandshakeInfo {
    // message fields
    mtu: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingServerHandshakeInfo {
    fn default() -> &'a CStreamingServerHandshakeInfo {
        <CStreamingServerHandshakeInfo as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingServerHandshakeInfo {
    pub fn new() -> CStreamingServerHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 mtu = 1;


    pub fn get_mtu(&self) -> i32 {
        self.mtu.unwrap_or(0)
    }
    pub fn clear_mtu(&mut self) {
        self.mtu = ::std::option::Option::None;
    }

    pub fn has_mtu(&self) -> bool {
        self.mtu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtu(&mut self, v: i32) {
        self.mtu = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingServerHandshakeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mtu = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mtu {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mtu {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingServerHandshakeInfo {
        CStreamingServerHandshakeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mtu",
                |m: &CStreamingServerHandshakeInfo| { &m.mtu },
                |m: &mut CStreamingServerHandshakeInfo| { &mut m.mtu },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingServerHandshakeInfo>(
                "CStreamingServerHandshakeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingServerHandshakeInfo {
        static instance: ::protobuf::rt::LazyV2<CStreamingServerHandshakeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingServerHandshakeInfo::new)
    }
}

impl ::protobuf::Clear for CStreamingServerHandshakeInfo {
    fn clear(&mut self) {
        self.mtu = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingServerHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingServerHandshakeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CServerHandshakeMsg {
    // message fields
    pub info: ::protobuf::SingularPtrField<CStreamingServerHandshakeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CServerHandshakeMsg {
    fn default() -> &'a CServerHandshakeMsg {
        <CServerHandshakeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CServerHandshakeMsg {
    pub fn new() -> CServerHandshakeMsg {
        ::std::default::Default::default()
    }

    // required .CStreamingServerHandshakeInfo info = 1;


    pub fn get_info(&self) -> &CStreamingServerHandshakeInfo {
        self.info.as_ref().unwrap_or_else(|| <CStreamingServerHandshakeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CStreamingServerHandshakeInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CStreamingServerHandshakeInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CStreamingServerHandshakeInfo {
        self.info.take().unwrap_or_else(|| CStreamingServerHandshakeInfo::new())
    }
}

impl ::protobuf::Message for CServerHandshakeMsg {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CServerHandshakeMsg {
        CServerHandshakeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingServerHandshakeInfo>>(
                "info",
                |m: &CServerHandshakeMsg| { &m.info },
                |m: &mut CServerHandshakeMsg| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CServerHandshakeMsg>(
                "CServerHandshakeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CServerHandshakeMsg {
        static instance: ::protobuf::rt::LazyV2<CServerHandshakeMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CServerHandshakeMsg::new)
    }
}

impl ::protobuf::Clear for CServerHandshakeMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CServerHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CServerHandshakeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAuthenticationRequestMsg {
    // message fields
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version: ::std::option::Option<EStreamVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAuthenticationRequestMsg {
    fn default() -> &'a CAuthenticationRequestMsg {
        <CAuthenticationRequestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CAuthenticationRequestMsg {
    pub fn new() -> CAuthenticationRequestMsg {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EStreamVersion version = 2;


    pub fn get_version(&self) -> EStreamVersion {
        self.version.unwrap_or(EStreamVersion::k_EStreamVersionNone)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAuthenticationRequestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.version, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAuthenticationRequestMsg {
        CAuthenticationRequestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CAuthenticationRequestMsg| { &m.token },
                |m: &mut CAuthenticationRequestMsg| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVersion>>(
                "version",
                |m: &CAuthenticationRequestMsg| { &m.version },
                |m: &mut CAuthenticationRequestMsg| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAuthenticationRequestMsg>(
                "CAuthenticationRequestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAuthenticationRequestMsg {
        static instance: ::protobuf::rt::LazyV2<CAuthenticationRequestMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAuthenticationRequestMsg::new)
    }
}

impl ::protobuf::Clear for CAuthenticationRequestMsg {
    fn clear(&mut self) {
        self.token.clear();
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAuthenticationRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationRequestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAuthenticationResponseMsg {
    // message fields
    result: ::std::option::Option<CAuthenticationResponseMsg_AuthenticationResult>,
    version: ::std::option::Option<EStreamVersion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAuthenticationResponseMsg {
    fn default() -> &'a CAuthenticationResponseMsg {
        <CAuthenticationResponseMsg as ::protobuf::Message>::default_instance()
    }
}

impl CAuthenticationResponseMsg {
    pub fn new() -> CAuthenticationResponseMsg {
        ::std::default::Default::default()
    }

    // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1;


    pub fn get_result(&self) -> CAuthenticationResponseMsg_AuthenticationResult {
        self.result.unwrap_or(CAuthenticationResponseMsg_AuthenticationResult::SUCCEEDED)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CAuthenticationResponseMsg_AuthenticationResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional .EStreamVersion version = 2;


    pub fn get_version(&self) -> EStreamVersion {
        self.version.unwrap_or(EStreamVersion::k_EStreamVersionNone)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAuthenticationResponseMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.version, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAuthenticationResponseMsg {
        CAuthenticationResponseMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CAuthenticationResponseMsg_AuthenticationResult>>(
                "result",
                |m: &CAuthenticationResponseMsg| { &m.result },
                |m: &mut CAuthenticationResponseMsg| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVersion>>(
                "version",
                |m: &CAuthenticationResponseMsg| { &m.version },
                |m: &mut CAuthenticationResponseMsg| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAuthenticationResponseMsg>(
                "CAuthenticationResponseMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAuthenticationResponseMsg {
        static instance: ::protobuf::rt::LazyV2<CAuthenticationResponseMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAuthenticationResponseMsg::new)
    }
}

impl ::protobuf::Clear for CAuthenticationResponseMsg {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAuthenticationResponseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationResponseMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CAuthenticationResponseMsg_AuthenticationResult {
    SUCCEEDED = 0,
    FAILED = 1,
}

impl ::protobuf::ProtobufEnum for CAuthenticationResponseMsg_AuthenticationResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CAuthenticationResponseMsg_AuthenticationResult> {
        match value {
            0 => ::std::option::Option::Some(CAuthenticationResponseMsg_AuthenticationResult::SUCCEEDED),
            1 => ::std::option::Option::Some(CAuthenticationResponseMsg_AuthenticationResult::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CAuthenticationResponseMsg_AuthenticationResult] = &[
            CAuthenticationResponseMsg_AuthenticationResult::SUCCEEDED,
            CAuthenticationResponseMsg_AuthenticationResult::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CAuthenticationResponseMsg_AuthenticationResult>("CAuthenticationResponseMsg.AuthenticationResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CAuthenticationResponseMsg_AuthenticationResult {
}

impl ::std::default::Default for CAuthenticationResponseMsg_AuthenticationResult {
    fn default() -> Self {
        CAuthenticationResponseMsg_AuthenticationResult::SUCCEEDED
    }
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationResponseMsg_AuthenticationResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CKeepAliveMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CKeepAliveMsg {
    fn default() -> &'a CKeepAliveMsg {
        <CKeepAliveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CKeepAliveMsg {
    pub fn new() -> CKeepAliveMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CKeepAliveMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CKeepAliveMsg {
        CKeepAliveMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CKeepAliveMsg>(
                "CKeepAliveMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CKeepAliveMsg {
        static instance: ::protobuf::rt::LazyV2<CKeepAliveMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CKeepAliveMsg::new)
    }
}

impl ::protobuf::Clear for CKeepAliveMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CKeepAliveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CKeepAliveMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartNetworkTestMsg {
    // message fields
    frames: ::std::option::Option<u32>,
    framerate: ::std::option::Option<u32>,
    bitrate_kbps: ::std::option::Option<u32>,
    burst_bitrate_kbps: ::std::option::Option<u32>,
    bandwidth_test: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStartNetworkTestMsg {
    fn default() -> &'a CStartNetworkTestMsg {
        <CStartNetworkTestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartNetworkTestMsg {
    pub fn new() -> CStartNetworkTestMsg {
        ::std::default::Default::default()
    }

    // optional uint32 frames = 1;


    pub fn get_frames(&self) -> u32 {
        self.frames.unwrap_or(0)
    }
    pub fn clear_frames(&mut self) {
        self.frames = ::std::option::Option::None;
    }

    pub fn has_frames(&self) -> bool {
        self.frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frames(&mut self, v: u32) {
        self.frames = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate = 2;


    pub fn get_framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }
    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 bitrate_kbps = 3;


    pub fn get_bitrate_kbps(&self) -> u32 {
        self.bitrate_kbps.unwrap_or(0)
    }
    pub fn clear_bitrate_kbps(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_bitrate_kbps(&self) -> bool {
        self.bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate_kbps(&mut self, v: u32) {
        self.bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 burst_bitrate_kbps = 4;


    pub fn get_burst_bitrate_kbps(&self) -> u32 {
        self.burst_bitrate_kbps.unwrap_or(0)
    }
    pub fn clear_burst_bitrate_kbps(&mut self) {
        self.burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_burst_bitrate_kbps(&self) -> bool {
        self.burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burst_bitrate_kbps(&mut self, v: u32) {
        self.burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool bandwidth_test = 5;


    pub fn get_bandwidth_test(&self) -> bool {
        self.bandwidth_test.unwrap_or(false)
    }
    pub fn clear_bandwidth_test(&mut self) {
        self.bandwidth_test = ::std::option::Option::None;
    }

    pub fn has_bandwidth_test(&self) -> bool {
        self.bandwidth_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth_test(&mut self, v: bool) {
        self.bandwidth_test = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartNetworkTestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frames = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.framerate = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.burst_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bandwidth_test = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frames {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bitrate_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.burst_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bandwidth_test {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frames {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bitrate_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.burst_bitrate_kbps {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bandwidth_test {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStartNetworkTestMsg {
        CStartNetworkTestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frames",
                |m: &CStartNetworkTestMsg| { &m.frames },
                |m: &mut CStartNetworkTestMsg| { &mut m.frames },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "framerate",
                |m: &CStartNetworkTestMsg| { &m.framerate },
                |m: &mut CStartNetworkTestMsg| { &mut m.framerate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bitrate_kbps",
                |m: &CStartNetworkTestMsg| { &m.bitrate_kbps },
                |m: &mut CStartNetworkTestMsg| { &mut m.bitrate_kbps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "burst_bitrate_kbps",
                |m: &CStartNetworkTestMsg| { &m.burst_bitrate_kbps },
                |m: &mut CStartNetworkTestMsg| { &mut m.burst_bitrate_kbps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bandwidth_test",
                |m: &CStartNetworkTestMsg| { &m.bandwidth_test },
                |m: &mut CStartNetworkTestMsg| { &mut m.bandwidth_test },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStartNetworkTestMsg>(
                "CStartNetworkTestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStartNetworkTestMsg {
        static instance: ::protobuf::rt::LazyV2<CStartNetworkTestMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStartNetworkTestMsg::new)
    }
}

impl ::protobuf::Clear for CStartNetworkTestMsg {
    fn clear(&mut self) {
        self.frames = ::std::option::Option::None;
        self.framerate = ::std::option::Option::None;
        self.bitrate_kbps = ::std::option::Option::None;
        self.burst_bitrate_kbps = ::std::option::Option::None;
        self.bandwidth_test = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartNetworkTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartNetworkTestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamVideoMode {
    // message fields
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    refresh_rate: ::std::option::Option<u32>,
    refresh_rate_numerator: ::std::option::Option<u32>,
    refresh_rate_denominator: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamVideoMode {
    fn default() -> &'a CStreamVideoMode {
        <CStreamVideoMode as ::protobuf::Message>::default_instance()
    }
}

impl CStreamVideoMode {
    pub fn new() -> CStreamVideoMode {
        ::std::default::Default::default()
    }

    // required uint32 width = 1;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required uint32 height = 2;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate = 3;


    pub fn get_refresh_rate(&self) -> u32 {
        self.refresh_rate.unwrap_or(0)
    }
    pub fn clear_refresh_rate(&mut self) {
        self.refresh_rate = ::std::option::Option::None;
    }

    pub fn has_refresh_rate(&self) -> bool {
        self.refresh_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate(&mut self, v: u32) {
        self.refresh_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_numerator = 4;


    pub fn get_refresh_rate_numerator(&self) -> u32 {
        self.refresh_rate_numerator.unwrap_or(0)
    }
    pub fn clear_refresh_rate_numerator(&mut self) {
        self.refresh_rate_numerator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_numerator(&self) -> bool {
        self.refresh_rate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_numerator(&mut self, v: u32) {
        self.refresh_rate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_denominator = 5;


    pub fn get_refresh_rate_denominator(&self) -> u32 {
        self.refresh_rate_denominator.unwrap_or(0)
    }
    pub fn clear_refresh_rate_denominator(&mut self) {
        self.refresh_rate_denominator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_denominator(&self) -> bool {
        self.refresh_rate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_denominator(&mut self, v: u32) {
        self.refresh_rate_denominator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamVideoMode {
    fn is_initialized(&self) -> bool {
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.refresh_rate = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.refresh_rate_numerator = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.refresh_rate_denominator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refresh_rate {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refresh_rate_numerator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refresh_rate_denominator {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.refresh_rate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.refresh_rate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.refresh_rate_denominator {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamVideoMode {
        CStreamVideoMode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "width",
                |m: &CStreamVideoMode| { &m.width },
                |m: &mut CStreamVideoMode| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &CStreamVideoMode| { &m.height },
                |m: &mut CStreamVideoMode| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "refresh_rate",
                |m: &CStreamVideoMode| { &m.refresh_rate },
                |m: &mut CStreamVideoMode| { &mut m.refresh_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "refresh_rate_numerator",
                |m: &CStreamVideoMode| { &m.refresh_rate_numerator },
                |m: &mut CStreamVideoMode| { &mut m.refresh_rate_numerator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "refresh_rate_denominator",
                |m: &CStreamVideoMode| { &m.refresh_rate_denominator },
                |m: &mut CStreamVideoMode| { &mut m.refresh_rate_denominator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamVideoMode>(
                "CStreamVideoMode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamVideoMode {
        static instance: ::protobuf::rt::LazyV2<CStreamVideoMode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamVideoMode::new)
    }
}

impl ::protobuf::Clear for CStreamVideoMode {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.refresh_rate = ::std::option::Option::None;
        self.refresh_rate_numerator = ::std::option::Option::None;
        self.refresh_rate_denominator = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamVideoMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamVideoMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientCaps {
    // message fields
    system_info: ::protobuf::SingularField<::std::string::String>,
    system_can_suspend: ::std::option::Option<bool>,
    maximum_decode_bitrate_kbps: ::std::option::Option<i32>,
    maximum_burst_bitrate_kbps: ::std::option::Option<i32>,
    supports_video_hevc: ::std::option::Option<bool>,
    disable_steam_store: ::std::option::Option<bool>,
    disable_client_cursor: ::std::option::Option<bool>,
    disable_intel_hardware_encoding: ::std::option::Option<bool>,
    disable_amd_hardware_encoding: ::std::option::Option<bool>,
    disable_nvidia_hardware_encoding: ::std::option::Option<bool>,
    form_factor: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingClientCaps {
    fn default() -> &'a CStreamingClientCaps {
        <CStreamingClientCaps as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientCaps {
    pub fn new() -> CStreamingClientCaps {
        ::std::default::Default::default()
    }

    // optional string system_info = 1;


    pub fn get_system_info(&self) -> &str {
        match self.system_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_system_info(&mut self) {
        self.system_info.clear();
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::string::String) {
        self.system_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::string::String {
        if self.system_info.is_none() {
            self.system_info.set_default();
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::string::String {
        self.system_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool system_can_suspend = 2;


    pub fn get_system_can_suspend(&self) -> bool {
        self.system_can_suspend.unwrap_or(false)
    }
    pub fn clear_system_can_suspend(&mut self) {
        self.system_can_suspend = ::std::option::Option::None;
    }

    pub fn has_system_can_suspend(&self) -> bool {
        self.system_can_suspend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_can_suspend(&mut self, v: bool) {
        self.system_can_suspend = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_decode_bitrate_kbps = 3;


    pub fn get_maximum_decode_bitrate_kbps(&self) -> i32 {
        self.maximum_decode_bitrate_kbps.unwrap_or(0)
    }
    pub fn clear_maximum_decode_bitrate_kbps(&mut self) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_decode_bitrate_kbps(&self) -> bool {
        self.maximum_decode_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_decode_bitrate_kbps(&mut self, v: i32) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_burst_bitrate_kbps = 4;


    pub fn get_maximum_burst_bitrate_kbps(&self) -> i32 {
        self.maximum_burst_bitrate_kbps.unwrap_or(0)
    }
    pub fn clear_maximum_burst_bitrate_kbps(&mut self) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_burst_bitrate_kbps(&self) -> bool {
        self.maximum_burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_burst_bitrate_kbps(&mut self, v: i32) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool supports_video_hevc = 5;


    pub fn get_supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.unwrap_or(false)
    }
    pub fn clear_supports_video_hevc(&mut self) {
        self.supports_video_hevc = ::std::option::Option::None;
    }

    pub fn has_supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_video_hevc(&mut self, v: bool) {
        self.supports_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool disable_steam_store = 6;


    pub fn get_disable_steam_store(&self) -> bool {
        self.disable_steam_store.unwrap_or(false)
    }
    pub fn clear_disable_steam_store(&mut self) {
        self.disable_steam_store = ::std::option::Option::None;
    }

    pub fn has_disable_steam_store(&self) -> bool {
        self.disable_steam_store.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_steam_store(&mut self, v: bool) {
        self.disable_steam_store = ::std::option::Option::Some(v);
    }

    // optional bool disable_client_cursor = 7;


    pub fn get_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.unwrap_or(false)
    }
    pub fn clear_disable_client_cursor(&mut self) {
        self.disable_client_cursor = ::std::option::Option::None;
    }

    pub fn has_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_client_cursor(&mut self, v: bool) {
        self.disable_client_cursor = ::std::option::Option::Some(v);
    }

    // optional bool disable_intel_hardware_encoding = 8;


    pub fn get_disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.unwrap_or(false)
    }
    pub fn clear_disable_intel_hardware_encoding(&mut self) {
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_intel_hardware_encoding(&mut self, v: bool) {
        self.disable_intel_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_amd_hardware_encoding = 9;


    pub fn get_disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.unwrap_or(false)
    }
    pub fn clear_disable_amd_hardware_encoding(&mut self) {
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_amd_hardware_encoding(&mut self, v: bool) {
        self.disable_amd_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_nvidia_hardware_encoding = 10;


    pub fn get_disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.unwrap_or(false)
    }
    pub fn clear_disable_nvidia_hardware_encoding(&mut self) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_nvidia_hardware_encoding(&mut self, v: bool) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional int32 form_factor = 11;


    pub fn get_form_factor(&self) -> i32 {
        self.form_factor.unwrap_or(0)
    }
    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: i32) {
        self.form_factor = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientCaps {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.system_info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.system_can_suspend = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_video_hevc = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_steam_store = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_client_cursor = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_intel_hardware_encoding = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_amd_hardware_encoding = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.form_factor = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.system_can_suspend {
            my_size += 2;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supports_video_hevc {
            my_size += 2;
        }
        if let Some(v) = self.disable_steam_store {
            my_size += 2;
        }
        if let Some(v) = self.disable_client_cursor {
            my_size += 2;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            my_size += 2;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            my_size += 2;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            my_size += 2;
        }
        if let Some(v) = self.form_factor {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.system_info.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.system_can_suspend {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.supports_video_hevc {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.disable_steam_store {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.disable_client_cursor {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingClientCaps {
        CStreamingClientCaps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "system_info",
                |m: &CStreamingClientCaps| { &m.system_info },
                |m: &mut CStreamingClientCaps| { &mut m.system_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "system_can_suspend",
                |m: &CStreamingClientCaps| { &m.system_can_suspend },
                |m: &mut CStreamingClientCaps| { &mut m.system_can_suspend },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maximum_decode_bitrate_kbps",
                |m: &CStreamingClientCaps| { &m.maximum_decode_bitrate_kbps },
                |m: &mut CStreamingClientCaps| { &mut m.maximum_decode_bitrate_kbps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maximum_burst_bitrate_kbps",
                |m: &CStreamingClientCaps| { &m.maximum_burst_bitrate_kbps },
                |m: &mut CStreamingClientCaps| { &mut m.maximum_burst_bitrate_kbps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_video_hevc",
                |m: &CStreamingClientCaps| { &m.supports_video_hevc },
                |m: &mut CStreamingClientCaps| { &mut m.supports_video_hevc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_steam_store",
                |m: &CStreamingClientCaps| { &m.disable_steam_store },
                |m: &mut CStreamingClientCaps| { &mut m.disable_steam_store },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_client_cursor",
                |m: &CStreamingClientCaps| { &m.disable_client_cursor },
                |m: &mut CStreamingClientCaps| { &mut m.disable_client_cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_intel_hardware_encoding",
                |m: &CStreamingClientCaps| { &m.disable_intel_hardware_encoding },
                |m: &mut CStreamingClientCaps| { &mut m.disable_intel_hardware_encoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_amd_hardware_encoding",
                |m: &CStreamingClientCaps| { &m.disable_amd_hardware_encoding },
                |m: &mut CStreamingClientCaps| { &mut m.disable_amd_hardware_encoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_nvidia_hardware_encoding",
                |m: &CStreamingClientCaps| { &m.disable_nvidia_hardware_encoding },
                |m: &mut CStreamingClientCaps| { &mut m.disable_nvidia_hardware_encoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "form_factor",
                |m: &CStreamingClientCaps| { &m.form_factor },
                |m: &mut CStreamingClientCaps| { &mut m.form_factor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingClientCaps>(
                "CStreamingClientCaps",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingClientCaps {
        static instance: ::protobuf::rt::LazyV2<CStreamingClientCaps> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingClientCaps::new)
    }
}

impl ::protobuf::Clear for CStreamingClientCaps {
    fn clear(&mut self) {
        self.system_info.clear();
        self.system_can_suspend = ::std::option::Option::None;
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
        self.supports_video_hevc = ::std::option::Option::None;
        self.disable_steam_store = ::std::option::Option::None;
        self.disable_client_cursor = ::std::option::Option::None;
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientCaps {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientConfig {
    // message fields
    quality: ::std::option::Option<EStreamQualityPreference>,
    maximum_resolution_x: ::std::option::Option<u32>,
    maximum_resolution_y: ::std::option::Option<u32>,
    maximum_framerate_numerator: ::std::option::Option<u32>,
    maximum_framerate_denominator: ::std::option::Option<u32>,
    maximum_bitrate_kbps: ::std::option::Option<i32>,
    enable_hardware_decoding: ::std::option::Option<bool>,
    enable_performance_overlay: ::std::option::Option<bool>,
    enable_video_streaming: ::std::option::Option<bool>,
    enable_audio_streaming: ::std::option::Option<bool>,
    enable_input_streaming: ::std::option::Option<bool>,
    audio_channels: ::std::option::Option<i32>,
    enable_video_hevc: ::std::option::Option<bool>,
    enable_performance_icons: ::std::option::Option<bool>,
    enable_microphone_streaming: ::std::option::Option<bool>,
    controller_overlay_hotkey: ::protobuf::SingularField<::std::string::String>,
    enable_touch_controller: ::std::option::Option<bool>,
    p2p_scope: ::std::option::Option<EStreamP2PScope>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingClientConfig {
    fn default() -> &'a CStreamingClientConfig {
        <CStreamingClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientConfig {
    pub fn new() -> CStreamingClientConfig {
        ::std::default::Default::default()
    }

    // optional .EStreamQualityPreference quality = 1;


    pub fn get_quality(&self) -> EStreamQualityPreference {
        self.quality.unwrap_or(EStreamQualityPreference::k_EStreamQualityBalanced)
    }
    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: EStreamQualityPreference) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_resolution_x = 2;


    pub fn get_maximum_resolution_x(&self) -> u32 {
        self.maximum_resolution_x.unwrap_or(0)
    }
    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: u32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_resolution_y = 3;


    pub fn get_maximum_resolution_y(&self) -> u32 {
        self.maximum_resolution_y.unwrap_or(0)
    }
    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: u32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_framerate_numerator = 4;


    pub fn get_maximum_framerate_numerator(&self) -> u32 {
        self.maximum_framerate_numerator.unwrap_or(0)
    }
    pub fn clear_maximum_framerate_numerator(&mut self) {
        self.maximum_framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_numerator(&self) -> bool {
        self.maximum_framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_numerator(&mut self, v: u32) {
        self.maximum_framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_framerate_denominator = 5;


    pub fn get_maximum_framerate_denominator(&self) -> u32 {
        self.maximum_framerate_denominator.unwrap_or(0)
    }
    pub fn clear_maximum_framerate_denominator(&mut self) {
        self.maximum_framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_denominator(&self) -> bool {
        self.maximum_framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_denominator(&mut self, v: u32) {
        self.maximum_framerate_denominator = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_bitrate_kbps = 6;


    pub fn get_maximum_bitrate_kbps(&self) -> i32 {
        self.maximum_bitrate_kbps.unwrap_or(-1i32)
    }
    pub fn clear_maximum_bitrate_kbps(&mut self) {
        self.maximum_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_bitrate_kbps(&self) -> bool {
        self.maximum_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_bitrate_kbps(&mut self, v: i32) {
        self.maximum_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_decoding = 7;


    pub fn get_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.unwrap_or(true)
    }
    pub fn clear_enable_hardware_decoding(&mut self) {
        self.enable_hardware_decoding = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_decoding(&mut self, v: bool) {
        self.enable_hardware_decoding = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_overlay = 8;


    pub fn get_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.unwrap_or(false)
    }
    pub fn clear_enable_performance_overlay(&mut self) {
        self.enable_performance_overlay = ::std::option::Option::None;
    }

    pub fn has_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_overlay(&mut self, v: bool) {
        self.enable_performance_overlay = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_streaming = 9;


    pub fn get_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }
    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;


    pub fn get_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }
    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;


    pub fn get_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }
    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channels = 12;


    pub fn get_audio_channels(&self) -> i32 {
        self.audio_channels.unwrap_or(2i32)
    }
    pub fn clear_audio_channels(&mut self) {
        self.audio_channels = ::std::option::Option::None;
    }

    pub fn has_audio_channels(&self) -> bool {
        self.audio_channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channels(&mut self, v: i32) {
        self.audio_channels = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_hevc = 13;


    pub fn get_enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.unwrap_or(false)
    }
    pub fn clear_enable_video_hevc(&mut self) {
        self.enable_video_hevc = ::std::option::Option::None;
    }

    pub fn has_enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_hevc(&mut self, v: bool) {
        self.enable_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_icons = 14;


    pub fn get_enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.unwrap_or(true)
    }
    pub fn clear_enable_performance_icons(&mut self) {
        self.enable_performance_icons = ::std::option::Option::None;
    }

    pub fn has_enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_icons(&mut self, v: bool) {
        self.enable_performance_icons = ::std::option::Option::Some(v);
    }

    // optional bool enable_microphone_streaming = 15;


    pub fn get_enable_microphone_streaming(&self) -> bool {
        self.enable_microphone_streaming.unwrap_or(false)
    }
    pub fn clear_enable_microphone_streaming(&mut self) {
        self.enable_microphone_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_microphone_streaming(&self) -> bool {
        self.enable_microphone_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_microphone_streaming(&mut self, v: bool) {
        self.enable_microphone_streaming = ::std::option::Option::Some(v);
    }

    // optional string controller_overlay_hotkey = 16;


    pub fn get_controller_overlay_hotkey(&self) -> &str {
        match self.controller_overlay_hotkey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_controller_overlay_hotkey(&mut self) {
        self.controller_overlay_hotkey.clear();
    }

    pub fn has_controller_overlay_hotkey(&self) -> bool {
        self.controller_overlay_hotkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_overlay_hotkey(&mut self, v: ::std::string::String) {
        self.controller_overlay_hotkey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller_overlay_hotkey(&mut self) -> &mut ::std::string::String {
        if self.controller_overlay_hotkey.is_none() {
            self.controller_overlay_hotkey.set_default();
        }
        self.controller_overlay_hotkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller_overlay_hotkey(&mut self) -> ::std::string::String {
        self.controller_overlay_hotkey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enable_touch_controller = 17;


    pub fn get_enable_touch_controller(&self) -> bool {
        self.enable_touch_controller.unwrap_or(false)
    }
    pub fn clear_enable_touch_controller(&mut self) {
        self.enable_touch_controller = ::std::option::Option::None;
    }

    pub fn has_enable_touch_controller(&self) -> bool {
        self.enable_touch_controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_touch_controller(&mut self, v: bool) {
        self.enable_touch_controller = ::std::option::Option::Some(v);
    }

    // optional .EStreamP2PScope p2p_scope = 18;


    pub fn get_p2p_scope(&self) -> EStreamP2PScope {
        self.p2p_scope.unwrap_or(EStreamP2PScope::k_EStreamP2PScopeUnknown)
    }
    pub fn clear_p2p_scope(&mut self) {
        self.p2p_scope = ::std::option::Option::None;
    }

    pub fn has_p2p_scope(&self) -> bool {
        self.p2p_scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2p_scope(&mut self, v: EStreamP2PScope) {
        self.p2p_scope = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.quality, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_resolution_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_resolution_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_framerate_numerator = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maximum_framerate_denominator = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximum_bitrate_kbps = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_hardware_decoding = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_performance_overlay = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_video_streaming = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_audio_streaming = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_input_streaming = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.audio_channels = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_video_hevc = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_performance_icons = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_microphone_streaming = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.controller_overlay_hotkey)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_touch_controller = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.p2p_scope, 18, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_framerate_numerator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_framerate_denominator {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_hardware_decoding {
            my_size += 2;
        }
        if let Some(v) = self.enable_performance_overlay {
            my_size += 2;
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 2;
        }
        if let Some(v) = self.audio_channels {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_video_hevc {
            my_size += 2;
        }
        if let Some(v) = self.enable_performance_icons {
            my_size += 2;
        }
        if let Some(v) = self.enable_microphone_streaming {
            my_size += 2;
        }
        if let Some(ref v) = self.controller_overlay_hotkey.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.enable_touch_controller {
            my_size += 3;
        }
        if let Some(v) = self.p2p_scope {
            my_size += ::protobuf::rt::enum_size(18, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quality {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.maximum_framerate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.maximum_framerate_denominator {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.maximum_bitrate_kbps {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.enable_hardware_decoding {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.enable_performance_overlay {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.audio_channels {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.enable_video_hevc {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.enable_performance_icons {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.enable_microphone_streaming {
            os.write_bool(15, v)?;
        }
        if let Some(ref v) = self.controller_overlay_hotkey.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(v) = self.enable_touch_controller {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.p2p_scope {
            os.write_enum(18, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingClientConfig {
        CStreamingClientConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamQualityPreference>>(
                "quality",
                |m: &CStreamingClientConfig| { &m.quality },
                |m: &mut CStreamingClientConfig| { &mut m.quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maximum_resolution_x",
                |m: &CStreamingClientConfig| { &m.maximum_resolution_x },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_resolution_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maximum_resolution_y",
                |m: &CStreamingClientConfig| { &m.maximum_resolution_y },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_resolution_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maximum_framerate_numerator",
                |m: &CStreamingClientConfig| { &m.maximum_framerate_numerator },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_framerate_numerator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maximum_framerate_denominator",
                |m: &CStreamingClientConfig| { &m.maximum_framerate_denominator },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_framerate_denominator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maximum_bitrate_kbps",
                |m: &CStreamingClientConfig| { &m.maximum_bitrate_kbps },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_bitrate_kbps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_hardware_decoding",
                |m: &CStreamingClientConfig| { &m.enable_hardware_decoding },
                |m: &mut CStreamingClientConfig| { &mut m.enable_hardware_decoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_performance_overlay",
                |m: &CStreamingClientConfig| { &m.enable_performance_overlay },
                |m: &mut CStreamingClientConfig| { &mut m.enable_performance_overlay },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_video_streaming",
                |m: &CStreamingClientConfig| { &m.enable_video_streaming },
                |m: &mut CStreamingClientConfig| { &mut m.enable_video_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_audio_streaming",
                |m: &CStreamingClientConfig| { &m.enable_audio_streaming },
                |m: &mut CStreamingClientConfig| { &mut m.enable_audio_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_input_streaming",
                |m: &CStreamingClientConfig| { &m.enable_input_streaming },
                |m: &mut CStreamingClientConfig| { &mut m.enable_input_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "audio_channels",
                |m: &CStreamingClientConfig| { &m.audio_channels },
                |m: &mut CStreamingClientConfig| { &mut m.audio_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_video_hevc",
                |m: &CStreamingClientConfig| { &m.enable_video_hevc },
                |m: &mut CStreamingClientConfig| { &mut m.enable_video_hevc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_performance_icons",
                |m: &CStreamingClientConfig| { &m.enable_performance_icons },
                |m: &mut CStreamingClientConfig| { &mut m.enable_performance_icons },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_microphone_streaming",
                |m: &CStreamingClientConfig| { &m.enable_microphone_streaming },
                |m: &mut CStreamingClientConfig| { &mut m.enable_microphone_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "controller_overlay_hotkey",
                |m: &CStreamingClientConfig| { &m.controller_overlay_hotkey },
                |m: &mut CStreamingClientConfig| { &mut m.controller_overlay_hotkey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_touch_controller",
                |m: &CStreamingClientConfig| { &m.enable_touch_controller },
                |m: &mut CStreamingClientConfig| { &mut m.enable_touch_controller },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamP2PScope>>(
                "p2p_scope",
                |m: &CStreamingClientConfig| { &m.p2p_scope },
                |m: &mut CStreamingClientConfig| { &mut m.p2p_scope },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingClientConfig>(
                "CStreamingClientConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingClientConfig {
        static instance: ::protobuf::rt::LazyV2<CStreamingClientConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingClientConfig::new)
    }
}

impl ::protobuf::Clear for CStreamingClientConfig {
    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.maximum_framerate_numerator = ::std::option::Option::None;
        self.maximum_framerate_denominator = ::std::option::Option::None;
        self.maximum_bitrate_kbps = ::std::option::Option::None;
        self.enable_hardware_decoding = ::std::option::Option::None;
        self.enable_performance_overlay = ::std::option::Option::None;
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.audio_channels = ::std::option::Option::None;
        self.enable_video_hevc = ::std::option::Option::None;
        self.enable_performance_icons = ::std::option::Option::None;
        self.enable_microphone_streaming = ::std::option::Option::None;
        self.controller_overlay_hotkey.clear();
        self.enable_touch_controller = ::std::option::Option::None;
        self.p2p_scope = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingServerConfig {
    // message fields
    change_desktop_resolution: ::std::option::Option<bool>,
    dynamically_adjust_resolution: ::std::option::Option<bool>,
    enable_capture_nvfbc: ::std::option::Option<bool>,
    enable_hardware_encoding_nvidia: ::std::option::Option<bool>,
    enable_hardware_encoding_amd: ::std::option::Option<bool>,
    enable_hardware_encoding_intel: ::std::option::Option<bool>,
    software_encoding_threads: ::std::option::Option<i32>,
    enable_traffic_priority: ::std::option::Option<bool>,
    host_play_audio: ::std::option::Option<EStreamHostPlayAudioPreference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingServerConfig {
    fn default() -> &'a CStreamingServerConfig {
        <CStreamingServerConfig as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingServerConfig {
    pub fn new() -> CStreamingServerConfig {
        ::std::default::Default::default()
    }

    // optional bool change_desktop_resolution = 1;


    pub fn get_change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.unwrap_or(false)
    }
    pub fn clear_change_desktop_resolution(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
    }

    pub fn has_change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_desktop_resolution(&mut self, v: bool) {
        self.change_desktop_resolution = ::std::option::Option::Some(v);
    }

    // optional bool dynamically_adjust_resolution = 2;


    pub fn get_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.unwrap_or(false)
    }
    pub fn clear_dynamically_adjust_resolution(&mut self) {
        self.dynamically_adjust_resolution = ::std::option::Option::None;
    }

    pub fn has_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamically_adjust_resolution(&mut self, v: bool) {
        self.dynamically_adjust_resolution = ::std::option::Option::Some(v);
    }

    // optional bool enable_capture_nvfbc = 3;


    pub fn get_enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.unwrap_or(false)
    }
    pub fn clear_enable_capture_nvfbc(&mut self) {
        self.enable_capture_nvfbc = ::std::option::Option::None;
    }

    pub fn has_enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_capture_nvfbc(&mut self, v: bool) {
        self.enable_capture_nvfbc = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_nvidia = 4;


    pub fn get_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.unwrap_or(false)
    }
    pub fn clear_enable_hardware_encoding_nvidia(&mut self) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_nvidia(&mut self, v: bool) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_amd = 5;


    pub fn get_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.unwrap_or(false)
    }
    pub fn clear_enable_hardware_encoding_amd(&mut self) {
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_amd(&mut self, v: bool) {
        self.enable_hardware_encoding_amd = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_intel = 6;


    pub fn get_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.unwrap_or(false)
    }
    pub fn clear_enable_hardware_encoding_intel(&mut self) {
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_intel(&mut self, v: bool) {
        self.enable_hardware_encoding_intel = ::std::option::Option::Some(v);
    }

    // optional int32 software_encoding_threads = 7;


    pub fn get_software_encoding_threads(&self) -> i32 {
        self.software_encoding_threads.unwrap_or(0)
    }
    pub fn clear_software_encoding_threads(&mut self) {
        self.software_encoding_threads = ::std::option::Option::None;
    }

    pub fn has_software_encoding_threads(&self) -> bool {
        self.software_encoding_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_software_encoding_threads(&mut self, v: i32) {
        self.software_encoding_threads = ::std::option::Option::Some(v);
    }

    // optional bool enable_traffic_priority = 8;


    pub fn get_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.unwrap_or(false)
    }
    pub fn clear_enable_traffic_priority(&mut self) {
        self.enable_traffic_priority = ::std::option::Option::None;
    }

    pub fn has_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_traffic_priority(&mut self, v: bool) {
        self.enable_traffic_priority = ::std::option::Option::Some(v);
    }

    // optional .EStreamHostPlayAudioPreference host_play_audio = 9;


    pub fn get_host_play_audio(&self) -> EStreamHostPlayAudioPreference {
        self.host_play_audio.unwrap_or(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault)
    }
    pub fn clear_host_play_audio(&mut self) {
        self.host_play_audio = ::std::option::Option::None;
    }

    pub fn has_host_play_audio(&self) -> bool {
        self.host_play_audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_play_audio(&mut self, v: EStreamHostPlayAudioPreference) {
        self.host_play_audio = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingServerConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.change_desktop_resolution = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dynamically_adjust_resolution = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_capture_nvfbc = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_hardware_encoding_amd = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_hardware_encoding_intel = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.software_encoding_threads = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_traffic_priority = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.host_play_audio, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.change_desktop_resolution {
            my_size += 2;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            my_size += 2;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            my_size += 2;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            my_size += 2;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            my_size += 2;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            my_size += 2;
        }
        if let Some(v) = self.software_encoding_threads {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_traffic_priority {
            my_size += 2;
        }
        if let Some(v) = self.host_play_audio {
            my_size += ::protobuf::rt::enum_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.change_desktop_resolution {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.software_encoding_threads {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.enable_traffic_priority {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.host_play_audio {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingServerConfig {
        CStreamingServerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "change_desktop_resolution",
                |m: &CStreamingServerConfig| { &m.change_desktop_resolution },
                |m: &mut CStreamingServerConfig| { &mut m.change_desktop_resolution },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dynamically_adjust_resolution",
                |m: &CStreamingServerConfig| { &m.dynamically_adjust_resolution },
                |m: &mut CStreamingServerConfig| { &mut m.dynamically_adjust_resolution },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_capture_nvfbc",
                |m: &CStreamingServerConfig| { &m.enable_capture_nvfbc },
                |m: &mut CStreamingServerConfig| { &mut m.enable_capture_nvfbc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_hardware_encoding_nvidia",
                |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_nvidia },
                |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_nvidia },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_hardware_encoding_amd",
                |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_amd },
                |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_amd },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_hardware_encoding_intel",
                |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_intel },
                |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_intel },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "software_encoding_threads",
                |m: &CStreamingServerConfig| { &m.software_encoding_threads },
                |m: &mut CStreamingServerConfig| { &mut m.software_encoding_threads },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_traffic_priority",
                |m: &CStreamingServerConfig| { &m.enable_traffic_priority },
                |m: &mut CStreamingServerConfig| { &mut m.enable_traffic_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamHostPlayAudioPreference>>(
                "host_play_audio",
                |m: &CStreamingServerConfig| { &m.host_play_audio },
                |m: &mut CStreamingServerConfig| { &mut m.host_play_audio },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingServerConfig>(
                "CStreamingServerConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingServerConfig {
        static instance: ::protobuf::rt::LazyV2<CStreamingServerConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingServerConfig::new)
    }
}

impl ::protobuf::Clear for CStreamingServerConfig {
    fn clear(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
        self.dynamically_adjust_resolution = ::std::option::Option::None;
        self.enable_capture_nvfbc = ::std::option::Option::None;
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
        self.software_encoding_threads = ::std::option::Option::None;
        self.enable_traffic_priority = ::std::option::Option::None;
        self.host_play_audio = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingServerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiatedConfig {
    // message fields
    reliable_data: ::std::option::Option<bool>,
    selected_audio_codec: ::std::option::Option<EStreamAudioCodec>,
    selected_video_codec: ::std::option::Option<EStreamVideoCodec>,
    pub available_video_modes: ::protobuf::RepeatedField<CStreamVideoMode>,
    enable_remote_hid: ::std::option::Option<bool>,
    enable_touch_input: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiatedConfig {
    fn default() -> &'a CNegotiatedConfig {
        <CNegotiatedConfig as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiatedConfig {
    pub fn new() -> CNegotiatedConfig {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;


    pub fn get_reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }
    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec selected_audio_codec = 2;


    pub fn get_selected_audio_codec(&self) -> EStreamAudioCodec {
        self.selected_audio_codec.unwrap_or(EStreamAudioCodec::k_EStreamAudioCodecNone)
    }
    pub fn clear_selected_audio_codec(&mut self) {
        self.selected_audio_codec = ::std::option::Option::None;
    }

    pub fn has_selected_audio_codec(&self) -> bool {
        self.selected_audio_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_audio_codec(&mut self, v: EStreamAudioCodec) {
        self.selected_audio_codec = ::std::option::Option::Some(v);
    }

    // optional .EStreamVideoCodec selected_video_codec = 3;


    pub fn get_selected_video_codec(&self) -> EStreamVideoCodec {
        self.selected_video_codec.unwrap_or(EStreamVideoCodec::k_EStreamVideoCodecNone)
    }
    pub fn clear_selected_video_codec(&mut self) {
        self.selected_video_codec = ::std::option::Option::None;
    }

    pub fn has_selected_video_codec(&self) -> bool {
        self.selected_video_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_video_codec(&mut self, v: EStreamVideoCodec) {
        self.selected_video_codec = ::std::option::Option::Some(v);
    }

    // repeated .CStreamVideoMode available_video_modes = 4;


    pub fn get_available_video_modes(&self) -> &[CStreamVideoMode] {
        &self.available_video_modes
    }
    pub fn clear_available_video_modes(&mut self) {
        self.available_video_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_video_modes(&mut self, v: ::protobuf::RepeatedField<CStreamVideoMode>) {
        self.available_video_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_available_video_modes(&mut self) -> &mut ::protobuf::RepeatedField<CStreamVideoMode> {
        &mut self.available_video_modes
    }

    // Take field
    pub fn take_available_video_modes(&mut self) -> ::protobuf::RepeatedField<CStreamVideoMode> {
        ::std::mem::replace(&mut self.available_video_modes, ::protobuf::RepeatedField::new())
    }

    // optional bool enable_remote_hid = 5;


    pub fn get_enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.unwrap_or(false)
    }
    pub fn clear_enable_remote_hid(&mut self) {
        self.enable_remote_hid = ::std::option::Option::None;
    }

    pub fn has_enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_remote_hid(&mut self, v: bool) {
        self.enable_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool enable_touch_input = 6;


    pub fn get_enable_touch_input(&self) -> bool {
        self.enable_touch_input.unwrap_or(false)
    }
    pub fn clear_enable_touch_input(&mut self) {
        self.enable_touch_input = ::std::option::Option::None;
    }

    pub fn has_enable_touch_input(&self) -> bool {
        self.enable_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_touch_input(&mut self, v: bool) {
        self.enable_touch_input = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CNegotiatedConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.available_video_modes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reliable_data = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.selected_audio_codec, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.selected_video_codec, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.available_video_modes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_remote_hid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_touch_input = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 2;
        }
        if let Some(v) = self.selected_audio_codec {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.selected_video_codec {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        for value in &self.available_video_modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.enable_remote_hid {
            my_size += 2;
        }
        if let Some(v) = self.enable_touch_input {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.selected_audio_codec {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.selected_video_codec {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.available_video_modes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.enable_remote_hid {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_touch_input {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiatedConfig {
        CNegotiatedConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reliable_data",
                |m: &CNegotiatedConfig| { &m.reliable_data },
                |m: &mut CNegotiatedConfig| { &mut m.reliable_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamAudioCodec>>(
                "selected_audio_codec",
                |m: &CNegotiatedConfig| { &m.selected_audio_codec },
                |m: &mut CNegotiatedConfig| { &mut m.selected_audio_codec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVideoCodec>>(
                "selected_video_codec",
                |m: &CNegotiatedConfig| { &m.selected_video_codec },
                |m: &mut CNegotiatedConfig| { &mut m.selected_video_codec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamVideoMode>>(
                "available_video_modes",
                |m: &CNegotiatedConfig| { &m.available_video_modes },
                |m: &mut CNegotiatedConfig| { &mut m.available_video_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_remote_hid",
                |m: &CNegotiatedConfig| { &m.enable_remote_hid },
                |m: &mut CNegotiatedConfig| { &mut m.enable_remote_hid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_touch_input",
                |m: &CNegotiatedConfig| { &m.enable_touch_input },
                |m: &mut CNegotiatedConfig| { &mut m.enable_touch_input },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CNegotiatedConfig>(
                "CNegotiatedConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiatedConfig {
        static instance: ::protobuf::rt::LazyV2<CNegotiatedConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CNegotiatedConfig::new)
    }
}

impl ::protobuf::Clear for CNegotiatedConfig {
    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.selected_audio_codec = ::std::option::Option::None;
        self.selected_video_codec = ::std::option::Option::None;
        self.available_video_modes.clear();
        self.enable_remote_hid = ::std::option::Option::None;
        self.enable_touch_input = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiatedConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiatedConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationInitMsg {
    // message fields
    reliable_data: ::std::option::Option<bool>,
    pub supported_audio_codecs: ::std::vec::Vec<EStreamAudioCodec>,
    pub supported_video_codecs: ::std::vec::Vec<EStreamVideoCodec>,
    supports_remote_hid: ::std::option::Option<bool>,
    supports_touch_input: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiationInitMsg {
    fn default() -> &'a CNegotiationInitMsg {
        <CNegotiationInitMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationInitMsg {
    pub fn new() -> CNegotiationInitMsg {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;


    pub fn get_reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }
    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // repeated .EStreamAudioCodec supported_audio_codecs = 2;


    pub fn get_supported_audio_codecs(&self) -> &[EStreamAudioCodec] {
        &self.supported_audio_codecs
    }
    pub fn clear_supported_audio_codecs(&mut self) {
        self.supported_audio_codecs.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_audio_codecs(&mut self, v: ::std::vec::Vec<EStreamAudioCodec>) {
        self.supported_audio_codecs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_audio_codecs(&mut self) -> &mut ::std::vec::Vec<EStreamAudioCodec> {
        &mut self.supported_audio_codecs
    }

    // Take field
    pub fn take_supported_audio_codecs(&mut self) -> ::std::vec::Vec<EStreamAudioCodec> {
        ::std::mem::replace(&mut self.supported_audio_codecs, ::std::vec::Vec::new())
    }

    // repeated .EStreamVideoCodec supported_video_codecs = 3;


    pub fn get_supported_video_codecs(&self) -> &[EStreamVideoCodec] {
        &self.supported_video_codecs
    }
    pub fn clear_supported_video_codecs(&mut self) {
        self.supported_video_codecs.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_video_codecs(&mut self, v: ::std::vec::Vec<EStreamVideoCodec>) {
        self.supported_video_codecs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_video_codecs(&mut self) -> &mut ::std::vec::Vec<EStreamVideoCodec> {
        &mut self.supported_video_codecs
    }

    // Take field
    pub fn take_supported_video_codecs(&mut self) -> ::std::vec::Vec<EStreamVideoCodec> {
        ::std::mem::replace(&mut self.supported_video_codecs, ::std::vec::Vec::new())
    }

    // optional bool supports_remote_hid = 4;


    pub fn get_supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.unwrap_or(false)
    }
    pub fn clear_supports_remote_hid(&mut self) {
        self.supports_remote_hid = ::std::option::Option::None;
    }

    pub fn has_supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_remote_hid(&mut self, v: bool) {
        self.supports_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool supports_touch_input = 5;


    pub fn get_supports_touch_input(&self) -> bool {
        self.supports_touch_input.unwrap_or(false)
    }
    pub fn clear_supports_touch_input(&mut self) {
        self.supports_touch_input = ::std::option::Option::None;
    }

    pub fn has_supports_touch_input(&self) -> bool {
        self.supports_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_touch_input(&mut self, v: bool) {
        self.supports_touch_input = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CNegotiationInitMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reliable_data = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_audio_codecs, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_video_codecs, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_remote_hid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_touch_input = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 2;
        }
        for value in &self.supported_audio_codecs {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in &self.supported_video_codecs {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        if let Some(v) = self.supports_remote_hid {
            my_size += 2;
        }
        if let Some(v) = self.supports_touch_input {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        for v in &self.supported_audio_codecs {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.supported_video_codecs {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.supports_remote_hid {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.supports_touch_input {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiationInitMsg {
        CNegotiationInitMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reliable_data",
                |m: &CNegotiationInitMsg| { &m.reliable_data },
                |m: &mut CNegotiationInitMsg| { &mut m.reliable_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamAudioCodec>>(
                "supported_audio_codecs",
                |m: &CNegotiationInitMsg| { &m.supported_audio_codecs },
                |m: &mut CNegotiationInitMsg| { &mut m.supported_audio_codecs },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVideoCodec>>(
                "supported_video_codecs",
                |m: &CNegotiationInitMsg| { &m.supported_video_codecs },
                |m: &mut CNegotiationInitMsg| { &mut m.supported_video_codecs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_remote_hid",
                |m: &CNegotiationInitMsg| { &m.supports_remote_hid },
                |m: &mut CNegotiationInitMsg| { &mut m.supports_remote_hid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_touch_input",
                |m: &CNegotiationInitMsg| { &m.supports_touch_input },
                |m: &mut CNegotiationInitMsg| { &mut m.supports_touch_input },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CNegotiationInitMsg>(
                "CNegotiationInitMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiationInitMsg {
        static instance: ::protobuf::rt::LazyV2<CNegotiationInitMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CNegotiationInitMsg::new)
    }
}

impl ::protobuf::Clear for CNegotiationInitMsg {
    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.supported_audio_codecs.clear();
        self.supported_video_codecs.clear();
        self.supports_remote_hid = ::std::option::Option::None;
        self.supports_touch_input = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationInitMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationInitMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationSetConfigMsg {
    // message fields
    pub config: ::protobuf::SingularPtrField<CNegotiatedConfig>,
    pub streaming_client_config: ::protobuf::SingularPtrField<CStreamingClientConfig>,
    pub streaming_client_caps: ::protobuf::SingularPtrField<CStreamingClientCaps>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiationSetConfigMsg {
    fn default() -> &'a CNegotiationSetConfigMsg {
        <CNegotiationSetConfigMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationSetConfigMsg {
    pub fn new() -> CNegotiationSetConfigMsg {
        ::std::default::Default::default()
    }

    // required .CNegotiatedConfig config = 1;


    pub fn get_config(&self) -> &CNegotiatedConfig {
        self.config.as_ref().unwrap_or_else(|| <CNegotiatedConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: CNegotiatedConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut CNegotiatedConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> CNegotiatedConfig {
        self.config.take().unwrap_or_else(|| CNegotiatedConfig::new())
    }

    // optional .CStreamingClientConfig streaming_client_config = 2;


    pub fn get_streaming_client_config(&self) -> &CStreamingClientConfig {
        self.streaming_client_config.as_ref().unwrap_or_else(|| <CStreamingClientConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_streaming_client_config(&mut self) {
        self.streaming_client_config.clear();
    }

    pub fn has_streaming_client_config(&self) -> bool {
        self.streaming_client_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_client_config(&mut self, v: CStreamingClientConfig) {
        self.streaming_client_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streaming_client_config(&mut self) -> &mut CStreamingClientConfig {
        if self.streaming_client_config.is_none() {
            self.streaming_client_config.set_default();
        }
        self.streaming_client_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_streaming_client_config(&mut self) -> CStreamingClientConfig {
        self.streaming_client_config.take().unwrap_or_else(|| CStreamingClientConfig::new())
    }

    // optional .CStreamingClientCaps streaming_client_caps = 3;


    pub fn get_streaming_client_caps(&self) -> &CStreamingClientCaps {
        self.streaming_client_caps.as_ref().unwrap_or_else(|| <CStreamingClientCaps as ::protobuf::Message>::default_instance())
    }
    pub fn clear_streaming_client_caps(&mut self) {
        self.streaming_client_caps.clear();
    }

    pub fn has_streaming_client_caps(&self) -> bool {
        self.streaming_client_caps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_client_caps(&mut self, v: CStreamingClientCaps) {
        self.streaming_client_caps = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streaming_client_caps(&mut self) -> &mut CStreamingClientCaps {
        if self.streaming_client_caps.is_none() {
            self.streaming_client_caps.set_default();
        }
        self.streaming_client_caps.as_mut().unwrap()
    }

    // Take field
    pub fn take_streaming_client_caps(&mut self) -> CStreamingClientCaps {
        self.streaming_client_caps.take().unwrap_or_else(|| CStreamingClientCaps::new())
    }
}

impl ::protobuf::Message for CNegotiationSetConfigMsg {
    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_caps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.streaming_client_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.streaming_client_caps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.streaming_client_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.streaming_client_caps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.streaming_client_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.streaming_client_caps.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiationSetConfigMsg {
        CNegotiationSetConfigMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CNegotiatedConfig>>(
                "config",
                |m: &CNegotiationSetConfigMsg| { &m.config },
                |m: &mut CNegotiationSetConfigMsg| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientConfig>>(
                "streaming_client_config",
                |m: &CNegotiationSetConfigMsg| { &m.streaming_client_config },
                |m: &mut CNegotiationSetConfigMsg| { &mut m.streaming_client_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientCaps>>(
                "streaming_client_caps",
                |m: &CNegotiationSetConfigMsg| { &m.streaming_client_caps },
                |m: &mut CNegotiationSetConfigMsg| { &mut m.streaming_client_caps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CNegotiationSetConfigMsg>(
                "CNegotiationSetConfigMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiationSetConfigMsg {
        static instance: ::protobuf::rt::LazyV2<CNegotiationSetConfigMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CNegotiationSetConfigMsg::new)
    }
}

impl ::protobuf::Clear for CNegotiationSetConfigMsg {
    fn clear(&mut self) {
        self.config.clear();
        self.streaming_client_config.clear();
        self.streaming_client_caps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationSetConfigMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationSetConfigMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationCompleteMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiationCompleteMsg {
    fn default() -> &'a CNegotiationCompleteMsg {
        <CNegotiationCompleteMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationCompleteMsg {
    pub fn new() -> CNegotiationCompleteMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CNegotiationCompleteMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiationCompleteMsg {
        CNegotiationCompleteMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CNegotiationCompleteMsg>(
                "CNegotiationCompleteMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiationCompleteMsg {
        static instance: ::protobuf::rt::LazyV2<CNegotiationCompleteMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CNegotiationCompleteMsg::new)
    }
}

impl ::protobuf::Clear for CNegotiationCompleteMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationCompleteMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationCompleteMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartAudioDataMsg {
    // message fields
    channel: ::std::option::Option<u32>,
    codec: ::std::option::Option<EStreamAudioCodec>,
    codec_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    frequency: ::std::option::Option<u32>,
    channels: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStartAudioDataMsg {
    fn default() -> &'a CStartAudioDataMsg {
        <CStartAudioDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartAudioDataMsg {
    pub fn new() -> CStartAudioDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 2;


    pub fn get_channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }
    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec codec = 3;


    pub fn get_codec(&self) -> EStreamAudioCodec {
        self.codec.unwrap_or(EStreamAudioCodec::k_EStreamAudioCodecNone)
    }
    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamAudioCodec) {
        self.codec = ::std::option::Option::Some(v);
    }

    // optional bytes codec_data = 4;


    pub fn get_codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_codec_data(&mut self) {
        self.codec_data.clear();
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data.set_default();
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 frequency = 5;


    pub fn get_frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 6;


    pub fn get_channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }
    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartAudioDataMsg {
    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.codec, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.codec_data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frequency = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channels = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.codec_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStartAudioDataMsg {
        CStartAudioDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel",
                |m: &CStartAudioDataMsg| { &m.channel },
                |m: &mut CStartAudioDataMsg| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamAudioCodec>>(
                "codec",
                |m: &CStartAudioDataMsg| { &m.codec },
                |m: &mut CStartAudioDataMsg| { &mut m.codec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "codec_data",
                |m: &CStartAudioDataMsg| { &m.codec_data },
                |m: &mut CStartAudioDataMsg| { &mut m.codec_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frequency",
                |m: &CStartAudioDataMsg| { &m.frequency },
                |m: &mut CStartAudioDataMsg| { &mut m.frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channels",
                |m: &CStartAudioDataMsg| { &m.channels },
                |m: &mut CStartAudioDataMsg| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStartAudioDataMsg>(
                "CStartAudioDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStartAudioDataMsg {
        static instance: ::protobuf::rt::LazyV2<CStartAudioDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStartAudioDataMsg::new)
    }
}

impl ::protobuf::Clear for CStartAudioDataMsg {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data.clear();
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartAudioDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStopAudioDataMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStopAudioDataMsg {
    fn default() -> &'a CStopAudioDataMsg {
        <CStopAudioDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStopAudioDataMsg {
    pub fn new() -> CStopAudioDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopAudioDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStopAudioDataMsg {
        CStopAudioDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStopAudioDataMsg>(
                "CStopAudioDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStopAudioDataMsg {
        static instance: ::protobuf::rt::LazyV2<CStopAudioDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStopAudioDataMsg::new)
    }
}

impl ::protobuf::Clear for CStopAudioDataMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStopAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStopAudioDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartVideoDataMsg {
    // message fields
    channel: ::std::option::Option<u32>,
    codec: ::std::option::Option<EStreamVideoCodec>,
    codec_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStartVideoDataMsg {
    fn default() -> &'a CStartVideoDataMsg {
        <CStartVideoDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartVideoDataMsg {
    pub fn new() -> CStartVideoDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 1;


    pub fn get_channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }
    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamVideoCodec codec = 2;


    pub fn get_codec(&self) -> EStreamVideoCodec {
        self.codec.unwrap_or(EStreamVideoCodec::k_EStreamVideoCodecNone)
    }
    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamVideoCodec) {
        self.codec = ::std::option::Option::Some(v);
    }

    // optional bytes codec_data = 3;


    pub fn get_codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_codec_data(&mut self) {
        self.codec_data.clear();
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data.set_default();
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 width = 4;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartVideoDataMsg {
    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channel = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.codec, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.codec_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.codec_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStartVideoDataMsg {
        CStartVideoDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channel",
                |m: &CStartVideoDataMsg| { &m.channel },
                |m: &mut CStartVideoDataMsg| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamVideoCodec>>(
                "codec",
                |m: &CStartVideoDataMsg| { &m.codec },
                |m: &mut CStartVideoDataMsg| { &mut m.codec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "codec_data",
                |m: &CStartVideoDataMsg| { &m.codec_data },
                |m: &mut CStartVideoDataMsg| { &mut m.codec_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "width",
                |m: &CStartVideoDataMsg| { &m.width },
                |m: &mut CStartVideoDataMsg| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &CStartVideoDataMsg| { &m.height },
                |m: &mut CStartVideoDataMsg| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStartVideoDataMsg>(
                "CStartVideoDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStartVideoDataMsg {
        static instance: ::protobuf::rt::LazyV2<CStartVideoDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStartVideoDataMsg::new)
    }
}

impl ::protobuf::Clear for CStartVideoDataMsg {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartVideoDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStopVideoDataMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStopVideoDataMsg {
    fn default() -> &'a CStopVideoDataMsg {
        <CStopVideoDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStopVideoDataMsg {
    pub fn new() -> CStopVideoDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopVideoDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStopVideoDataMsg {
        CStopVideoDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStopVideoDataMsg>(
                "CStopVideoDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStopVideoDataMsg {
        static instance: ::protobuf::rt::LazyV2<CStopVideoDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStopVideoDataMsg::new)
    }
}

impl ::protobuf::Clear for CStopVideoDataMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStopVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStopVideoDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CRecordedInput {
    // message fields
    field_type: ::std::option::Option<EStreamControlMessage>,
    timestamp: ::std::option::Option<u32>,
    // message oneof groups
    pub data: ::std::option::Option<CRecordedInput_oneof_data>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CRecordedInput {
    fn default() -> &'a CRecordedInput {
        <CRecordedInput as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CRecordedInput_oneof_data {
    finger_down(CInputTouchFingerDownMsg),
    finger_motion(CInputTouchFingerMotionMsg),
    finger_up(CInputTouchFingerUpMsg),
    mouse_motion(CInputMouseMotionMsg),
    mouse_wheel(CInputMouseWheelMsg),
    mouse_down(CInputMouseDownMsg),
    mouse_up(CInputMouseUpMsg),
    key_down(CInputKeyDownMsg),
    key_up(CInputKeyUpMsg),
    text(CInputTextMsg),
    hid(CRemoteHIDMsg),
}

impl CRecordedInput {
    pub fn new() -> CRecordedInput {
        ::std::default::Default::default()
    }

    // optional .EStreamControlMessage type = 1;


    pub fn get_field_type(&self) -> EStreamControlMessage {
        self.field_type.unwrap_or(EStreamControlMessage::k_EStreamControlAuthenticationRequest)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: EStreamControlMessage) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .CInputTouchFingerDownMsg finger_down = 3;


    pub fn get_finger_down(&self) -> &CInputTouchFingerDownMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(ref v)) => v,
            _ => <CInputTouchFingerDownMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_finger_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_down(&mut self, v: CInputTouchFingerDownMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_down(&mut self) -> &mut CInputTouchFingerDownMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(CInputTouchFingerDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_down(&mut self) -> CInputTouchFingerDownMsg {
        if self.has_finger_down() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerDownMsg::new()
        }
    }

    // optional .CInputTouchFingerMotionMsg finger_motion = 4;


    pub fn get_finger_motion(&self) -> &CInputTouchFingerMotionMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(ref v)) => v,
            _ => <CInputTouchFingerMotionMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_finger_motion(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_motion(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_motion(&mut self, v: CInputTouchFingerMotionMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_motion(&mut self) -> &mut CInputTouchFingerMotionMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(CInputTouchFingerMotionMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_motion(&mut self) -> CInputTouchFingerMotionMsg {
        if self.has_finger_motion() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerMotionMsg::new()
        }
    }

    // optional .CInputTouchFingerUpMsg finger_up = 5;


    pub fn get_finger_up(&self) -> &CInputTouchFingerUpMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(ref v)) => v,
            _ => <CInputTouchFingerUpMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_finger_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_up(&mut self, v: CInputTouchFingerUpMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_up(&mut self) -> &mut CInputTouchFingerUpMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(CInputTouchFingerUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_up(&mut self) -> CInputTouchFingerUpMsg {
        if self.has_finger_up() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerUpMsg::new()
        }
    }

    // optional .CInputMouseMotionMsg mouse_motion = 6;


    pub fn get_mouse_motion(&self) -> &CInputMouseMotionMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(ref v)) => v,
            _ => <CInputMouseMotionMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mouse_motion(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_motion(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_motion(&mut self, v: CInputMouseMotionMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_motion(&mut self) -> &mut CInputMouseMotionMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(CInputMouseMotionMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_motion(&mut self) -> CInputMouseMotionMsg {
        if self.has_mouse_motion() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseMotionMsg::new()
        }
    }

    // optional .CInputMouseWheelMsg mouse_wheel = 7;


    pub fn get_mouse_wheel(&self) -> &CInputMouseWheelMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(ref v)) => v,
            _ => <CInputMouseWheelMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mouse_wheel(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_wheel(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_wheel(&mut self, v: CInputMouseWheelMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_wheel(&mut self) -> &mut CInputMouseWheelMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(CInputMouseWheelMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_wheel(&mut self) -> CInputMouseWheelMsg {
        if self.has_mouse_wheel() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseWheelMsg::new()
        }
    }

    // optional .CInputMouseDownMsg mouse_down = 8;


    pub fn get_mouse_down(&self) -> &CInputMouseDownMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(ref v)) => v,
            _ => <CInputMouseDownMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mouse_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_down(&mut self, v: CInputMouseDownMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_down(&mut self) -> &mut CInputMouseDownMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(CInputMouseDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_down(&mut self) -> CInputMouseDownMsg {
        if self.has_mouse_down() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseDownMsg::new()
        }
    }

    // optional .CInputMouseUpMsg mouse_up = 9;


    pub fn get_mouse_up(&self) -> &CInputMouseUpMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(ref v)) => v,
            _ => <CInputMouseUpMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mouse_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_up(&mut self, v: CInputMouseUpMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_up(&mut self) -> &mut CInputMouseUpMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(CInputMouseUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_up(&mut self) -> CInputMouseUpMsg {
        if self.has_mouse_up() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseUpMsg::new()
        }
    }

    // optional .CInputKeyDownMsg key_down = 10;


    pub fn get_key_down(&self) -> &CInputKeyDownMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(ref v)) => v,
            _ => <CInputKeyDownMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_key_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_key_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_down(&mut self, v: CInputKeyDownMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_down(&mut self) -> &mut CInputKeyDownMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(CInputKeyDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_down(&mut self) -> CInputKeyDownMsg {
        if self.has_key_down() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputKeyDownMsg::new()
        }
    }

    // optional .CInputKeyUpMsg key_up = 11;


    pub fn get_key_up(&self) -> &CInputKeyUpMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(ref v)) => v,
            _ => <CInputKeyUpMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_key_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_key_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_up(&mut self, v: CInputKeyUpMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_up(&mut self) -> &mut CInputKeyUpMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(CInputKeyUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_up(&mut self) -> CInputKeyUpMsg {
        if self.has_key_up() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputKeyUpMsg::new()
        }
    }

    // optional .CInputTextMsg text = 12;


    pub fn get_text(&self) -> &CInputTextMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::text(ref v)) => v,
            _ => <CInputTextMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_text(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: CInputTextMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut CInputTextMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::text(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::text(CInputTextMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> CInputTextMsg {
        if self.has_text() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::text(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTextMsg::new()
        }
    }

    // optional .CRemoteHIDMsg hid = 13;


    pub fn get_hid(&self) -> &CRemoteHIDMsg {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::hid(ref v)) => v,
            _ => <CRemoteHIDMsg as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_hid(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_hid(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::hid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hid(&mut self, v: CRemoteHIDMsg) {
        self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::hid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hid(&mut self) -> &mut CRemoteHIDMsg {
        if let ::std::option::Option::Some(CRecordedInput_oneof_data::hid(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::hid(CRemoteHIDMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(CRecordedInput_oneof_data::hid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hid(&mut self) -> CRemoteHIDMsg {
        if self.has_hid() {
            match self.data.take() {
                ::std::option::Option::Some(CRecordedInput_oneof_data::hid(v)) => v,
                _ => panic!(),
            }
        } else {
            CRemoteHIDMsg::new()
        }
    }
}

impl ::protobuf::Message for CRecordedInput {
    fn is_initialized(&self) -> bool {
        if let Some(CRecordedInput_oneof_data::finger_down(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::finger_motion(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::finger_up(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::mouse_motion(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::mouse_wheel(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::mouse_down(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::mouse_up(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::key_down(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::key_up(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::text(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CRecordedInput_oneof_data::hid(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_down(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_motion(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::finger_up(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_motion(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_wheel(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_down(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::mouse_up(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::key_down(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::key_up(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::text(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(CRecordedInput_oneof_data::hid(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &CRecordedInput_oneof_data::finger_down(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::finger_motion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::finger_up(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::mouse_motion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::mouse_wheel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::mouse_down(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::mouse_up(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::key_down(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::key_up(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CRecordedInput_oneof_data::hid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &CRecordedInput_oneof_data::finger_down(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::finger_motion(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::finger_up(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::mouse_motion(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::mouse_wheel(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::mouse_down(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::mouse_up(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::key_down(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::key_up(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::text(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CRecordedInput_oneof_data::hid(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CRecordedInput {
        CRecordedInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamControlMessage>>(
                "type",
                |m: &CRecordedInput| { &m.field_type },
                |m: &mut CRecordedInput| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CRecordedInput| { &m.timestamp },
                |m: &mut CRecordedInput| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputTouchFingerDownMsg>(
                "finger_down",
                CRecordedInput::has_finger_down,
                CRecordedInput::get_finger_down,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputTouchFingerMotionMsg>(
                "finger_motion",
                CRecordedInput::has_finger_motion,
                CRecordedInput::get_finger_motion,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputTouchFingerUpMsg>(
                "finger_up",
                CRecordedInput::has_finger_up,
                CRecordedInput::get_finger_up,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputMouseMotionMsg>(
                "mouse_motion",
                CRecordedInput::has_mouse_motion,
                CRecordedInput::get_mouse_motion,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputMouseWheelMsg>(
                "mouse_wheel",
                CRecordedInput::has_mouse_wheel,
                CRecordedInput::get_mouse_wheel,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputMouseDownMsg>(
                "mouse_down",
                CRecordedInput::has_mouse_down,
                CRecordedInput::get_mouse_down,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputMouseUpMsg>(
                "mouse_up",
                CRecordedInput::has_mouse_up,
                CRecordedInput::get_mouse_up,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputKeyDownMsg>(
                "key_down",
                CRecordedInput::has_key_down,
                CRecordedInput::get_key_down,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputKeyUpMsg>(
                "key_up",
                CRecordedInput::has_key_up,
                CRecordedInput::get_key_up,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CInputTextMsg>(
                "text",
                CRecordedInput::has_text,
                CRecordedInput::get_text,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CRemoteHIDMsg>(
                "hid",
                CRecordedInput::has_hid,
                CRecordedInput::get_hid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CRecordedInput>(
                "CRecordedInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CRecordedInput {
        static instance: ::protobuf::rt::LazyV2<CRecordedInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CRecordedInput::new)
    }
}

impl ::protobuf::Clear for CRecordedInput {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CRecordedInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CRecordedInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CRecordedInputStream {
    // message fields
    pub entries: ::protobuf::RepeatedField<CRecordedInput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CRecordedInputStream {
    fn default() -> &'a CRecordedInputStream {
        <CRecordedInputStream as ::protobuf::Message>::default_instance()
    }
}

impl CRecordedInputStream {
    pub fn new() -> CRecordedInputStream {
        ::std::default::Default::default()
    }

    // repeated .CRecordedInput entries = 1;


    pub fn get_entries(&self) -> &[CRecordedInput] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CRecordedInput>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CRecordedInput> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CRecordedInput> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CRecordedInputStream {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CRecordedInputStream {
        CRecordedInputStream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CRecordedInput>>(
                "entries",
                |m: &CRecordedInputStream| { &m.entries },
                |m: &mut CRecordedInputStream| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CRecordedInputStream>(
                "CRecordedInputStream",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CRecordedInputStream {
        static instance: ::protobuf::rt::LazyV2<CRecordedInputStream> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CRecordedInputStream::new)
    }
}

impl ::protobuf::Clear for CRecordedInputStream {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CRecordedInputStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CRecordedInputStream {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputLatencyTestMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    color: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputLatencyTestMsg {
    fn default() -> &'a CInputLatencyTestMsg {
        <CInputLatencyTestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputLatencyTestMsg {
    pub fn new() -> CInputLatencyTestMsg {
        ::std::default::Default::default()
    }

    // required uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 2;


    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or(0)
    }
    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputLatencyTestMsg {
    fn is_initialized(&self) -> bool {
        if self.input_mark.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.color = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputLatencyTestMsg {
        CInputLatencyTestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputLatencyTestMsg| { &m.input_mark },
                |m: &mut CInputLatencyTestMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "color",
                |m: &CInputLatencyTestMsg| { &m.color },
                |m: &mut CInputLatencyTestMsg| { &mut m.color },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputLatencyTestMsg>(
                "CInputLatencyTestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputLatencyTestMsg {
        static instance: ::protobuf::rt::LazyV2<CInputLatencyTestMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputLatencyTestMsg::new)
    }
}

impl ::protobuf::Clear for CInputLatencyTestMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputLatencyTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputLatencyTestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTouchFingerDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    fingerid: ::std::option::Option<u64>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerDownMsg {
    fn default() -> &'a CInputTouchFingerDownMsg {
        <CInputTouchFingerDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerDownMsg {
    pub fn new() -> CInputTouchFingerDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;


    pub fn get_fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }
    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;


    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }
    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;


    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }
    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerDownMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fingerid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x_normalized = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y_normalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTouchFingerDownMsg {
        CInputTouchFingerDownMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputTouchFingerDownMsg| { &m.input_mark },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fingerid",
                |m: &CInputTouchFingerDownMsg| { &m.fingerid },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.fingerid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x_normalized",
                |m: &CInputTouchFingerDownMsg| { &m.x_normalized },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.x_normalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y_normalized",
                |m: &CInputTouchFingerDownMsg| { &m.y_normalized },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.y_normalized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputTouchFingerDownMsg>(
                "CInputTouchFingerDownMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTouchFingerDownMsg {
        static instance: ::protobuf::rt::LazyV2<CInputTouchFingerDownMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputTouchFingerDownMsg::new)
    }
}

impl ::protobuf::Clear for CInputTouchFingerDownMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTouchFingerDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTouchFingerDownMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTouchFingerMotionMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    fingerid: ::std::option::Option<u64>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerMotionMsg {
    fn default() -> &'a CInputTouchFingerMotionMsg {
        <CInputTouchFingerMotionMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerMotionMsg {
    pub fn new() -> CInputTouchFingerMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;


    pub fn get_fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }
    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;


    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }
    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;


    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }
    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerMotionMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fingerid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x_normalized = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y_normalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTouchFingerMotionMsg {
        CInputTouchFingerMotionMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputTouchFingerMotionMsg| { &m.input_mark },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fingerid",
                |m: &CInputTouchFingerMotionMsg| { &m.fingerid },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.fingerid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x_normalized",
                |m: &CInputTouchFingerMotionMsg| { &m.x_normalized },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.x_normalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y_normalized",
                |m: &CInputTouchFingerMotionMsg| { &m.y_normalized },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.y_normalized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputTouchFingerMotionMsg>(
                "CInputTouchFingerMotionMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTouchFingerMotionMsg {
        static instance: ::protobuf::rt::LazyV2<CInputTouchFingerMotionMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputTouchFingerMotionMsg::new)
    }
}

impl ::protobuf::Clear for CInputTouchFingerMotionMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTouchFingerMotionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTouchFingerMotionMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTouchFingerUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    fingerid: ::std::option::Option<u64>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerUpMsg {
    fn default() -> &'a CInputTouchFingerUpMsg {
        <CInputTouchFingerUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerUpMsg {
    pub fn new() -> CInputTouchFingerUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;


    pub fn get_fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }
    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;


    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }
    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;


    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }
    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerUpMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fingerid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x_normalized = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y_normalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTouchFingerUpMsg {
        CInputTouchFingerUpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputTouchFingerUpMsg| { &m.input_mark },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fingerid",
                |m: &CInputTouchFingerUpMsg| { &m.fingerid },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.fingerid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x_normalized",
                |m: &CInputTouchFingerUpMsg| { &m.x_normalized },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.x_normalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y_normalized",
                |m: &CInputTouchFingerUpMsg| { &m.y_normalized },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.y_normalized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputTouchFingerUpMsg>(
                "CInputTouchFingerUpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTouchFingerUpMsg {
        static instance: ::protobuf::rt::LazyV2<CInputTouchFingerUpMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputTouchFingerUpMsg::new)
    }
}

impl ::protobuf::Clear for CInputTouchFingerUpMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTouchFingerUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTouchFingerUpMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseMotionMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    dx: ::std::option::Option<i32>,
    dy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseMotionMsg {
    fn default() -> &'a CInputMouseMotionMsg {
        <CInputMouseMotionMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseMotionMsg {
    pub fn new() -> CInputMouseMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 2;


    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }
    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 3;


    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }
    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    // optional int32 dx = 4;


    pub fn get_dx(&self) -> i32 {
        self.dx.unwrap_or(0)
    }
    pub fn clear_dx(&mut self) {
        self.dx = ::std::option::Option::None;
    }

    pub fn has_dx(&self) -> bool {
        self.dx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dx(&mut self, v: i32) {
        self.dx = ::std::option::Option::Some(v);
    }

    // optional int32 dy = 5;


    pub fn get_dy(&self) -> i32 {
        self.dy.unwrap_or(0)
    }
    pub fn clear_dy(&mut self) {
        self.dy = ::std::option::Option::None;
    }

    pub fn has_dy(&self) -> bool {
        self.dy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dy(&mut self, v: i32) {
        self.dy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputMouseMotionMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x_normalized = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y_normalized = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dx = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        if let Some(v) = self.dx {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dy {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.dx {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dy {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseMotionMsg {
        CInputMouseMotionMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputMouseMotionMsg| { &m.input_mark },
                |m: &mut CInputMouseMotionMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x_normalized",
                |m: &CInputMouseMotionMsg| { &m.x_normalized },
                |m: &mut CInputMouseMotionMsg| { &mut m.x_normalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y_normalized",
                |m: &CInputMouseMotionMsg| { &m.y_normalized },
                |m: &mut CInputMouseMotionMsg| { &mut m.y_normalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dx",
                |m: &CInputMouseMotionMsg| { &m.dx },
                |m: &mut CInputMouseMotionMsg| { &mut m.dx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dy",
                |m: &CInputMouseMotionMsg| { &m.dy },
                |m: &mut CInputMouseMotionMsg| { &mut m.dy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputMouseMotionMsg>(
                "CInputMouseMotionMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseMotionMsg {
        static instance: ::protobuf::rt::LazyV2<CInputMouseMotionMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputMouseMotionMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseMotionMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.dx = ::std::option::Option::None;
        self.dy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseMotionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseMotionMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseWheelMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    direction: ::std::option::Option<EStreamMouseWheelDirection>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseWheelMsg {
    fn default() -> &'a CInputMouseWheelMsg {
        <CInputMouseWheelMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseWheelMsg {
    pub fn new() -> CInputMouseWheelMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseWheelDirection direction = 2;


    pub fn get_direction(&self) -> EStreamMouseWheelDirection {
        self.direction.unwrap_or(EStreamMouseWheelDirection::k_EStreamMouseWheelUp)
    }
    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EStreamMouseWheelDirection) {
        self.direction = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputMouseWheelMsg {
    fn is_initialized(&self) -> bool {
        if self.direction.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.direction {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseWheelMsg {
        CInputMouseWheelMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputMouseWheelMsg| { &m.input_mark },
                |m: &mut CInputMouseWheelMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamMouseWheelDirection>>(
                "direction",
                |m: &CInputMouseWheelMsg| { &m.direction },
                |m: &mut CInputMouseWheelMsg| { &mut m.direction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputMouseWheelMsg>(
                "CInputMouseWheelMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseWheelMsg {
        static instance: ::protobuf::rt::LazyV2<CInputMouseWheelMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputMouseWheelMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseWheelMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseWheelMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseWheelMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    button: ::std::option::Option<EStreamMouseButton>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseDownMsg {
    fn default() -> &'a CInputMouseDownMsg {
        <CInputMouseDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseDownMsg {
    pub fn new() -> CInputMouseDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;


    pub fn get_button(&self) -> EStreamMouseButton {
        self.button.unwrap_or(EStreamMouseButton::k_EStreamMouseButtonLeft)
    }
    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputMouseDownMsg {
    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.button, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseDownMsg {
        CInputMouseDownMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputMouseDownMsg| { &m.input_mark },
                |m: &mut CInputMouseDownMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamMouseButton>>(
                "button",
                |m: &CInputMouseDownMsg| { &m.button },
                |m: &mut CInputMouseDownMsg| { &mut m.button },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputMouseDownMsg>(
                "CInputMouseDownMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseDownMsg {
        static instance: ::protobuf::rt::LazyV2<CInputMouseDownMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputMouseDownMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseDownMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseDownMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    button: ::std::option::Option<EStreamMouseButton>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseUpMsg {
    fn default() -> &'a CInputMouseUpMsg {
        <CInputMouseUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseUpMsg {
    pub fn new() -> CInputMouseUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;


    pub fn get_button(&self) -> EStreamMouseButton {
        self.button.unwrap_or(EStreamMouseButton::k_EStreamMouseButtonLeft)
    }
    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputMouseUpMsg {
    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.button, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseUpMsg {
        CInputMouseUpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputMouseUpMsg| { &m.input_mark },
                |m: &mut CInputMouseUpMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamMouseButton>>(
                "button",
                |m: &CInputMouseUpMsg| { &m.button },
                |m: &mut CInputMouseUpMsg| { &mut m.button },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputMouseUpMsg>(
                "CInputMouseUpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseUpMsg {
        static instance: ::protobuf::rt::LazyV2<CInputMouseUpMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputMouseUpMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseUpMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseUpMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputKeyDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    scancode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputKeyDownMsg {
    fn default() -> &'a CInputKeyDownMsg {
        <CInputKeyDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputKeyDownMsg {
    pub fn new() -> CInputKeyDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;


    pub fn get_scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }
    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputKeyDownMsg {
    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scancode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputKeyDownMsg {
        CInputKeyDownMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputKeyDownMsg| { &m.input_mark },
                |m: &mut CInputKeyDownMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scancode",
                |m: &CInputKeyDownMsg| { &m.scancode },
                |m: &mut CInputKeyDownMsg| { &mut m.scancode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputKeyDownMsg>(
                "CInputKeyDownMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputKeyDownMsg {
        static instance: ::protobuf::rt::LazyV2<CInputKeyDownMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputKeyDownMsg::new)
    }
}

impl ::protobuf::Clear for CInputKeyDownMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputKeyDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputKeyDownMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputKeyUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    scancode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputKeyUpMsg {
    fn default() -> &'a CInputKeyUpMsg {
        <CInputKeyUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputKeyUpMsg {
    pub fn new() -> CInputKeyUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;


    pub fn get_scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }
    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputKeyUpMsg {
    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scancode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputKeyUpMsg {
        CInputKeyUpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputKeyUpMsg| { &m.input_mark },
                |m: &mut CInputKeyUpMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scancode",
                |m: &CInputKeyUpMsg| { &m.scancode },
                |m: &mut CInputKeyUpMsg| { &mut m.scancode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputKeyUpMsg>(
                "CInputKeyUpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputKeyUpMsg {
        static instance: ::protobuf::rt::LazyV2<CInputKeyUpMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputKeyUpMsg::new)
    }
}

impl ::protobuf::Clear for CInputKeyUpMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputKeyUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputKeyUpMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTextMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    text_utf8: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTextMsg {
    fn default() -> &'a CInputTextMsg {
        <CInputTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTextMsg {
    pub fn new() -> CInputTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required string text_utf8 = 2;


    pub fn get_text_utf8(&self) -> &str {
        match self.text_utf8.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text_utf8(&mut self) {
        self.text_utf8.clear();
    }

    pub fn has_text_utf8(&self) -> bool {
        self.text_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_utf8(&mut self, v: ::std::string::String) {
        self.text_utf8 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text_utf8(&mut self) -> &mut ::std::string::String {
        if self.text_utf8.is_none() {
            self.text_utf8.set_default();
        }
        self.text_utf8.as_mut().unwrap()
    }

    // Take field
    pub fn take_text_utf8(&mut self) -> ::std::string::String {
        self.text_utf8.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CInputTextMsg {
    fn is_initialized(&self) -> bool {
        if self.text_utf8.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text_utf8)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text_utf8.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.text_utf8.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTextMsg {
        CInputTextMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CInputTextMsg| { &m.input_mark },
                |m: &mut CInputTextMsg| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text_utf8",
                |m: &CInputTextMsg| { &m.text_utf8 },
                |m: &mut CInputTextMsg| { &mut m.text_utf8 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CInputTextMsg>(
                "CInputTextMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTextMsg {
        static instance: ::protobuf::rt::LazyV2<CInputTextMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CInputTextMsg::new)
    }
}

impl ::protobuf::Clear for CInputTextMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.text_utf8.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTextMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTitleMsg {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTitleMsg {
    fn default() -> &'a CSetTitleMsg {
        <CSetTitleMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTitleMsg {
    pub fn new() -> CSetTitleMsg {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSetTitleMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTitleMsg {
        CSetTitleMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CSetTitleMsg| { &m.text },
                |m: &mut CSetTitleMsg| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetTitleMsg>(
                "CSetTitleMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTitleMsg {
        static instance: ::protobuf::rt::LazyV2<CSetTitleMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetTitleMsg::new)
    }
}

impl ::protobuf::Clear for CSetTitleMsg {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTitleMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTitleMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCaptureSizeMsg {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetCaptureSizeMsg {
    fn default() -> &'a CSetCaptureSizeMsg {
        <CSetCaptureSizeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCaptureSizeMsg {
    pub fn new() -> CSetCaptureSizeMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCaptureSizeMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetCaptureSizeMsg {
        CSetCaptureSizeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &CSetCaptureSizeMsg| { &m.width },
                |m: &mut CSetCaptureSizeMsg| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &CSetCaptureSizeMsg| { &m.height },
                |m: &mut CSetCaptureSizeMsg| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetCaptureSizeMsg>(
                "CSetCaptureSizeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetCaptureSizeMsg {
        static instance: ::protobuf::rt::LazyV2<CSetCaptureSizeMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetCaptureSizeMsg::new)
    }
}

impl ::protobuf::Clear for CSetCaptureSizeMsg {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCaptureSizeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCaptureSizeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetIconMsg {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetIconMsg {
    fn default() -> &'a CSetIconMsg {
        <CSetIconMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetIconMsg {
    pub fn new() -> CSetIconMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional bytes image = 3;


    pub fn get_image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetIconMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetIconMsg {
        CSetIconMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &CSetIconMsg| { &m.width },
                |m: &mut CSetIconMsg| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &CSetIconMsg| { &m.height },
                |m: &mut CSetIconMsg| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image",
                |m: &CSetIconMsg| { &m.image },
                |m: &mut CSetIconMsg| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetIconMsg>(
                "CSetIconMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetIconMsg {
        static instance: ::protobuf::rt::LazyV2<CSetIconMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetIconMsg::new)
    }
}

impl ::protobuf::Clear for CSetIconMsg {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetIconMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetIconMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetFlashStateMsg {
    // message fields
    flags: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    timeout_ms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetFlashStateMsg {
    fn default() -> &'a CSetFlashStateMsg {
        <CSetFlashStateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetFlashStateMsg {
    pub fn new() -> CSetFlashStateMsg {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 1;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 2;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout_ms = 3;


    pub fn get_timeout_ms(&self) -> u32 {
        self.timeout_ms.unwrap_or(0)
    }
    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: u32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetFlashStateMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timeout_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetFlashStateMsg {
        CSetFlashStateMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CSetFlashStateMsg| { &m.flags },
                |m: &mut CSetFlashStateMsg| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CSetFlashStateMsg| { &m.count },
                |m: &mut CSetFlashStateMsg| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timeout_ms",
                |m: &CSetFlashStateMsg| { &m.timeout_ms },
                |m: &mut CSetFlashStateMsg| { &mut m.timeout_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetFlashStateMsg>(
                "CSetFlashStateMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetFlashStateMsg {
        static instance: ::protobuf::rt::LazyV2<CSetFlashStateMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetFlashStateMsg::new)
    }
}

impl ::protobuf::Clear for CSetFlashStateMsg {
    fn clear(&mut self) {
        self.flags = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.timeout_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetFlashStateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetFlashStateMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CShowCursorMsg {
    // message fields
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CShowCursorMsg {
    fn default() -> &'a CShowCursorMsg {
        <CShowCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CShowCursorMsg {
    pub fn new() -> CShowCursorMsg {
        ::std::default::Default::default()
    }

    // optional float x_normalized = 1;


    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }
    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 2;


    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }
    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CShowCursorMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x_normalized = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y_normalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x_normalized {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CShowCursorMsg {
        CShowCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x_normalized",
                |m: &CShowCursorMsg| { &m.x_normalized },
                |m: &mut CShowCursorMsg| { &mut m.x_normalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y_normalized",
                |m: &CShowCursorMsg| { &m.y_normalized },
                |m: &mut CShowCursorMsg| { &mut m.y_normalized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CShowCursorMsg>(
                "CShowCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CShowCursorMsg {
        static instance: ::protobuf::rt::LazyV2<CShowCursorMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CShowCursorMsg::new)
    }
}

impl ::protobuf::Clear for CShowCursorMsg {
    fn clear(&mut self) {
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CShowCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CShowCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CHideCursorMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CHideCursorMsg {
    fn default() -> &'a CHideCursorMsg {
        <CHideCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CHideCursorMsg {
    pub fn new() -> CHideCursorMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CHideCursorMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CHideCursorMsg {
        CHideCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CHideCursorMsg>(
                "CHideCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CHideCursorMsg {
        static instance: ::protobuf::rt::LazyV2<CHideCursorMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CHideCursorMsg::new)
    }
}

impl ::protobuf::Clear for CHideCursorMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CHideCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CHideCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCursorMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetCursorMsg {
    fn default() -> &'a CSetCursorMsg {
        <CSetCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCursorMsg {
    pub fn new() -> CSetCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;


    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }
    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCursorMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetCursorMsg {
        CSetCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cursor_id",
                |m: &CSetCursorMsg| { &m.cursor_id },
                |m: &mut CSetCursorMsg| { &mut m.cursor_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetCursorMsg>(
                "CSetCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetCursorMsg {
        static instance: ::protobuf::rt::LazyV2<CSetCursorMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetCursorMsg::new)
    }
}

impl ::protobuf::Clear for CSetCursorMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGetCursorImageMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGetCursorImageMsg {
    fn default() -> &'a CGetCursorImageMsg {
        <CGetCursorImageMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetCursorImageMsg {
    pub fn new() -> CGetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;


    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }
    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGetCursorImageMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGetCursorImageMsg {
        CGetCursorImageMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cursor_id",
                |m: &CGetCursorImageMsg| { &m.cursor_id },
                |m: &mut CGetCursorImageMsg| { &mut m.cursor_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGetCursorImageMsg>(
                "CGetCursorImageMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGetCursorImageMsg {
        static instance: ::protobuf::rt::LazyV2<CGetCursorImageMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGetCursorImageMsg::new)
    }
}

impl ::protobuf::Clear for CGetCursorImageMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGetCursorImageMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCursorImageMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    hot_x: ::std::option::Option<i32>,
    hot_y: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetCursorImageMsg {
    fn default() -> &'a CSetCursorImageMsg {
        <CSetCursorImageMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCursorImageMsg {
    pub fn new() -> CSetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;


    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }
    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;


    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;


    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 hot_x = 4;


    pub fn get_hot_x(&self) -> i32 {
        self.hot_x.unwrap_or(0)
    }
    pub fn clear_hot_x(&mut self) {
        self.hot_x = ::std::option::Option::None;
    }

    pub fn has_hot_x(&self) -> bool {
        self.hot_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_x(&mut self, v: i32) {
        self.hot_x = ::std::option::Option::Some(v);
    }

    // optional int32 hot_y = 5;


    pub fn get_hot_y(&self) -> i32 {
        self.hot_y.unwrap_or(0)
    }
    pub fn clear_hot_y(&mut self) {
        self.hot_y = ::std::option::Option::None;
    }

    pub fn has_hot_y(&self) -> bool {
        self.hot_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_y(&mut self, v: i32) {
        self.hot_y = ::std::option::Option::Some(v);
    }

    // optional bytes image = 6;


    pub fn get_image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetCursorImageMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hot_x = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hot_y = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hot_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hot_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hot_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hot_y {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetCursorImageMsg {
        CSetCursorImageMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cursor_id",
                |m: &CSetCursorImageMsg| { &m.cursor_id },
                |m: &mut CSetCursorImageMsg| { &mut m.cursor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &CSetCursorImageMsg| { &m.width },
                |m: &mut CSetCursorImageMsg| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &CSetCursorImageMsg| { &m.height },
                |m: &mut CSetCursorImageMsg| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "hot_x",
                |m: &CSetCursorImageMsg| { &m.hot_x },
                |m: &mut CSetCursorImageMsg| { &mut m.hot_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "hot_y",
                |m: &CSetCursorImageMsg| { &m.hot_y },
                |m: &mut CSetCursorImageMsg| { &mut m.hot_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "image",
                |m: &CSetCursorImageMsg| { &m.image },
                |m: &mut CSetCursorImageMsg| { &mut m.image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetCursorImageMsg>(
                "CSetCursorImageMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetCursorImageMsg {
        static instance: ::protobuf::rt::LazyV2<CSetCursorImageMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetCursorImageMsg::new)
    }
}

impl ::protobuf::Clear for CSetCursorImageMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.hot_x = ::std::option::Option::None;
        self.hot_y = ::std::option::Option::None;
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCursorImageMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoDecoderInfoMsg {
    // message fields
    info: ::protobuf::SingularField<::std::string::String>,
    threads: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVideoDecoderInfoMsg {
    fn default() -> &'a CVideoDecoderInfoMsg {
        <CVideoDecoderInfoMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVideoDecoderInfoMsg {
    pub fn new() -> CVideoDecoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;


    pub fn get_info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 threads = 2;


    pub fn get_threads(&self) -> i32 {
        self.threads.unwrap_or(0)
    }
    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: i32) {
        self.threads = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVideoDecoderInfoMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threads = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.threads {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.threads {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVideoDecoderInfoMsg {
        CVideoDecoderInfoMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "info",
                |m: &CVideoDecoderInfoMsg| { &m.info },
                |m: &mut CVideoDecoderInfoMsg| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "threads",
                |m: &CVideoDecoderInfoMsg| { &m.threads },
                |m: &mut CVideoDecoderInfoMsg| { &mut m.threads },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CVideoDecoderInfoMsg>(
                "CVideoDecoderInfoMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVideoDecoderInfoMsg {
        static instance: ::protobuf::rt::LazyV2<CVideoDecoderInfoMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CVideoDecoderInfoMsg::new)
    }
}

impl ::protobuf::Clear for CVideoDecoderInfoMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.threads = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoDecoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoDecoderInfoMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoEncoderInfoMsg {
    // message fields
    info: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVideoEncoderInfoMsg {
    fn default() -> &'a CVideoEncoderInfoMsg {
        <CVideoEncoderInfoMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVideoEncoderInfoMsg {
    pub fn new() -> CVideoEncoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;


    pub fn get_info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVideoEncoderInfoMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVideoEncoderInfoMsg {
        CVideoEncoderInfoMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "info",
                |m: &CVideoEncoderInfoMsg| { &m.info },
                |m: &mut CVideoEncoderInfoMsg| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CVideoEncoderInfoMsg>(
                "CVideoEncoderInfoMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVideoEncoderInfoMsg {
        static instance: ::protobuf::rt::LazyV2<CVideoEncoderInfoMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CVideoEncoderInfoMsg::new)
    }
}

impl ::protobuf::Clear for CVideoEncoderInfoMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoEncoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoEncoderInfoMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CPauseMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPauseMsg {
    fn default() -> &'a CPauseMsg {
        <CPauseMsg as ::protobuf::Message>::default_instance()
    }
}

impl CPauseMsg {
    pub fn new() -> CPauseMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPauseMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPauseMsg {
        CPauseMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPauseMsg>(
                "CPauseMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPauseMsg {
        static instance: ::protobuf::rt::LazyV2<CPauseMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPauseMsg::new)
    }
}

impl ::protobuf::Clear for CPauseMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPauseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPauseMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CResumeMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CResumeMsg {
    fn default() -> &'a CResumeMsg {
        <CResumeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CResumeMsg {
    pub fn new() -> CResumeMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CResumeMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CResumeMsg {
        CResumeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CResumeMsg>(
                "CResumeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CResumeMsg {
        static instance: ::protobuf::rt::LazyV2<CResumeMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CResumeMsg::new)
    }
}

impl ::protobuf::Clear for CResumeMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CResumeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CResumeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CEnableHighResCaptureMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CEnableHighResCaptureMsg {
    fn default() -> &'a CEnableHighResCaptureMsg {
        <CEnableHighResCaptureMsg as ::protobuf::Message>::default_instance()
    }
}

impl CEnableHighResCaptureMsg {
    pub fn new() -> CEnableHighResCaptureMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CEnableHighResCaptureMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CEnableHighResCaptureMsg {
        CEnableHighResCaptureMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CEnableHighResCaptureMsg>(
                "CEnableHighResCaptureMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CEnableHighResCaptureMsg {
        static instance: ::protobuf::rt::LazyV2<CEnableHighResCaptureMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CEnableHighResCaptureMsg::new)
    }
}

impl ::protobuf::Clear for CEnableHighResCaptureMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CEnableHighResCaptureMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEnableHighResCaptureMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDisableHighResCaptureMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDisableHighResCaptureMsg {
    fn default() -> &'a CDisableHighResCaptureMsg {
        <CDisableHighResCaptureMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDisableHighResCaptureMsg {
    pub fn new() -> CDisableHighResCaptureMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CDisableHighResCaptureMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDisableHighResCaptureMsg {
        CDisableHighResCaptureMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CDisableHighResCaptureMsg>(
                "CDisableHighResCaptureMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDisableHighResCaptureMsg {
        static instance: ::protobuf::rt::LazyV2<CDisableHighResCaptureMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CDisableHighResCaptureMsg::new)
    }
}

impl ::protobuf::Clear for CDisableHighResCaptureMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDisableHighResCaptureMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDisableHighResCaptureMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CToggleMagnificationMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CToggleMagnificationMsg {
    fn default() -> &'a CToggleMagnificationMsg {
        <CToggleMagnificationMsg as ::protobuf::Message>::default_instance()
    }
}

impl CToggleMagnificationMsg {
    pub fn new() -> CToggleMagnificationMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CToggleMagnificationMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CToggleMagnificationMsg {
        CToggleMagnificationMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CToggleMagnificationMsg>(
                "CToggleMagnificationMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CToggleMagnificationMsg {
        static instance: ::protobuf::rt::LazyV2<CToggleMagnificationMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CToggleMagnificationMsg::new)
    }
}

impl ::protobuf::Clear for CToggleMagnificationMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CToggleMagnificationMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CToggleMagnificationMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCapslockMsg {
    // message fields
    pressed: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetCapslockMsg {
    fn default() -> &'a CSetCapslockMsg {
        <CSetCapslockMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCapslockMsg {
    pub fn new() -> CSetCapslockMsg {
        ::std::default::Default::default()
    }

    // optional bool pressed = 1;


    pub fn get_pressed(&self) -> bool {
        self.pressed.unwrap_or(false)
    }
    pub fn clear_pressed(&mut self) {
        self.pressed = ::std::option::Option::None;
    }

    pub fn has_pressed(&self) -> bool {
        self.pressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pressed(&mut self, v: bool) {
        self.pressed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCapslockMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pressed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pressed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pressed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetCapslockMsg {
        CSetCapslockMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pressed",
                |m: &CSetCapslockMsg| { &m.pressed },
                |m: &mut CSetCapslockMsg| { &mut m.pressed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetCapslockMsg>(
                "CSetCapslockMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetCapslockMsg {
        static instance: ::protobuf::rt::LazyV2<CSetCapslockMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetCapslockMsg::new)
    }
}

impl ::protobuf::Clear for CSetCapslockMsg {
    fn clear(&mut self) {
        self.pressed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCapslockMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCapslockMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingKeymapEntry {
    // message fields
    scancode: ::std::option::Option<i32>,
    normal_keycode: ::std::option::Option<i32>,
    shift_keycode: ::std::option::Option<i32>,
    capslock_keycode: ::std::option::Option<i32>,
    shift_capslock_keycode: ::std::option::Option<i32>,
    altgr_keycode: ::std::option::Option<i32>,
    altgr_shift_keycode: ::std::option::Option<i32>,
    altgr_capslock_keycode: ::std::option::Option<i32>,
    altgr_shift_capslock_keycode: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingKeymapEntry {
    fn default() -> &'a CStreamingKeymapEntry {
        <CStreamingKeymapEntry as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingKeymapEntry {
    pub fn new() -> CStreamingKeymapEntry {
        ::std::default::Default::default()
    }

    // optional int32 scancode = 1;


    pub fn get_scancode(&self) -> i32 {
        self.scancode.unwrap_or(0)
    }
    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: i32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    // optional int32 normal_keycode = 2;


    pub fn get_normal_keycode(&self) -> i32 {
        self.normal_keycode.unwrap_or(0)
    }
    pub fn clear_normal_keycode(&mut self) {
        self.normal_keycode = ::std::option::Option::None;
    }

    pub fn has_normal_keycode(&self) -> bool {
        self.normal_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_keycode(&mut self, v: i32) {
        self.normal_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 shift_keycode = 3;


    pub fn get_shift_keycode(&self) -> i32 {
        self.shift_keycode.unwrap_or(0)
    }
    pub fn clear_shift_keycode(&mut self) {
        self.shift_keycode = ::std::option::Option::None;
    }

    pub fn has_shift_keycode(&self) -> bool {
        self.shift_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_keycode(&mut self, v: i32) {
        self.shift_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 capslock_keycode = 4;


    pub fn get_capslock_keycode(&self) -> i32 {
        self.capslock_keycode.unwrap_or(0)
    }
    pub fn clear_capslock_keycode(&mut self) {
        self.capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_capslock_keycode(&self) -> bool {
        self.capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capslock_keycode(&mut self, v: i32) {
        self.capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 shift_capslock_keycode = 5;


    pub fn get_shift_capslock_keycode(&self) -> i32 {
        self.shift_capslock_keycode.unwrap_or(0)
    }
    pub fn clear_shift_capslock_keycode(&mut self) {
        self.shift_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_shift_capslock_keycode(&self) -> bool {
        self.shift_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_capslock_keycode(&mut self, v: i32) {
        self.shift_capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_keycode = 6;


    pub fn get_altgr_keycode(&self) -> i32 {
        self.altgr_keycode.unwrap_or(0)
    }
    pub fn clear_altgr_keycode(&mut self) {
        self.altgr_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_keycode(&self) -> bool {
        self.altgr_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_keycode(&mut self, v: i32) {
        self.altgr_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_shift_keycode = 7;


    pub fn get_altgr_shift_keycode(&self) -> i32 {
        self.altgr_shift_keycode.unwrap_or(0)
    }
    pub fn clear_altgr_shift_keycode(&mut self) {
        self.altgr_shift_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_shift_keycode(&self) -> bool {
        self.altgr_shift_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_shift_keycode(&mut self, v: i32) {
        self.altgr_shift_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_capslock_keycode = 8;


    pub fn get_altgr_capslock_keycode(&self) -> i32 {
        self.altgr_capslock_keycode.unwrap_or(0)
    }
    pub fn clear_altgr_capslock_keycode(&mut self) {
        self.altgr_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_capslock_keycode(&self) -> bool {
        self.altgr_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_capslock_keycode(&mut self, v: i32) {
        self.altgr_capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_shift_capslock_keycode = 9;


    pub fn get_altgr_shift_capslock_keycode(&self) -> i32 {
        self.altgr_shift_capslock_keycode.unwrap_or(0)
    }
    pub fn clear_altgr_shift_capslock_keycode(&mut self) {
        self.altgr_shift_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_shift_capslock_keycode(&self) -> bool {
        self.altgr_shift_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_shift_capslock_keycode(&mut self, v: i32) {
        self.altgr_shift_capslock_keycode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingKeymapEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.scancode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.normal_keycode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shift_keycode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.capslock_keycode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shift_capslock_keycode = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.altgr_keycode = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.altgr_shift_keycode = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.altgr_capslock_keycode = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.altgr_shift_capslock_keycode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.normal_keycode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shift_keycode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.capslock_keycode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.shift_capslock_keycode {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.altgr_keycode {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.altgr_shift_keycode {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.altgr_capslock_keycode {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.altgr_shift_capslock_keycode {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.scancode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.normal_keycode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.shift_keycode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.capslock_keycode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.shift_capslock_keycode {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.altgr_keycode {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.altgr_shift_keycode {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.altgr_capslock_keycode {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.altgr_shift_capslock_keycode {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingKeymapEntry {
        CStreamingKeymapEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "scancode",
                |m: &CStreamingKeymapEntry| { &m.scancode },
                |m: &mut CStreamingKeymapEntry| { &mut m.scancode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "normal_keycode",
                |m: &CStreamingKeymapEntry| { &m.normal_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.normal_keycode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shift_keycode",
                |m: &CStreamingKeymapEntry| { &m.shift_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.shift_keycode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "capslock_keycode",
                |m: &CStreamingKeymapEntry| { &m.capslock_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.capslock_keycode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shift_capslock_keycode",
                |m: &CStreamingKeymapEntry| { &m.shift_capslock_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.shift_capslock_keycode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "altgr_keycode",
                |m: &CStreamingKeymapEntry| { &m.altgr_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.altgr_keycode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "altgr_shift_keycode",
                |m: &CStreamingKeymapEntry| { &m.altgr_shift_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.altgr_shift_keycode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "altgr_capslock_keycode",
                |m: &CStreamingKeymapEntry| { &m.altgr_capslock_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.altgr_capslock_keycode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "altgr_shift_capslock_keycode",
                |m: &CStreamingKeymapEntry| { &m.altgr_shift_capslock_keycode },
                |m: &mut CStreamingKeymapEntry| { &mut m.altgr_shift_capslock_keycode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingKeymapEntry>(
                "CStreamingKeymapEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingKeymapEntry {
        static instance: ::protobuf::rt::LazyV2<CStreamingKeymapEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingKeymapEntry::new)
    }
}

impl ::protobuf::Clear for CStreamingKeymapEntry {
    fn clear(&mut self) {
        self.scancode = ::std::option::Option::None;
        self.normal_keycode = ::std::option::Option::None;
        self.shift_keycode = ::std::option::Option::None;
        self.capslock_keycode = ::std::option::Option::None;
        self.shift_capslock_keycode = ::std::option::Option::None;
        self.altgr_keycode = ::std::option::Option::None;
        self.altgr_shift_keycode = ::std::option::Option::None;
        self.altgr_capslock_keycode = ::std::option::Option::None;
        self.altgr_shift_capslock_keycode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingKeymapEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingKeymapEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingKeymap {
    // message fields
    pub entries: ::protobuf::RepeatedField<CStreamingKeymapEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingKeymap {
    fn default() -> &'a CStreamingKeymap {
        <CStreamingKeymap as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingKeymap {
    pub fn new() -> CStreamingKeymap {
        ::std::default::Default::default()
    }

    // repeated .CStreamingKeymapEntry entries = 1;


    pub fn get_entries(&self) -> &[CStreamingKeymapEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CStreamingKeymapEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CStreamingKeymapEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CStreamingKeymapEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CStreamingKeymap {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingKeymap {
        CStreamingKeymap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingKeymapEntry>>(
                "entries",
                |m: &CStreamingKeymap| { &m.entries },
                |m: &mut CStreamingKeymap| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingKeymap>(
                "CStreamingKeymap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingKeymap {
        static instance: ::protobuf::rt::LazyV2<CStreamingKeymap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingKeymap::new)
    }
}

impl ::protobuf::Clear for CStreamingKeymap {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingKeymap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingKeymap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetKeymapMsg {
    // message fields
    pub keymap: ::protobuf::SingularPtrField<CStreamingKeymap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetKeymapMsg {
    fn default() -> &'a CSetKeymapMsg {
        <CSetKeymapMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetKeymapMsg {
    pub fn new() -> CSetKeymapMsg {
        ::std::default::Default::default()
    }

    // optional .CStreamingKeymap keymap = 1;


    pub fn get_keymap(&self) -> &CStreamingKeymap {
        self.keymap.as_ref().unwrap_or_else(|| <CStreamingKeymap as ::protobuf::Message>::default_instance())
    }
    pub fn clear_keymap(&mut self) {
        self.keymap.clear();
    }

    pub fn has_keymap(&self) -> bool {
        self.keymap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keymap(&mut self, v: CStreamingKeymap) {
        self.keymap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keymap(&mut self) -> &mut CStreamingKeymap {
        if self.keymap.is_none() {
            self.keymap.set_default();
        }
        self.keymap.as_mut().unwrap()
    }

    // Take field
    pub fn take_keymap(&mut self) -> CStreamingKeymap {
        self.keymap.take().unwrap_or_else(|| CStreamingKeymap::new())
    }
}

impl ::protobuf::Message for CSetKeymapMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.keymap {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keymap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.keymap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.keymap.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetKeymapMsg {
        CSetKeymapMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingKeymap>>(
                "keymap",
                |m: &CSetKeymapMsg| { &m.keymap },
                |m: &mut CSetKeymapMsg| { &mut m.keymap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetKeymapMsg>(
                "CSetKeymapMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetKeymapMsg {
        static instance: ::protobuf::rt::LazyV2<CSetKeymapMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetKeymapMsg::new)
    }
}

impl ::protobuf::Clear for CSetKeymapMsg {
    fn clear(&mut self) {
        self.keymap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetKeymapMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetKeymapMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStopRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStopRequest {
    fn default() -> &'a CStopRequest {
        <CStopRequest as ::protobuf::Message>::default_instance()
    }
}

impl CStopRequest {
    pub fn new() -> CStopRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStopRequest {
        CStopRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStopRequest>(
                "CStopRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStopRequest {
        static instance: ::protobuf::rt::LazyV2<CStopRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStopRequest::new)
    }
}

impl ::protobuf::Clear for CStopRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStopRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStopRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CQuitRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CQuitRequest {
    fn default() -> &'a CQuitRequest {
        <CQuitRequest as ::protobuf::Message>::default_instance()
    }
}

impl CQuitRequest {
    pub fn new() -> CQuitRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CQuitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CQuitRequest {
        CQuitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CQuitRequest>(
                "CQuitRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CQuitRequest {
        static instance: ::protobuf::rt::LazyV2<CQuitRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CQuitRequest::new)
    }
}

impl ::protobuf::Clear for CQuitRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CQuitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CQuitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDeleteCursorMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDeleteCursorMsg {
    fn default() -> &'a CDeleteCursorMsg {
        <CDeleteCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDeleteCursorMsg {
    pub fn new() -> CDeleteCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;


    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }
    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDeleteCursorMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cursor_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDeleteCursorMsg {
        CDeleteCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cursor_id",
                |m: &CDeleteCursorMsg| { &m.cursor_id },
                |m: &mut CDeleteCursorMsg| { &mut m.cursor_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CDeleteCursorMsg>(
                "CDeleteCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDeleteCursorMsg {
        static instance: ::protobuf::rt::LazyV2<CDeleteCursorMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CDeleteCursorMsg::new)
    }
}

impl ::protobuf::Clear for CDeleteCursorMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDeleteCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDeleteCursorMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetStreamingClientConfig {
    // message fields
    pub config: ::protobuf::SingularPtrField<CStreamingClientConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetStreamingClientConfig {
    fn default() -> &'a CSetStreamingClientConfig {
        <CSetStreamingClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl CSetStreamingClientConfig {
    pub fn new() -> CSetStreamingClientConfig {
        ::std::default::Default::default()
    }

    // required .CStreamingClientConfig config = 1;


    pub fn get_config(&self) -> &CStreamingClientConfig {
        self.config.as_ref().unwrap_or_else(|| <CStreamingClientConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: CStreamingClientConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut CStreamingClientConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> CStreamingClientConfig {
        self.config.take().unwrap_or_else(|| CStreamingClientConfig::new())
    }
}

impl ::protobuf::Message for CSetStreamingClientConfig {
    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetStreamingClientConfig {
        CSetStreamingClientConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CStreamingClientConfig>>(
                "config",
                |m: &CSetStreamingClientConfig| { &m.config },
                |m: &mut CSetStreamingClientConfig| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetStreamingClientConfig>(
                "CSetStreamingClientConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetStreamingClientConfig {
        static instance: ::protobuf::rt::LazyV2<CSetStreamingClientConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetStreamingClientConfig::new)
    }
}

impl ::protobuf::Clear for CSetStreamingClientConfig {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetStreamingClientConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetQoSMsg {
    // message fields
    use_qos: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetQoSMsg {
    fn default() -> &'a CSetQoSMsg {
        <CSetQoSMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetQoSMsg {
    pub fn new() -> CSetQoSMsg {
        ::std::default::Default::default()
    }

    // required bool use_qos = 1;


    pub fn get_use_qos(&self) -> bool {
        self.use_qos.unwrap_or(false)
    }
    pub fn clear_use_qos(&mut self) {
        self.use_qos = ::std::option::Option::None;
    }

    pub fn has_use_qos(&self) -> bool {
        self.use_qos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_qos(&mut self, v: bool) {
        self.use_qos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetQoSMsg {
    fn is_initialized(&self) -> bool {
        if self.use_qos.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_qos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.use_qos {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.use_qos {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetQoSMsg {
        CSetQoSMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_qos",
                |m: &CSetQoSMsg| { &m.use_qos },
                |m: &mut CSetQoSMsg| { &mut m.use_qos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetQoSMsg>(
                "CSetQoSMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetQoSMsg {
        static instance: ::protobuf::rt::LazyV2<CSetQoSMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetQoSMsg::new)
    }
}

impl ::protobuf::Clear for CSetQoSMsg {
    fn clear(&mut self) {
        self.use_qos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetQoSMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetQoSMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTargetFramerateMsg {
    // message fields
    framerate: ::std::option::Option<u32>,
    reasons: ::std::option::Option<u32>,
    framerate_numerator: ::std::option::Option<u32>,
    framerate_denominator: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTargetFramerateMsg {
    fn default() -> &'a CSetTargetFramerateMsg {
        <CSetTargetFramerateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTargetFramerateMsg {
    pub fn new() -> CSetTargetFramerateMsg {
        ::std::default::Default::default()
    }

    // required uint32 framerate = 1;


    pub fn get_framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }
    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 reasons = 2;


    pub fn get_reasons(&self) -> u32 {
        self.reasons.unwrap_or(0)
    }
    pub fn clear_reasons(&mut self) {
        self.reasons = ::std::option::Option::None;
    }

    pub fn has_reasons(&self) -> bool {
        self.reasons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reasons(&mut self, v: u32) {
        self.reasons = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_numerator = 3;


    pub fn get_framerate_numerator(&self) -> u32 {
        self.framerate_numerator.unwrap_or(0)
    }
    pub fn clear_framerate_numerator(&mut self) {
        self.framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_framerate_numerator(&self) -> bool {
        self.framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_numerator(&mut self, v: u32) {
        self.framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_denominator = 4;


    pub fn get_framerate_denominator(&self) -> u32 {
        self.framerate_denominator.unwrap_or(0)
    }
    pub fn clear_framerate_denominator(&mut self) {
        self.framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_framerate_denominator(&self) -> bool {
        self.framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_denominator(&mut self, v: u32) {
        self.framerate_denominator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTargetFramerateMsg {
    fn is_initialized(&self) -> bool {
        if self.framerate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.framerate = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reasons = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.framerate_numerator = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.framerate_denominator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reasons {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.framerate_numerator {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.framerate_denominator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.framerate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reasons {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.framerate_numerator {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.framerate_denominator {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTargetFramerateMsg {
        CSetTargetFramerateMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "framerate",
                |m: &CSetTargetFramerateMsg| { &m.framerate },
                |m: &mut CSetTargetFramerateMsg| { &mut m.framerate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reasons",
                |m: &CSetTargetFramerateMsg| { &m.reasons },
                |m: &mut CSetTargetFramerateMsg| { &mut m.reasons },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "framerate_numerator",
                |m: &CSetTargetFramerateMsg| { &m.framerate_numerator },
                |m: &mut CSetTargetFramerateMsg| { &mut m.framerate_numerator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "framerate_denominator",
                |m: &CSetTargetFramerateMsg| { &m.framerate_denominator },
                |m: &mut CSetTargetFramerateMsg| { &mut m.framerate_denominator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetTargetFramerateMsg>(
                "CSetTargetFramerateMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTargetFramerateMsg {
        static instance: ::protobuf::rt::LazyV2<CSetTargetFramerateMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetTargetFramerateMsg::new)
    }
}

impl ::protobuf::Clear for CSetTargetFramerateMsg {
    fn clear(&mut self) {
        self.framerate = ::std::option::Option::None;
        self.reasons = ::std::option::Option::None;
        self.framerate_numerator = ::std::option::Option::None;
        self.framerate_denominator = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTargetFramerateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTargetFramerateMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTargetBitrateMsg {
    // message fields
    bitrate: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTargetBitrateMsg {
    fn default() -> &'a CSetTargetBitrateMsg {
        <CSetTargetBitrateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTargetBitrateMsg {
    pub fn new() -> CSetTargetBitrateMsg {
        ::std::default::Default::default()
    }

    // required int32 bitrate = 1;


    pub fn get_bitrate(&self) -> i32 {
        self.bitrate.unwrap_or(0)
    }
    pub fn clear_bitrate(&mut self) {
        self.bitrate = ::std::option::Option::None;
    }

    pub fn has_bitrate(&self) -> bool {
        self.bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: i32) {
        self.bitrate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTargetBitrateMsg {
    fn is_initialized(&self) -> bool {
        if self.bitrate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bitrate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bitrate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bitrate {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTargetBitrateMsg {
        CSetTargetBitrateMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bitrate",
                |m: &CSetTargetBitrateMsg| { &m.bitrate },
                |m: &mut CSetTargetBitrateMsg| { &mut m.bitrate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetTargetBitrateMsg>(
                "CSetTargetBitrateMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTargetBitrateMsg {
        static instance: ::protobuf::rt::LazyV2<CSetTargetBitrateMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetTargetBitrateMsg::new)
    }
}

impl ::protobuf::Clear for CSetTargetBitrateMsg {
    fn clear(&mut self) {
        self.bitrate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTargetBitrateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTargetBitrateMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct COverlayEnabledMsg {
    // message fields
    enabled: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a COverlayEnabledMsg {
    fn default() -> &'a COverlayEnabledMsg {
        <COverlayEnabledMsg as ::protobuf::Message>::default_instance()
    }
}

impl COverlayEnabledMsg {
    pub fn new() -> COverlayEnabledMsg {
        ::std::default::Default::default()
    }

    // required bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for COverlayEnabledMsg {
    fn is_initialized(&self) -> bool {
        if self.enabled.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> COverlayEnabledMsg {
        COverlayEnabledMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &COverlayEnabledMsg| { &m.enabled },
                |m: &mut COverlayEnabledMsg| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<COverlayEnabledMsg>(
                "COverlayEnabledMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static COverlayEnabledMsg {
        static instance: ::protobuf::rt::LazyV2<COverlayEnabledMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(COverlayEnabledMsg::new)
    }
}

impl ::protobuf::Clear for COverlayEnabledMsg {
    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for COverlayEnabledMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for COverlayEnabledMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetGammaRampMsg {
    // message fields
    gamma_ramp: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetGammaRampMsg {
    fn default() -> &'a CSetGammaRampMsg {
        <CSetGammaRampMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetGammaRampMsg {
    pub fn new() -> CSetGammaRampMsg {
        ::std::default::Default::default()
    }

    // optional bytes gamma_ramp = 1;


    pub fn get_gamma_ramp(&self) -> &[u8] {
        match self.gamma_ramp.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gamma_ramp(&mut self) {
        self.gamma_ramp.clear();
    }

    pub fn has_gamma_ramp(&self) -> bool {
        self.gamma_ramp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma_ramp(&mut self, v: ::std::vec::Vec<u8>) {
        self.gamma_ramp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma_ramp(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gamma_ramp.is_none() {
            self.gamma_ramp.set_default();
        }
        self.gamma_ramp.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma_ramp(&mut self) -> ::std::vec::Vec<u8> {
        self.gamma_ramp.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetGammaRampMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gamma_ramp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gamma_ramp.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gamma_ramp.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetGammaRampMsg {
        CSetGammaRampMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "gamma_ramp",
                |m: &CSetGammaRampMsg| { &m.gamma_ramp },
                |m: &mut CSetGammaRampMsg| { &mut m.gamma_ramp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetGammaRampMsg>(
                "CSetGammaRampMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetGammaRampMsg {
        static instance: ::protobuf::rt::LazyV2<CSetGammaRampMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetGammaRampMsg::new)
    }
}

impl ::protobuf::Clear for CSetGammaRampMsg {
    fn clear(&mut self) {
        self.gamma_ramp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetGammaRampMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetGammaRampMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetActivityMsg {
    // message fields
    activity: ::std::option::Option<EStreamActivity>,
    appid: ::std::option::Option<u32>,
    gameid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetActivityMsg {
    fn default() -> &'a CSetActivityMsg {
        <CSetActivityMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetActivityMsg {
    pub fn new() -> CSetActivityMsg {
        ::std::default::Default::default()
    }

    // optional .EStreamActivity activity = 1;


    pub fn get_activity(&self) -> EStreamActivity {
        self.activity.unwrap_or(EStreamActivity::k_EStreamActivityIdle)
    }
    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: EStreamActivity) {
        self.activity = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 3;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetActivityMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.activity, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetActivityMsg {
        CSetActivityMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamActivity>>(
                "activity",
                |m: &CSetActivityMsg| { &m.activity },
                |m: &mut CSetActivityMsg| { &mut m.activity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CSetActivityMsg| { &m.appid },
                |m: &mut CSetActivityMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gameid",
                |m: &CSetActivityMsg| { &m.gameid },
                |m: &mut CSetActivityMsg| { &mut m.gameid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetActivityMsg>(
                "CSetActivityMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetActivityMsg {
        static instance: ::protobuf::rt::LazyV2<CSetActivityMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetActivityMsg::new)
    }
}

impl ::protobuf::Clear for CSetActivityMsg {
    fn clear(&mut self) {
        self.activity = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetActivityMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetActivityMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSystemSuspendMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSystemSuspendMsg {
    fn default() -> &'a CSystemSuspendMsg {
        <CSystemSuspendMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSystemSuspendMsg {
    pub fn new() -> CSystemSuspendMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSystemSuspendMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSystemSuspendMsg {
        CSystemSuspendMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSystemSuspendMsg>(
                "CSystemSuspendMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSystemSuspendMsg {
        static instance: ::protobuf::rt::LazyV2<CSystemSuspendMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSystemSuspendMsg::new)
    }
}

impl ::protobuf::Clear for CSystemSuspendMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSystemSuspendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSystemSuspendMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereRequestMsg {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVirtualHereRequestMsg {
    fn default() -> &'a CVirtualHereRequestMsg {
        <CVirtualHereRequestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereRequestMsg {
    pub fn new() -> CVirtualHereRequestMsg {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;


    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVirtualHereRequestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVirtualHereRequestMsg {
        CVirtualHereRequestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &CVirtualHereRequestMsg| { &m.hostname },
                |m: &mut CVirtualHereRequestMsg| { &mut m.hostname },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CVirtualHereRequestMsg>(
                "CVirtualHereRequestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVirtualHereRequestMsg {
        static instance: ::protobuf::rt::LazyV2<CVirtualHereRequestMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CVirtualHereRequestMsg::new)
    }
}

impl ::protobuf::Clear for CVirtualHereRequestMsg {
    fn clear(&mut self) {
        self.hostname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereRequestMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereReadyMsg {
    // message fields
    licensed_device_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVirtualHereReadyMsg {
    fn default() -> &'a CVirtualHereReadyMsg {
        <CVirtualHereReadyMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereReadyMsg {
    pub fn new() -> CVirtualHereReadyMsg {
        ::std::default::Default::default()
    }

    // optional uint32 licensed_device_count = 1;


    pub fn get_licensed_device_count(&self) -> u32 {
        self.licensed_device_count.unwrap_or(0)
    }
    pub fn clear_licensed_device_count(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
    }

    pub fn has_licensed_device_count(&self) -> bool {
        self.licensed_device_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_licensed_device_count(&mut self, v: u32) {
        self.licensed_device_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVirtualHereReadyMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.licensed_device_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.licensed_device_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.licensed_device_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVirtualHereReadyMsg {
        CVirtualHereReadyMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "licensed_device_count",
                |m: &CVirtualHereReadyMsg| { &m.licensed_device_count },
                |m: &mut CVirtualHereReadyMsg| { &mut m.licensed_device_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CVirtualHereReadyMsg>(
                "CVirtualHereReadyMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVirtualHereReadyMsg {
        static instance: ::protobuf::rt::LazyV2<CVirtualHereReadyMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CVirtualHereReadyMsg::new)
    }
}

impl ::protobuf::Clear for CVirtualHereReadyMsg {
    fn clear(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereReadyMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereReadyMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereShareDeviceMsg {
    // message fields
    device_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVirtualHereShareDeviceMsg {
    fn default() -> &'a CVirtualHereShareDeviceMsg {
        <CVirtualHereShareDeviceMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereShareDeviceMsg {
    pub fn new() -> CVirtualHereShareDeviceMsg {
        ::std::default::Default::default()
    }

    // optional string device_address = 1;


    pub fn get_device_address(&self) -> &str {
        match self.device_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_address(&mut self) {
        self.device_address.clear();
    }

    pub fn has_device_address(&self) -> bool {
        self.device_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_address(&mut self, v: ::std::string::String) {
        self.device_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_address(&mut self) -> &mut ::std::string::String {
        if self.device_address.is_none() {
            self.device_address.set_default();
        }
        self.device_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_address(&mut self) -> ::std::string::String {
        self.device_address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVirtualHereShareDeviceMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_address.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVirtualHereShareDeviceMsg {
        CVirtualHereShareDeviceMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_address",
                |m: &CVirtualHereShareDeviceMsg| { &m.device_address },
                |m: &mut CVirtualHereShareDeviceMsg| { &mut m.device_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CVirtualHereShareDeviceMsg>(
                "CVirtualHereShareDeviceMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVirtualHereShareDeviceMsg {
        static instance: ::protobuf::rt::LazyV2<CVirtualHereShareDeviceMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CVirtualHereShareDeviceMsg::new)
    }
}

impl ::protobuf::Clear for CVirtualHereShareDeviceMsg {
    fn clear(&mut self) {
        self.device_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereShareDeviceMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereShareDeviceMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetSpectatorModeMsg {
    // message fields
    enabled: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetSpectatorModeMsg {
    fn default() -> &'a CSetSpectatorModeMsg {
        <CSetSpectatorModeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetSpectatorModeMsg {
    pub fn new() -> CSetSpectatorModeMsg {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetSpectatorModeMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetSpectatorModeMsg {
        CSetSpectatorModeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &CSetSpectatorModeMsg| { &m.enabled },
                |m: &mut CSetSpectatorModeMsg| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetSpectatorModeMsg>(
                "CSetSpectatorModeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetSpectatorModeMsg {
        static instance: ::protobuf::rt::LazyV2<CSetSpectatorModeMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetSpectatorModeMsg::new)
    }
}

impl ::protobuf::Clear for CSetSpectatorModeMsg {
    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetSpectatorModeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetSpectatorModeMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CRemoteHIDMsg {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CRemoteHIDMsg {
    fn default() -> &'a CRemoteHIDMsg {
        <CRemoteHIDMsg as ::protobuf::Message>::default_instance()
    }
}

impl CRemoteHIDMsg {
    pub fn new() -> CRemoteHIDMsg {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CRemoteHIDMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CRemoteHIDMsg {
        CRemoteHIDMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CRemoteHIDMsg| { &m.data },
                |m: &mut CRemoteHIDMsg| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CRemoteHIDMsg>(
                "CRemoteHIDMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CRemoteHIDMsg {
        static instance: ::protobuf::rt::LazyV2<CRemoteHIDMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CRemoteHIDMsg::new)
    }
}

impl ::protobuf::Clear for CRemoteHIDMsg {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CRemoteHIDMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CRemoteHIDMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTouchConfigActiveMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    revision: ::std::option::Option<u32>,
    creator: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTouchConfigActiveMsg {
    fn default() -> &'a CTouchConfigActiveMsg {
        <CTouchConfigActiveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchConfigActiveMsg {
    pub fn new() -> CTouchConfigActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;


    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional uint64 creator = 3;


    pub fn get_creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }
    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchConfigActiveMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.creator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.creator {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTouchConfigActiveMsg {
        CTouchConfigActiveMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CTouchConfigActiveMsg| { &m.appid },
                |m: &mut CTouchConfigActiveMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &CTouchConfigActiveMsg| { &m.revision },
                |m: &mut CTouchConfigActiveMsg| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "creator",
                |m: &CTouchConfigActiveMsg| { &m.creator },
                |m: &mut CTouchConfigActiveMsg| { &mut m.creator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTouchConfigActiveMsg>(
                "CTouchConfigActiveMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTouchConfigActiveMsg {
        static instance: ::protobuf::rt::LazyV2<CTouchConfigActiveMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTouchConfigActiveMsg::new)
    }
}

impl ::protobuf::Clear for CTouchConfigActiveMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.creator = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTouchConfigActiveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTouchConfigActiveMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGetTouchConfigDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGetTouchConfigDataMsg {
    fn default() -> &'a CGetTouchConfigDataMsg {
        <CGetTouchConfigDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetTouchConfigDataMsg {
    pub fn new() -> CGetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGetTouchConfigDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGetTouchConfigDataMsg {
        CGetTouchConfigDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CGetTouchConfigDataMsg| { &m.appid },
                |m: &mut CGetTouchConfigDataMsg| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGetTouchConfigDataMsg>(
                "CGetTouchConfigDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGetTouchConfigDataMsg {
        static instance: ::protobuf::rt::LazyV2<CGetTouchConfigDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGetTouchConfigDataMsg::new)
    }
}

impl ::protobuf::Clear for CGetTouchConfigDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGetTouchConfigDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGetTouchConfigDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTouchConfigDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    revision: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    layout: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    creator: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTouchConfigDataMsg {
    fn default() -> &'a CSetTouchConfigDataMsg {
        <CSetTouchConfigDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTouchConfigDataMsg {
    pub fn new() -> CSetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;


    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes layout = 4;


    pub fn get_layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_layout(&mut self) {
        self.layout.clear();
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::std::vec::Vec<u8>) {
        self.layout = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.layout.is_none() {
            self.layout.set_default();
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::std::vec::Vec<u8> {
        self.layout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 creator = 5;


    pub fn get_creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }
    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTouchConfigDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.layout)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.creator = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.layout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.creator {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.layout.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.creator {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTouchConfigDataMsg {
        CSetTouchConfigDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CSetTouchConfigDataMsg| { &m.appid },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &CSetTouchConfigDataMsg| { &m.revision },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CSetTouchConfigDataMsg| { &m.data },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "layout",
                |m: &CSetTouchConfigDataMsg| { &m.layout },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.layout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "creator",
                |m: &CSetTouchConfigDataMsg| { &m.creator },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.creator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetTouchConfigDataMsg>(
                "CSetTouchConfigDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTouchConfigDataMsg {
        static instance: ::protobuf::rt::LazyV2<CSetTouchConfigDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetTouchConfigDataMsg::new)
    }
}

impl ::protobuf::Clear for CSetTouchConfigDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.data.clear();
        self.layout.clear();
        self.creator = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTouchConfigDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTouchConfigDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSaveTouchConfigLayoutMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    layout: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSaveTouchConfigLayoutMsg {
    fn default() -> &'a CSaveTouchConfigLayoutMsg {
        <CSaveTouchConfigLayoutMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSaveTouchConfigLayoutMsg {
    pub fn new() -> CSaveTouchConfigLayoutMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bytes layout = 4;


    pub fn get_layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_layout(&mut self) {
        self.layout.clear();
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::std::vec::Vec<u8>) {
        self.layout = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.layout.is_none() {
            self.layout.set_default();
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::std::vec::Vec<u8> {
        self.layout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSaveTouchConfigLayoutMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.layout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.layout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.layout.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSaveTouchConfigLayoutMsg {
        CSaveTouchConfigLayoutMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CSaveTouchConfigLayoutMsg| { &m.appid },
                |m: &mut CSaveTouchConfigLayoutMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "layout",
                |m: &CSaveTouchConfigLayoutMsg| { &m.layout },
                |m: &mut CSaveTouchConfigLayoutMsg| { &mut m.layout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSaveTouchConfigLayoutMsg>(
                "CSaveTouchConfigLayoutMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSaveTouchConfigLayoutMsg {
        static instance: ::protobuf::rt::LazyV2<CSaveTouchConfigLayoutMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSaveTouchConfigLayoutMsg::new)
    }
}

impl ::protobuf::Clear for CSaveTouchConfigLayoutMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.layout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSaveTouchConfigLayoutMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSaveTouchConfigLayoutMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTouchActionSetActiveMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    actionset_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetActiveMsg {
    fn default() -> &'a CTouchActionSetActiveMsg {
        <CTouchActionSetActiveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchActionSetActiveMsg {
    pub fn new() -> CTouchActionSetActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;


    pub fn get_actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }
    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchActionSetActiveMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.actionset_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actionset_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTouchActionSetActiveMsg {
        CTouchActionSetActiveMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CTouchActionSetActiveMsg| { &m.appid },
                |m: &mut CTouchActionSetActiveMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "actionset_id",
                |m: &CTouchActionSetActiveMsg| { &m.actionset_id },
                |m: &mut CTouchActionSetActiveMsg| { &mut m.actionset_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTouchActionSetActiveMsg>(
                "CTouchActionSetActiveMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTouchActionSetActiveMsg {
        static instance: ::protobuf::rt::LazyV2<CTouchActionSetActiveMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTouchActionSetActiveMsg::new)
    }
}

impl ::protobuf::Clear for CTouchActionSetActiveMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTouchActionSetActiveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTouchActionSetActiveMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTouchActionSetLayerAddedMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    actionset_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetLayerAddedMsg {
    fn default() -> &'a CTouchActionSetLayerAddedMsg {
        <CTouchActionSetLayerAddedMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchActionSetLayerAddedMsg {
    pub fn new() -> CTouchActionSetLayerAddedMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;


    pub fn get_actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }
    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchActionSetLayerAddedMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.actionset_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actionset_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTouchActionSetLayerAddedMsg {
        CTouchActionSetLayerAddedMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CTouchActionSetLayerAddedMsg| { &m.appid },
                |m: &mut CTouchActionSetLayerAddedMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "actionset_id",
                |m: &CTouchActionSetLayerAddedMsg| { &m.actionset_id },
                |m: &mut CTouchActionSetLayerAddedMsg| { &mut m.actionset_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTouchActionSetLayerAddedMsg>(
                "CTouchActionSetLayerAddedMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTouchActionSetLayerAddedMsg {
        static instance: ::protobuf::rt::LazyV2<CTouchActionSetLayerAddedMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTouchActionSetLayerAddedMsg::new)
    }
}

impl ::protobuf::Clear for CTouchActionSetLayerAddedMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTouchActionSetLayerAddedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTouchActionSetLayerAddedMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTouchActionSetLayerRemovedMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    actionset_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetLayerRemovedMsg {
    fn default() -> &'a CTouchActionSetLayerRemovedMsg {
        <CTouchActionSetLayerRemovedMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchActionSetLayerRemovedMsg {
    pub fn new() -> CTouchActionSetLayerRemovedMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;


    pub fn get_actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }
    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchActionSetLayerRemovedMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.actionset_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actionset_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTouchActionSetLayerRemovedMsg {
        CTouchActionSetLayerRemovedMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CTouchActionSetLayerRemovedMsg| { &m.appid },
                |m: &mut CTouchActionSetLayerRemovedMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "actionset_id",
                |m: &CTouchActionSetLayerRemovedMsg| { &m.actionset_id },
                |m: &mut CTouchActionSetLayerRemovedMsg| { &mut m.actionset_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTouchActionSetLayerRemovedMsg>(
                "CTouchActionSetLayerRemovedMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTouchActionSetLayerRemovedMsg {
        static instance: ::protobuf::rt::LazyV2<CTouchActionSetLayerRemovedMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTouchActionSetLayerRemovedMsg::new)
    }
}

impl ::protobuf::Clear for CTouchActionSetLayerRemovedMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTouchActionSetLayerRemovedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTouchActionSetLayerRemovedMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGetTouchIconDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    icon: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGetTouchIconDataMsg {
    fn default() -> &'a CGetTouchIconDataMsg {
        <CGetTouchIconDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetTouchIconDataMsg {
    pub fn new() -> CGetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;


    pub fn get_icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CGetTouchIconDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.icon.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGetTouchIconDataMsg {
        CGetTouchIconDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CGetTouchIconDataMsg| { &m.appid },
                |m: &mut CGetTouchIconDataMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &CGetTouchIconDataMsg| { &m.icon },
                |m: &mut CGetTouchIconDataMsg| { &mut m.icon },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGetTouchIconDataMsg>(
                "CGetTouchIconDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGetTouchIconDataMsg {
        static instance: ::protobuf::rt::LazyV2<CGetTouchIconDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGetTouchIconDataMsg::new)
    }
}

impl ::protobuf::Clear for CGetTouchIconDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGetTouchIconDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGetTouchIconDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTouchIconDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    icon: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTouchIconDataMsg {
    fn default() -> &'a CSetTouchIconDataMsg {
        <CSetTouchIconDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTouchIconDataMsg {
    pub fn new() -> CSetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;


    pub fn get_icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetTouchIconDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.icon.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTouchIconDataMsg {
        CSetTouchIconDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CSetTouchIconDataMsg| { &m.appid },
                |m: &mut CSetTouchIconDataMsg| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &CSetTouchIconDataMsg| { &m.icon },
                |m: &mut CSetTouchIconDataMsg| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CSetTouchIconDataMsg| { &m.data },
                |m: &mut CSetTouchIconDataMsg| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSetTouchIconDataMsg>(
                "CSetTouchIconDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTouchIconDataMsg {
        static instance: ::protobuf::rt::LazyV2<CSetTouchIconDataMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSetTouchIconDataMsg::new)
    }
}

impl ::protobuf::Clear for CSetTouchIconDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTouchIconDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTouchIconDataMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamDataLostMsg {
    // message fields
    pub packets: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamDataLostMsg {
    fn default() -> &'a CStreamDataLostMsg {
        <CStreamDataLostMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStreamDataLostMsg {
    pub fn new() -> CStreamDataLostMsg {
        ::std::default::Default::default()
    }

    // repeated uint32 packets = 1;


    pub fn get_packets(&self) -> &[u32] {
        &self.packets
    }
    pub fn clear_packets(&mut self) {
        self.packets.clear();
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: ::std::vec::Vec<u32>) {
        self.packets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packets
    }

    // Take field
    pub fn take_packets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packets, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CStreamDataLostMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packets {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packets {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamDataLostMsg {
        CStreamDataLostMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "packets",
                |m: &CStreamDataLostMsg| { &m.packets },
                |m: &mut CStreamDataLostMsg| { &mut m.packets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamDataLostMsg>(
                "CStreamDataLostMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamDataLostMsg {
        static instance: ::protobuf::rt::LazyV2<CStreamDataLostMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamDataLostMsg::new)
    }
}

impl ::protobuf::Clear for CStreamDataLostMsg {
    fn clear(&mut self) {
        self.packets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamDataLostMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamDataLostMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAudioFormat {
    // message fields
    format: ::std::option::Option<EAudioFormat>,
    frequency: ::std::option::Option<u32>,
    channels: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAudioFormat {
    fn default() -> &'a CAudioFormat {
        <CAudioFormat as ::protobuf::Message>::default_instance()
    }
}

impl CAudioFormat {
    pub fn new() -> CAudioFormat {
        ::std::default::Default::default()
    }

    // required .EAudioFormat format = 1;


    pub fn get_format(&self) -> EAudioFormat {
        self.format.unwrap_or(EAudioFormat::k_EAudioFormatNone)
    }
    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EAudioFormat) {
        self.format = ::std::option::Option::Some(v);
    }

    // optional uint32 frequency = 2;


    pub fn get_frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 3;


    pub fn get_channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }
    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAudioFormat {
    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.format, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frequency = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.channels = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAudioFormat {
        CAudioFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EAudioFormat>>(
                "format",
                |m: &CAudioFormat| { &m.format },
                |m: &mut CAudioFormat| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frequency",
                |m: &CAudioFormat| { &m.frequency },
                |m: &mut CAudioFormat| { &mut m.frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "channels",
                |m: &CAudioFormat| { &m.channels },
                |m: &mut CAudioFormat| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAudioFormat>(
                "CAudioFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAudioFormat {
        static instance: ::protobuf::rt::LazyV2<CAudioFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAudioFormat::new)
    }
}

impl ::protobuf::Clear for CAudioFormat {
    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAudioFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAudioFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoFormat {
    // message fields
    format: ::std::option::Option<EVideoFormat>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVideoFormat {
    fn default() -> &'a CVideoFormat {
        <CVideoFormat as ::protobuf::Message>::default_instance()
    }
}

impl CVideoFormat {
    pub fn new() -> CVideoFormat {
        ::std::default::Default::default()
    }

    // required .EVideoFormat format = 1;


    pub fn get_format(&self) -> EVideoFormat {
        self.format.unwrap_or(EVideoFormat::k_EVideoFormatNone)
    }
    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EVideoFormat) {
        self.format = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 2;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVideoFormat {
    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.format, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVideoFormat {
        CVideoFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EVideoFormat>>(
                "format",
                |m: &CVideoFormat| { &m.format },
                |m: &mut CVideoFormat| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "width",
                |m: &CVideoFormat| { &m.width },
                |m: &mut CVideoFormat| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &CVideoFormat| { &m.height },
                |m: &mut CVideoFormat| { &mut m.height },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CVideoFormat>(
                "CVideoFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVideoFormat {
        static instance: ::protobuf::rt::LazyV2<CVideoFormat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CVideoFormat::new)
    }
}

impl ::protobuf::Clear for CVideoFormat {
    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameEvent {
    // message fields
    event_id: ::std::option::Option<EStreamFrameEvent>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameEvent {
    fn default() -> &'a CFrameEvent {
        <CFrameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CFrameEvent {
    pub fn new() -> CFrameEvent {
        ::std::default::Default::default()
    }

    // required .EStreamFrameEvent event_id = 1;


    pub fn get_event_id(&self) -> EStreamFrameEvent {
        self.event_id.unwrap_or(EStreamFrameEvent::k_EStreamInputEventStart)
    }
    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EStreamFrameEvent) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // required uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameEvent {
    fn is_initialized(&self) -> bool {
        if self.event_id.is_none() {
            return false;
        }
        if self.timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.event_id, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameEvent {
        CFrameEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamFrameEvent>>(
                "event_id",
                |m: &CFrameEvent| { &m.event_id },
                |m: &mut CFrameEvent| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CFrameEvent| { &m.timestamp },
                |m: &mut CFrameEvent| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFrameEvent>(
                "CFrameEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameEvent {
        static instance: ::protobuf::rt::LazyV2<CFrameEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFrameEvent::new)
    }
}

impl ::protobuf::Clear for CFrameEvent {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStats {
    // message fields
    frame_id: ::std::option::Option<u32>,
    input_mark: ::std::option::Option<u32>,
    pub events: ::protobuf::RepeatedField<CFrameEvent>,
    result: ::std::option::Option<EStreamFrameResult>,
    frame_start_delta: ::std::option::Option<f32>,
    frame_display_delta: ::std::option::Option<f32>,
    ping_time: ::std::option::Option<f32>,
    server_bitrate: ::std::option::Option<f32>,
    client_bitrate: ::std::option::Option<f32>,
    link_bandwidth: ::std::option::Option<f32>,
    packet_loss: ::std::option::Option<f32>,
    frame_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameStats {
    fn default() -> &'a CFrameStats {
        <CFrameStats as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStats {
    pub fn new() -> CFrameStats {
        ::std::default::Default::default()
    }

    // required uint32 frame_id = 1;


    pub fn get_frame_id(&self) -> u32 {
        self.frame_id.unwrap_or(0)
    }
    pub fn clear_frame_id(&mut self) {
        self.frame_id = ::std::option::Option::None;
    }

    pub fn has_frame_id(&self) -> bool {
        self.frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_id(&mut self, v: u32) {
        self.frame_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_mark = 2;


    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }
    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // repeated .CFrameEvent events = 3;


    pub fn get_events(&self) -> &[CFrameEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<CFrameEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<CFrameEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<CFrameEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // required .EStreamFrameResult result = 4;


    pub fn get_result(&self) -> EStreamFrameResult {
        self.result.unwrap_or(EStreamFrameResult::k_EStreamFrameResultPending)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EStreamFrameResult) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional float frame_start_delta = 5;


    pub fn get_frame_start_delta(&self) -> f32 {
        self.frame_start_delta.unwrap_or(0.)
    }
    pub fn clear_frame_start_delta(&mut self) {
        self.frame_start_delta = ::std::option::Option::None;
    }

    pub fn has_frame_start_delta(&self) -> bool {
        self.frame_start_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_start_delta(&mut self, v: f32) {
        self.frame_start_delta = ::std::option::Option::Some(v);
    }

    // optional float frame_display_delta = 6;


    pub fn get_frame_display_delta(&self) -> f32 {
        self.frame_display_delta.unwrap_or(0.)
    }
    pub fn clear_frame_display_delta(&mut self) {
        self.frame_display_delta = ::std::option::Option::None;
    }

    pub fn has_frame_display_delta(&self) -> bool {
        self.frame_display_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_display_delta(&mut self, v: f32) {
        self.frame_display_delta = ::std::option::Option::Some(v);
    }

    // optional float ping_time = 7;


    pub fn get_ping_time(&self) -> f32 {
        self.ping_time.unwrap_or(0.)
    }
    pub fn clear_ping_time(&mut self) {
        self.ping_time = ::std::option::Option::None;
    }

    pub fn has_ping_time(&self) -> bool {
        self.ping_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: f32) {
        self.ping_time = ::std::option::Option::Some(v);
    }

    // optional float server_bitrate = 8;


    pub fn get_server_bitrate(&self) -> f32 {
        self.server_bitrate.unwrap_or(0.)
    }
    pub fn clear_server_bitrate(&mut self) {
        self.server_bitrate = ::std::option::Option::None;
    }

    pub fn has_server_bitrate(&self) -> bool {
        self.server_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_bitrate(&mut self, v: f32) {
        self.server_bitrate = ::std::option::Option::Some(v);
    }

    // optional float client_bitrate = 9;


    pub fn get_client_bitrate(&self) -> f32 {
        self.client_bitrate.unwrap_or(0.)
    }
    pub fn clear_client_bitrate(&mut self) {
        self.client_bitrate = ::std::option::Option::None;
    }

    pub fn has_client_bitrate(&self) -> bool {
        self.client_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_bitrate(&mut self, v: f32) {
        self.client_bitrate = ::std::option::Option::Some(v);
    }

    // optional float link_bandwidth = 10;


    pub fn get_link_bandwidth(&self) -> f32 {
        self.link_bandwidth.unwrap_or(0.)
    }
    pub fn clear_link_bandwidth(&mut self) {
        self.link_bandwidth = ::std::option::Option::None;
    }

    pub fn has_link_bandwidth(&self) -> bool {
        self.link_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_bandwidth(&mut self, v: f32) {
        self.link_bandwidth = ::std::option::Option::Some(v);
    }

    // optional float packet_loss = 11;


    pub fn get_packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }
    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 frame_size = 12;


    pub fn get_frame_size(&self) -> u32 {
        self.frame_size.unwrap_or(0)
    }
    pub fn clear_frame_size(&mut self) {
        self.frame_size = ::std::option::Option::None;
    }

    pub fn has_frame_size(&self) -> bool {
        self.frame_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_size(&mut self, v: u32) {
        self.frame_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStats {
    fn is_initialized(&self) -> bool {
        if self.frame_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frame_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.input_mark = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.frame_start_delta = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.frame_display_delta = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ping_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_bitrate = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.client_bitrate = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.link_bandwidth = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.packet_loss = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.frame_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frame_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.frame_start_delta {
            my_size += 5;
        }
        if let Some(v) = self.frame_display_delta {
            my_size += 5;
        }
        if let Some(v) = self.ping_time {
            my_size += 5;
        }
        if let Some(v) = self.server_bitrate {
            my_size += 5;
        }
        if let Some(v) = self.client_bitrate {
            my_size += 5;
        }
        if let Some(v) = self.link_bandwidth {
            my_size += 5;
        }
        if let Some(v) = self.packet_loss {
            my_size += 5;
        }
        if let Some(v) = self.frame_size {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frame_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.input_mark {
            os.write_uint32(2, v)?;
        }
        for v in &self.events {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.result {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.frame_start_delta {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.frame_display_delta {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ping_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.server_bitrate {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.client_bitrate {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.link_bandwidth {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.packet_loss {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.frame_size {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameStats {
        CFrameStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frame_id",
                |m: &CFrameStats| { &m.frame_id },
                |m: &mut CFrameStats| { &mut m.frame_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_mark",
                |m: &CFrameStats| { &m.input_mark },
                |m: &mut CFrameStats| { &mut m.input_mark },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFrameEvent>>(
                "events",
                |m: &CFrameStats| { &m.events },
                |m: &mut CFrameStats| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamFrameResult>>(
                "result",
                |m: &CFrameStats| { &m.result },
                |m: &mut CFrameStats| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "frame_start_delta",
                |m: &CFrameStats| { &m.frame_start_delta },
                |m: &mut CFrameStats| { &mut m.frame_start_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "frame_display_delta",
                |m: &CFrameStats| { &m.frame_display_delta },
                |m: &mut CFrameStats| { &mut m.frame_display_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ping_time",
                |m: &CFrameStats| { &m.ping_time },
                |m: &mut CFrameStats| { &mut m.ping_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "server_bitrate",
                |m: &CFrameStats| { &m.server_bitrate },
                |m: &mut CFrameStats| { &mut m.server_bitrate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "client_bitrate",
                |m: &CFrameStats| { &m.client_bitrate },
                |m: &mut CFrameStats| { &mut m.client_bitrate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "link_bandwidth",
                |m: &CFrameStats| { &m.link_bandwidth },
                |m: &mut CFrameStats| { &mut m.link_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "packet_loss",
                |m: &CFrameStats| { &m.packet_loss },
                |m: &mut CFrameStats| { &mut m.packet_loss },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "frame_size",
                |m: &CFrameStats| { &m.frame_size },
                |m: &mut CFrameStats| { &mut m.frame_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFrameStats>(
                "CFrameStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameStats {
        static instance: ::protobuf::rt::LazyV2<CFrameStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFrameStats::new)
    }
}

impl ::protobuf::Clear for CFrameStats {
    fn clear(&mut self) {
        self.frame_id = ::std::option::Option::None;
        self.input_mark = ::std::option::Option::None;
        self.events.clear();
        self.result = ::std::option::Option::None;
        self.frame_start_delta = ::std::option::Option::None;
        self.frame_display_delta = ::std::option::Option::None;
        self.ping_time = ::std::option::Option::None;
        self.server_bitrate = ::std::option::Option::None;
        self.client_bitrate = ::std::option::Option::None;
        self.link_bandwidth = ::std::option::Option::None;
        self.packet_loss = ::std::option::Option::None;
        self.frame_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStatAccumulatedValue {
    // message fields
    stat_type: ::std::option::Option<EFrameAccumulatedStat>,
    count: ::std::option::Option<i32>,
    average: ::std::option::Option<f32>,
    stddev: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameStatAccumulatedValue {
    fn default() -> &'a CFrameStatAccumulatedValue {
        <CFrameStatAccumulatedValue as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStatAccumulatedValue {
    pub fn new() -> CFrameStatAccumulatedValue {
        ::std::default::Default::default()
    }

    // required .EFrameAccumulatedStat stat_type = 1;


    pub fn get_stat_type(&self) -> EFrameAccumulatedStat {
        self.stat_type.unwrap_or(EFrameAccumulatedStat::k_EFrameStatFPS)
    }
    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EFrameAccumulatedStat) {
        self.stat_type = ::std::option::Option::Some(v);
    }

    // required int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // required float average = 3;


    pub fn get_average(&self) -> f32 {
        self.average.unwrap_or(0.)
    }
    pub fn clear_average(&mut self) {
        self.average = ::std::option::Option::None;
    }

    pub fn has_average(&self) -> bool {
        self.average.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average(&mut self, v: f32) {
        self.average = ::std::option::Option::Some(v);
    }

    // optional float stddev = 4;


    pub fn get_stddev(&self) -> f32 {
        self.stddev.unwrap_or(0.)
    }
    pub fn clear_stddev(&mut self) {
        self.stddev = ::std::option::Option::None;
    }

    pub fn has_stddev(&self) -> bool {
        self.stddev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev(&mut self, v: f32) {
        self.stddev = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStatAccumulatedValue {
    fn is_initialized(&self) -> bool {
        if self.stat_type.is_none() {
            return false;
        }
        if self.count.is_none() {
            return false;
        }
        if self.average.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.stat_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.average = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stddev = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.average {
            my_size += 5;
        }
        if let Some(v) = self.stddev {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.average {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.stddev {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameStatAccumulatedValue {
        CFrameStatAccumulatedValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EFrameAccumulatedStat>>(
                "stat_type",
                |m: &CFrameStatAccumulatedValue| { &m.stat_type },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.stat_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CFrameStatAccumulatedValue| { &m.count },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "average",
                |m: &CFrameStatAccumulatedValue| { &m.average },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.average },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "stddev",
                |m: &CFrameStatAccumulatedValue| { &m.stddev },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.stddev },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFrameStatAccumulatedValue>(
                "CFrameStatAccumulatedValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameStatAccumulatedValue {
        static instance: ::protobuf::rt::LazyV2<CFrameStatAccumulatedValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFrameStatAccumulatedValue::new)
    }
}

impl ::protobuf::Clear for CFrameStatAccumulatedValue {
    fn clear(&mut self) {
        self.stat_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.average = ::std::option::Option::None;
        self.stddev = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStatAccumulatedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStatAccumulatedValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStatsListMsg {
    // message fields
    data_type: ::std::option::Option<EStreamingDataType>,
    pub stats: ::protobuf::RepeatedField<CFrameStats>,
    pub accumulated_stats: ::protobuf::RepeatedField<CFrameStatAccumulatedValue>,
    latest_frame_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameStatsListMsg {
    fn default() -> &'a CFrameStatsListMsg {
        <CFrameStatsListMsg as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStatsListMsg {
    pub fn new() -> CFrameStatsListMsg {
        ::std::default::Default::default()
    }

    // required .EStreamingDataType data_type = 1;


    pub fn get_data_type(&self) -> EStreamingDataType {
        self.data_type.unwrap_or(EStreamingDataType::k_EStreamingAudioData)
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: EStreamingDataType) {
        self.data_type = ::std::option::Option::Some(v);
    }

    // repeated .CFrameStats stats = 2;


    pub fn get_stats(&self) -> &[CFrameStats] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CFrameStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CFrameStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CFrameStats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;


    pub fn get_accumulated_stats(&self) -> &[CFrameStatAccumulatedValue] {
        &self.accumulated_stats
    }
    pub fn clear_accumulated_stats(&mut self) {
        self.accumulated_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_accumulated_stats(&mut self, v: ::protobuf::RepeatedField<CFrameStatAccumulatedValue>) {
        self.accumulated_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accumulated_stats(&mut self) -> &mut ::protobuf::RepeatedField<CFrameStatAccumulatedValue> {
        &mut self.accumulated_stats
    }

    // Take field
    pub fn take_accumulated_stats(&mut self) -> ::protobuf::RepeatedField<CFrameStatAccumulatedValue> {
        ::std::mem::replace(&mut self.accumulated_stats, ::protobuf::RepeatedField::new())
    }

    // required int32 latest_frame_id = 4;


    pub fn get_latest_frame_id(&self) -> i32 {
        self.latest_frame_id.unwrap_or(0)
    }
    pub fn clear_latest_frame_id(&mut self) {
        self.latest_frame_id = ::std::option::Option::None;
    }

    pub fn has_latest_frame_id(&self) -> bool {
        self.latest_frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_frame_id(&mut self, v: i32) {
        self.latest_frame_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStatsListMsg {
    fn is_initialized(&self) -> bool {
        if self.data_type.is_none() {
            return false;
        }
        if self.latest_frame_id.is_none() {
            return false;
        }
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accumulated_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accumulated_stats)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.latest_frame_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.accumulated_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.latest_frame_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.accumulated_stats {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.latest_frame_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameStatsListMsg {
        CFrameStatsListMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EStreamingDataType>>(
                "data_type",
                |m: &CFrameStatsListMsg| { &m.data_type },
                |m: &mut CFrameStatsListMsg| { &mut m.data_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFrameStats>>(
                "stats",
                |m: &CFrameStatsListMsg| { &m.stats },
                |m: &mut CFrameStatsListMsg| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFrameStatAccumulatedValue>>(
                "accumulated_stats",
                |m: &CFrameStatsListMsg| { &m.accumulated_stats },
                |m: &mut CFrameStatsListMsg| { &mut m.accumulated_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "latest_frame_id",
                |m: &CFrameStatsListMsg| { &m.latest_frame_id },
                |m: &mut CFrameStatsListMsg| { &mut m.latest_frame_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFrameStatsListMsg>(
                "CFrameStatsListMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameStatsListMsg {
        static instance: ::protobuf::rt::LazyV2<CFrameStatsListMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFrameStatsListMsg::new)
    }
}

impl ::protobuf::Clear for CFrameStatsListMsg {
    fn clear(&mut self) {
        self.data_type = ::std::option::Option::None;
        self.stats.clear();
        self.accumulated_stats.clear();
        self.latest_frame_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStatsListMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStatsListMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingSessionStats {
    // message fields
    frame_loss_percentage: ::std::option::Option<f32>,
    average_network_time_ms: ::std::option::Option<f32>,
    stddev_network_time_ms: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingSessionStats {
    fn default() -> &'a CStreamingSessionStats {
        <CStreamingSessionStats as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingSessionStats {
    pub fn new() -> CStreamingSessionStats {
        ::std::default::Default::default()
    }

    // optional float frame_loss_percentage = 1;


    pub fn get_frame_loss_percentage(&self) -> f32 {
        self.frame_loss_percentage.unwrap_or(0.)
    }
    pub fn clear_frame_loss_percentage(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
    }

    pub fn has_frame_loss_percentage(&self) -> bool {
        self.frame_loss_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_loss_percentage(&mut self, v: f32) {
        self.frame_loss_percentage = ::std::option::Option::Some(v);
    }

    // optional float average_network_time_ms = 2;


    pub fn get_average_network_time_ms(&self) -> f32 {
        self.average_network_time_ms.unwrap_or(0.)
    }
    pub fn clear_average_network_time_ms(&mut self) {
        self.average_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_average_network_time_ms(&self) -> bool {
        self.average_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_network_time_ms(&mut self, v: f32) {
        self.average_network_time_ms = ::std::option::Option::Some(v);
    }

    // optional float stddev_network_time_ms = 3;


    pub fn get_stddev_network_time_ms(&self) -> f32 {
        self.stddev_network_time_ms.unwrap_or(0.)
    }
    pub fn clear_stddev_network_time_ms(&mut self) {
        self.stddev_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_stddev_network_time_ms(&self) -> bool {
        self.stddev_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_network_time_ms(&mut self, v: f32) {
        self.stddev_network_time_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingSessionStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.frame_loss_percentage = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.average_network_time_ms = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stddev_network_time_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frame_loss_percentage {
            my_size += 5;
        }
        if let Some(v) = self.average_network_time_ms {
            my_size += 5;
        }
        if let Some(v) = self.stddev_network_time_ms {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frame_loss_percentage {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.average_network_time_ms {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.stddev_network_time_ms {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingSessionStats {
        CStreamingSessionStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "frame_loss_percentage",
                |m: &CStreamingSessionStats| { &m.frame_loss_percentage },
                |m: &mut CStreamingSessionStats| { &mut m.frame_loss_percentage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "average_network_time_ms",
                |m: &CStreamingSessionStats| { &m.average_network_time_ms },
                |m: &mut CStreamingSessionStats| { &mut m.average_network_time_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "stddev_network_time_ms",
                |m: &CStreamingSessionStats| { &m.stddev_network_time_ms },
                |m: &mut CStreamingSessionStats| { &mut m.stddev_network_time_ms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CStreamingSessionStats>(
                "CStreamingSessionStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingSessionStats {
        static instance: ::protobuf::rt::LazyV2<CStreamingSessionStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CStreamingSessionStats::new)
    }
}

impl ::protobuf::Clear for CStreamingSessionStats {
    fn clear(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
        self.average_network_time_ms = ::std::option::Option::None;
        self.stddev_network_time_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingSessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingSessionStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CDebugDumpMsg {
    // message fields
    screenshot: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDebugDumpMsg {
    fn default() -> &'a CDebugDumpMsg {
        <CDebugDumpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDebugDumpMsg {
    pub fn new() -> CDebugDumpMsg {
        ::std::default::Default::default()
    }

    // optional bytes screenshot = 1;


    pub fn get_screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_screenshot(&mut self) {
        self.screenshot.clear();
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot.set_default();
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CDebugDumpMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.screenshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.screenshot.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDebugDumpMsg {
        CDebugDumpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "screenshot",
                |m: &CDebugDumpMsg| { &m.screenshot },
                |m: &mut CDebugDumpMsg| { &mut m.screenshot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CDebugDumpMsg>(
                "CDebugDumpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDebugDumpMsg {
        static instance: ::protobuf::rt::LazyV2<CDebugDumpMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CDebugDumpMsg::new)
    }
}

impl ::protobuf::Clear for CDebugDumpMsg {
    fn clear(&mut self) {
        self.screenshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDebugDumpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDebugDumpMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CLogMsg {
    // message fields
    field_type: ::std::option::Option<i32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CLogMsg {
    fn default() -> &'a CLogMsg {
        <CLogMsg as ::protobuf::Message>::default_instance()
    }
}

impl CLogMsg {
    pub fn new() -> CLogMsg {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CLogMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CLogMsg {
        CLogMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &CLogMsg| { &m.field_type },
                |m: &mut CLogMsg| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CLogMsg| { &m.message },
                |m: &mut CLogMsg| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CLogMsg>(
                "CLogMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CLogMsg {
        static instance: ::protobuf::rt::LazyV2<CLogMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CLogMsg::new)
    }
}

impl ::protobuf::Clear for CLogMsg {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLogMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLogMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CLogUploadMsg {
    // message fields
    field_type: ::std::option::Option<ELogFileType>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CLogUploadMsg {
    fn default() -> &'a CLogUploadMsg {
        <CLogUploadMsg as ::protobuf::Message>::default_instance()
    }
}

impl CLogUploadMsg {
    pub fn new() -> CLogUploadMsg {
        ::std::default::Default::default()
    }

    // optional .ELogFileType type = 1;


    pub fn get_field_type(&self) -> ELogFileType {
        self.field_type.unwrap_or(ELogFileType::k_ELogFileSystemBoot)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ELogFileType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CLogUploadMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CLogUploadMsg {
        CLogUploadMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ELogFileType>>(
                "type",
                |m: &CLogUploadMsg| { &m.field_type },
                |m: &mut CLogUploadMsg| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CLogUploadMsg| { &m.data },
                |m: &mut CLogUploadMsg| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CLogUploadMsg>(
                "CLogUploadMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CLogUploadMsg {
        static instance: ::protobuf::rt::LazyV2<CLogUploadMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CLogUploadMsg::new)
    }
}

impl ::protobuf::Clear for CLogUploadMsg {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLogUploadMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLogUploadMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTransportSignalMsg {
    // message fields
    pub webrtc: ::protobuf::SingularPtrField<CTransportSignalMsg_WebRTCMessage>,
    pub sdr: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTransportSignalMsg {
    fn default() -> &'a CTransportSignalMsg {
        <CTransportSignalMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTransportSignalMsg {
    pub fn new() -> CTransportSignalMsg {
        ::std::default::Default::default()
    }

    // optional .CTransportSignalMsg.WebRTCMessage webrtc = 1;


    pub fn get_webrtc(&self) -> &CTransportSignalMsg_WebRTCMessage {
        self.webrtc.as_ref().unwrap_or_else(|| <CTransportSignalMsg_WebRTCMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_webrtc(&mut self) {
        self.webrtc.clear();
    }

    pub fn has_webrtc(&self) -> bool {
        self.webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc(&mut self, v: CTransportSignalMsg_WebRTCMessage) {
        self.webrtc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webrtc(&mut self) -> &mut CTransportSignalMsg_WebRTCMessage {
        if self.webrtc.is_none() {
            self.webrtc.set_default();
        }
        self.webrtc.as_mut().unwrap()
    }

    // Take field
    pub fn take_webrtc(&mut self) -> CTransportSignalMsg_WebRTCMessage {
        self.webrtc.take().unwrap_or_else(|| CTransportSignalMsg_WebRTCMessage::new())
    }

    // repeated bytes sdr = 2;


    pub fn get_sdr(&self) -> &[::std::vec::Vec<u8>] {
        &self.sdr
    }
    pub fn clear_sdr(&mut self) {
        self.sdr.clear();
    }

    // Param is passed by value, moved
    pub fn set_sdr(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.sdr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sdr(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.sdr
    }

    // Take field
    pub fn take_sdr(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.sdr, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CTransportSignalMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.webrtc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.webrtc)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.sdr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.webrtc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.sdr {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.webrtc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.sdr {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTransportSignalMsg {
        CTransportSignalMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTransportSignalMsg_WebRTCMessage>>(
                "webrtc",
                |m: &CTransportSignalMsg| { &m.webrtc },
                |m: &mut CTransportSignalMsg| { &mut m.webrtc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sdr",
                |m: &CTransportSignalMsg| { &m.sdr },
                |m: &mut CTransportSignalMsg| { &mut m.sdr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTransportSignalMsg>(
                "CTransportSignalMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTransportSignalMsg {
        static instance: ::protobuf::rt::LazyV2<CTransportSignalMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTransportSignalMsg::new)
    }
}

impl ::protobuf::Clear for CTransportSignalMsg {
    fn clear(&mut self) {
        self.webrtc.clear();
        self.sdr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTransportSignalMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTransportSignalMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTransportSignalMsg_WebRTCMessage {
    // message oneof groups
    pub msg: ::std::option::Option<CTransportSignalMsg_WebRTCMessage_oneof_msg>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTransportSignalMsg_WebRTCMessage {
    fn default() -> &'a CTransportSignalMsg_WebRTCMessage {
        <CTransportSignalMsg_WebRTCMessage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CTransportSignalMsg_WebRTCMessage_oneof_msg {
    greeting(bool),
    offer(::std::string::String),
    answer(::std::string::String),
    candidate(CTransportSignalMsg_WebRTCMessage_Candidate),
}

impl CTransportSignalMsg_WebRTCMessage {
    pub fn new() -> CTransportSignalMsg_WebRTCMessage {
        ::std::default::Default::default()
    }

    // optional bool greeting = 1;


    pub fn get_greeting(&self) -> bool {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::greeting(v)) => v,
            _ => false,
        }
    }
    pub fn clear_greeting(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_greeting(&self) -> bool {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::greeting(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_greeting(&mut self, v: bool) {
        self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::greeting(v))
    }

    // optional string offer = 2;


    pub fn get_offer(&self) -> &str {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_offer(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_offer(&self) -> bool {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_offer(&mut self, v: ::std::string::String) {
        self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_offer(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(_)) = self.msg {
        } else {
            self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(::std::string::String::new()));
        }
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_offer(&mut self) -> ::std::string::String {
        if self.has_offer() {
            match self.msg.take() {
                ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional string answer = 3;


    pub fn get_answer(&self) -> &str {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_answer(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_answer(&self) -> bool {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_answer(&mut self, v: ::std::string::String) {
        self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_answer(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(_)) = self.msg {
        } else {
            self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(::std::string::String::new()));
        }
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_answer(&mut self) -> ::std::string::String {
        if self.has_answer() {
            match self.msg.take() {
                ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;


    pub fn get_candidate(&self) -> &CTransportSignalMsg_WebRTCMessage_Candidate {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(ref v)) => v,
            _ => <CTransportSignalMsg_WebRTCMessage_Candidate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_candidate(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_candidate(&self) -> bool {
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: CTransportSignalMsg_WebRTCMessage_Candidate) {
        self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_candidate(&mut self) -> &mut CTransportSignalMsg_WebRTCMessage_Candidate {
        if let ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(_)) = self.msg {
        } else {
            self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(CTransportSignalMsg_WebRTCMessage_Candidate::new()));
        }
        match self.msg {
            ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_candidate(&mut self) -> CTransportSignalMsg_WebRTCMessage_Candidate {
        if self.has_candidate() {
            match self.msg.take() {
                ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(v)) => v,
                _ => panic!(),
            }
        } else {
            CTransportSignalMsg_WebRTCMessage_Candidate::new()
        }
    }
}

impl ::protobuf::Message for CTransportSignalMsg_WebRTCMessage {
    fn is_initialized(&self) -> bool {
        if let Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(ref v)) = self.msg {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::greeting(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.msg = ::std::option::Option::Some(CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.msg {
            match v {
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::greeting(v) => {
                    my_size += 2;
                },
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.msg {
            match v {
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::greeting(v) => {
                    os.write_bool(1, v)?;
                },
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::offer(ref v) => {
                    os.write_string(2, v)?;
                },
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::answer(ref v) => {
                    os.write_string(3, v)?;
                },
                &CTransportSignalMsg_WebRTCMessage_oneof_msg::candidate(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTransportSignalMsg_WebRTCMessage {
        CTransportSignalMsg_WebRTCMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "greeting",
                CTransportSignalMsg_WebRTCMessage::has_greeting,
                CTransportSignalMsg_WebRTCMessage::get_greeting,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "offer",
                CTransportSignalMsg_WebRTCMessage::has_offer,
                CTransportSignalMsg_WebRTCMessage::get_offer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "answer",
                CTransportSignalMsg_WebRTCMessage::has_answer,
                CTransportSignalMsg_WebRTCMessage::get_answer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CTransportSignalMsg_WebRTCMessage_Candidate>(
                "candidate",
                CTransportSignalMsg_WebRTCMessage::has_candidate,
                CTransportSignalMsg_WebRTCMessage::get_candidate,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTransportSignalMsg_WebRTCMessage>(
                "CTransportSignalMsg.WebRTCMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTransportSignalMsg_WebRTCMessage {
        static instance: ::protobuf::rt::LazyV2<CTransportSignalMsg_WebRTCMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTransportSignalMsg_WebRTCMessage::new)
    }
}

impl ::protobuf::Clear for CTransportSignalMsg_WebRTCMessage {
    fn clear(&mut self) {
        self.msg = ::std::option::Option::None;
        self.msg = ::std::option::Option::None;
        self.msg = ::std::option::Option::None;
        self.msg = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTransportSignalMsg_WebRTCMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTransportSignalMsg_WebRTCMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTransportSignalMsg_WebRTCMessage_Candidate {
    // message fields
    sdp_mid: ::protobuf::SingularField<::std::string::String>,
    sdp_mline_index: ::std::option::Option<i32>,
    candidate: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTransportSignalMsg_WebRTCMessage_Candidate {
    fn default() -> &'a CTransportSignalMsg_WebRTCMessage_Candidate {
        <CTransportSignalMsg_WebRTCMessage_Candidate as ::protobuf::Message>::default_instance()
    }
}

impl CTransportSignalMsg_WebRTCMessage_Candidate {
    pub fn new() -> CTransportSignalMsg_WebRTCMessage_Candidate {
        ::std::default::Default::default()
    }

    // optional string sdp_mid = 1;


    pub fn get_sdp_mid(&self) -> &str {
        match self.sdp_mid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sdp_mid(&mut self) {
        self.sdp_mid.clear();
    }

    pub fn has_sdp_mid(&self) -> bool {
        self.sdp_mid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp_mid(&mut self, v: ::std::string::String) {
        self.sdp_mid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdp_mid(&mut self) -> &mut ::std::string::String {
        if self.sdp_mid.is_none() {
            self.sdp_mid.set_default();
        }
        self.sdp_mid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdp_mid(&mut self) -> ::std::string::String {
        self.sdp_mid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 sdp_mline_index = 2;


    pub fn get_sdp_mline_index(&self) -> i32 {
        self.sdp_mline_index.unwrap_or(0)
    }
    pub fn clear_sdp_mline_index(&mut self) {
        self.sdp_mline_index = ::std::option::Option::None;
    }

    pub fn has_sdp_mline_index(&self) -> bool {
        self.sdp_mline_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdp_mline_index(&mut self, v: i32) {
        self.sdp_mline_index = ::std::option::Option::Some(v);
    }

    // optional string candidate = 3;


    pub fn get_candidate(&self) -> &str {
        match self.candidate.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        if self.candidate.is_none() {
            self.candidate.set_default();
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CTransportSignalMsg_WebRTCMessage_Candidate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdp_mid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sdp_mline_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.candidate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sdp_mid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sdp_mline_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sdp_mid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.sdp_mline_index {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.candidate.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTransportSignalMsg_WebRTCMessage_Candidate {
        CTransportSignalMsg_WebRTCMessage_Candidate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sdp_mid",
                |m: &CTransportSignalMsg_WebRTCMessage_Candidate| { &m.sdp_mid },
                |m: &mut CTransportSignalMsg_WebRTCMessage_Candidate| { &mut m.sdp_mid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sdp_mline_index",
                |m: &CTransportSignalMsg_WebRTCMessage_Candidate| { &m.sdp_mline_index },
                |m: &mut CTransportSignalMsg_WebRTCMessage_Candidate| { &mut m.sdp_mline_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "candidate",
                |m: &CTransportSignalMsg_WebRTCMessage_Candidate| { &m.candidate },
                |m: &mut CTransportSignalMsg_WebRTCMessage_Candidate| { &mut m.candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTransportSignalMsg_WebRTCMessage_Candidate>(
                "CTransportSignalMsg.WebRTCMessage.Candidate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTransportSignalMsg_WebRTCMessage_Candidate {
        static instance: ::protobuf::rt::LazyV2<CTransportSignalMsg_WebRTCMessage_Candidate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTransportSignalMsg_WebRTCMessage_Candidate::new)
    }
}

impl ::protobuf::Clear for CTransportSignalMsg_WebRTCMessage_Candidate {
    fn clear(&mut self) {
        self.sdp_mid.clear();
        self.sdp_mline_index = ::std::option::Option::None;
        self.candidate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTransportSignalMsg_WebRTCMessage_Candidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTransportSignalMsg_WebRTCMessage_Candidate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamChannel {
    k_EStreamChannelInvalid = -1,
    k_EStreamChannelDiscovery = 0,
    k_EStreamChannelControl = 1,
    k_EStreamChannelStats = 2,
    k_EStreamChannelDataChannelStart = 3,
}

impl ::protobuf::ProtobufEnum for EStreamChannel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamChannel> {
        match value {
            -1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelInvalid),
            0 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDiscovery),
            1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelControl),
            2 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelStats),
            3 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDataChannelStart),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamChannel] = &[
            EStreamChannel::k_EStreamChannelInvalid,
            EStreamChannel::k_EStreamChannelDiscovery,
            EStreamChannel::k_EStreamChannelControl,
            EStreamChannel::k_EStreamChannelStats,
            EStreamChannel::k_EStreamChannelDataChannelStart,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamChannel>("EStreamChannel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamChannel {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamChannel {
    fn default() -> Self {
        EStreamChannel::k_EStreamChannelInvalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDiscoveryMessage {
    k_EStreamDiscoveryPingRequest = 1,
    k_EStreamDiscoveryPingResponse = 2,
}

impl ::protobuf::ProtobufEnum for EStreamDiscoveryMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDiscoveryMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest),
            2 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDiscoveryMessage] = &[
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest,
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamDiscoveryMessage>("EStreamDiscoveryMessage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamDiscoveryMessage {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDiscoveryMessage {
    fn default() -> Self {
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamDiscoveryMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamControlMessage {
    k_EStreamControlAuthenticationRequest = 1,
    k_EStreamControlAuthenticationResponse = 2,
    k_EStreamControlNegotiationInit = 3,
    k_EStreamControlNegotiationSetConfig = 4,
    k_EStreamControlNegotiationComplete = 5,
    k_EStreamControlClientHandshake = 6,
    k_EStreamControlServerHandshake = 7,
    k_EStreamControlStartNetworkTest = 8,
    k_EStreamControlKeepAlive = 9,
    k_EStreamControl_LAST_SETUP_MESSAGE = 15,
    k_EStreamControlStartAudioData = 50,
    k_EStreamControlStopAudioData = 51,
    k_EStreamControlStartVideoData = 52,
    k_EStreamControlStopVideoData = 53,
    k_EStreamControlInputMouseMotion = 54,
    k_EStreamControlInputMouseWheel = 55,
    k_EStreamControlInputMouseDown = 56,
    k_EStreamControlInputMouseUp = 57,
    k_EStreamControlInputKeyDown = 58,
    k_EStreamControlInputKeyUp = 59,
    k_EStreamControlInputGamepadAttached_OBSOLETE = 60,
    k_EStreamControlInputGamepadEvent_OBSOLETE = 61,
    k_EStreamControlInputGamepadDetached_OBSOLETE = 62,
    k_EStreamControlShowCursor = 63,
    k_EStreamControlHideCursor = 64,
    k_EStreamControlSetCursor = 65,
    k_EStreamControlGetCursorImage = 66,
    k_EStreamControlSetCursorImage = 67,
    k_EStreamControlDeleteCursor = 68,
    k_EStreamControlSetTargetFramerate = 69,
    k_EStreamControlInputLatencyTest = 70,
    k_EStreamControlGamepadRumble_OBSOLETE = 71,
    k_EStreamControlOverlayEnabled = 74,
    k_EStreamControlInputControllerAttached_OBSOLETE = 75,
    k_EStreamControlInputControllerState_OBSOLETE = 76,
    k_EStreamControlTriggerHapticPulse_OBSOLETE = 77,
    k_EStreamControlInputControllerDetached_OBSOLETE = 78,
    k_EStreamControlVideoDecoderInfo = 80,
    k_EStreamControlSetTitle = 81,
    k_EStreamControlSetIcon = 82,
    k_EStreamControlQuitRequest = 83,
    k_EStreamControlSetQoS = 87,
    k_EStreamControlInputControllerWirelessPresence_OBSOLETE = 88,
    k_EStreamControlSetGammaRamp = 89,
    k_EStreamControlVideoEncoderInfo = 90,
    k_EStreamControlInputControllerStateHID_OBSOLETE = 93,
    k_EStreamControlSetTargetBitrate = 94,
    k_EStreamControlSetControllerPairingEnabled_OBSOLETE = 95,
    k_EStreamControlSetControllerPairingResult_OBSOLETE = 96,
    k_EStreamControlTriggerControllerDisconnect_OBSOLETE = 97,
    k_EStreamControlSetActivity = 98,
    k_EStreamControlSetStreamingClientConfig = 99,
    k_EStreamControlSystemSuspend = 100,
    k_EStreamControlSetControllerSettings_OBSOLETE = 101,
    k_EStreamControlVirtualHereRequest = 102,
    k_EStreamControlVirtualHereReady = 103,
    k_EStreamControlVirtualHereShareDevice = 104,
    k_EStreamControlSetSpectatorMode = 105,
    k_EStreamControlRemoteHID = 106,
    k_EStreamControlStartMicrophoneData = 107,
    k_EStreamControlStopMicrophoneData = 108,
    k_EStreamControlInputText = 109,
    k_EStreamControlTouchConfigActive = 110,
    k_EStreamControlGetTouchConfigData = 111,
    k_EStreamControlSetTouchConfigData = 112,
    k_EStreamControlSaveTouchConfigLayout = 113,
    k_EStreamControlTouchActionSetActive = 114,
    k_EStreamControlGetTouchIconData = 115,
    k_EStreamControlSetTouchIconData = 116,
    k_EStreamControlInputTouchFingerDown = 117,
    k_EStreamControlInputTouchFingerMotion = 118,
    k_EStreamControlInputTouchFingerUp = 119,
    k_EStreamControlSetCaptureSize = 120,
    k_EStreamControlSetFlashState = 121,
    k_EStreamControlPause = 122,
    k_EStreamControlResume = 123,
    k_EStreamControlEnableHighResCapture = 124,
    k_EStreamControlDisableHighResCapture = 125,
    k_EStreamControlToggleMagnification = 126,
    k_EStreamControlSetCapslock = 127,
    k_EStreamControlSetKeymap = 128,
    k_EStreamControlStopRequest = 129,
    k_EStreamControlTouchActionSetLayerAdded = 130,
    k_EStreamControlTouchActionSetLayerRemoved = 131,
}

impl ::protobuf::ProtobufEnum for EStreamControlMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamControlMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            2 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationResponse),
            3 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationInit),
            4 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationSetConfig),
            5 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationComplete),
            6 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlClientHandshake),
            7 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlServerHandshake),
            8 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNetworkTest),
            9 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlKeepAlive),
            15 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE),
            50 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartAudioData),
            51 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopAudioData),
            52 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartVideoData),
            53 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopVideoData),
            54 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseMotion),
            55 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseWheel),
            56 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseDown),
            57 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseUp),
            58 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyDown),
            59 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyUp),
            60 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE),
            61 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE),
            62 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE),
            63 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowCursor),
            64 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlHideCursor),
            65 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursor),
            66 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetCursorImage),
            67 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorImage),
            68 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDeleteCursor),
            69 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetFramerate),
            70 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputLatencyTest),
            71 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE),
            74 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlOverlayEnabled),
            75 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE),
            76 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE),
            77 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE),
            78 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE),
            80 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoDecoderInfo),
            81 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTitle),
            82 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetIcon),
            83 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlQuitRequest),
            87 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQoS),
            88 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE),
            89 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetGammaRamp),
            90 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoEncoderInfo),
            93 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE),
            94 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetBitrate),
            95 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE),
            96 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE),
            97 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE),
            98 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetActivity),
            99 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetStreamingClientConfig),
            100 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSystemSuspend),
            101 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE),
            102 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereRequest),
            103 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereReady),
            104 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereShareDevice),
            105 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetSpectatorMode),
            106 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemoteHID),
            107 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartMicrophoneData),
            108 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopMicrophoneData),
            109 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputText),
            110 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchConfigActive),
            111 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchConfigData),
            112 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchConfigData),
            113 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout),
            114 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetActive),
            115 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchIconData),
            116 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchIconData),
            117 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerDown),
            118 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerMotion),
            119 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerUp),
            120 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCaptureSize),
            121 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetFlashState),
            122 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPause),
            123 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResume),
            124 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableHighResCapture),
            125 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableHighResCapture),
            126 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlToggleMagnification),
            127 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCapslock),
            128 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetKeymap),
            129 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopRequest),
            130 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded),
            131 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamControlMessage] = &[
            EStreamControlMessage::k_EStreamControlAuthenticationRequest,
            EStreamControlMessage::k_EStreamControlAuthenticationResponse,
            EStreamControlMessage::k_EStreamControlNegotiationInit,
            EStreamControlMessage::k_EStreamControlNegotiationSetConfig,
            EStreamControlMessage::k_EStreamControlNegotiationComplete,
            EStreamControlMessage::k_EStreamControlClientHandshake,
            EStreamControlMessage::k_EStreamControlServerHandshake,
            EStreamControlMessage::k_EStreamControlStartNetworkTest,
            EStreamControlMessage::k_EStreamControlKeepAlive,
            EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE,
            EStreamControlMessage::k_EStreamControlStartAudioData,
            EStreamControlMessage::k_EStreamControlStopAudioData,
            EStreamControlMessage::k_EStreamControlStartVideoData,
            EStreamControlMessage::k_EStreamControlStopVideoData,
            EStreamControlMessage::k_EStreamControlInputMouseMotion,
            EStreamControlMessage::k_EStreamControlInputMouseWheel,
            EStreamControlMessage::k_EStreamControlInputMouseDown,
            EStreamControlMessage::k_EStreamControlInputMouseUp,
            EStreamControlMessage::k_EStreamControlInputKeyDown,
            EStreamControlMessage::k_EStreamControlInputKeyUp,
            EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlShowCursor,
            EStreamControlMessage::k_EStreamControlHideCursor,
            EStreamControlMessage::k_EStreamControlSetCursor,
            EStreamControlMessage::k_EStreamControlGetCursorImage,
            EStreamControlMessage::k_EStreamControlSetCursorImage,
            EStreamControlMessage::k_EStreamControlDeleteCursor,
            EStreamControlMessage::k_EStreamControlSetTargetFramerate,
            EStreamControlMessage::k_EStreamControlInputLatencyTest,
            EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE,
            EStreamControlMessage::k_EStreamControlOverlayEnabled,
            EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE,
            EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlVideoDecoderInfo,
            EStreamControlMessage::k_EStreamControlSetTitle,
            EStreamControlMessage::k_EStreamControlSetIcon,
            EStreamControlMessage::k_EStreamControlQuitRequest,
            EStreamControlMessage::k_EStreamControlSetQoS,
            EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetGammaRamp,
            EStreamControlMessage::k_EStreamControlVideoEncoderInfo,
            EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetTargetBitrate,
            EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE,
            EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetActivity,
            EStreamControlMessage::k_EStreamControlSetStreamingClientConfig,
            EStreamControlMessage::k_EStreamControlSystemSuspend,
            EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE,
            EStreamControlMessage::k_EStreamControlVirtualHereRequest,
            EStreamControlMessage::k_EStreamControlVirtualHereReady,
            EStreamControlMessage::k_EStreamControlVirtualHereShareDevice,
            EStreamControlMessage::k_EStreamControlSetSpectatorMode,
            EStreamControlMessage::k_EStreamControlRemoteHID,
            EStreamControlMessage::k_EStreamControlStartMicrophoneData,
            EStreamControlMessage::k_EStreamControlStopMicrophoneData,
            EStreamControlMessage::k_EStreamControlInputText,
            EStreamControlMessage::k_EStreamControlTouchConfigActive,
            EStreamControlMessage::k_EStreamControlGetTouchConfigData,
            EStreamControlMessage::k_EStreamControlSetTouchConfigData,
            EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout,
            EStreamControlMessage::k_EStreamControlTouchActionSetActive,
            EStreamControlMessage::k_EStreamControlGetTouchIconData,
            EStreamControlMessage::k_EStreamControlSetTouchIconData,
            EStreamControlMessage::k_EStreamControlInputTouchFingerDown,
            EStreamControlMessage::k_EStreamControlInputTouchFingerMotion,
            EStreamControlMessage::k_EStreamControlInputTouchFingerUp,
            EStreamControlMessage::k_EStreamControlSetCaptureSize,
            EStreamControlMessage::k_EStreamControlSetFlashState,
            EStreamControlMessage::k_EStreamControlPause,
            EStreamControlMessage::k_EStreamControlResume,
            EStreamControlMessage::k_EStreamControlEnableHighResCapture,
            EStreamControlMessage::k_EStreamControlDisableHighResCapture,
            EStreamControlMessage::k_EStreamControlToggleMagnification,
            EStreamControlMessage::k_EStreamControlSetCapslock,
            EStreamControlMessage::k_EStreamControlSetKeymap,
            EStreamControlMessage::k_EStreamControlStopRequest,
            EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded,
            EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamControlMessage>("EStreamControlMessage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamControlMessage {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamControlMessage {
    fn default() -> Self {
        EStreamControlMessage::k_EStreamControlAuthenticationRequest
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamControlMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamVersion {
    k_EStreamVersionNone = 0,
    k_EStreamVersionCurrent = 1,
}

impl ::protobuf::ProtobufEnum for EStreamVersion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVersion> {
        match value {
            0 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionNone),
            1 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionCurrent),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamVersion] = &[
            EStreamVersion::k_EStreamVersionNone,
            EStreamVersion::k_EStreamVersionCurrent,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamVersion>("EStreamVersion", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamVersion {
}

impl ::std::default::Default for EStreamVersion {
    fn default() -> Self {
        EStreamVersion::k_EStreamVersionNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamAudioCodec {
    k_EStreamAudioCodecNone = 0,
    k_EStreamAudioCodecRaw = 1,
    k_EStreamAudioCodecVorbis = 2,
    k_EStreamAudioCodecOpus = 3,
    k_EStreamAudioCodecMP3 = 4,
    k_EStreamAudioCodecAAC = 5,
}

impl ::protobuf::ProtobufEnum for EStreamAudioCodec {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamAudioCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecNone),
            1 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecRaw),
            2 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecVorbis),
            3 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecOpus),
            4 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecMP3),
            5 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecAAC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamAudioCodec] = &[
            EStreamAudioCodec::k_EStreamAudioCodecNone,
            EStreamAudioCodec::k_EStreamAudioCodecRaw,
            EStreamAudioCodec::k_EStreamAudioCodecVorbis,
            EStreamAudioCodec::k_EStreamAudioCodecOpus,
            EStreamAudioCodec::k_EStreamAudioCodecMP3,
            EStreamAudioCodec::k_EStreamAudioCodecAAC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamAudioCodec>("EStreamAudioCodec", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamAudioCodec {
}

impl ::std::default::Default for EStreamAudioCodec {
    fn default() -> Self {
        EStreamAudioCodec::k_EStreamAudioCodecNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamAudioCodec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamVideoCodec {
    k_EStreamVideoCodecNone = 0,
    k_EStreamVideoCodecRaw = 1,
    k_EStreamVideoCodecVP8 = 2,
    k_EStreamVideoCodecVP9 = 3,
    k_EStreamVideoCodecH264 = 4,
    k_EStreamVideoCodecHEVC = 5,
    k_EStreamVideoCodecORBX1 = 6,
    k_EStreamVideoCodecORBX2 = 7,
}

impl ::protobuf::ProtobufEnum for EStreamVideoCodec {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVideoCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecNone),
            1 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecRaw),
            2 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP8),
            3 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP9),
            4 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH264),
            5 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecHEVC),
            6 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX1),
            7 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamVideoCodec] = &[
            EStreamVideoCodec::k_EStreamVideoCodecNone,
            EStreamVideoCodec::k_EStreamVideoCodecRaw,
            EStreamVideoCodec::k_EStreamVideoCodecVP8,
            EStreamVideoCodec::k_EStreamVideoCodecVP9,
            EStreamVideoCodec::k_EStreamVideoCodecH264,
            EStreamVideoCodec::k_EStreamVideoCodecHEVC,
            EStreamVideoCodec::k_EStreamVideoCodecORBX1,
            EStreamVideoCodec::k_EStreamVideoCodecORBX2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamVideoCodec>("EStreamVideoCodec", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamVideoCodec {
}

impl ::std::default::Default for EStreamVideoCodec {
    fn default() -> Self {
        EStreamVideoCodec::k_EStreamVideoCodecNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamVideoCodec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamQualityPreference {
    k_EStreamQualityFast = 1,
    k_EStreamQualityBalanced = 2,
    k_EStreamQualityBeautiful = 3,
}

impl ::protobuf::ProtobufEnum for EStreamQualityPreference {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamQualityPreference> {
        match value {
            1 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityFast),
            2 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBalanced),
            3 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBeautiful),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamQualityPreference] = &[
            EStreamQualityPreference::k_EStreamQualityFast,
            EStreamQualityPreference::k_EStreamQualityBalanced,
            EStreamQualityPreference::k_EStreamQualityBeautiful,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamQualityPreference>("EStreamQualityPreference", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamQualityPreference {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamQualityPreference {
    fn default() -> Self {
        EStreamQualityPreference::k_EStreamQualityFast
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamQualityPreference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamBitrate {
    k_EStreamBitrateAutodetect = -1,
    k_EStreamBitrateUnlimited = 0,
}

impl ::protobuf::ProtobufEnum for EStreamBitrate {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamBitrate> {
        match value {
            -1 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateAutodetect),
            0 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateUnlimited),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamBitrate] = &[
            EStreamBitrate::k_EStreamBitrateAutodetect,
            EStreamBitrate::k_EStreamBitrateUnlimited,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamBitrate>("EStreamBitrate", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamBitrate {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamBitrate {
    fn default() -> Self {
        EStreamBitrate::k_EStreamBitrateAutodetect
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamBitrate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamP2PScope {
    k_EStreamP2PScopeUnknown = 0,
    k_EStreamP2PScopeDisabled = 1,
    k_EStreamP2PScopeOnlyMe = 2,
    k_EStreamP2PScopeFriends = 3,
    k_EStreamP2PScopeEveryone = 4,
}

impl ::protobuf::ProtobufEnum for EStreamP2PScope {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamP2PScope> {
        match value {
            0 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeUnknown),
            1 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeDisabled),
            2 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeOnlyMe),
            3 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeFriends),
            4 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeEveryone),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamP2PScope] = &[
            EStreamP2PScope::k_EStreamP2PScopeUnknown,
            EStreamP2PScope::k_EStreamP2PScopeDisabled,
            EStreamP2PScope::k_EStreamP2PScopeOnlyMe,
            EStreamP2PScope::k_EStreamP2PScopeFriends,
            EStreamP2PScope::k_EStreamP2PScopeEveryone,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamP2PScope>("EStreamP2PScope", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamP2PScope {
}

impl ::std::default::Default for EStreamP2PScope {
    fn default() -> Self {
        EStreamP2PScope::k_EStreamP2PScopeUnknown
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamP2PScope {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamHostPlayAudioPreference {
    k_EStreamHostPlayAudioDefault = 0,
    k_EStreamHostPlayAudioAlways = 1,
}

impl ::protobuf::ProtobufEnum for EStreamHostPlayAudioPreference {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamHostPlayAudioPreference> {
        match value {
            0 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            1 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamHostPlayAudioPreference] = &[
            EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
            EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamHostPlayAudioPreference>("EStreamHostPlayAudioPreference", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamHostPlayAudioPreference {
}

impl ::std::default::Default for EStreamHostPlayAudioPreference {
    fn default() -> Self {
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamHostPlayAudioPreference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamingDataType {
    k_EStreamingAudioData = 0,
    k_EStreamingVideoData = 1,
    k_EStreamingMicrophoneData = 2,
}

impl ::protobuf::ProtobufEnum for EStreamingDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamingDataType> {
        match value {
            0 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingAudioData),
            1 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingVideoData),
            2 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingMicrophoneData),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamingDataType] = &[
            EStreamingDataType::k_EStreamingAudioData,
            EStreamingDataType::k_EStreamingVideoData,
            EStreamingDataType::k_EStreamingMicrophoneData,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamingDataType>("EStreamingDataType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamingDataType {
}

impl ::std::default::Default for EStreamingDataType {
    fn default() -> Self {
        EStreamingDataType::k_EStreamingAudioData
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamingDataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamMouseButton {
    k_EStreamMouseButtonLeft = 1,
    k_EStreamMouseButtonRight = 2,
    k_EStreamMouseButtonMiddle = 16,
    k_EStreamMouseButtonX1 = 32,
    k_EStreamMouseButtonX2 = 64,
    k_EStreamMouseButtonUnknown = 4096,
}

impl ::protobuf::ProtobufEnum for EStreamMouseButton {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseButton> {
        match value {
            1 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonLeft),
            2 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonRight),
            16 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonMiddle),
            32 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX1),
            64 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX2),
            4096 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonUnknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamMouseButton] = &[
            EStreamMouseButton::k_EStreamMouseButtonLeft,
            EStreamMouseButton::k_EStreamMouseButtonRight,
            EStreamMouseButton::k_EStreamMouseButtonMiddle,
            EStreamMouseButton::k_EStreamMouseButtonX1,
            EStreamMouseButton::k_EStreamMouseButtonX2,
            EStreamMouseButton::k_EStreamMouseButtonUnknown,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamMouseButton>("EStreamMouseButton", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamMouseButton {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseButton {
    fn default() -> Self {
        EStreamMouseButton::k_EStreamMouseButtonLeft
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamMouseButton {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamMouseWheelDirection {
    k_EStreamMouseWheelUp = 120,
    k_EStreamMouseWheelDown = -120,
    k_EStreamMouseWheelLeft = 3,
    k_EStreamMouseWheelRight = 4,
}

impl ::protobuf::ProtobufEnum for EStreamMouseWheelDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseWheelDirection> {
        match value {
            120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            -120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelDown),
            3 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelLeft),
            4 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelRight),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamMouseWheelDirection] = &[
            EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
            EStreamMouseWheelDirection::k_EStreamMouseWheelDown,
            EStreamMouseWheelDirection::k_EStreamMouseWheelLeft,
            EStreamMouseWheelDirection::k_EStreamMouseWheelRight,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamMouseWheelDirection>("EStreamMouseWheelDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamMouseWheelDirection {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseWheelDirection {
    fn default() -> Self {
        EStreamMouseWheelDirection::k_EStreamMouseWheelUp
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamMouseWheelDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFramerateLimiter {
    k_EStreamFramerateSlowCapture = 1,
    k_EStreamFramerateSlowConvert = 2,
    k_EStreamFramerateSlowEncode = 4,
    k_EStreamFramerateSlowNetwork = 8,
    k_EStreamFramerateSlowDecode = 16,
    k_EStreamFramerateSlowGame = 32,
    k_EStreamFramerateSlowDisplay = 64,
}

impl ::protobuf::ProtobufEnum for EStreamFramerateLimiter {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFramerateLimiter> {
        match value {
            1 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowCapture),
            2 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowConvert),
            4 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowEncode),
            8 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork),
            16 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDecode),
            32 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowGame),
            64 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFramerateLimiter] = &[
            EStreamFramerateLimiter::k_EStreamFramerateSlowCapture,
            EStreamFramerateLimiter::k_EStreamFramerateSlowConvert,
            EStreamFramerateLimiter::k_EStreamFramerateSlowEncode,
            EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDecode,
            EStreamFramerateLimiter::k_EStreamFramerateSlowGame,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamFramerateLimiter>("EStreamFramerateLimiter", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamFramerateLimiter {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamFramerateLimiter {
    fn default() -> Self {
        EStreamFramerateLimiter::k_EStreamFramerateSlowCapture
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamFramerateLimiter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamActivity {
    k_EStreamActivityIdle = 1,
    k_EStreamActivityGame = 2,
    k_EStreamActivityDesktop = 3,
    k_EStreamActivitySecureDesktop = 4,
}

impl ::protobuf::ProtobufEnum for EStreamActivity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamActivity> {
        match value {
            1 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityIdle),
            2 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityGame),
            3 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityDesktop),
            4 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivitySecureDesktop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamActivity] = &[
            EStreamActivity::k_EStreamActivityIdle,
            EStreamActivity::k_EStreamActivityGame,
            EStreamActivity::k_EStreamActivityDesktop,
            EStreamActivity::k_EStreamActivitySecureDesktop,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamActivity>("EStreamActivity", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamActivity {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamActivity {
    fn default() -> Self {
        EStreamActivity::k_EStreamActivityIdle
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDataMessage {
    k_EStreamDataPacket = 1,
    k_EStreamDataLost = 2,
}

impl ::protobuf::ProtobufEnum for EStreamDataMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDataMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataPacket),
            2 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataLost),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDataMessage] = &[
            EStreamDataMessage::k_EStreamDataPacket,
            EStreamDataMessage::k_EStreamDataLost,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamDataMessage>("EStreamDataMessage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamDataMessage {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDataMessage {
    fn default() -> Self {
        EStreamDataMessage::k_EStreamDataPacket
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamDataMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EAudioFormat {
    k_EAudioFormatNone = 0,
    k_EAudioFormat16BitLittleEndian = 1,
    k_EAudioFormatFloat = 2,
}

impl ::protobuf::ProtobufEnum for EAudioFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAudioFormat> {
        match value {
            0 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatNone),
            1 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormat16BitLittleEndian),
            2 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatFloat),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EAudioFormat] = &[
            EAudioFormat::k_EAudioFormatNone,
            EAudioFormat::k_EAudioFormat16BitLittleEndian,
            EAudioFormat::k_EAudioFormatFloat,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EAudioFormat>("EAudioFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EAudioFormat {
}

impl ::std::default::Default for EAudioFormat {
    fn default() -> Self {
        EAudioFormat::k_EAudioFormatNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EAudioFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EVideoFormat {
    k_EVideoFormatNone = 0,
    k_EVideoFormatYV12 = 1,
    k_EVideoFormatAccel = 2,
}

impl ::protobuf::ProtobufEnum for EVideoFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVideoFormat> {
        match value {
            0 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatNone),
            1 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatYV12),
            2 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatAccel),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EVideoFormat] = &[
            EVideoFormat::k_EVideoFormatNone,
            EVideoFormat::k_EVideoFormatYV12,
            EVideoFormat::k_EVideoFormatAccel,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EVideoFormat>("EVideoFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EVideoFormat {
}

impl ::std::default::Default for EVideoFormat {
    fn default() -> Self {
        EVideoFormat::k_EVideoFormatNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EVideoFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamStatsMessage {
    k_EStreamStatsFrameEvents = 1,
    k_EStreamStatsDebugDump = 2,
    k_EStreamStatsLogMessage = 3,
    k_EStreamStatsLogUploadBegin = 4,
    k_EStreamStatsLogUploadData = 5,
    k_EStreamStatsLogUploadComplete = 6,
}

impl ::protobuf::ProtobufEnum for EStreamStatsMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamStatsMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsFrameEvents),
            2 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsDebugDump),
            3 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogMessage),
            4 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadBegin),
            5 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadData),
            6 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadComplete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamStatsMessage] = &[
            EStreamStatsMessage::k_EStreamStatsFrameEvents,
            EStreamStatsMessage::k_EStreamStatsDebugDump,
            EStreamStatsMessage::k_EStreamStatsLogMessage,
            EStreamStatsMessage::k_EStreamStatsLogUploadBegin,
            EStreamStatsMessage::k_EStreamStatsLogUploadData,
            EStreamStatsMessage::k_EStreamStatsLogUploadComplete,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamStatsMessage>("EStreamStatsMessage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamStatsMessage {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamStatsMessage {
    fn default() -> Self {
        EStreamStatsMessage::k_EStreamStatsFrameEvents
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamStatsMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFrameEvent {
    k_EStreamInputEventStart = 0,
    k_EStreamInputEventSend = 1,
    k_EStreamInputEventRecv = 2,
    k_EStreamInputEventQueued = 3,
    k_EStreamInputEventHandled = 4,
    k_EStreamFrameEventStart = 5,
    k_EStreamFrameEventCaptureBegin = 6,
    k_EStreamFrameEventCaptureEnd = 7,
    k_EStreamFrameEventConvertBegin = 8,
    k_EStreamFrameEventConvertEnd = 9,
    k_EStreamFrameEventEncodeBegin = 10,
    k_EStreamFrameEventEncodeEnd = 11,
    k_EStreamFrameEventSend = 12,
    k_EStreamFrameEventRecv = 13,
    k_EStreamFrameEventDecodeBegin = 14,
    k_EStreamFrameEventDecodeEnd = 15,
    k_EStreamFrameEventUploadBegin = 16,
    k_EStreamFrameEventUploadEnd = 17,
    k_EStreamFrameEventComplete = 18,
}

impl ::protobuf::ProtobufEnum for EStreamFrameEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameEvent> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventStart),
            1 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventSend),
            2 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventRecv),
            3 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventQueued),
            4 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventHandled),
            5 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventStart),
            6 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureBegin),
            7 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureEnd),
            8 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertBegin),
            9 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertEnd),
            10 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeBegin),
            11 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeEnd),
            12 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventSend),
            13 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventRecv),
            14 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeBegin),
            15 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeEnd),
            16 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadBegin),
            17 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadEnd),
            18 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventComplete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFrameEvent] = &[
            EStreamFrameEvent::k_EStreamInputEventStart,
            EStreamFrameEvent::k_EStreamInputEventSend,
            EStreamFrameEvent::k_EStreamInputEventRecv,
            EStreamFrameEvent::k_EStreamInputEventQueued,
            EStreamFrameEvent::k_EStreamInputEventHandled,
            EStreamFrameEvent::k_EStreamFrameEventStart,
            EStreamFrameEvent::k_EStreamFrameEventCaptureBegin,
            EStreamFrameEvent::k_EStreamFrameEventCaptureEnd,
            EStreamFrameEvent::k_EStreamFrameEventConvertBegin,
            EStreamFrameEvent::k_EStreamFrameEventConvertEnd,
            EStreamFrameEvent::k_EStreamFrameEventEncodeBegin,
            EStreamFrameEvent::k_EStreamFrameEventEncodeEnd,
            EStreamFrameEvent::k_EStreamFrameEventSend,
            EStreamFrameEvent::k_EStreamFrameEventRecv,
            EStreamFrameEvent::k_EStreamFrameEventDecodeBegin,
            EStreamFrameEvent::k_EStreamFrameEventDecodeEnd,
            EStreamFrameEvent::k_EStreamFrameEventUploadBegin,
            EStreamFrameEvent::k_EStreamFrameEventUploadEnd,
            EStreamFrameEvent::k_EStreamFrameEventComplete,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamFrameEvent>("EStreamFrameEvent", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamFrameEvent {
}

impl ::std::default::Default for EStreamFrameEvent {
    fn default() -> Self {
        EStreamFrameEvent::k_EStreamInputEventStart
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamFrameEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFrameResult {
    k_EStreamFrameResultPending = 0,
    k_EStreamFrameResultDisplayed = 1,
    k_EStreamFrameResultDroppedNetworkSlow = 2,
    k_EStreamFrameResultDroppedNetworkLost = 3,
    k_EStreamFrameResultDroppedDecodeSlow = 4,
    k_EStreamFrameResultDroppedDecodeCorrupt = 5,
    k_EStreamFrameResultDroppedLate = 6,
    k_EStreamFrameResultDroppedReset = 7,
}

impl ::protobuf::ProtobufEnum for EStreamFrameResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameResult> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultPending),
            1 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDisplayed),
            2 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow),
            3 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost),
            4 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow),
            5 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt),
            6 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedLate),
            7 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedReset),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFrameResult] = &[
            EStreamFrameResult::k_EStreamFrameResultPending,
            EStreamFrameResult::k_EStreamFrameResultDisplayed,
            EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow,
            EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost,
            EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow,
            EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt,
            EStreamFrameResult::k_EStreamFrameResultDroppedLate,
            EStreamFrameResult::k_EStreamFrameResultDroppedReset,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EStreamFrameResult>("EStreamFrameResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EStreamFrameResult {
}

impl ::std::default::Default for EStreamFrameResult {
    fn default() -> Self {
        EStreamFrameResult::k_EStreamFrameResultPending
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamFrameResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EFrameAccumulatedStat {
    k_EFrameStatFPS = 0,
    k_EFrameStatCaptureDurationMS = 1,
    k_EFrameStatConvertDurationMS = 2,
    k_EFrameStatEncodeDurationMS = 3,
    k_EFrameStatSteamDurationMS = 4,
    k_EFrameStatServerDurationMS = 5,
    k_EFrameStatNetworkDurationMS = 6,
    k_EFrameStatDecodeDurationMS = 7,
    k_EFrameStatDisplayDurationMS = 8,
    k_EFrameStatClientDurationMS = 9,
    k_EFrameStatFrameDurationMS = 10,
    k_EFrameStatInputLatencyMS = 11,
    k_EFrameStatGameLatencyMS = 12,
    k_EFrameStatRoundTripLatencyMS = 13,
    k_EFrameStatPingTimeMS = 14,
    k_EFrameStatServerBitrateKbitPerSec = 15,
    k_EFrameStatClientBitrateKbitPerSec = 16,
    k_EFrameStatLinkBandwidthKbitPerSec = 17,
    k_EFrameStatPacketLossPercentage = 18,
}

impl ::protobuf::ProtobufEnum for EFrameAccumulatedStat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFrameAccumulatedStat> {
        match value {
            0 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFPS),
            1 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS),
            2 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatConvertDurationMS),
            3 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS),
            4 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatSteamDurationMS),
            5 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerDurationMS),
            6 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS),
            7 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS),
            8 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS),
            9 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientDurationMS),
            10 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFrameDurationMS),
            11 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatInputLatencyMS),
            12 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatGameLatencyMS),
            13 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS),
            14 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPingTimeMS),
            15 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec),
            16 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec),
            17 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec),
            18 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EFrameAccumulatedStat] = &[
            EFrameAccumulatedStat::k_EFrameStatFPS,
            EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS,
            EFrameAccumulatedStat::k_EFrameStatConvertDurationMS,
            EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS,
            EFrameAccumulatedStat::k_EFrameStatSteamDurationMS,
            EFrameAccumulatedStat::k_EFrameStatServerDurationMS,
            EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS,
            EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS,
            EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS,
            EFrameAccumulatedStat::k_EFrameStatClientDurationMS,
            EFrameAccumulatedStat::k_EFrameStatFrameDurationMS,
            EFrameAccumulatedStat::k_EFrameStatInputLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatGameLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatPingTimeMS,
            EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EFrameAccumulatedStat>("EFrameAccumulatedStat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EFrameAccumulatedStat {
}

impl ::std::default::Default for EFrameAccumulatedStat {
    fn default() -> Self {
        EFrameAccumulatedStat::k_EFrameStatFPS
    }
}

impl ::protobuf::reflect::ProtobufValue for EFrameAccumulatedStat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ELogFileType {
    k_ELogFileSystemBoot = 0,
    k_ELogFileSystemReset = 1,
    k_ELogFileSystemDebug = 2,
}

impl ::protobuf::ProtobufEnum for ELogFileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELogFileType> {
        match value {
            0 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemBoot),
            1 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemReset),
            2 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemDebug),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ELogFileType] = &[
            ELogFileType::k_ELogFileSystemBoot,
            ELogFileType::k_ELogFileSystemReset,
            ELogFileType::k_ELogFileSystemDebug,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ELogFileType>("ELogFileType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ELogFileType {
}

impl ::std::default::Default for ELogFileType {
    fn default() -> Self {
        ELogFileType::k_ELogFileSystemBoot
    }
}

impl ::protobuf::reflect::ProtobufValue for ELogFileType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cstream.proto\"g\n\x15CDiscoveryPingRequest\x12\x1a\n\x08sequence\
    \x18\x01\x20\x01(\rR\x08sequence\x122\n\x15packet_size_requested\x18\x02\
    \x20\x01(\rR\x13packetSizeRequested\"f\n\x16CDiscoveryPingResponse\x12\
    \x1a\n\x08sequence\x18\x01\x20\x01(\rR\x08sequence\x120\n\x14packet_size\
    _received\x18\x02\x20\x01(\rR\x12packetSizeReceived\"B\n\x1dCStreamingCl\
    ientHandshakeInfo\x12!\n\x0cnetwork_test\x18\x02\x20\x01(\x05R\x0bnetwor\
    kTest\"I\n\x13CClientHandshakeMsg\x122\n\x04info\x18\x01\x20\x02(\x0b2\
    \x1e.CStreamingClientHandshakeInfoR\x04info\"1\n\x1dCStreamingServerHand\
    shakeInfo\x12\x10\n\x03mtu\x18\x01\x20\x01(\x05R\x03mtu\"I\n\x13CServerH\
    andshakeMsg\x122\n\x04info\x18\x01\x20\x02(\x0b2\x1e.CStreamingServerHan\
    dshakeInfoR\x04info\"r\n\x19CAuthenticationRequestMsg\x12\x14\n\x05token\
    \x18\x01\x20\x01(\x0cR\x05token\x12?\n\x07version\x18\x02\x20\x01(\x0e2\
    \x0f.EStreamVersion:\x14k_EStreamVersionNoneR\x07version\"\xe5\x01\n\x1a\
    CAuthenticationResponseMsg\x12S\n\x06result\x18\x01\x20\x01(\x0e20.CAuth\
    enticationResponseMsg.AuthenticationResult:\tSUCCEEDEDR\x06result\x12?\n\
    \x07version\x18\x02\x20\x01(\x0e2\x0f.EStreamVersion:\x14k_EStreamVersio\
    nNoneR\x07version\"1\n\x14AuthenticationResult\x12\r\n\tSUCCEEDED\x10\0\
    \x12\n\n\x06FAILED\x10\x01\"\x0f\n\rCKeepAliveMsg\"\xc4\x01\n\x14CStartN\
    etworkTestMsg\x12\x16\n\x06frames\x18\x01\x20\x01(\rR\x06frames\x12\x1c\
    \n\tframerate\x18\x02\x20\x01(\rR\tframerate\x12!\n\x0cbitrate_kbps\x18\
    \x03\x20\x01(\rR\x0bbitrateKbps\x12,\n\x12burst_bitrate_kbps\x18\x04\x20\
    \x01(\rR\x10burstBitrateKbps\x12%\n\x0ebandwidth_test\x18\x05\x20\x01(\
    \x08R\rbandwidthTest\"\xd3\x01\n\x10CStreamVideoMode\x12\x14\n\x05width\
    \x18\x01\x20\x02(\rR\x05width\x12\x16\n\x06height\x18\x02\x20\x02(\rR\
    \x06height\x12!\n\x0crefresh_rate\x18\x03\x20\x01(\rR\x0brefreshRate\x12\
    4\n\x16refresh_rate_numerator\x18\x04\x20\x01(\rR\x14refreshRateNumerato\
    r\x128\n\x18refresh_rate_denominator\x18\x05\x20\x01(\rR\x16refreshRateD\
    enominator\"\xe9\x04\n\x14CStreamingClientCaps\x12\x1f\n\x0bsystem_info\
    \x18\x01\x20\x01(\tR\nsystemInfo\x12,\n\x12system_can_suspend\x18\x02\
    \x20\x01(\x08R\x10systemCanSuspend\x12=\n\x1bmaximum_decode_bitrate_kbps\
    \x18\x03\x20\x01(\x05R\x18maximumDecodeBitrateKbps\x12;\n\x1amaximum_bur\
    st_bitrate_kbps\x18\x04\x20\x01(\x05R\x17maximumBurstBitrateKbps\x12.\n\
    \x13supports_video_hevc\x18\x05\x20\x01(\x08R\x11supportsVideoHevc\x12.\
    \n\x13disable_steam_store\x18\x06\x20\x01(\x08R\x11disableSteamStore\x12\
    2\n\x15disable_client_cursor\x18\x07\x20\x01(\x08R\x13disableClientCurso\
    r\x12E\n\x1fdisable_intel_hardware_encoding\x18\x08\x20\x01(\x08R\x1cdis\
    ableIntelHardwareEncoding\x12A\n\x1ddisable_amd_hardware_encoding\x18\t\
    \x20\x01(\x08R\x1adisableAmdHardwareEncoding\x12G\n\x20disable_nvidia_ha\
    rdware_encoding\x18\n\x20\x01(\x08R\x1ddisableNvidiaHardwareEncoding\x12\
    \x1f\n\x0bform_factor\x18\x0b\x20\x01(\x05R\nformFactor\"\xe6\x08\n\x16C\
    StreamingClientConfig\x12M\n\x07quality\x18\x01\x20\x01(\x0e2\x19.EStrea\
    mQualityPreference:\x18k_EStreamQualityBalancedR\x07quality\x120\n\x14ma\
    ximum_resolution_x\x18\x02\x20\x01(\rR\x12maximumResolutionX\x120\n\x14m\
    aximum_resolution_y\x18\x03\x20\x01(\rR\x12maximumResolutionY\x12>\n\x1b\
    maximum_framerate_numerator\x18\x04\x20\x01(\rR\x19maximumFramerateNumer\
    ator\x12B\n\x1dmaximum_framerate_denominator\x18\x05\x20\x01(\rR\x1bmaxi\
    mumFramerateDenominator\x124\n\x14maximum_bitrate_kbps\x18\x06\x20\x01(\
    \x05:\x02-1R\x12maximumBitrateKbps\x12>\n\x18enable_hardware_decoding\
    \x18\x07\x20\x01(\x08:\x04trueR\x16enableHardwareDecoding\x12C\n\x1aenab\
    le_performance_overlay\x18\x08\x20\x01(\x08:\x05falseR\x18enablePerforma\
    nceOverlay\x12:\n\x16enable_video_streaming\x18\t\x20\x01(\x08:\x04trueR\
    \x14enableVideoStreaming\x12:\n\x16enable_audio_streaming\x18\n\x20\x01(\
    \x08:\x04trueR\x14enableAudioStreaming\x12:\n\x16enable_input_streaming\
    \x18\x0b\x20\x01(\x08:\x04trueR\x14enableInputStreaming\x12(\n\x0eaudio_\
    channels\x18\x0c\x20\x01(\x05:\x012R\raudioChannels\x121\n\x11enable_vid\
    eo_hevc\x18\r\x20\x01(\x08:\x05falseR\x0fenableVideoHevc\x12>\n\x18enabl\
    e_performance_icons\x18\x0e\x20\x01(\x08:\x04trueR\x16enablePerformanceI\
    cons\x12E\n\x1benable_microphone_streaming\x18\x0f\x20\x01(\x08:\x05fals\
    eR\x19enableMicrophoneStreaming\x12:\n\x19controller_overlay_hotkey\x18\
    \x10\x20\x01(\tR\x17controllerOverlayHotkey\x12=\n\x17enable_touch_contr\
    oller\x18\x11\x20\x01(\x08:\x05falseR\x15enableTouchController\x12G\n\tp\
    2p_scope\x18\x12\x20\x01(\x0e2\x10.EStreamP2PScope:\x18k_EStreamP2PScope\
    UnknownR\x08p2pScope\"\xf3\x04\n\x16CStreamingServerConfig\x12:\n\x19cha\
    nge_desktop_resolution\x18\x01\x20\x01(\x08R\x17changeDesktopResolution\
    \x12B\n\x1ddynamically_adjust_resolution\x18\x02\x20\x01(\x08R\x1bdynami\
    callyAdjustResolution\x120\n\x14enable_capture_nvfbc\x18\x03\x20\x01(\
    \x08R\x12enableCaptureNvfbc\x12E\n\x1fenable_hardware_encoding_nvidia\
    \x18\x04\x20\x01(\x08R\x1cenableHardwareEncodingNvidia\x12?\n\x1cenable_\
    hardware_encoding_amd\x18\x05\x20\x01(\x08R\x19enableHardwareEncodingAmd\
    \x12C\n\x1eenable_hardware_encoding_intel\x18\x06\x20\x01(\x08R\x1benabl\
    eHardwareEncodingIntel\x12:\n\x19software_encoding_threads\x18\x07\x20\
    \x01(\x05R\x17softwareEncodingThreads\x126\n\x17enable_traffic_priority\
    \x18\x08\x20\x01(\x08R\x15enableTrafficPriority\x12f\n\x0fhost_play_audi\
    o\x18\t\x20\x01(\x0e2\x1f.EStreamHostPlayAudioPreference:\x1dk_EStreamHo\
    stPlayAudioDefaultR\rhostPlayAudio\"\x97\x03\n\x11CNegotiatedConfig\x12#\
    \n\rreliable_data\x18\x01\x20\x01(\x08R\x0creliableData\x12]\n\x14select\
    ed_audio_codec\x18\x02\x20\x01(\x0e2\x12.EStreamAudioCodec:\x17k_EStream\
    AudioCodecNoneR\x12selectedAudioCodec\x12]\n\x14selected_video_codec\x18\
    \x03\x20\x01(\x0e2\x12.EStreamVideoCodec:\x17k_EStreamVideoCodecNoneR\
    \x12selectedVideoCodec\x12E\n\x15available_video_modes\x18\x04\x20\x03(\
    \x0b2\x11.CStreamVideoModeR\x13availableVideoModes\x12*\n\x11enable_remo\
    te_hid\x18\x05\x20\x01(\x08R\x0fenableRemoteHid\x12,\n\x12enable_touch_i\
    nput\x18\x06\x20\x01(\x08R\x10enableTouchInput\"\xb0\x02\n\x13CNegotiati\
    onInitMsg\x12#\n\rreliable_data\x18\x01\x20\x01(\x08R\x0creliableData\
    \x12H\n\x16supported_audio_codecs\x18\x02\x20\x03(\x0e2\x12.EStreamAudio\
    CodecR\x14supportedAudioCodecs\x12H\n\x16supported_video_codecs\x18\x03\
    \x20\x03(\x0e2\x12.EStreamVideoCodecR\x14supportedVideoCodecs\x12.\n\x13\
    supports_remote_hid\x18\x04\x20\x01(\x08R\x11supportsRemoteHid\x120\n\
    \x14supports_touch_input\x18\x05\x20\x01(\x08R\x12supportsTouchInput\"\
    \xe2\x01\n\x18CNegotiationSetConfigMsg\x12*\n\x06config\x18\x01\x20\x02(\
    \x0b2\x12.CNegotiatedConfigR\x06config\x12O\n\x17streaming_client_config\
    \x18\x02\x20\x01(\x0b2\x17.CStreamingClientConfigR\x15streamingClientCon\
    fig\x12I\n\x15streaming_client_caps\x18\x03\x20\x01(\x0b2\x15.CStreaming\
    ClientCapsR\x13streamingClientCaps\"\x19\n\x17CNegotiationCompleteMsg\"\
    \xca\x01\n\x12CStartAudioDataMsg\x12\x18\n\x07channel\x18\x02\x20\x02(\r\
    R\x07channel\x12A\n\x05codec\x18\x03\x20\x01(\x0e2\x12.EStreamAudioCodec\
    :\x17k_EStreamAudioCodecNoneR\x05codec\x12\x1d\n\ncodec_data\x18\x04\x20\
    \x01(\x0cR\tcodecData\x12\x1c\n\tfrequency\x18\x05\x20\x01(\rR\tfrequenc\
    y\x12\x1a\n\x08channels\x18\x06\x20\x01(\rR\x08channels\"\x13\n\x11CStop\
    AudioDataMsg\"\xbe\x01\n\x12CStartVideoDataMsg\x12\x18\n\x07channel\x18\
    \x01\x20\x02(\rR\x07channel\x12A\n\x05codec\x18\x02\x20\x01(\x0e2\x12.ES\
    treamVideoCodec:\x17k_EStreamVideoCodecNoneR\x05codec\x12\x1d\n\ncodec_d\
    ata\x18\x03\x20\x01(\x0cR\tcodecData\x12\x14\n\x05width\x18\x04\x20\x01(\
    \rR\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\rR\x06height\"\x13\n\
    \x11CStopVideoDataMsg\"\xc2\x05\n\x0eCRecordedInput\x12Q\n\x04type\x18\
    \x01\x20\x01(\x0e2\x16.EStreamControlMessage:%k_EStreamControlAuthentica\
    tionRequestR\x04type\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\
    \x12<\n\x0bfinger_down\x18\x03\x20\x01(\x0b2\x19.CInputTouchFingerDownMs\
    gH\0R\nfingerDown\x12B\n\rfinger_motion\x18\x04\x20\x01(\x0b2\x1b.CInput\
    TouchFingerMotionMsgH\0R\x0cfingerMotion\x126\n\tfinger_up\x18\x05\x20\
    \x01(\x0b2\x17.CInputTouchFingerUpMsgH\0R\x08fingerUp\x12:\n\x0cmouse_mo\
    tion\x18\x06\x20\x01(\x0b2\x15.CInputMouseMotionMsgH\0R\x0bmouseMotion\
    \x127\n\x0bmouse_wheel\x18\x07\x20\x01(\x0b2\x14.CInputMouseWheelMsgH\0R\
    \nmouseWheel\x124\n\nmouse_down\x18\x08\x20\x01(\x0b2\x13.CInputMouseDow\
    nMsgH\0R\tmouseDown\x12.\n\x08mouse_up\x18\t\x20\x01(\x0b2\x11.CInputMou\
    seUpMsgH\0R\x07mouseUp\x12.\n\x08key_down\x18\n\x20\x01(\x0b2\x11.CInput\
    KeyDownMsgH\0R\x07keyDown\x12(\n\x06key_up\x18\x0b\x20\x01(\x0b2\x0f.CIn\
    putKeyUpMsgH\0R\x05keyUp\x12$\n\x04text\x18\x0c\x20\x01(\x0b2\x0e.CInput\
    TextMsgH\0R\x04text\x12\"\n\x03hid\x18\r\x20\x01(\x0b2\x0e.CRemoteHIDMsg\
    H\0R\x03hidB\x06\n\x04data\"A\n\x14CRecordedInputStream\x12)\n\x07entrie\
    s\x18\x01\x20\x03(\x0b2\x0f.CRecordedInputR\x07entries\"K\n\x14CInputLat\
    encyTestMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x02(\rR\tinputMark\x12\x14\
    \n\x05color\x18\x02\x20\x01(\rR\x05color\"\x9b\x01\n\x18CInputTouchFinge\
    rDownMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\
    \x08fingerid\x18\x02\x20\x01(\x04R\x08fingerid\x12!\n\x0cx_normalized\
    \x18\x03\x20\x01(\x02R\x0bxNormalized\x12!\n\x0cy_normalized\x18\x04\x20\
    \x01(\x02R\x0byNormalized\"\x9d\x01\n\x1aCInputTouchFingerMotionMsg\x12\
    \x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08fingerid\
    \x18\x02\x20\x01(\x04R\x08fingerid\x12!\n\x0cx_normalized\x18\x03\x20\
    \x01(\x02R\x0bxNormalized\x12!\n\x0cy_normalized\x18\x04\x20\x01(\x02R\
    \x0byNormalized\"\x99\x01\n\x16CInputTouchFingerUpMsg\x12\x1d\n\ninput_m\
    ark\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08fingerid\x18\x02\x20\x01\
    (\x04R\x08fingerid\x12!\n\x0cx_normalized\x18\x03\x20\x01(\x02R\x0bxNorm\
    alized\x12!\n\x0cy_normalized\x18\x04\x20\x01(\x02R\x0byNormalized\"\x9b\
    \x01\n\x14CInputMouseMotionMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\
    \tinputMark\x12!\n\x0cx_normalized\x18\x02\x20\x01(\x02R\x0bxNormalized\
    \x12!\n\x0cy_normalized\x18\x03\x20\x01(\x02R\x0byNormalized\x12\x0e\n\
    \x02dx\x18\x04\x20\x01(\x05R\x02dx\x12\x0e\n\x02dy\x18\x05\x20\x01(\x05R\
    \x02dy\"\x86\x01\n\x13CInputMouseWheelMsg\x12\x1d\n\ninput_mark\x18\x01\
    \x20\x01(\rR\tinputMark\x12P\n\tdirection\x18\x02\x20\x02(\x0e2\x1b.EStr\
    eamMouseWheelDirection:\x15k_EStreamMouseWheelUpR\tdirection\"z\n\x12CIn\
    putMouseDownMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12\
    E\n\x06button\x18\x02\x20\x02(\x0e2\x13.EStreamMouseButton:\x18k_EStream\
    MouseButtonLeftR\x06button\"x\n\x10CInputMouseUpMsg\x12\x1d\n\ninput_mar\
    k\x18\x01\x20\x01(\rR\tinputMark\x12E\n\x06button\x18\x02\x20\x02(\x0e2\
    \x13.EStreamMouseButton:\x18k_EStreamMouseButtonLeftR\x06button\"M\n\x10\
    CInputKeyDownMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\
    \x12\x1a\n\x08scancode\x18\x02\x20\x02(\rR\x08scancode\"K\n\x0eCInputKey\
    UpMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08\
    scancode\x18\x02\x20\x02(\rR\x08scancode\"K\n\rCInputTextMsg\x12\x1d\n\n\
    input_mark\x18\x01\x20\x01(\rR\tinputMark\x12\x1b\n\ttext_utf8\x18\x02\
    \x20\x02(\tR\x08textUtf8\"\"\n\x0cCSetTitleMsg\x12\x12\n\x04text\x18\x01\
    \x20\x01(\tR\x04text\"B\n\x12CSetCaptureSizeMsg\x12\x14\n\x05width\x18\
    \x01\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\
    \x06height\"Q\n\x0bCSetIconMsg\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\
    \x05width\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\x12\x14\n\
    \x05image\x18\x03\x20\x01(\x0cR\x05image\"^\n\x11CSetFlashStateMsg\x12\
    \x14\n\x05flags\x18\x01\x20\x01(\rR\x05flags\x12\x14\n\x05count\x18\x02\
    \x20\x01(\rR\x05count\x12\x1d\n\ntimeout_ms\x18\x03\x20\x01(\rR\ttimeout\
    Ms\"V\n\x0eCShowCursorMsg\x12!\n\x0cx_normalized\x18\x01\x20\x01(\x02R\
    \x0bxNormalized\x12!\n\x0cy_normalized\x18\x02\x20\x01(\x02R\x0byNormali\
    zed\"\x10\n\x0eCHideCursorMsg\",\n\rCSetCursorMsg\x12\x1b\n\tcursor_id\
    \x18\x01\x20\x02(\x04R\x08cursorId\"1\n\x12CGetCursorImageMsg\x12\x1b\n\
    \tcursor_id\x18\x01\x20\x02(\x04R\x08cursorId\"\x9f\x01\n\x12CSetCursorI\
    mageMsg\x12\x1b\n\tcursor_id\x18\x01\x20\x02(\x04R\x08cursorId\x12\x14\n\
    \x05width\x18\x02\x20\x01(\x05R\x05width\x12\x16\n\x06height\x18\x03\x20\
    \x01(\x05R\x06height\x12\x13\n\x05hot_x\x18\x04\x20\x01(\x05R\x04hotX\
    \x12\x13\n\x05hot_y\x18\x05\x20\x01(\x05R\x04hotY\x12\x14\n\x05image\x18\
    \x06\x20\x01(\x0cR\x05image\"D\n\x14CVideoDecoderInfoMsg\x12\x12\n\x04in\
    fo\x18\x01\x20\x01(\tR\x04info\x12\x18\n\x07threads\x18\x02\x20\x01(\x05\
    R\x07threads\"*\n\x14CVideoEncoderInfoMsg\x12\x12\n\x04info\x18\x01\x20\
    \x01(\tR\x04info\"\x0b\n\tCPauseMsg\"\x0c\n\nCResumeMsg\"\x1a\n\x18CEnab\
    leHighResCaptureMsg\"\x1b\n\x19CDisableHighResCaptureMsg\"\x19\n\x17CTog\
    gleMagnificationMsg\"+\n\x0fCSetCapslockMsg\x12\x18\n\x07pressed\x18\x01\
    \x20\x01(\x08R\x07pressed\"\xac\x03\n\x15CStreamingKeymapEntry\x12\x1a\n\
    \x08scancode\x18\x01\x20\x01(\x05R\x08scancode\x12%\n\x0enormal_keycode\
    \x18\x02\x20\x01(\x05R\rnormalKeycode\x12#\n\rshift_keycode\x18\x03\x20\
    \x01(\x05R\x0cshiftKeycode\x12)\n\x10capslock_keycode\x18\x04\x20\x01(\
    \x05R\x0fcapslockKeycode\x124\n\x16shift_capslock_keycode\x18\x05\x20\
    \x01(\x05R\x14shiftCapslockKeycode\x12#\n\raltgr_keycode\x18\x06\x20\x01\
    (\x05R\x0caltgrKeycode\x12.\n\x13altgr_shift_keycode\x18\x07\x20\x01(\
    \x05R\x11altgrShiftKeycode\x124\n\x16altgr_capslock_keycode\x18\x08\x20\
    \x01(\x05R\x14altgrCapslockKeycode\x12?\n\x1caltgr_shift_capslock_keycod\
    e\x18\t\x20\x01(\x05R\x19altgrShiftCapslockKeycode\"D\n\x10CStreamingKey\
    map\x120\n\x07entries\x18\x01\x20\x03(\x0b2\x16.CStreamingKeymapEntryR\
    \x07entries\":\n\rCSetKeymapMsg\x12)\n\x06keymap\x18\x01\x20\x01(\x0b2\
    \x11.CStreamingKeymapR\x06keymap\"\x0e\n\x0cCStopRequest\"\x0e\n\x0cCQui\
    tRequest\"/\n\x10CDeleteCursorMsg\x12\x1b\n\tcursor_id\x18\x01\x20\x02(\
    \x04R\x08cursorId\"L\n\x19CSetStreamingClientConfig\x12/\n\x06config\x18\
    \x01\x20\x02(\x0b2\x17.CStreamingClientConfigR\x06config\"%\n\nCSetQoSMs\
    g\x12\x17\n\x07use_qos\x18\x01\x20\x02(\x08R\x06useQos\"\xb6\x01\n\x16CS\
    etTargetFramerateMsg\x12\x1c\n\tframerate\x18\x01\x20\x02(\rR\tframerate\
    \x12\x18\n\x07reasons\x18\x02\x20\x01(\rR\x07reasons\x12/\n\x13framerate\
    _numerator\x18\x03\x20\x01(\rR\x12framerateNumerator\x123\n\x15framerate\
    _denominator\x18\x04\x20\x01(\rR\x14framerateDenominator\"0\n\x14CSetTar\
    getBitrateMsg\x12\x18\n\x07bitrate\x18\x01\x20\x02(\x05R\x07bitrate\".\n\
    \x12COverlayEnabledMsg\x12\x18\n\x07enabled\x18\x01\x20\x02(\x08R\x07ena\
    bled\"1\n\x10CSetGammaRampMsg\x12\x1d\n\ngamma_ramp\x18\x01\x20\x01(\x0c\
    R\tgammaRamp\"\x84\x01\n\x0fCSetActivityMsg\x12C\n\x08activity\x18\x01\
    \x20\x01(\x0e2\x10.EStreamActivity:\x15k_EStreamActivityIdleR\x08activit\
    y\x12\x14\n\x05appid\x18\x02\x20\x01(\rR\x05appid\x12\x16\n\x06gameid\
    \x18\x03\x20\x01(\x04R\x06gameid\"\x13\n\x11CSystemSuspendMsg\"4\n\x16CV\
    irtualHereRequestMsg\x12\x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostna\
    me\"J\n\x14CVirtualHereReadyMsg\x122\n\x15licensed_device_count\x18\x01\
    \x20\x01(\rR\x13licensedDeviceCount\"C\n\x1aCVirtualHereShareDeviceMsg\
    \x12%\n\x0edevice_address\x18\x01\x20\x01(\tR\rdeviceAddress\"0\n\x14CSe\
    tSpectatorModeMsg\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\
    \"#\n\rCRemoteHIDMsg\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"c\
    \n\x15CTouchConfigActiveMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05ap\
    pid\x12\x1a\n\x08revision\x18\x02\x20\x01(\rR\x08revision\x12\x18\n\x07c\
    reator\x18\x03\x20\x01(\x04R\x07creator\".\n\x16CGetTouchConfigDataMsg\
    \x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\x90\x01\n\x16CSetTouc\
    hConfigDataMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1a\n\
    \x08revision\x18\x02\x20\x01(\rR\x08revision\x12\x12\n\x04data\x18\x03\
    \x20\x01(\x0cR\x04data\x12\x16\n\x06layout\x18\x04\x20\x01(\x0cR\x06layo\
    ut\x12\x18\n\x07creator\x18\x05\x20\x01(\x04R\x07creator\"I\n\x19CSaveTo\
    uchConfigLayoutMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x16\n\x06layout\x18\x04\x20\x01(\x0cR\x06layout\"S\n\x18CTouchActionSet\
    ActiveMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0cacti\
    onset_id\x18\x02\x20\x01(\x05R\x0bactionsetId\"W\n\x1cCTouchActionSetLay\
    erAddedMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0cact\
    ionset_id\x18\x02\x20\x01(\x05R\x0bactionsetId\"Y\n\x1eCTouchActionSetLa\
    yerRemovedMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0c\
    actionset_id\x18\x02\x20\x01(\x05R\x0bactionsetId\"@\n\x14CGetTouchIconD\
    ataMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04icon\
    \x18\x02\x20\x01(\tR\x04icon\"T\n\x14CSetTouchIconDataMsg\x12\x14\n\x05a\
    ppid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04icon\x18\x02\x20\x01(\tR\
    \x04icon\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\".\n\x12CStream\
    DataLostMsg\x12\x18\n\x07packets\x18\x01\x20\x03(\rR\x07packets\"\x83\
    \x01\n\x0cCAudioFormat\x129\n\x06format\x18\x01\x20\x02(\x0e2\r.EAudioFo\
    rmat:\x12k_EAudioFormatNoneR\x06format\x12\x1c\n\tfrequency\x18\x02\x20\
    \x01(\rR\tfrequency\x12\x1a\n\x08channels\x18\x03\x20\x01(\rR\x08channel\
    s\"w\n\x0cCVideoFormat\x129\n\x06format\x18\x01\x20\x02(\x0e2\r.EVideoFo\
    rmat:\x12k_EVideoFormatNoneR\x06format\x12\x14\n\x05width\x18\x02\x20\
    \x01(\rR\x05width\x12\x16\n\x06height\x18\x03\x20\x01(\rR\x06height\"t\n\
    \x0bCFrameEvent\x12G\n\x08event_id\x18\x01\x20\x02(\x0e2\x12.EStreamFram\
    eEvent:\x18k_EStreamInputEventStartR\x07eventId\x12\x1c\n\ttimestamp\x18\
    \x02\x20\x02(\rR\ttimestamp\"\xe5\x03\n\x0bCFrameStats\x12\x19\n\x08fram\
    e_id\x18\x01\x20\x02(\rR\x07frameId\x12\x1d\n\ninput_mark\x18\x02\x20\
    \x01(\rR\tinputMark\x12$\n\x06events\x18\x03\x20\x03(\x0b2\x0c.CFrameEve\
    ntR\x06events\x12H\n\x06result\x18\x04\x20\x02(\x0e2\x13.EStreamFrameRes\
    ult:\x1bk_EStreamFrameResultPendingR\x06result\x12*\n\x11frame_start_del\
    ta\x18\x05\x20\x01(\x02R\x0fframeStartDelta\x12.\n\x13frame_display_delt\
    a\x18\x06\x20\x01(\x02R\x11frameDisplayDelta\x12\x1b\n\tping_time\x18\
    \x07\x20\x01(\x02R\x08pingTime\x12%\n\x0eserver_bitrate\x18\x08\x20\x01(\
    \x02R\rserverBitrate\x12%\n\x0eclient_bitrate\x18\t\x20\x01(\x02R\rclien\
    tBitrate\x12%\n\x0elink_bandwidth\x18\n\x20\x01(\x02R\rlinkBandwidth\x12\
    \x1f\n\x0bpacket_loss\x18\x0b\x20\x01(\x02R\npacketLoss\x12\x1d\n\nframe\
    _size\x18\x0c\x20\x01(\rR\tframeSize\"\xaa\x01\n\x1aCFrameStatAccumulate\
    dValue\x12D\n\tstat_type\x18\x01\x20\x02(\x0e2\x16.EFrameAccumulatedStat\
    :\x0fk_EFrameStatFPSR\x08statType\x12\x14\n\x05count\x18\x02\x20\x02(\
    \x05R\x05count\x12\x18\n\x07average\x18\x03\x20\x02(\x02R\x07average\x12\
    \x16\n\x06stddev\x18\x04\x20\x01(\x02R\x06stddev\"\xf3\x01\n\x12CFrameSt\
    atsListMsg\x12G\n\tdata_type\x18\x01\x20\x02(\x0e2\x13.EStreamingDataTyp\
    e:\x15k_EStreamingAudioDataR\x08dataType\x12\"\n\x05stats\x18\x02\x20\
    \x03(\x0b2\x0c.CFrameStatsR\x05stats\x12H\n\x11accumulated_stats\x18\x03\
    \x20\x03(\x0b2\x1b.CFrameStatAccumulatedValueR\x10accumulatedStats\x12&\
    \n\x0flatest_frame_id\x18\x04\x20\x02(\x05R\rlatestFrameId\"\xb8\x01\n\
    \x16CStreamingSessionStats\x122\n\x15frame_loss_percentage\x18\x01\x20\
    \x01(\x02R\x13frameLossPercentage\x125\n\x17average_network_time_ms\x18\
    \x02\x20\x01(\x02R\x14averageNetworkTimeMs\x123\n\x16stddev_network_time\
    _ms\x18\x03\x20\x01(\x02R\x13stddevNetworkTimeMs\"/\n\rCDebugDumpMsg\x12\
    \x1e\n\nscreenshot\x18\x01\x20\x01(\x0cR\nscreenshot\"7\n\x07CLogMsg\x12\
    \x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\"\\\n\rCLogUploadMsg\x127\n\x04type\x18\x01\
    \x20\x01(\x0e2\r.ELogFileType:\x14k_ELogFileSystemBootR\x04type\x12\x12\
    \n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\x86\x03\n\x13CTransportSignal\
    Msg\x12:\n\x06webrtc\x18\x01\x20\x01(\x0b2\".CTransportSignalMsg.WebRTCM\
    essageR\x06webrtc\x12\x10\n\x03sdr\x18\x02\x20\x03(\x0cR\x03sdr\x1a\xa0\
    \x02\n\rWebRTCMessage\x12\x1c\n\x08greeting\x18\x01\x20\x01(\x08H\0R\x08\
    greeting\x12\x16\n\x05offer\x18\x02\x20\x01(\tH\0R\x05offer\x12\x18\n\
    \x06answer\x18\x03\x20\x01(\tH\0R\x06answer\x12L\n\tcandidate\x18\x04\
    \x20\x01(\x0b2,.CTransportSignalMsg.WebRTCMessage.CandidateH\0R\tcandida\
    te\x1aj\n\tCandidate\x12\x17\n\x07sdp_mid\x18\x01\x20\x01(\tR\x06sdpMid\
    \x12&\n\x0fsdp_mline_index\x18\x02\x20\x01(\x05R\rsdpMlineIndex\x12\x1c\
    \n\tcandidate\x18\x03\x20\x01(\tR\tcandidateB\x05\n\x03msg*\xb3\x01\n\
    \x0eEStreamChannel\x12$\n\x17k_EStreamChannelInvalid\x10\xff\xff\xff\xff\
    \xff\xff\xff\xff\xff\x01\x12\x1d\n\x19k_EStreamChannelDiscovery\x10\0\
    \x12\x1b\n\x17k_EStreamChannelControl\x10\x01\x12\x19\n\x15k_EStreamChan\
    nelStats\x10\x02\x12$\n\x20k_EStreamChannelDataChannelStart\x10\x03*`\n\
    \x17EStreamDiscoveryMessage\x12!\n\x1dk_EStreamDiscoveryPingRequest\x10\
    \x01\x12\"\n\x1ek_EStreamDiscoveryPingResponse\x10\x02*\xa3\x1a\n\x15ESt\
    reamControlMessage\x12)\n%k_EStreamControlAuthenticationRequest\x10\x01\
    \x12*\n&k_EStreamControlAuthenticationResponse\x10\x02\x12#\n\x1fk_EStre\
    amControlNegotiationInit\x10\x03\x12(\n$k_EStreamControlNegotiationSetCo\
    nfig\x10\x04\x12'\n#k_EStreamControlNegotiationComplete\x10\x05\x12#\n\
    \x1fk_EStreamControlClientHandshake\x10\x06\x12#\n\x1fk_EStreamControlSe\
    rverHandshake\x10\x07\x12$\n\x20k_EStreamControlStartNetworkTest\x10\x08\
    \x12\x1d\n\x19k_EStreamControlKeepAlive\x10\t\x12'\n#k_EStreamControl_LA\
    ST_SETUP_MESSAGE\x10\x0f\x12\"\n\x1ek_EStreamControlStartAudioData\x102\
    \x12!\n\x1dk_EStreamControlStopAudioData\x103\x12\"\n\x1ek_EStreamContro\
    lStartVideoData\x104\x12!\n\x1dk_EStreamControlStopVideoData\x105\x12$\n\
    \x20k_EStreamControlInputMouseMotion\x106\x12#\n\x1fk_EStreamControlInpu\
    tMouseWheel\x107\x12\"\n\x1ek_EStreamControlInputMouseDown\x108\x12\x20\
    \n\x1ck_EStreamControlInputMouseUp\x109\x12\x20\n\x1ck_EStreamControlInp\
    utKeyDown\x10:\x12\x1e\n\x1ak_EStreamControlInputKeyUp\x10;\x121\n-k_ESt\
    reamControlInputGamepadAttached_OBSOLETE\x10<\x12.\n*k_EStreamControlInp\
    utGamepadEvent_OBSOLETE\x10=\x121\n-k_EStreamControlInputGamepadDetached\
    _OBSOLETE\x10>\x12\x1e\n\x1ak_EStreamControlShowCursor\x10?\x12\x1e\n\
    \x1ak_EStreamControlHideCursor\x10@\x12\x1d\n\x19k_EStreamControlSetCurs\
    or\x10A\x12\"\n\x1ek_EStreamControlGetCursorImage\x10B\x12\"\n\x1ek_EStr\
    eamControlSetCursorImage\x10C\x12\x20\n\x1ck_EStreamControlDeleteCursor\
    \x10D\x12&\n\"k_EStreamControlSetTargetFramerate\x10E\x12$\n\x20k_EStrea\
    mControlInputLatencyTest\x10F\x12*\n&k_EStreamControlGamepadRumble_OBSOL\
    ETE\x10G\x12\"\n\x1ek_EStreamControlOverlayEnabled\x10J\x124\n0k_EStream\
    ControlInputControllerAttached_OBSOLETE\x10K\x121\n-k_EStreamControlInpu\
    tControllerState_OBSOLETE\x10L\x12/\n+k_EStreamControlTriggerHapticPulse\
    _OBSOLETE\x10M\x124\n0k_EStreamControlInputControllerDetached_OBSOLETE\
    \x10N\x12$\n\x20k_EStreamControlVideoDecoderInfo\x10P\x12\x1c\n\x18k_ESt\
    reamControlSetTitle\x10Q\x12\x1b\n\x17k_EStreamControlSetIcon\x10R\x12\
    \x1f\n\x1bk_EStreamControlQuitRequest\x10S\x12\x1a\n\x16k_EStreamControl\
    SetQoS\x10W\x12<\n8k_EStreamControlInputControllerWirelessPresence_OBSOL\
    ETE\x10X\x12\x20\n\x1ck_EStreamControlSetGammaRamp\x10Y\x12$\n\x20k_EStr\
    eamControlVideoEncoderInfo\x10Z\x124\n0k_EStreamControlInputControllerSt\
    ateHID_OBSOLETE\x10]\x12$\n\x20k_EStreamControlSetTargetBitrate\x10^\x12\
    8\n4k_EStreamControlSetControllerPairingEnabled_OBSOLETE\x10_\x127\n3k_E\
    StreamControlSetControllerPairingResult_OBSOLETE\x10`\x128\n4k_EStreamCo\
    ntrolTriggerControllerDisconnect_OBSOLETE\x10a\x12\x1f\n\x1bk_EStreamCon\
    trolSetActivity\x10b\x12,\n(k_EStreamControlSetStreamingClientConfig\x10\
    c\x12!\n\x1dk_EStreamControlSystemSuspend\x10d\x122\n.k_EStreamControlSe\
    tControllerSettings_OBSOLETE\x10e\x12&\n\"k_EStreamControlVirtualHereReq\
    uest\x10f\x12$\n\x20k_EStreamControlVirtualHereReady\x10g\x12*\n&k_EStre\
    amControlVirtualHereShareDevice\x10h\x12$\n\x20k_EStreamControlSetSpecta\
    torMode\x10i\x12\x1d\n\x19k_EStreamControlRemoteHID\x10j\x12'\n#k_EStrea\
    mControlStartMicrophoneData\x10k\x12&\n\"k_EStreamControlStopMicrophoneD\
    ata\x10l\x12\x1d\n\x19k_EStreamControlInputText\x10m\x12%\n!k_EStreamCon\
    trolTouchConfigActive\x10n\x12&\n\"k_EStreamControlGetTouchConfigData\
    \x10o\x12&\n\"k_EStreamControlSetTouchConfigData\x10p\x12)\n%k_EStreamCo\
    ntrolSaveTouchConfigLayout\x10q\x12(\n$k_EStreamControlTouchActionSetAct\
    ive\x10r\x12$\n\x20k_EStreamControlGetTouchIconData\x10s\x12$\n\x20k_ESt\
    reamControlSetTouchIconData\x10t\x12(\n$k_EStreamControlInputTouchFinger\
    Down\x10u\x12*\n&k_EStreamControlInputTouchFingerMotion\x10v\x12&\n\"k_E\
    StreamControlInputTouchFingerUp\x10w\x12\"\n\x1ek_EStreamControlSetCaptu\
    reSize\x10x\x12!\n\x1dk_EStreamControlSetFlashState\x10y\x12\x19\n\x15k_\
    EStreamControlPause\x10z\x12\x1a\n\x16k_EStreamControlResume\x10{\x12(\n\
    $k_EStreamControlEnableHighResCapture\x10|\x12)\n%k_EStreamControlDisabl\
    eHighResCapture\x10}\x12'\n#k_EStreamControlToggleMagnification\x10~\x12\
    \x1f\n\x1bk_EStreamControlSetCapslock\x10\x7f\x12\x1e\n\x19k_EStreamCont\
    rolSetKeymap\x10\x80\x01\x12\x20\n\x1bk_EStreamControlStopRequest\x10\
    \x81\x01\x12-\n(k_EStreamControlTouchActionSetLayerAdded\x10\x82\x01\x12\
    /\n*k_EStreamControlTouchActionSetLayerRemoved\x10\x83\x01*G\n\x0eEStrea\
    mVersion\x12\x18\n\x14k_EStreamVersionNone\x10\0\x12\x1b\n\x17k_EStreamV\
    ersionCurrent\x10\x01*\xc0\x01\n\x11EStreamAudioCodec\x12\x1b\n\x17k_ESt\
    reamAudioCodecNone\x10\0\x12\x1a\n\x16k_EStreamAudioCodecRaw\x10\x01\x12\
    \x1d\n\x19k_EStreamAudioCodecVorbis\x10\x02\x12\x1b\n\x17k_EStreamAudioC\
    odecOpus\x10\x03\x12\x1a\n\x16k_EStreamAudioCodecMP3\x10\x04\x12\x1a\n\
    \x16k_EStreamAudioCodecAAC\x10\x05*\xfa\x01\n\x11EStreamVideoCodec\x12\
    \x1b\n\x17k_EStreamVideoCodecNone\x10\0\x12\x1a\n\x16k_EStreamVideoCodec\
    Raw\x10\x01\x12\x1a\n\x16k_EStreamVideoCodecVP8\x10\x02\x12\x1a\n\x16k_E\
    StreamVideoCodecVP9\x10\x03\x12\x1b\n\x17k_EStreamVideoCodecH264\x10\x04\
    \x12\x1b\n\x17k_EStreamVideoCodecHEVC\x10\x05\x12\x1c\n\x18k_EStreamVide\
    oCodecORBX1\x10\x06\x12\x1c\n\x18k_EStreamVideoCodecORBX2\x10\x07*q\n\
    \x18EStreamQualityPreference\x12\x18\n\x14k_EStreamQualityFast\x10\x01\
    \x12\x1c\n\x18k_EStreamQualityBalanced\x10\x02\x12\x1d\n\x19k_EStreamQua\
    lityBeautiful\x10\x03*X\n\x0eEStreamBitrate\x12'\n\x1ak_EStreamBitrateAu\
    todetect\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1d\n\x19k_EStr\
    eamBitrateUnlimited\x10\0*\xa8\x01\n\x0fEStreamP2PScope\x12\x1c\n\x18k_E\
    StreamP2PScopeUnknown\x10\0\x12\x1d\n\x19k_EStreamP2PScopeDisabled\x10\
    \x01\x12\x1b\n\x17k_EStreamP2PScopeOnlyMe\x10\x02\x12\x1c\n\x18k_EStream\
    P2PScopeFriends\x10\x03\x12\x1d\n\x19k_EStreamP2PScopeEveryone\x10\x04*e\
    \n\x1eEStreamHostPlayAudioPreference\x12!\n\x1dk_EStreamHostPlayAudioDef\
    ault\x10\0\x12\x20\n\x1ck_EStreamHostPlayAudioAlways\x10\x01*j\n\x12EStr\
    eamingDataType\x12\x19\n\x15k_EStreamingAudioData\x10\0\x12\x19\n\x15k_E\
    StreamingVideoData\x10\x01\x12\x1e\n\x1ak_EStreamingMicrophoneData\x10\
    \x02*\xcb\x01\n\x12EStreamMouseButton\x12\x1c\n\x18k_EStreamMouseButtonL\
    eft\x10\x01\x12\x1d\n\x19k_EStreamMouseButtonRight\x10\x02\x12\x1e\n\x1a\
    k_EStreamMouseButtonMiddle\x10\x10\x12\x1a\n\x16k_EStreamMouseButtonX1\
    \x10\x20\x12\x1a\n\x16k_EStreamMouseButtonX2\x10@\x12\x20\n\x1bk_EStream\
    MouseButtonUnknown\x10\x80\x20*\x98\x01\n\x1aEStreamMouseWheelDirection\
    \x12\x19\n\x15k_EStreamMouseWheelUp\x10x\x12$\n\x17k_EStreamMouseWheelDo\
    wn\x10\x88\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1b\n\x17k_EStreamMou\
    seWheelLeft\x10\x03\x12\x1c\n\x18k_EStreamMouseWheelRight\x10\x04*\x89\
    \x02\n\x17EStreamFramerateLimiter\x12!\n\x1dk_EStreamFramerateSlowCaptur\
    e\x10\x01\x12!\n\x1dk_EStreamFramerateSlowConvert\x10\x02\x12\x20\n\x1ck\
    _EStreamFramerateSlowEncode\x10\x04\x12!\n\x1dk_EStreamFramerateSlowNetw\
    ork\x10\x08\x12\x20\n\x1ck_EStreamFramerateSlowDecode\x10\x10\x12\x1e\n\
    \x1ak_EStreamFramerateSlowGame\x10\x20\x12!\n\x1dk_EStreamFramerateSlowD\
    isplay\x10@*\x89\x01\n\x0fEStreamActivity\x12\x19\n\x15k_EStreamActivity\
    Idle\x10\x01\x12\x19\n\x15k_EStreamActivityGame\x10\x02\x12\x1c\n\x18k_E\
    StreamActivityDesktop\x10\x03\x12\"\n\x1ek_EStreamActivitySecureDesktop\
    \x10\x04*D\n\x12EStreamDataMessage\x12\x17\n\x13k_EStreamDataPacket\x10\
    \x01\x12\x15\n\x11k_EStreamDataLost\x10\x02*d\n\x0cEAudioFormat\x12\x16\
    \n\x12k_EAudioFormatNone\x10\0\x12#\n\x1fk_EAudioFormat16BitLittleEndian\
    \x10\x01\x12\x17\n\x13k_EAudioFormatFloat\x10\x02*W\n\x0cEVideoFormat\
    \x12\x16\n\x12k_EVideoFormatNone\x10\0\x12\x16\n\x12k_EVideoFormatYV12\
    \x10\x01\x12\x17\n\x13k_EVideoFormatAccel\x10\x02*\xd7\x01\n\x13EStreamS\
    tatsMessage\x12\x1d\n\x19k_EStreamStatsFrameEvents\x10\x01\x12\x1b\n\x17\
    k_EStreamStatsDebugDump\x10\x02\x12\x1c\n\x18k_EStreamStatsLogMessage\
    \x10\x03\x12\x20\n\x1ck_EStreamStatsLogUploadBegin\x10\x04\x12\x1f\n\x1b\
    k_EStreamStatsLogUploadData\x10\x05\x12#\n\x1fk_EStreamStatsLogUploadCom\
    plete\x10\x06*\x85\x05\n\x11EStreamFrameEvent\x12\x1c\n\x18k_EStreamInpu\
    tEventStart\x10\0\x12\x1b\n\x17k_EStreamInputEventSend\x10\x01\x12\x1b\n\
    \x17k_EStreamInputEventRecv\x10\x02\x12\x1d\n\x19k_EStreamInputEventQueu\
    ed\x10\x03\x12\x1e\n\x1ak_EStreamInputEventHandled\x10\x04\x12\x1c\n\x18\
    k_EStreamFrameEventStart\x10\x05\x12#\n\x1fk_EStreamFrameEventCaptureBeg\
    in\x10\x06\x12!\n\x1dk_EStreamFrameEventCaptureEnd\x10\x07\x12#\n\x1fk_E\
    StreamFrameEventConvertBegin\x10\x08\x12!\n\x1dk_EStreamFrameEventConver\
    tEnd\x10\t\x12\"\n\x1ek_EStreamFrameEventEncodeBegin\x10\n\x12\x20\n\x1c\
    k_EStreamFrameEventEncodeEnd\x10\x0b\x12\x1b\n\x17k_EStreamFrameEventSen\
    d\x10\x0c\x12\x1b\n\x17k_EStreamFrameEventRecv\x10\r\x12\"\n\x1ek_EStrea\
    mFrameEventDecodeBegin\x10\x0e\x12\x20\n\x1ck_EStreamFrameEventDecodeEnd\
    \x10\x0f\x12\"\n\x1ek_EStreamFrameEventUploadBegin\x10\x10\x12\x20\n\x1c\
    k_EStreamFrameEventUploadEnd\x10\x11\x12\x1f\n\x1bk_EStreamFrameEventCom\
    plete\x10\x12*\xd4\x02\n\x12EStreamFrameResult\x12\x1f\n\x1bk_EStreamFra\
    meResultPending\x10\0\x12!\n\x1dk_EStreamFrameResultDisplayed\x10\x01\
    \x12*\n&k_EStreamFrameResultDroppedNetworkSlow\x10\x02\x12*\n&k_EStreamF\
    rameResultDroppedNetworkLost\x10\x03\x12)\n%k_EStreamFrameResultDroppedD\
    ecodeSlow\x10\x04\x12,\n(k_EStreamFrameResultDroppedDecodeCorrupt\x10\
    \x05\x12#\n\x1fk_EStreamFrameResultDroppedLate\x10\x06\x12$\n\x20k_EStre\
    amFrameResultDroppedReset\x10\x07*\xa2\x05\n\x15EFrameAccumulatedStat\
    \x12\x13\n\x0fk_EFrameStatFPS\x10\0\x12!\n\x1dk_EFrameStatCaptureDuratio\
    nMS\x10\x01\x12!\n\x1dk_EFrameStatConvertDurationMS\x10\x02\x12\x20\n\
    \x1ck_EFrameStatEncodeDurationMS\x10\x03\x12\x1f\n\x1bk_EFrameStatSteamD\
    urationMS\x10\x04\x12\x20\n\x1ck_EFrameStatServerDurationMS\x10\x05\x12!\
    \n\x1dk_EFrameStatNetworkDurationMS\x10\x06\x12\x20\n\x1ck_EFrameStatDec\
    odeDurationMS\x10\x07\x12!\n\x1dk_EFrameStatDisplayDurationMS\x10\x08\
    \x12\x20\n\x1ck_EFrameStatClientDurationMS\x10\t\x12\x1f\n\x1bk_EFrameSt\
    atFrameDurationMS\x10\n\x12\x1e\n\x1ak_EFrameStatInputLatencyMS\x10\x0b\
    \x12\x1d\n\x19k_EFrameStatGameLatencyMS\x10\x0c\x12\"\n\x1ek_EFrameStatR\
    oundTripLatencyMS\x10\r\x12\x1a\n\x16k_EFrameStatPingTimeMS\x10\x0e\x12'\
    \n#k_EFrameStatServerBitrateKbitPerSec\x10\x0f\x12'\n#k_EFrameStatClient\
    BitrateKbitPerSec\x10\x10\x12'\n#k_EFrameStatLinkBandwidthKbitPerSec\x10\
    \x11\x12$\n\x20k_EFrameStatPacketLossPercentage\x10\x12*^\n\x0cELogFileT\
    ype\x12\x18\n\x14k_ELogFileSystemBoot\x10\0\x12\x19\n\x15k_ELogFileSyste\
    mReset\x10\x01\x12\x19\n\x15k_ELogFileSystemDebug\x10\x02B\x05H\x01\x80\
    \x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
