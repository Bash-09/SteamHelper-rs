// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_clientserver_2.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMAddScreenshot {
    // message fields
    appid: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    thumbname: ::protobuf::SingularField<::std::string::String>,
    vr_filename: ::protobuf::SingularField<::std::string::String>,
    rtime32_created: ::std::option::Option<u32>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    permissions: ::std::option::Option<u32>,
    caption: ::protobuf::SingularField<::std::string::String>,
    shortcut_name: ::protobuf::SingularField<::std::string::String>,
    pub tag: ::protobuf::RepeatedField<CMsgClientUCMAddScreenshot_Tag>,
    pub tagged_steamid: ::std::vec::Vec<u64>,
    spoiler_tag: ::std::option::Option<bool>,
    pub tagged_publishedfileid: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshot {
    fn default() -> &'a CMsgClientUCMAddScreenshot {
        <CMsgClientUCMAddScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshot {
    pub fn new() -> CMsgClientUCMAddScreenshot {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string filename = 2;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string thumbname = 3;


    pub fn get_thumbname(&self) -> &str {
        match self.thumbname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_thumbname(&mut self) {
        self.thumbname.clear();
    }

    pub fn has_thumbname(&self) -> bool {
        self.thumbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbname(&mut self, v: ::std::string::String) {
        self.thumbname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbname(&mut self) -> &mut ::std::string::String {
        if self.thumbname.is_none() {
            self.thumbname.set_default();
        }
        self.thumbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbname(&mut self) -> ::std::string::String {
        self.thumbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vr_filename = 14;


    pub fn get_vr_filename(&self) -> &str {
        match self.vr_filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vr_filename(&mut self) {
        self.vr_filename.clear();
    }

    pub fn has_vr_filename(&self) -> bool {
        self.vr_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_filename(&mut self, v: ::std::string::String) {
        self.vr_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vr_filename(&mut self) -> &mut ::std::string::String {
        if self.vr_filename.is_none() {
            self.vr_filename.set_default();
        }
        self.vr_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_vr_filename(&mut self) -> ::std::string::String {
        self.vr_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 rtime32_created = 4;


    pub fn get_rtime32_created(&self) -> u32 {
        self.rtime32_created.unwrap_or(0)
    }
    pub fn clear_rtime32_created(&mut self) {
        self.rtime32_created = ::std::option::Option::None;
    }

    pub fn has_rtime32_created(&self) -> bool {
        self.rtime32_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_created(&mut self, v: u32) {
        self.rtime32_created = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 5;


    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }
    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 6;


    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }
    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 permissions = 7;


    pub fn get_permissions(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }
    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    // optional string caption = 8;


    pub fn get_caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_caption(&mut self) {
        self.caption.clear();
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption.set_default();
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shortcut_name = 9;


    pub fn get_shortcut_name(&self) -> &str {
        match self.shortcut_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shortcut_name(&mut self) {
        self.shortcut_name.clear();
    }

    pub fn has_shortcut_name(&self) -> bool {
        self.shortcut_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcut_name(&mut self, v: ::std::string::String) {
        self.shortcut_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcut_name(&mut self) -> &mut ::std::string::String {
        if self.shortcut_name.is_none() {
            self.shortcut_name.set_default();
        }
        self.shortcut_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcut_name(&mut self) -> ::std::string::String {
        self.shortcut_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgClientUCMAddScreenshot.Tag tag = 10;


    pub fn get_tag(&self) -> &[CMsgClientUCMAddScreenshot_Tag] {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMAddScreenshot_Tag>) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tag(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMAddScreenshot_Tag> {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMAddScreenshot_Tag> {
        ::std::mem::replace(&mut self.tag, ::protobuf::RepeatedField::new())
    }

    // repeated fixed64 tagged_steamid = 11;


    pub fn get_tagged_steamid(&self) -> &[u64] {
        &self.tagged_steamid
    }
    pub fn clear_tagged_steamid(&mut self) {
        self.tagged_steamid.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagged_steamid(&mut self, v: ::std::vec::Vec<u64>) {
        self.tagged_steamid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagged_steamid(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.tagged_steamid
    }

    // Take field
    pub fn take_tagged_steamid(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.tagged_steamid, ::std::vec::Vec::new())
    }

    // optional bool spoiler_tag = 12;


    pub fn get_spoiler_tag(&self) -> bool {
        self.spoiler_tag.unwrap_or(false)
    }
    pub fn clear_spoiler_tag(&mut self) {
        self.spoiler_tag = ::std::option::Option::None;
    }

    pub fn has_spoiler_tag(&self) -> bool {
        self.spoiler_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spoiler_tag(&mut self, v: bool) {
        self.spoiler_tag = ::std::option::Option::Some(v);
    }

    // repeated uint64 tagged_publishedfileid = 13;


    pub fn get_tagged_publishedfileid(&self) -> &[u64] {
        &self.tagged_publishedfileid
    }
    pub fn clear_tagged_publishedfileid(&mut self) {
        self.tagged_publishedfileid.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagged_publishedfileid(&mut self, v: ::std::vec::Vec<u64>) {
        self.tagged_publishedfileid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagged_publishedfileid(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.tagged_publishedfileid
    }

    // Take field
    pub fn take_tagged_publishedfileid(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.tagged_publishedfileid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshot {
    fn is_initialized(&self) -> bool {
        for v in &self.tag {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.thumbname)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vr_filename)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_created = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.width = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.height = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.permissions = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.caption)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shortcut_name)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tag)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.tagged_steamid)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spoiler_tag = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.tagged_publishedfileid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.thumbname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.vr_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.rtime32_created {
            my_size += 5;
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permissions {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.shortcut_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.tag {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 9 * self.tagged_steamid.len() as u32;
        if let Some(v) = self.spoiler_tag {
            my_size += 2;
        }
        for value in &self.tagged_publishedfileid {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.thumbname.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.vr_filename.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.rtime32_created {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.permissions {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.caption.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.shortcut_name.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.tag {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tagged_steamid {
            os.write_fixed64(11, *v)?;
        };
        if let Some(v) = self.spoiler_tag {
            os.write_bool(12, v)?;
        }
        for v in &self.tagged_publishedfileid {
            os.write_uint64(13, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMAddScreenshot {
        CMsgClientUCMAddScreenshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientUCMAddScreenshot| { &m.appid },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientUCMAddScreenshot| { &m.filename },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "thumbname",
                |m: &CMsgClientUCMAddScreenshot| { &m.thumbname },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.thumbname },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vr_filename",
                |m: &CMsgClientUCMAddScreenshot| { &m.vr_filename },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.vr_filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_created",
                |m: &CMsgClientUCMAddScreenshot| { &m.rtime32_created },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.rtime32_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "width",
                |m: &CMsgClientUCMAddScreenshot| { &m.width },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "height",
                |m: &CMsgClientUCMAddScreenshot| { &m.height },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "permissions",
                |m: &CMsgClientUCMAddScreenshot| { &m.permissions },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "caption",
                |m: &CMsgClientUCMAddScreenshot| { &m.caption },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.caption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shortcut_name",
                |m: &CMsgClientUCMAddScreenshot| { &m.shortcut_name },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.shortcut_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMAddScreenshot_Tag>>(
                "tag",
                |m: &CMsgClientUCMAddScreenshot| { &m.tag },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "tagged_steamid",
                |m: &CMsgClientUCMAddScreenshot| { &m.tagged_steamid },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "spoiler_tag",
                |m: &CMsgClientUCMAddScreenshot| { &m.spoiler_tag },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.spoiler_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tagged_publishedfileid",
                |m: &CMsgClientUCMAddScreenshot| { &m.tagged_publishedfileid },
                |m: &mut CMsgClientUCMAddScreenshot| { &mut m.tagged_publishedfileid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMAddScreenshot>(
                "CMsgClientUCMAddScreenshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshot {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMAddScreenshot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMAddScreenshot::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMAddScreenshot {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.filename.clear();
        self.thumbname.clear();
        self.vr_filename.clear();
        self.rtime32_created = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.permissions = ::std::option::Option::None;
        self.caption.clear();
        self.shortcut_name.clear();
        self.tag.clear();
        self.tagged_steamid.clear();
        self.spoiler_tag = ::std::option::Option::None;
        self.tagged_publishedfileid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMAddScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMAddScreenshot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMAddScreenshot_Tag {
    // message fields
    tag_name: ::protobuf::SingularField<::std::string::String>,
    tag_value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshot_Tag {
    fn default() -> &'a CMsgClientUCMAddScreenshot_Tag {
        <CMsgClientUCMAddScreenshot_Tag as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshot_Tag {
    pub fn new() -> CMsgClientUCMAddScreenshot_Tag {
        ::std::default::Default::default()
    }

    // optional string tag_name = 1;


    pub fn get_tag_name(&self) -> &str {
        match self.tag_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tag_name(&mut self) {
        self.tag_name.clear();
    }

    pub fn has_tag_name(&self) -> bool {
        self.tag_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag_name(&mut self, v: ::std::string::String) {
        self.tag_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag_name(&mut self) -> &mut ::std::string::String {
        if self.tag_name.is_none() {
            self.tag_name.set_default();
        }
        self.tag_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag_name(&mut self) -> ::std::string::String {
        self.tag_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tag_value = 2;


    pub fn get_tag_value(&self) -> &str {
        match self.tag_value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tag_value(&mut self) {
        self.tag_value.clear();
    }

    pub fn has_tag_value(&self) -> bool {
        self.tag_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag_value(&mut self, v: ::std::string::String) {
        self.tag_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag_value(&mut self) -> &mut ::std::string::String {
        if self.tag_value.is_none() {
            self.tag_value.set_default();
        }
        self.tag_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag_value(&mut self) -> ::std::string::String {
        self.tag_value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshot_Tag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tag_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tag_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.tag_value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tag_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.tag_value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMAddScreenshot_Tag {
        CMsgClientUCMAddScreenshot_Tag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag_name",
                |m: &CMsgClientUCMAddScreenshot_Tag| { &m.tag_name },
                |m: &mut CMsgClientUCMAddScreenshot_Tag| { &mut m.tag_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag_value",
                |m: &CMsgClientUCMAddScreenshot_Tag| { &m.tag_value },
                |m: &mut CMsgClientUCMAddScreenshot_Tag| { &mut m.tag_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMAddScreenshot_Tag>(
                "CMsgClientUCMAddScreenshot.Tag",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshot_Tag {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMAddScreenshot_Tag> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMAddScreenshot_Tag::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMAddScreenshot_Tag {
    fn clear(&mut self) {
        self.tag_name.clear();
        self.tag_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMAddScreenshot_Tag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMAddScreenshot_Tag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMAddScreenshotResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    screenshotid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMAddScreenshotResponse {
    fn default() -> &'a CMsgClientUCMAddScreenshotResponse {
        <CMsgClientUCMAddScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMAddScreenshotResponse {
    pub fn new() -> CMsgClientUCMAddScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 screenshotid = 2;


    pub fn get_screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMAddScreenshotResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.screenshotid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.screenshotid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.screenshotid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMAddScreenshotResponse {
        CMsgClientUCMAddScreenshotResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMAddScreenshotResponse| { &m.eresult },
                |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "screenshotid",
                |m: &CMsgClientUCMAddScreenshotResponse| { &m.screenshotid },
                |m: &mut CMsgClientUCMAddScreenshotResponse| { &mut m.screenshotid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMAddScreenshotResponse>(
                "CMsgClientUCMAddScreenshotResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMAddScreenshotResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMAddScreenshotResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMAddScreenshotResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMAddScreenshotResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.screenshotid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMAddScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMAddScreenshotResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeleteScreenshot {
    // message fields
    screenshotid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshot {
    fn default() -> &'a CMsgClientUCMDeleteScreenshot {
        <CMsgClientUCMDeleteScreenshot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshot {
    pub fn new() -> CMsgClientUCMDeleteScreenshot {
        ::std::default::Default::default()
    }

    // optional fixed64 screenshotid = 1;


    pub fn get_screenshotid(&self) -> u64 {
        self.screenshotid.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_screenshotid(&mut self) {
        self.screenshotid = ::std::option::Option::None;
    }

    pub fn has_screenshotid(&self) -> bool {
        self.screenshotid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshotid(&mut self, v: u64) {
        self.screenshotid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshot {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.screenshotid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.screenshotid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.screenshotid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeleteScreenshot {
        CMsgClientUCMDeleteScreenshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "screenshotid",
                |m: &CMsgClientUCMDeleteScreenshot| { &m.screenshotid },
                |m: &mut CMsgClientUCMDeleteScreenshot| { &mut m.screenshotid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMDeleteScreenshot>(
                "CMsgClientUCMDeleteScreenshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshot {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMDeleteScreenshot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMDeleteScreenshot::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeleteScreenshot {
    fn clear(&mut self) {
        self.screenshotid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeleteScreenshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeleteScreenshotResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeleteScreenshotResponse {
    fn default() -> &'a CMsgClientUCMDeleteScreenshotResponse {
        <CMsgClientUCMDeleteScreenshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeleteScreenshotResponse {
    pub fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeleteScreenshotResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeleteScreenshotResponse {
        CMsgClientUCMDeleteScreenshotResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMDeleteScreenshotResponse| { &m.eresult },
                |m: &mut CMsgClientUCMDeleteScreenshotResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMDeleteScreenshotResponse>(
                "CMsgClientUCMDeleteScreenshotResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeleteScreenshotResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMDeleteScreenshotResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMDeleteScreenshotResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeleteScreenshotResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeleteScreenshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeleteScreenshotResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMPublishFile {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    preview_file_name: ::protobuf::SingularField<::std::string::String>,
    consumer_app_id: ::std::option::Option<u32>,
    title: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    workshop_file: ::std::option::Option<bool>,
    visibility: ::std::option::Option<i32>,
    file_type: ::std::option::Option<u32>,
    url: ::protobuf::SingularField<::std::string::String>,
    video_provider: ::std::option::Option<u32>,
    video_account_name: ::protobuf::SingularField<::std::string::String>,
    video_identifier: ::protobuf::SingularField<::std::string::String>,
    in_progress: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFile {
    fn default() -> &'a CMsgClientUCMPublishFile {
        <CMsgClientUCMPublishFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFile {
    pub fn new() -> CMsgClientUCMPublishFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 3;


    pub fn get_preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name.clear();
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name.set_default();
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 consumer_app_id = 4;


    pub fn get_consumer_app_id(&self) -> u32 {
        self.consumer_app_id.unwrap_or(0)
    }
    pub fn clear_consumer_app_id(&mut self) {
        self.consumer_app_id = ::std::option::Option::None;
    }

    pub fn has_consumer_app_id(&self) -> bool {
        self.consumer_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_app_id(&mut self, v: u32) {
        self.consumer_app_id = ::std::option::Option::Some(v);
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tags = 8;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // optional bool workshop_file = 9;


    pub fn get_workshop_file(&self) -> bool {
        self.workshop_file.unwrap_or(false)
    }
    pub fn clear_workshop_file(&mut self) {
        self.workshop_file = ::std::option::Option::None;
    }

    pub fn has_workshop_file(&self) -> bool {
        self.workshop_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file(&mut self, v: bool) {
        self.workshop_file = ::std::option::Option::Some(v);
    }

    // optional int32 visibility = 10;


    pub fn get_visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }
    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional uint32 file_type = 11;


    pub fn get_file_type(&self) -> u32 {
        self.file_type.unwrap_or(0)
    }
    pub fn clear_file_type(&mut self) {
        self.file_type = ::std::option::Option::None;
    }

    pub fn has_file_type(&self) -> bool {
        self.file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_type(&mut self, v: u32) {
        self.file_type = ::std::option::Option::Some(v);
    }

    // optional string url = 12;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 video_provider = 13;


    pub fn get_video_provider(&self) -> u32 {
        self.video_provider.unwrap_or(0)
    }
    pub fn clear_video_provider(&mut self) {
        self.video_provider = ::std::option::Option::None;
    }

    pub fn has_video_provider(&self) -> bool {
        self.video_provider.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_provider(&mut self, v: u32) {
        self.video_provider = ::std::option::Option::Some(v);
    }

    // optional string video_account_name = 14;


    pub fn get_video_account_name(&self) -> &str {
        match self.video_account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_video_account_name(&mut self) {
        self.video_account_name.clear();
    }

    pub fn has_video_account_name(&self) -> bool {
        self.video_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_account_name(&mut self, v: ::std::string::String) {
        self.video_account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_account_name(&mut self) -> &mut ::std::string::String {
        if self.video_account_name.is_none() {
            self.video_account_name.set_default();
        }
        self.video_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_account_name(&mut self) -> ::std::string::String {
        self.video_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string video_identifier = 15;


    pub fn get_video_identifier(&self) -> &str {
        match self.video_identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_video_identifier(&mut self) {
        self.video_identifier.clear();
    }

    pub fn has_video_identifier(&self) -> bool {
        self.video_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_identifier(&mut self, v: ::std::string::String) {
        self.video_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_identifier(&mut self) -> &mut ::std::string::String {
        if self.video_identifier.is_none() {
            self.video_identifier.set_default();
        }
        self.video_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_identifier(&mut self) -> ::std::string::String {
        self.video_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_progress = 16;


    pub fn get_in_progress(&self) -> bool {
        self.in_progress.unwrap_or(false)
    }
    pub fn clear_in_progress(&mut self) {
        self.in_progress = ::std::option::Option::None;
    }

    pub fn has_in_progress(&self) -> bool {
        self.in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_progress(&mut self, v: bool) {
        self.in_progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_file_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.consumer_app_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.workshop_file = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_type = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.video_provider = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.video_account_name)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.video_identifier)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_progress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.consumer_app_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.workshop_file {
            my_size += 2;
        }
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_type {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.video_provider {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.video_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.video_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.in_progress {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.preview_file_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.consumer_app_id {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.tags {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.workshop_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.file_type {
            os.write_uint32(11, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(v) = self.video_provider {
            os.write_uint32(13, v)?;
        }
        if let Some(ref v) = self.video_account_name.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.video_identifier.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.in_progress {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMPublishFile {
        CMsgClientUCMPublishFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMPublishFile| { &m.app_id },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUCMPublishFile| { &m.file_name },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preview_file_name",
                |m: &CMsgClientUCMPublishFile| { &m.preview_file_name },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.preview_file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "consumer_app_id",
                |m: &CMsgClientUCMPublishFile| { &m.consumer_app_id },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.consumer_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CMsgClientUCMPublishFile| { &m.title },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &CMsgClientUCMPublishFile| { &m.description },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &CMsgClientUCMPublishFile| { &m.tags },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "workshop_file",
                |m: &CMsgClientUCMPublishFile| { &m.workshop_file },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.workshop_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "visibility",
                |m: &CMsgClientUCMPublishFile| { &m.visibility },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_type",
                |m: &CMsgClientUCMPublishFile| { &m.file_type },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.file_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &CMsgClientUCMPublishFile| { &m.url },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "video_provider",
                |m: &CMsgClientUCMPublishFile| { &m.video_provider },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.video_provider },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "video_account_name",
                |m: &CMsgClientUCMPublishFile| { &m.video_account_name },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.video_account_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "video_identifier",
                |m: &CMsgClientUCMPublishFile| { &m.video_identifier },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.video_identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_progress",
                |m: &CMsgClientUCMPublishFile| { &m.in_progress },
                |m: &mut CMsgClientUCMPublishFile| { &mut m.in_progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMPublishFile>(
                "CMsgClientUCMPublishFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFile {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMPublishFile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMPublishFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMPublishFile {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.file_name.clear();
        self.preview_file_name.clear();
        self.consumer_app_id = ::std::option::Option::None;
        self.title.clear();
        self.description.clear();
        self.tags.clear();
        self.workshop_file = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.file_type = ::std::option::Option::None;
        self.url.clear();
        self.video_provider = ::std::option::Option::None;
        self.video_account_name.clear();
        self.video_identifier.clear();
        self.in_progress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMPublishFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishFile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMPublishFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    published_file_id: ::std::option::Option<u64>,
    needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishFileResponse {
    fn default() -> &'a CMsgClientUCMPublishFileResponse {
        <CMsgClientUCMPublishFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishFileResponse {
    pub fn new() -> CMsgClientUCMPublishFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 3;


    pub fn get_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }
    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMPublishFileResponse {
        CMsgClientUCMPublishFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMPublishFileResponse| { &m.eresult },
                |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMPublishFileResponse| { &m.published_file_id },
                |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needs_workshop_legal_agreement_acceptance",
                |m: &CMsgClientUCMPublishFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
                |m: &mut CMsgClientUCMPublishFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMPublishFileResponse>(
                "CMsgClientUCMPublishFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMPublishFileResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMPublishFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMPublishFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMPublishFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMPublishFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMUpdatePublishedFile {
    // message fields
    app_id: ::std::option::Option<u32>,
    published_file_id: ::std::option::Option<u64>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    preview_file_name: ::protobuf::SingularField<::std::string::String>,
    title: ::protobuf::SingularField<::std::string::String>,
    description: ::protobuf::SingularField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    visibility: ::std::option::Option<i32>,
    update_file: ::std::option::Option<bool>,
    update_preview_file: ::std::option::Option<bool>,
    update_title: ::std::option::Option<bool>,
    update_description: ::std::option::Option<bool>,
    update_tags: ::std::option::Option<bool>,
    update_visibility: ::std::option::Option<bool>,
    change_description: ::protobuf::SingularField<::std::string::String>,
    update_url: ::std::option::Option<bool>,
    url: ::protobuf::SingularField<::std::string::String>,
    update_content_manifest: ::std::option::Option<bool>,
    content_manifest: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::string::String>,
    update_metadata: ::std::option::Option<bool>,
    language: ::std::option::Option<i32>,
    pub removed_kvtags: ::protobuf::RepeatedField<::std::string::String>,
    pub kvtags: ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_KeyValueTag>,
    pub previews: ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_AdditionalPreview>,
    pub previews_to_remove: ::std::vec::Vec<i32>,
    clear_in_progress: ::std::option::Option<bool>,
    remove_all_kvtags: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFile {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFile {
        <CMsgClientUCMUpdatePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFile {
    pub fn new() -> CMsgClientUCMUpdatePublishedFile {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 published_file_id = 2;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 3;


    pub fn get_file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preview_file_name = 4;


    pub fn get_preview_file_name(&self) -> &str {
        match self.preview_file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_preview_file_name(&mut self) {
        self.preview_file_name.clear();
    }

    pub fn has_preview_file_name(&self) -> bool {
        self.preview_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_file_name(&mut self, v: ::std::string::String) {
        self.preview_file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preview_file_name(&mut self) -> &mut ::std::string::String {
        if self.preview_file_name.is_none() {
            self.preview_file_name.set_default();
        }
        self.preview_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preview_file_name(&mut self) -> ::std::string::String {
        self.preview_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 5;


    pub fn get_title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 6;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tags = 7;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // optional int32 visibility = 8;


    pub fn get_visibility(&self) -> i32 {
        self.visibility.unwrap_or(0)
    }
    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: i32) {
        self.visibility = ::std::option::Option::Some(v);
    }

    // optional bool update_file = 9;


    pub fn get_update_file(&self) -> bool {
        self.update_file.unwrap_or(false)
    }
    pub fn clear_update_file(&mut self) {
        self.update_file = ::std::option::Option::None;
    }

    pub fn has_update_file(&self) -> bool {
        self.update_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_file(&mut self, v: bool) {
        self.update_file = ::std::option::Option::Some(v);
    }

    // optional bool update_preview_file = 10;


    pub fn get_update_preview_file(&self) -> bool {
        self.update_preview_file.unwrap_or(false)
    }
    pub fn clear_update_preview_file(&mut self) {
        self.update_preview_file = ::std::option::Option::None;
    }

    pub fn has_update_preview_file(&self) -> bool {
        self.update_preview_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_preview_file(&mut self, v: bool) {
        self.update_preview_file = ::std::option::Option::Some(v);
    }

    // optional bool update_title = 11;


    pub fn get_update_title(&self) -> bool {
        self.update_title.unwrap_or(false)
    }
    pub fn clear_update_title(&mut self) {
        self.update_title = ::std::option::Option::None;
    }

    pub fn has_update_title(&self) -> bool {
        self.update_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_title(&mut self, v: bool) {
        self.update_title = ::std::option::Option::Some(v);
    }

    // optional bool update_description = 12;


    pub fn get_update_description(&self) -> bool {
        self.update_description.unwrap_or(false)
    }
    pub fn clear_update_description(&mut self) {
        self.update_description = ::std::option::Option::None;
    }

    pub fn has_update_description(&self) -> bool {
        self.update_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_description(&mut self, v: bool) {
        self.update_description = ::std::option::Option::Some(v);
    }

    // optional bool update_tags = 13;


    pub fn get_update_tags(&self) -> bool {
        self.update_tags.unwrap_or(false)
    }
    pub fn clear_update_tags(&mut self) {
        self.update_tags = ::std::option::Option::None;
    }

    pub fn has_update_tags(&self) -> bool {
        self.update_tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_tags(&mut self, v: bool) {
        self.update_tags = ::std::option::Option::Some(v);
    }

    // optional bool update_visibility = 14;


    pub fn get_update_visibility(&self) -> bool {
        self.update_visibility.unwrap_or(false)
    }
    pub fn clear_update_visibility(&mut self) {
        self.update_visibility = ::std::option::Option::None;
    }

    pub fn has_update_visibility(&self) -> bool {
        self.update_visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_visibility(&mut self, v: bool) {
        self.update_visibility = ::std::option::Option::Some(v);
    }

    // optional string change_description = 15;


    pub fn get_change_description(&self) -> &str {
        match self.change_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_change_description(&mut self) {
        self.change_description.clear();
    }

    pub fn has_change_description(&self) -> bool {
        self.change_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_description(&mut self, v: ::std::string::String) {
        self.change_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_description(&mut self) -> &mut ::std::string::String {
        if self.change_description.is_none() {
            self.change_description.set_default();
        }
        self.change_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_description(&mut self) -> ::std::string::String {
        self.change_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_url = 16;


    pub fn get_update_url(&self) -> bool {
        self.update_url.unwrap_or(false)
    }
    pub fn clear_update_url(&mut self) {
        self.update_url = ::std::option::Option::None;
    }

    pub fn has_update_url(&self) -> bool {
        self.update_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_url(&mut self, v: bool) {
        self.update_url = ::std::option::Option::Some(v);
    }

    // optional string url = 17;


    pub fn get_url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_content_manifest = 18;


    pub fn get_update_content_manifest(&self) -> bool {
        self.update_content_manifest.unwrap_or(false)
    }
    pub fn clear_update_content_manifest(&mut self) {
        self.update_content_manifest = ::std::option::Option::None;
    }

    pub fn has_update_content_manifest(&self) -> bool {
        self.update_content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_content_manifest(&mut self, v: bool) {
        self.update_content_manifest = ::std::option::Option::Some(v);
    }

    // optional fixed64 content_manifest = 19;


    pub fn get_content_manifest(&self) -> u64 {
        self.content_manifest.unwrap_or(0)
    }
    pub fn clear_content_manifest(&mut self) {
        self.content_manifest = ::std::option::Option::None;
    }

    pub fn has_content_manifest(&self) -> bool {
        self.content_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_manifest(&mut self, v: u64) {
        self.content_manifest = ::std::option::Option::Some(v);
    }

    // optional string metadata = 20;


    pub fn get_metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool update_metadata = 21;


    pub fn get_update_metadata(&self) -> bool {
        self.update_metadata.unwrap_or(false)
    }
    pub fn clear_update_metadata(&mut self) {
        self.update_metadata = ::std::option::Option::None;
    }

    pub fn has_update_metadata(&self) -> bool {
        self.update_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_metadata(&mut self, v: bool) {
        self.update_metadata = ::std::option::Option::Some(v);
    }

    // optional int32 language = 22;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0i32)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // repeated string removed_kvtags = 23;


    pub fn get_removed_kvtags(&self) -> &[::std::string::String] {
        &self.removed_kvtags
    }
    pub fn clear_removed_kvtags(&mut self) {
        self.removed_kvtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_removed_kvtags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.removed_kvtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_removed_kvtags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.removed_kvtags
    }

    // Take field
    pub fn take_removed_kvtags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.removed_kvtags, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientUCMUpdatePublishedFile.KeyValueTag kvtags = 24;


    pub fn get_kvtags(&self) -> &[CMsgClientUCMUpdatePublishedFile_KeyValueTag] {
        &self.kvtags
    }
    pub fn clear_kvtags(&mut self) {
        self.kvtags.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvtags(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_KeyValueTag>) {
        self.kvtags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvtags(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_KeyValueTag> {
        &mut self.kvtags
    }

    // Take field
    pub fn take_kvtags(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_KeyValueTag> {
        ::std::mem::replace(&mut self.kvtags, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientUCMUpdatePublishedFile.AdditionalPreview previews = 25;


    pub fn get_previews(&self) -> &[CMsgClientUCMUpdatePublishedFile_AdditionalPreview] {
        &self.previews
    }
    pub fn clear_previews(&mut self) {
        self.previews.clear();
    }

    // Param is passed by value, moved
    pub fn set_previews(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_AdditionalPreview>) {
        self.previews = v;
    }

    // Mutable pointer to the field.
    pub fn mut_previews(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_AdditionalPreview> {
        &mut self.previews
    }

    // Take field
    pub fn take_previews(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMUpdatePublishedFile_AdditionalPreview> {
        ::std::mem::replace(&mut self.previews, ::protobuf::RepeatedField::new())
    }

    // repeated int32 previews_to_remove = 26;


    pub fn get_previews_to_remove(&self) -> &[i32] {
        &self.previews_to_remove
    }
    pub fn clear_previews_to_remove(&mut self) {
        self.previews_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_previews_to_remove(&mut self, v: ::std::vec::Vec<i32>) {
        self.previews_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_previews_to_remove(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.previews_to_remove
    }

    // Take field
    pub fn take_previews_to_remove(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.previews_to_remove, ::std::vec::Vec::new())
    }

    // optional bool clear_in_progress = 27;


    pub fn get_clear_in_progress(&self) -> bool {
        self.clear_in_progress.unwrap_or(false)
    }
    pub fn clear_clear_in_progress(&mut self) {
        self.clear_in_progress = ::std::option::Option::None;
    }

    pub fn has_clear_in_progress(&self) -> bool {
        self.clear_in_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear_in_progress(&mut self, v: bool) {
        self.clear_in_progress = ::std::option::Option::Some(v);
    }

    // optional bool remove_all_kvtags = 28;


    pub fn get_remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.unwrap_or(false)
    }
    pub fn clear_remove_all_kvtags(&mut self) {
        self.remove_all_kvtags = ::std::option::Option::None;
    }

    pub fn has_remove_all_kvtags(&self) -> bool {
        self.remove_all_kvtags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_all_kvtags(&mut self, v: bool) {
        self.remove_all_kvtags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFile {
    fn is_initialized(&self) -> bool {
        for v in &self.kvtags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.previews {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preview_file_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_file = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_preview_file = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_title = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_description = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_tags = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_visibility = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.change_description)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_url = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_content_manifest = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.content_manifest = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.metadata)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_metadata = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.removed_kvtags)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kvtags)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.previews)?;
                },
                26 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.previews_to_remove)?;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clear_in_progress = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remove_all_kvtags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.preview_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.visibility {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_file {
            my_size += 2;
        }
        if let Some(v) = self.update_preview_file {
            my_size += 2;
        }
        if let Some(v) = self.update_title {
            my_size += 2;
        }
        if let Some(v) = self.update_description {
            my_size += 2;
        }
        if let Some(v) = self.update_tags {
            my_size += 2;
        }
        if let Some(v) = self.update_visibility {
            my_size += 2;
        }
        if let Some(ref v) = self.change_description.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.update_url {
            my_size += 3;
        }
        if let Some(ref v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.update_content_manifest {
            my_size += 3;
        }
        if let Some(v) = self.content_manifest {
            my_size += 10;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.update_metadata {
            my_size += 3;
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.removed_kvtags {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.kvtags {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.previews {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.previews_to_remove {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.clear_in_progress {
            my_size += 3;
        }
        if let Some(v) = self.remove_all_kvtags {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.published_file_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.preview_file_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.tags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.visibility {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.update_file {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.update_preview_file {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.update_title {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.update_description {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.update_tags {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.update_visibility {
            os.write_bool(14, v)?;
        }
        if let Some(ref v) = self.change_description.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.update_url {
            os.write_bool(16, v)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(v) = self.update_content_manifest {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_manifest {
            os.write_fixed64(19, v)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(v) = self.update_metadata {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(22, v)?;
        }
        for v in &self.removed_kvtags {
            os.write_string(23, &v)?;
        };
        for v in &self.kvtags {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.previews {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.previews_to_remove {
            os.write_int32(26, *v)?;
        };
        if let Some(v) = self.clear_in_progress {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.remove_all_kvtags {
            os.write_bool(28, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMUpdatePublishedFile {
        CMsgClientUCMUpdatePublishedFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.app_id },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.published_file_id },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file_name",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.file_name },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preview_file_name",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.preview_file_name },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.preview_file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.title },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.description },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.tags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "visibility",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.visibility },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_file",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_file },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_preview_file",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_preview_file },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_preview_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_title",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_title },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_title },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_description",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_description },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_tags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_tags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_visibility",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_visibility },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_visibility },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "change_description",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.change_description },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.change_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_url",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_url },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.url },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_content_manifest",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_content_manifest },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_content_manifest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "content_manifest",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.content_manifest },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.content_manifest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.metadata },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_metadata",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.update_metadata },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.update_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "language",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.language },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "removed_kvtags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.removed_kvtags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.removed_kvtags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMUpdatePublishedFile_KeyValueTag>>(
                "kvtags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.kvtags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.kvtags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMUpdatePublishedFile_AdditionalPreview>>(
                "previews",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "previews_to_remove",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.previews_to_remove },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.previews_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clear_in_progress",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.clear_in_progress },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.clear_in_progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remove_all_kvtags",
                |m: &CMsgClientUCMUpdatePublishedFile| { &m.remove_all_kvtags },
                |m: &mut CMsgClientUCMUpdatePublishedFile| { &mut m.remove_all_kvtags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMUpdatePublishedFile>(
                "CMsgClientUCMUpdatePublishedFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFile {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMUpdatePublishedFile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMUpdatePublishedFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMUpdatePublishedFile {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.published_file_id = ::std::option::Option::None;
        self.file_name.clear();
        self.preview_file_name.clear();
        self.title.clear();
        self.description.clear();
        self.tags.clear();
        self.visibility = ::std::option::Option::None;
        self.update_file = ::std::option::Option::None;
        self.update_preview_file = ::std::option::Option::None;
        self.update_title = ::std::option::Option::None;
        self.update_description = ::std::option::Option::None;
        self.update_tags = ::std::option::Option::None;
        self.update_visibility = ::std::option::Option::None;
        self.change_description.clear();
        self.update_url = ::std::option::Option::None;
        self.url.clear();
        self.update_content_manifest = ::std::option::Option::None;
        self.content_manifest = ::std::option::Option::None;
        self.metadata.clear();
        self.update_metadata = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.removed_kvtags.clear();
        self.kvtags.clear();
        self.previews.clear();
        self.previews_to_remove.clear();
        self.clear_in_progress = ::std::option::Option::None;
        self.remove_all_kvtags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMUpdatePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFile_KeyValueTag {
        <CMsgClientUCMUpdatePublishedFile_KeyValueTag as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    pub fn new() -> CMsgClientUCMUpdatePublishedFile_KeyValueTag {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMUpdatePublishedFile_KeyValueTag {
        CMsgClientUCMUpdatePublishedFile_KeyValueTag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &CMsgClientUCMUpdatePublishedFile_KeyValueTag| { &m.key },
                |m: &mut CMsgClientUCMUpdatePublishedFile_KeyValueTag| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CMsgClientUCMUpdatePublishedFile_KeyValueTag| { &m.value },
                |m: &mut CMsgClientUCMUpdatePublishedFile_KeyValueTag| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMUpdatePublishedFile_KeyValueTag>(
                "CMsgClientUCMUpdatePublishedFile.KeyValueTag",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFile_KeyValueTag {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMUpdatePublishedFile_KeyValueTag> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMUpdatePublishedFile_KeyValueTag::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFile_KeyValueTag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    // message fields
    original_file_name: ::protobuf::SingularField<::std::string::String>,
    internal_file_name: ::protobuf::SingularField<::std::string::String>,
    videoid: ::protobuf::SingularField<::std::string::String>,
    preview_type: ::std::option::Option<u32>,
    update_index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
        <CMsgClientUCMUpdatePublishedFile_AdditionalPreview as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    pub fn new() -> CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
        ::std::default::Default::default()
    }

    // optional string original_file_name = 1;


    pub fn get_original_file_name(&self) -> &str {
        match self.original_file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_original_file_name(&mut self) {
        self.original_file_name.clear();
    }

    pub fn has_original_file_name(&self) -> bool {
        self.original_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_file_name(&mut self, v: ::std::string::String) {
        self.original_file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_file_name(&mut self) -> &mut ::std::string::String {
        if self.original_file_name.is_none() {
            self.original_file_name.set_default();
        }
        self.original_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_file_name(&mut self) -> ::std::string::String {
        self.original_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string internal_file_name = 2;


    pub fn get_internal_file_name(&self) -> &str {
        match self.internal_file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_internal_file_name(&mut self) {
        self.internal_file_name.clear();
    }

    pub fn has_internal_file_name(&self) -> bool {
        self.internal_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_file_name(&mut self, v: ::std::string::String) {
        self.internal_file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internal_file_name(&mut self) -> &mut ::std::string::String {
        if self.internal_file_name.is_none() {
            self.internal_file_name.set_default();
        }
        self.internal_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_internal_file_name(&mut self) -> ::std::string::String {
        self.internal_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string videoid = 3;


    pub fn get_videoid(&self) -> &str {
        match self.videoid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_videoid(&mut self) {
        self.videoid.clear();
    }

    pub fn has_videoid(&self) -> bool {
        self.videoid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_videoid(&mut self, v: ::std::string::String) {
        self.videoid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_videoid(&mut self) -> &mut ::std::string::String {
        if self.videoid.is_none() {
            self.videoid.set_default();
        }
        self.videoid.as_mut().unwrap()
    }

    // Take field
    pub fn take_videoid(&mut self) -> ::std::string::String {
        self.videoid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 preview_type = 4;


    pub fn get_preview_type(&self) -> u32 {
        self.preview_type.unwrap_or(0)
    }
    pub fn clear_preview_type(&mut self) {
        self.preview_type = ::std::option::Option::None;
    }

    pub fn has_preview_type(&self) -> bool {
        self.preview_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_type(&mut self, v: u32) {
        self.preview_type = ::std::option::Option::Some(v);
    }

    // optional int32 update_index = 5;


    pub fn get_update_index(&self) -> i32 {
        self.update_index.unwrap_or(-1i32)
    }
    pub fn clear_update_index(&mut self) {
        self.update_index = ::std::option::Option::None;
    }

    pub fn has_update_index(&self) -> bool {
        self.update_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_index(&mut self, v: i32) {
        self.update_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_file_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.internal_file_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.videoid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.preview_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.update_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.internal_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.videoid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preview_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original_file_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.internal_file_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.videoid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.preview_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.update_index {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
        CMsgClientUCMUpdatePublishedFile_AdditionalPreview::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "original_file_name",
                |m: &CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &m.original_file_name },
                |m: &mut CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &mut m.original_file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "internal_file_name",
                |m: &CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &m.internal_file_name },
                |m: &mut CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &mut m.internal_file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "videoid",
                |m: &CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &m.videoid },
                |m: &mut CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &mut m.videoid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "preview_type",
                |m: &CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &m.preview_type },
                |m: &mut CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &mut m.preview_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "update_index",
                |m: &CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &m.update_index },
                |m: &mut CMsgClientUCMUpdatePublishedFile_AdditionalPreview| { &mut m.update_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMUpdatePublishedFile_AdditionalPreview>(
                "CMsgClientUCMUpdatePublishedFile.AdditionalPreview",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMUpdatePublishedFile_AdditionalPreview> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMUpdatePublishedFile_AdditionalPreview::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    fn clear(&mut self) {
        self.original_file_name.clear();
        self.internal_file_name.clear();
        self.videoid.clear();
        self.preview_type = ::std::option::Option::None;
        self.update_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMUpdatePublishedFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    needs_workshop_legal_agreement_acceptance: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMUpdatePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMUpdatePublishedFileResponse {
        <CMsgClientUCMUpdatePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMUpdatePublishedFileResponse {
    pub fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool needs_workshop_legal_agreement_acceptance = 2;


    pub fn get_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.unwrap_or(false)
    }
    pub fn clear_needs_workshop_legal_agreement_acceptance(&mut self) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
    }

    pub fn has_needs_workshop_legal_agreement_acceptance(&self) -> bool {
        self.needs_workshop_legal_agreement_acceptance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_workshop_legal_agreement_acceptance(&mut self, v: bool) {
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMUpdatePublishedFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.needs_workshop_legal_agreement_acceptance {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMUpdatePublishedFileResponse {
        CMsgClientUCMUpdatePublishedFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.eresult },
                |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needs_workshop_legal_agreement_acceptance",
                |m: &CMsgClientUCMUpdatePublishedFileResponse| { &m.needs_workshop_legal_agreement_acceptance },
                |m: &mut CMsgClientUCMUpdatePublishedFileResponse| { &mut m.needs_workshop_legal_agreement_acceptance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMUpdatePublishedFileResponse>(
                "CMsgClientUCMUpdatePublishedFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMUpdatePublishedFileResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMUpdatePublishedFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMUpdatePublishedFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMUpdatePublishedFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.needs_workshop_legal_agreement_acceptance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMUpdatePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMUpdatePublishedFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeletePublishedFile {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFile {
    fn default() -> &'a CMsgClientUCMDeletePublishedFile {
        <CMsgClientUCMDeletePublishedFile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFile {
    pub fn new() -> CMsgClientUCMDeletePublishedFile {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeletePublishedFile {
        CMsgClientUCMDeletePublishedFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMDeletePublishedFile| { &m.published_file_id },
                |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMDeletePublishedFile| { &m.app_id },
                |m: &mut CMsgClientUCMDeletePublishedFile| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMDeletePublishedFile>(
                "CMsgClientUCMDeletePublishedFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFile {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMDeletePublishedFile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMDeletePublishedFile::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeletePublishedFile {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeletePublishedFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMDeletePublishedFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMDeletePublishedFileResponse {
    fn default() -> &'a CMsgClientUCMDeletePublishedFileResponse {
        <CMsgClientUCMDeletePublishedFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMDeletePublishedFileResponse {
    pub fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMDeletePublishedFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMDeletePublishedFileResponse {
        CMsgClientUCMDeletePublishedFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMDeletePublishedFileResponse| { &m.eresult },
                |m: &mut CMsgClientUCMDeletePublishedFileResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMDeletePublishedFileResponse>(
                "CMsgClientUCMDeletePublishedFileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMDeletePublishedFileResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMDeletePublishedFileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMDeletePublishedFileResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMDeletePublishedFileResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMDeletePublishedFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMDeletePublishedFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserPublishedFiles {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    sort_order: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserPublishedFiles {
    fn default() -> &'a CMsgClientUCMEnumerateUserPublishedFiles {
        <CMsgClientUCMEnumerateUserPublishedFiles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserPublishedFiles {
    pub fn new() -> CMsgClientUCMEnumerateUserPublishedFiles {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;


    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 3;


    pub fn get_sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }
    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserPublishedFiles {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sort_order = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sort_order {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserPublishedFiles {
        CMsgClientUCMEnumerateUserPublishedFiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.app_id },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_index",
                |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.start_index },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.start_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sort_order",
                |m: &CMsgClientUCMEnumerateUserPublishedFiles| { &m.sort_order },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFiles| { &mut m.sort_order },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserPublishedFiles>(
                "CMsgClientUCMEnumerateUserPublishedFiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserPublishedFiles {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserPublishedFiles> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserPublishedFiles::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserPublishedFiles {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserPublishedFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserPublishedFiles {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserPublishedFilesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub published_files: ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserPublishedFilesResponse {
        <CMsgClientUCMEnumerateUserPublishedFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserPublishedFilesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId published_files = 2;


    pub fn get_published_files(&self) -> &[CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId] {
        &self.published_files
    }
    pub fn clear_published_files(&mut self) {
        self.published_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId>) {
        self.published_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId> {
        &mut self.published_files
    }

    // Take field
    pub fn take_published_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId> {
        ::std::mem::replace(&mut self.published_files, ::protobuf::RepeatedField::new())
    }

    // optional uint32 total_results = 3;


    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }
    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.published_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.published_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_results = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse {
        CMsgClientUCMEnumerateUserPublishedFilesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId>>(
                "published_files",
                |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.published_files },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.published_files },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_results",
                |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse| { &mut m.total_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserPublishedFilesResponse>(
                "CMsgClientUCMEnumerateUserPublishedFilesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserPublishedFilesResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserPublishedFilesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserPublishedFilesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserPublishedFilesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    fn default() -> &'a CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
        <CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    pub fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
        CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId| { &m.published_file_id },
                |m: &mut CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId>(
                "CMsgClientUCMEnumerateUserPublishedFilesResponse.PublishedFileId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFiles {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    list_type: ::std::option::Option<u32>,
    matching_file_type: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFiles {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFiles {
        <CMsgClientUCMEnumerateUserSubscribedFiles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFiles {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFiles {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;


    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional uint32 list_type = 3;


    pub fn get_list_type(&self) -> u32 {
        self.list_type.unwrap_or(1u32)
    }
    pub fn clear_list_type(&mut self) {
        self.list_type = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        self.list_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: u32) {
        self.list_type = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_file_type = 4;


    pub fn get_matching_file_type(&self) -> u32 {
        self.matching_file_type.unwrap_or(0u32)
    }
    pub fn clear_matching_file_type(&mut self) {
        self.matching_file_type = ::std::option::Option::None;
    }

    pub fn has_matching_file_type(&self) -> bool {
        self.matching_file_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_file_type(&mut self, v: u32) {
        self.matching_file_type = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 5;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(50u32)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.list_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_file_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.list_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_file_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.list_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.matching_file_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFiles {
        CMsgClientUCMEnumerateUserSubscribedFiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.app_id },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_index",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.start_index },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.start_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "list_type",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.list_type },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.list_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matching_file_type",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.matching_file_type },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.matching_file_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CMsgClientUCMEnumerateUserSubscribedFiles| { &m.count },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFiles| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserSubscribedFiles>(
                "CMsgClientUCMEnumerateUserSubscribedFiles",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFiles {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserSubscribedFiles> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFiles::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.list_type = ::std::option::Option::None;
        self.matching_file_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFiles {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub subscribed_files: ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId subscribed_files = 2;


    pub fn get_subscribed_files(&self) -> &[CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId] {
        &self.subscribed_files
    }
    pub fn clear_subscribed_files(&mut self) {
        self.subscribed_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscribed_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId>) {
        self.subscribed_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscribed_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId> {
        &mut self.subscribed_files
    }

    // Take field
    pub fn take_subscribed_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId> {
        ::std::mem::replace(&mut self.subscribed_files, ::protobuf::RepeatedField::new())
    }

    // optional uint32 total_results = 3;


    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }
    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.subscribed_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscribed_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_results = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId>>(
                "subscribed_files",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.subscribed_files },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.subscribed_files },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_results",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse| { &mut m.total_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserSubscribedFilesResponse>(
                "CMsgClientUCMEnumerateUserSubscribedFilesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserSubscribedFilesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    rtime32_subscribed: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
        <CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime32_subscribed = 2;


    pub fn get_rtime32_subscribed(&self) -> u32 {
        self.rtime32_subscribed.unwrap_or(0u32)
    }
    pub fn clear_rtime32_subscribed(&mut self) {
        self.rtime32_subscribed = ::std::option::Option::None;
    }

    pub fn has_rtime32_subscribed(&self) -> bool {
        self.rtime32_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_subscribed(&mut self, v: u32) {
        self.rtime32_subscribed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_subscribed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.rtime32_subscribed {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.rtime32_subscribed {
            os.write_fixed32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
        CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId| { &m.published_file_id },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_subscribed",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId| { &m.rtime32_subscribed },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId| { &mut m.rtime32_subscribed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId>(
                "CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.rtime32_subscribed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    start_time: ::std::option::Option<u32>,
    desired_revision: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;


    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional fixed32 start_time = 3;


    pub fn get_start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_revision = 4;


    pub fn get_desired_revision(&self) -> u32 {
        self.desired_revision.unwrap_or(0u32)
    }
    pub fn clear_desired_revision(&mut self) {
        self.desired_revision = ::std::option::Option::None;
    }

    pub fn has_desired_revision(&self) -> bool {
        self.desired_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_revision(&mut self, v: u32) {
        self.desired_revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.desired_revision = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_time {
            my_size += 5;
        }
        if let Some(v) = self.desired_revision {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.desired_revision {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.app_id },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_index",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_index },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "start_time",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.start_time },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "desired_revision",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &m.desired_revision },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates| { &mut m.desired_revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates>(
                "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.desired_revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub subscribed_files: ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId subscribed_files = 2;


    pub fn get_subscribed_files(&self) -> &[CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId] {
        &self.subscribed_files
    }
    pub fn clear_subscribed_files(&mut self) {
        self.subscribed_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscribed_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId>) {
        self.subscribed_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscribed_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId> {
        &mut self.subscribed_files
    }

    // Take field
    pub fn take_subscribed_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId> {
        ::std::mem::replace(&mut self.subscribed_files, ::protobuf::RepeatedField::new())
    }

    // optional uint32 total_results = 3;


    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }
    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.subscribed_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subscribed_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_results = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subscribed_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.subscribed_files {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId>>(
                "subscribed_files",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.subscribed_files },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.subscribed_files },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_results",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse| { &mut m.total_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse>(
                "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.subscribed_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    rtime32_subscribed: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    file_hcontent: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    rtime32_last_updated: ::std::option::Option<u32>,
    is_depot_content: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    fn default() -> &'a CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
        <CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    pub fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime32_subscribed = 2;


    pub fn get_rtime32_subscribed(&self) -> u32 {
        self.rtime32_subscribed.unwrap_or(0u32)
    }
    pub fn clear_rtime32_subscribed(&mut self) {
        self.rtime32_subscribed = ::std::option::Option::None;
    }

    pub fn has_rtime32_subscribed(&self) -> bool {
        self.rtime32_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_subscribed(&mut self, v: u32) {
        self.rtime32_subscribed = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 3;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 file_hcontent = 4;


    pub fn get_file_hcontent(&self) -> u64 {
        self.file_hcontent.unwrap_or(0)
    }
    pub fn clear_file_hcontent(&mut self) {
        self.file_hcontent = ::std::option::Option::None;
    }

    pub fn has_file_hcontent(&self) -> bool {
        self.file_hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_hcontent(&mut self, v: u64) {
        self.file_hcontent = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 5;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime32_last_updated = 6;


    pub fn get_rtime32_last_updated(&self) -> u32 {
        self.rtime32_last_updated.unwrap_or(0)
    }
    pub fn clear_rtime32_last_updated(&mut self) {
        self.rtime32_last_updated = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_updated(&self) -> bool {
        self.rtime32_last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_updated(&mut self, v: u32) {
        self.rtime32_last_updated = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 7;


    pub fn get_is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }
    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_subscribed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.file_hcontent = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_last_updated = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_depot_content = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.rtime32_subscribed {
            my_size += 5;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.file_hcontent {
            my_size += 9;
        }
        if let Some(v) = self.file_size {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime32_last_updated {
            my_size += 5;
        }
        if let Some(v) = self.is_depot_content {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.rtime32_subscribed {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.file_hcontent {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rtime32_last_updated {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
        CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &m.published_file_id },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_subscribed",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &m.rtime32_subscribed },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &mut m.rtime32_subscribed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &m.appid },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "file_hcontent",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &m.file_hcontent },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &mut m.file_hcontent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "file_size",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &m.file_size },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &mut m.file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_last_updated",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &m.rtime32_last_updated },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &mut m.rtime32_last_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_depot_content",
                |m: &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &m.is_depot_content },
                |m: &mut CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId| { &mut m.is_depot_content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId>(
                "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.rtime32_subscribed = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.file_hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.rtime32_last_updated = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMPublishedFileUpdated {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    time_updated: ::std::option::Option<u32>,
    hcontent: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    is_depot_content: ::std::option::Option<bool>,
    revision: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMPublishedFileUpdated {
    fn default() -> &'a CMsgClientUCMPublishedFileUpdated {
        <CMsgClientUCMPublishedFileUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMPublishedFileUpdated {
    pub fn new() -> CMsgClientUCMPublishedFileUpdated {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 3;


    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }
    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 hcontent = 4;


    pub fn get_hcontent(&self) -> u64 {
        self.hcontent.unwrap_or(0)
    }
    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    // optional fixed32 file_size = 5;


    pub fn get_file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional bool is_depot_content = 6;


    pub fn get_is_depot_content(&self) -> bool {
        self.is_depot_content.unwrap_or(false)
    }
    pub fn clear_is_depot_content(&mut self) {
        self.is_depot_content = ::std::option::Option::None;
    }

    pub fn has_is_depot_content(&self) -> bool {
        self.is_depot_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_depot_content(&mut self, v: bool) {
        self.is_depot_content = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 7;


    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }
    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMPublishedFileUpdated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_updated = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.hcontent = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_depot_content = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.revision = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hcontent {
            my_size += 9;
        }
        if let Some(v) = self.file_size {
            my_size += 5;
        }
        if let Some(v) = self.is_depot_content {
            my_size += 2;
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hcontent {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.is_depot_content {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMPublishedFileUpdated {
        CMsgClientUCMPublishedFileUpdated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.published_file_id },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.app_id },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_updated",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.time_updated },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.time_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "hcontent",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.hcontent },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.hcontent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "file_size",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.file_size },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.file_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_depot_content",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.is_depot_content },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.is_depot_content },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "revision",
                |m: &CMsgClientUCMPublishedFileUpdated| { &m.revision },
                |m: &mut CMsgClientUCMPublishedFileUpdated| { &mut m.revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMPublishedFileUpdated>(
                "CMsgClientUCMPublishedFileUpdated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMPublishedFileUpdated {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMPublishedFileUpdated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMPublishedFileUpdated::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMPublishedFileUpdated {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.hcontent = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.is_depot_content = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMPublishedFileUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMPublishedFileUpdated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemChangesRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    last_time_updated: ::std::option::Option<u32>,
    num_items_needed: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesRequest {
    fn default() -> &'a CMsgClientWorkshopItemChangesRequest {
        <CMsgClientWorkshopItemChangesRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesRequest {
    pub fn new() -> CMsgClientWorkshopItemChangesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;


    pub fn get_last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }
    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    // optional uint32 num_items_needed = 3;


    pub fn get_num_items_needed(&self) -> u32 {
        self.num_items_needed.unwrap_or(0)
    }
    pub fn clear_num_items_needed(&mut self) {
        self.num_items_needed = ::std::option::Option::None;
    }

    pub fn has_num_items_needed(&self) -> bool {
        self.num_items_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_items_needed(&mut self, v: u32) {
        self.num_items_needed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time_updated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_items_needed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_items_needed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_items_needed {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemChangesRequest {
        CMsgClientWorkshopItemChangesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientWorkshopItemChangesRequest| { &m.app_id },
                |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_time_updated",
                |m: &CMsgClientWorkshopItemChangesRequest| { &m.last_time_updated },
                |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.last_time_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_items_needed",
                |m: &CMsgClientWorkshopItemChangesRequest| { &m.num_items_needed },
                |m: &mut CMsgClientWorkshopItemChangesRequest| { &mut m.num_items_needed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWorkshopItemChangesRequest>(
                "CMsgClientWorkshopItemChangesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWorkshopItemChangesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWorkshopItemChangesRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemChangesRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.num_items_needed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemChangesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemChangesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemChangesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    update_time: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesResponse {
    fn default() -> &'a CMsgClientWorkshopItemChangesResponse {
        <CMsgClientWorkshopItemChangesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesResponse {
    pub fn new() -> CMsgClientWorkshopItemChangesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;


    pub fn get_update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }
    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo workshop_items = 5;


    pub fn get_workshop_items(&self) -> &[CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo] {
        &self.workshop_items
    }
    pub fn clear_workshop_items(&mut self) {
        self.workshop_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_workshop_items(&mut self, v: ::protobuf::RepeatedField<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo>) {
        self.workshop_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workshop_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo> {
        &mut self.workshop_items
    }

    // Take field
    pub fn take_workshop_items(&mut self) -> ::protobuf::RepeatedField<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo> {
        ::std::mem::replace(&mut self.workshop_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.update_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workshop_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemChangesResponse {
        CMsgClientWorkshopItemChangesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientWorkshopItemChangesResponse| { &m.eresult },
                |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "update_time",
                |m: &CMsgClientWorkshopItemChangesResponse| { &m.update_time },
                |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo>>(
                "workshop_items",
                |m: &CMsgClientWorkshopItemChangesResponse| { &m.workshop_items },
                |m: &mut CMsgClientWorkshopItemChangesResponse| { &mut m.workshop_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWorkshopItemChangesResponse>(
                "CMsgClientWorkshopItemChangesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWorkshopItemChangesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWorkshopItemChangesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemChangesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemChangesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemChangesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    time_updated: ::std::option::Option<u32>,
    manifest_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    fn default() -> &'a CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
        <CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    pub fn new() -> CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 2;


    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }
    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 manifest_id = 3;


    pub fn get_manifest_id(&self) -> u64 {
        self.manifest_id.unwrap_or(0)
    }
    pub fn clear_manifest_id(&mut self) {
        self.manifest_id = ::std::option::Option::None;
    }

    pub fn has_manifest_id(&self) -> bool {
        self.manifest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest_id(&mut self, v: u64) {
        self.manifest_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_updated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.manifest_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.manifest_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.manifest_id {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
        CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo| { &m.published_file_id },
                |m: &mut CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_updated",
                |m: &CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo| { &m.time_updated },
                |m: &mut CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo| { &mut m.time_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "manifest_id",
                |m: &CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo| { &m.manifest_id },
                |m: &mut CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo| { &mut m.manifest_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo>(
                "CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.manifest_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemInfoRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    last_time_updated: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoRequest_WorkshopItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoRequest {
    fn default() -> &'a CMsgClientWorkshopItemInfoRequest {
        <CMsgClientWorkshopItemInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoRequest {
    pub fn new() -> CMsgClientWorkshopItemInfoRequest {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_updated = 2;


    pub fn get_last_time_updated(&self) -> u32 {
        self.last_time_updated.unwrap_or(0)
    }
    pub fn clear_last_time_updated(&mut self) {
        self.last_time_updated = ::std::option::Option::None;
    }

    pub fn has_last_time_updated(&self) -> bool {
        self.last_time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_updated(&mut self, v: u32) {
        self.last_time_updated = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientWorkshopItemInfoRequest.WorkshopItem workshop_items = 3;


    pub fn get_workshop_items(&self) -> &[CMsgClientWorkshopItemInfoRequest_WorkshopItem] {
        &self.workshop_items
    }
    pub fn clear_workshop_items(&mut self) {
        self.workshop_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_workshop_items(&mut self, v: ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoRequest_WorkshopItem>) {
        self.workshop_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workshop_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoRequest_WorkshopItem> {
        &mut self.workshop_items
    }

    // Take field
    pub fn take_workshop_items(&mut self) -> ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoRequest_WorkshopItem> {
        ::std::mem::replace(&mut self.workshop_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_time_updated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workshop_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_time_updated {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemInfoRequest {
        CMsgClientWorkshopItemInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientWorkshopItemInfoRequest| { &m.app_id },
                |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_time_updated",
                |m: &CMsgClientWorkshopItemInfoRequest| { &m.last_time_updated },
                |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.last_time_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientWorkshopItemInfoRequest_WorkshopItem>>(
                "workshop_items",
                |m: &CMsgClientWorkshopItemInfoRequest| { &m.workshop_items },
                |m: &mut CMsgClientWorkshopItemInfoRequest| { &mut m.workshop_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWorkshopItemInfoRequest>(
                "CMsgClientWorkshopItemInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWorkshopItemInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWorkshopItemInfoRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemInfoRequest {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.last_time_updated = ::std::option::Option::None;
        self.workshop_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    time_updated: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    fn default() -> &'a CMsgClientWorkshopItemInfoRequest_WorkshopItem {
        <CMsgClientWorkshopItemInfoRequest_WorkshopItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    pub fn new() -> CMsgClientWorkshopItemInfoRequest_WorkshopItem {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 2;


    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }
    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_updated = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemInfoRequest_WorkshopItem {
        CMsgClientWorkshopItemInfoRequest_WorkshopItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientWorkshopItemInfoRequest_WorkshopItem| { &m.published_file_id },
                |m: &mut CMsgClientWorkshopItemInfoRequest_WorkshopItem| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_updated",
                |m: &CMsgClientWorkshopItemInfoRequest_WorkshopItem| { &m.time_updated },
                |m: &mut CMsgClientWorkshopItemInfoRequest_WorkshopItem| { &mut m.time_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWorkshopItemInfoRequest_WorkshopItem>(
                "CMsgClientWorkshopItemInfoRequest.WorkshopItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoRequest_WorkshopItem {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWorkshopItemInfoRequest_WorkshopItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWorkshopItemInfoRequest_WorkshopItem::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoRequest_WorkshopItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    update_time: ::std::option::Option<u32>,
    pub workshop_items: ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo>,
    pub private_items: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoResponse {
    fn default() -> &'a CMsgClientWorkshopItemInfoResponse {
        <CMsgClientWorkshopItemInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoResponse {
    pub fn new() -> CMsgClientWorkshopItemInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 update_time = 2;


    pub fn get_update_time(&self) -> u32 {
        self.update_time.unwrap_or(0)
    }
    pub fn clear_update_time(&mut self) {
        self.update_time = ::std::option::Option::None;
    }

    pub fn has_update_time(&self) -> bool {
        self.update_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_time(&mut self, v: u32) {
        self.update_time = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo workshop_items = 3;


    pub fn get_workshop_items(&self) -> &[CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo] {
        &self.workshop_items
    }
    pub fn clear_workshop_items(&mut self) {
        self.workshop_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_workshop_items(&mut self, v: ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo>) {
        self.workshop_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_workshop_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo> {
        &mut self.workshop_items
    }

    // Take field
    pub fn take_workshop_items(&mut self) -> ::protobuf::RepeatedField<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo> {
        ::std::mem::replace(&mut self.workshop_items, ::protobuf::RepeatedField::new())
    }

    // repeated fixed64 private_items = 4;


    pub fn get_private_items(&self) -> &[u64] {
        &self.private_items
    }
    pub fn clear_private_items(&mut self) {
        self.private_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_private_items(&mut self, v: ::std::vec::Vec<u64>) {
        self.private_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_private_items(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.private_items
    }

    // Take field
    pub fn take_private_items(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.private_items, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.workshop_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.update_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.workshop_items)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.private_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.workshop_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 9 * self.private_items.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.update_time {
            os.write_uint32(2, v)?;
        }
        for v in &self.workshop_items {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.private_items {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemInfoResponse {
        CMsgClientWorkshopItemInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.eresult },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "update_time",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.update_time },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.update_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo>>(
                "workshop_items",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.workshop_items },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.workshop_items },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "private_items",
                |m: &CMsgClientWorkshopItemInfoResponse| { &m.private_items },
                |m: &mut CMsgClientWorkshopItemInfoResponse| { &mut m.private_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWorkshopItemInfoResponse>(
                "CMsgClientWorkshopItemInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWorkshopItemInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWorkshopItemInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemInfoResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.update_time = ::std::option::Option::None;
        self.workshop_items.clear();
        self.private_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    time_updated: ::std::option::Option<u32>,
    manifest_id: ::std::option::Option<u64>,
    is_legacy: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    fn default() -> &'a CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
        <CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    pub fn new() -> CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_updated = 2;


    pub fn get_time_updated(&self) -> u32 {
        self.time_updated.unwrap_or(0)
    }
    pub fn clear_time_updated(&mut self) {
        self.time_updated = ::std::option::Option::None;
    }

    pub fn has_time_updated(&self) -> bool {
        self.time_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_updated(&mut self, v: u32) {
        self.time_updated = ::std::option::Option::Some(v);
    }

    // optional fixed64 manifest_id = 3;


    pub fn get_manifest_id(&self) -> u64 {
        self.manifest_id.unwrap_or(0)
    }
    pub fn clear_manifest_id(&mut self) {
        self.manifest_id = ::std::option::Option::None;
    }

    pub fn has_manifest_id(&self) -> bool {
        self.manifest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest_id(&mut self, v: u64) {
        self.manifest_id = ::std::option::Option::Some(v);
    }

    // optional bool is_legacy = 4;


    pub fn get_is_legacy(&self) -> bool {
        self.is_legacy.unwrap_or(false)
    }
    pub fn clear_is_legacy(&mut self) {
        self.is_legacy = ::std::option::Option::None;
    }

    pub fn has_is_legacy(&self) -> bool {
        self.is_legacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_legacy(&mut self, v: bool) {
        self.is_legacy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_updated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.manifest_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_legacy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.time_updated {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.manifest_id {
            my_size += 9;
        }
        if let Some(v) = self.is_legacy {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.time_updated {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.manifest_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.is_legacy {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
        CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &m.published_file_id },
                |m: &mut CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_updated",
                |m: &CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &m.time_updated },
                |m: &mut CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &mut m.time_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "manifest_id",
                |m: &CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &m.manifest_id },
                |m: &mut CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &mut m.manifest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_legacy",
                |m: &CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &m.is_legacy },
                |m: &mut CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo| { &mut m.is_legacy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo>(
                "CMsgClientWorkshopItemInfoResponse.WorkshopItemInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.time_updated = ::std::option::Option::None;
        self.manifest_id = ::std::option::Option::None;
        self.is_legacy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMGetPublishedFilesForUser {
    // message fields
    app_id: ::std::option::Option<u32>,
    creator_steam_id: ::std::option::Option<u64>,
    pub required_tags: ::protobuf::RepeatedField<::std::string::String>,
    pub excluded_tags: ::protobuf::RepeatedField<::std::string::String>,
    start_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMGetPublishedFilesForUser {
    fn default() -> &'a CMsgClientUCMGetPublishedFilesForUser {
        <CMsgClientUCMGetPublishedFilesForUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMGetPublishedFilesForUser {
    pub fn new() -> CMsgClientUCMGetPublishedFilesForUser {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steam_id = 2;


    pub fn get_creator_steam_id(&self) -> u64 {
        self.creator_steam_id.unwrap_or(0)
    }
    pub fn clear_creator_steam_id(&mut self) {
        self.creator_steam_id = ::std::option::Option::None;
    }

    pub fn has_creator_steam_id(&self) -> bool {
        self.creator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steam_id(&mut self, v: u64) {
        self.creator_steam_id = ::std::option::Option::Some(v);
    }

    // repeated string required_tags = 3;


    pub fn get_required_tags(&self) -> &[::std::string::String] {
        &self.required_tags
    }
    pub fn clear_required_tags(&mut self) {
        self.required_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_required_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.required_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_required_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.required_tags
    }

    // Take field
    pub fn take_required_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.required_tags, ::protobuf::RepeatedField::new())
    }

    // repeated string excluded_tags = 4;


    pub fn get_excluded_tags(&self) -> &[::std::string::String] {
        &self.excluded_tags
    }
    pub fn clear_excluded_tags(&mut self) {
        self.excluded_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_excluded_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excluded_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excluded_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excluded_tags
    }

    // Take field
    pub fn take_excluded_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excluded_tags, ::protobuf::RepeatedField::new())
    }

    // optional uint32 start_index = 5;


    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMGetPublishedFilesForUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.creator_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.required_tags)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excluded_tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator_steam_id {
            my_size += 9;
        }
        for value in &self.required_tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.excluded_tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.creator_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.required_tags {
            os.write_string(3, &v)?;
        };
        for v in &self.excluded_tags {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.start_index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMGetPublishedFilesForUser {
        CMsgClientUCMGetPublishedFilesForUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.app_id },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "creator_steam_id",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.creator_steam_id },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.creator_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "required_tags",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.required_tags },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.required_tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excluded_tags",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.excluded_tags },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.excluded_tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_index",
                |m: &CMsgClientUCMGetPublishedFilesForUser| { &m.start_index },
                |m: &mut CMsgClientUCMGetPublishedFilesForUser| { &mut m.start_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMGetPublishedFilesForUser>(
                "CMsgClientUCMGetPublishedFilesForUser",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMGetPublishedFilesForUser {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMGetPublishedFilesForUser> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMGetPublishedFilesForUser::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMGetPublishedFilesForUser {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.creator_steam_id = ::std::option::Option::None;
        self.required_tags.clear();
        self.excluded_tags.clear();
        self.start_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMGetPublishedFilesForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMGetPublishedFilesForUser {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMGetPublishedFilesForUserResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub published_files: ::protobuf::RepeatedField<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMGetPublishedFilesForUserResponse {
    fn default() -> &'a CMsgClientUCMGetPublishedFilesForUserResponse {
        <CMsgClientUCMGetPublishedFilesForUserResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMGetPublishedFilesForUserResponse {
    pub fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId published_files = 2;


    pub fn get_published_files(&self) -> &[CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId] {
        &self.published_files
    }
    pub fn clear_published_files(&mut self) {
        self.published_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId>) {
        self.published_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId> {
        &mut self.published_files
    }

    // Take field
    pub fn take_published_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId> {
        ::std::mem::replace(&mut self.published_files, ::protobuf::RepeatedField::new())
    }

    // optional uint32 total_results = 3;


    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }
    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.published_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.published_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_results = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse {
        CMsgClientUCMGetPublishedFilesForUserResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.eresult },
                |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId>>(
                "published_files",
                |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.published_files },
                |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.published_files },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_results",
                |m: &CMsgClientUCMGetPublishedFilesForUserResponse| { &m.total_results },
                |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse| { &mut m.total_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMGetPublishedFilesForUserResponse>(
                "CMsgClientUCMGetPublishedFilesForUserResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMGetPublishedFilesForUserResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMGetPublishedFilesForUserResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMGetPublishedFilesForUserResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMGetPublishedFilesForUserResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    fn default() -> &'a CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
        <CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    pub fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
        CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId| { &m.published_file_id },
                |m: &mut CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId>(
                "CMsgClientUCMGetPublishedFilesForUserResponse.PublishedFileId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMSetUserPublishedFileAction {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    action: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileAction {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileAction {
        <CMsgClientUCMSetUserPublishedFileAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileAction {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;


    pub fn get_action(&self) -> i32 {
        self.action.unwrap_or(0)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileAction {
        CMsgClientUCMSetUserPublishedFileAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.published_file_id },
                |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.app_id },
                |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "action",
                |m: &CMsgClientUCMSetUserPublishedFileAction| { &m.action },
                |m: &mut CMsgClientUCMSetUserPublishedFileAction| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMSetUserPublishedFileAction>(
                "CMsgClientUCMSetUserPublishedFileAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileAction {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMSetUserPublishedFileAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMSetUserPublishedFileAction::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMSetUserPublishedFileAction {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMSetUserPublishedFileAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMSetUserPublishedFileActionResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMSetUserPublishedFileActionResponse {
    fn default() -> &'a CMsgClientUCMSetUserPublishedFileActionResponse {
        <CMsgClientUCMSetUserPublishedFileActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMSetUserPublishedFileActionResponse {
    pub fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMSetUserPublishedFileActionResponse {
        CMsgClientUCMSetUserPublishedFileActionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMSetUserPublishedFileActionResponse| { &m.eresult },
                |m: &mut CMsgClientUCMSetUserPublishedFileActionResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMSetUserPublishedFileActionResponse>(
                "CMsgClientUCMSetUserPublishedFileActionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMSetUserPublishedFileActionResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMSetUserPublishedFileActionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMSetUserPublishedFileActionResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMSetUserPublishedFileActionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserAction {
    // message fields
    app_id: ::std::option::Option<u32>,
    start_index: ::std::option::Option<u32>,
    action: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserAction {
        <CMsgClientUCMEnumeratePublishedFilesByUserAction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserAction {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_index = 2;


    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }

    // optional int32 action = 3;


    pub fn get_action(&self) -> i32 {
        self.action.unwrap_or(0)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: i32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserAction {
        CMsgClientUCMEnumeratePublishedFilesByUserAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.app_id },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_index",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.start_index },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.start_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "action",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserAction| { &m.action },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserAction| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumeratePublishedFilesByUserAction>(
                "CMsgClientUCMEnumeratePublishedFilesByUserAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserAction {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumeratePublishedFilesByUserAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumeratePublishedFilesByUserAction::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.start_index = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub published_files: ::protobuf::RepeatedField<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId>,
    total_results: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        <CMsgClientUCMEnumeratePublishedFilesByUserActionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId published_files = 2;


    pub fn get_published_files(&self) -> &[CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId] {
        &self.published_files
    }
    pub fn clear_published_files(&mut self) {
        self.published_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId>) {
        self.published_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_files(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId> {
        &mut self.published_files
    }

    // Take field
    pub fn take_published_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId> {
        ::std::mem::replace(&mut self.published_files, ::protobuf::RepeatedField::new())
    }

    // optional uint32 total_results = 3;


    pub fn get_total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }
    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.published_files {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.published_files)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_results = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.published_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.published_files {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.total_results {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.eresult },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId>>(
                "published_files",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.published_files },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.published_files },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_results",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &m.total_results },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse| { &mut m.total_results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse>(
                "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.published_files.clear();
        self.total_results = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    rtime_time_stamp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    fn default() -> &'a CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
        <CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    pub fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime_time_stamp = 2;


    pub fn get_rtime_time_stamp(&self) -> u32 {
        self.rtime_time_stamp.unwrap_or(0u32)
    }
    pub fn clear_rtime_time_stamp(&mut self) {
        self.rtime_time_stamp = ::std::option::Option::None;
    }

    pub fn has_rtime_time_stamp(&self) -> bool {
        self.rtime_time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_time_stamp(&mut self, v: u32) {
        self.rtime_time_stamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime_time_stamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.rtime_time_stamp {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.rtime_time_stamp {
            os.write_fixed32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
        CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId| { &m.published_file_id },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime_time_stamp",
                |m: &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId| { &m.rtime_time_stamp },
                |m: &mut CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId| { &mut m.rtime_time_stamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId>(
                "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId::new)
    }
}

impl ::protobuf::Clear for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.rtime_time_stamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientScreenshotsChanged {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientScreenshotsChanged {
    fn default() -> &'a CMsgClientScreenshotsChanged {
        <CMsgClientScreenshotsChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientScreenshotsChanged {
    pub fn new() -> CMsgClientScreenshotsChanged {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientScreenshotsChanged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientScreenshotsChanged {
        CMsgClientScreenshotsChanged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientScreenshotsChanged>(
                "CMsgClientScreenshotsChanged",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientScreenshotsChanged {
        static instance: ::protobuf::rt::LazyV2<CMsgClientScreenshotsChanged> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientScreenshotsChanged::new)
    }
}

impl ::protobuf::Clear for CMsgClientScreenshotsChanged {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientScreenshotsChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientScreenshotsChanged {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateUserGameInfo {
    // message fields
    steamid_idgs: ::std::option::Option<u64>,
    gameid: ::std::option::Option<u64>,
    game_ip: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateUserGameInfo {
    fn default() -> &'a CMsgClientUpdateUserGameInfo {
        <CMsgClientUpdateUserGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateUserGameInfo {
    pub fn new() -> CMsgClientUpdateUserGameInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_idgs = 1;


    pub fn get_steamid_idgs(&self) -> u64 {
        self.steamid_idgs.unwrap_or(0)
    }
    pub fn clear_steamid_idgs(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
    }

    pub fn has_steamid_idgs(&self) -> bool {
        self.steamid_idgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_idgs(&mut self, v: u64) {
        self.steamid_idgs = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 2;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_ip = 3;


    pub fn get_game_ip(&self) -> u32 {
        self.game_ip.unwrap_or(0)
    }
    pub fn clear_game_ip(&mut self) {
        self.game_ip = ::std::option::Option::None;
    }

    pub fn has_game_ip(&self) -> bool {
        self.game_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip(&mut self, v: u32) {
        self.game_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;


    pub fn get_game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }
    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional bytes token = 5;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientUpdateUserGameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_idgs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_idgs {
            my_size += 9;
        }
        if let Some(v) = self.gameid {
            my_size += 9;
        }
        if let Some(v) = self.game_ip {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_idgs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateUserGameInfo {
        CMsgClientUpdateUserGameInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_idgs",
                |m: &CMsgClientUpdateUserGameInfo| { &m.steamid_idgs },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.steamid_idgs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "gameid",
                |m: &CMsgClientUpdateUserGameInfo| { &m.gameid },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_ip",
                |m: &CMsgClientUpdateUserGameInfo| { &m.game_ip },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_port",
                |m: &CMsgClientUpdateUserGameInfo| { &m.game_port },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.game_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CMsgClientUpdateUserGameInfo| { &m.token },
                |m: &mut CMsgClientUpdateUserGameInfo| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUpdateUserGameInfo>(
                "CMsgClientUpdateUserGameInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateUserGameInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUpdateUserGameInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUpdateUserGameInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateUserGameInfo {
    fn clear(&mut self) {
        self.steamid_idgs = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.game_ip = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateUserGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateUserGameInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRichPresenceUpload {
    // message fields
    rich_presence_kv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub steamid_broadcast: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceUpload {
    fn default() -> &'a CMsgClientRichPresenceUpload {
        <CMsgClientRichPresenceUpload as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceUpload {
    pub fn new() -> CMsgClientRichPresenceUpload {
        ::std::default::Default::default()
    }

    // optional bytes rich_presence_kv = 1;


    pub fn get_rich_presence_kv(&self) -> &[u8] {
        match self.rich_presence_kv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rich_presence_kv(&mut self) {
        self.rich_presence_kv.clear();
    }

    pub fn has_rich_presence_kv(&self) -> bool {
        self.rich_presence_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
        self.rich_presence_kv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rich_presence_kv.is_none() {
            self.rich_presence_kv.set_default();
        }
        self.rich_presence_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
        self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated fixed64 steamid_broadcast = 2;


    pub fn get_steamid_broadcast(&self) -> &[u64] {
        &self.steamid_broadcast
    }
    pub fn clear_steamid_broadcast(&mut self) {
        self.steamid_broadcast.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_broadcast(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_broadcast = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_broadcast(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_broadcast
    }

    // Take field
    pub fn take_steamid_broadcast(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_broadcast, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceUpload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rich_presence_kv)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_broadcast)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rich_presence_kv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += 9 * self.steamid_broadcast.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rich_presence_kv.as_ref() {
            os.write_bytes(1, &v)?;
        }
        for v in &self.steamid_broadcast {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRichPresenceUpload {
        CMsgClientRichPresenceUpload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rich_presence_kv",
                |m: &CMsgClientRichPresenceUpload| { &m.rich_presence_kv },
                |m: &mut CMsgClientRichPresenceUpload| { &mut m.rich_presence_kv },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_broadcast",
                |m: &CMsgClientRichPresenceUpload| { &m.steamid_broadcast },
                |m: &mut CMsgClientRichPresenceUpload| { &mut m.steamid_broadcast },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRichPresenceUpload>(
                "CMsgClientRichPresenceUpload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRichPresenceUpload {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRichPresenceUpload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRichPresenceUpload::new)
    }
}

impl ::protobuf::Clear for CMsgClientRichPresenceUpload {
    fn clear(&mut self) {
        self.rich_presence_kv.clear();
        self.steamid_broadcast.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRichPresenceUpload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceUpload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRichPresenceRequest {
    // message fields
    pub steamid_request: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceRequest {
    fn default() -> &'a CMsgClientRichPresenceRequest {
        <CMsgClientRichPresenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceRequest {
    pub fn new() -> CMsgClientRichPresenceRequest {
        ::std::default::Default::default()
    }

    // repeated fixed64 steamid_request = 1;


    pub fn get_steamid_request(&self) -> &[u64] {
        &self.steamid_request
    }
    pub fn clear_steamid_request(&mut self) {
        self.steamid_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_request(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_request = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_request(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_request
    }

    // Take field
    pub fn take_steamid_request(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_request, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.steamid_request.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.steamid_request {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRichPresenceRequest {
        CMsgClientRichPresenceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_request",
                |m: &CMsgClientRichPresenceRequest| { &m.steamid_request },
                |m: &mut CMsgClientRichPresenceRequest| { &mut m.steamid_request },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRichPresenceRequest>(
                "CMsgClientRichPresenceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRichPresenceRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRichPresenceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRichPresenceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientRichPresenceRequest {
    fn clear(&mut self) {
        self.steamid_request.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRichPresenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRichPresenceInfo {
    // message fields
    pub rich_presence: ::protobuf::RepeatedField<CMsgClientRichPresenceInfo_RichPresence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceInfo {
    fn default() -> &'a CMsgClientRichPresenceInfo {
        <CMsgClientRichPresenceInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceInfo {
    pub fn new() -> CMsgClientRichPresenceInfo {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientRichPresenceInfo.RichPresence rich_presence = 1;


    pub fn get_rich_presence(&self) -> &[CMsgClientRichPresenceInfo_RichPresence] {
        &self.rich_presence
    }
    pub fn clear_rich_presence(&mut self) {
        self.rich_presence.clear();
    }

    // Param is passed by value, moved
    pub fn set_rich_presence(&mut self, v: ::protobuf::RepeatedField<CMsgClientRichPresenceInfo_RichPresence>) {
        self.rich_presence = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rich_presence(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientRichPresenceInfo_RichPresence> {
        &mut self.rich_presence
    }

    // Take field
    pub fn take_rich_presence(&mut self) -> ::protobuf::RepeatedField<CMsgClientRichPresenceInfo_RichPresence> {
        ::std::mem::replace(&mut self.rich_presence, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.rich_presence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rich_presence)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rich_presence {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rich_presence {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRichPresenceInfo {
        CMsgClientRichPresenceInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientRichPresenceInfo_RichPresence>>(
                "rich_presence",
                |m: &CMsgClientRichPresenceInfo| { &m.rich_presence },
                |m: &mut CMsgClientRichPresenceInfo| { &mut m.rich_presence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRichPresenceInfo>(
                "CMsgClientRichPresenceInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRichPresenceInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRichPresenceInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRichPresenceInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientRichPresenceInfo {
    fn clear(&mut self) {
        self.rich_presence.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRichPresenceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRichPresenceInfo_RichPresence {
    // message fields
    steamid_user: ::std::option::Option<u64>,
    rich_presence_kv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRichPresenceInfo_RichPresence {
    fn default() -> &'a CMsgClientRichPresenceInfo_RichPresence {
        <CMsgClientRichPresenceInfo_RichPresence as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRichPresenceInfo_RichPresence {
    pub fn new() -> CMsgClientRichPresenceInfo_RichPresence {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_user = 1;


    pub fn get_steamid_user(&self) -> u64 {
        self.steamid_user.unwrap_or(0)
    }
    pub fn clear_steamid_user(&mut self) {
        self.steamid_user = ::std::option::Option::None;
    }

    pub fn has_steamid_user(&self) -> bool {
        self.steamid_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_user(&mut self, v: u64) {
        self.steamid_user = ::std::option::Option::Some(v);
    }

    // optional bytes rich_presence_kv = 2;


    pub fn get_rich_presence_kv(&self) -> &[u8] {
        match self.rich_presence_kv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rich_presence_kv(&mut self) {
        self.rich_presence_kv.clear();
    }

    pub fn has_rich_presence_kv(&self) -> bool {
        self.rich_presence_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rich_presence_kv(&mut self, v: ::std::vec::Vec<u8>) {
        self.rich_presence_kv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rich_presence_kv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rich_presence_kv.is_none() {
            self.rich_presence_kv.set_default();
        }
        self.rich_presence_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rich_presence_kv(&mut self) -> ::std::vec::Vec<u8> {
        self.rich_presence_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRichPresenceInfo_RichPresence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_user = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rich_presence_kv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_user {
            my_size += 9;
        }
        if let Some(ref v) = self.rich_presence_kv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_user {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.rich_presence_kv.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRichPresenceInfo_RichPresence {
        CMsgClientRichPresenceInfo_RichPresence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_user",
                |m: &CMsgClientRichPresenceInfo_RichPresence| { &m.steamid_user },
                |m: &mut CMsgClientRichPresenceInfo_RichPresence| { &mut m.steamid_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rich_presence_kv",
                |m: &CMsgClientRichPresenceInfo_RichPresence| { &m.rich_presence_kv },
                |m: &mut CMsgClientRichPresenceInfo_RichPresence| { &mut m.rich_presence_kv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRichPresenceInfo_RichPresence>(
                "CMsgClientRichPresenceInfo.RichPresence",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRichPresenceInfo_RichPresence {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRichPresenceInfo_RichPresence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRichPresenceInfo_RichPresence::new)
    }
}

impl ::protobuf::Clear for CMsgClientRichPresenceInfo_RichPresence {
    fn clear(&mut self) {
        self.steamid_user = ::std::option::Option::None;
        self.rich_presence_kv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRichPresenceInfo_RichPresence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRichPresenceInfo_RichPresence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckFileSignature {
    // message fields
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignature {
    fn default() -> &'a CMsgClientCheckFileSignature {
        <CMsgClientCheckFileSignature as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignature {
    pub fn new() -> CMsgClientCheckFileSignature {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckFileSignature {
        CMsgClientCheckFileSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientCheckFileSignature| { &m.app_id },
                |m: &mut CMsgClientCheckFileSignature| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCheckFileSignature>(
                "CMsgClientCheckFileSignature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignature {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCheckFileSignature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCheckFileSignature::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckFileSignature {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckFileSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckFileSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckFileSignatureResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    pid: ::std::option::Option<u32>,
    eresult: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    esignatureresult: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signatureheader: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    filesize: ::std::option::Option<u32>,
    getlasterror: ::std::option::Option<u32>,
    evalvesignaturecheckdetail: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckFileSignatureResponse {
    fn default() -> &'a CMsgClientCheckFileSignatureResponse {
        <CMsgClientCheckFileSignatureResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckFileSignatureResponse {
    pub fn new() -> CMsgClientCheckFileSignatureResponse {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 pid = 2;


    pub fn get_pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }
    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 3;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 esignatureresult = 5;


    pub fn get_esignatureresult(&self) -> u32 {
        self.esignatureresult.unwrap_or(0)
    }
    pub fn clear_esignatureresult(&mut self) {
        self.esignatureresult = ::std::option::Option::None;
    }

    pub fn has_esignatureresult(&self) -> bool {
        self.esignatureresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_esignatureresult(&mut self, v: u32) {
        self.esignatureresult = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 6;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signatureheader = 7;


    pub fn get_signatureheader(&self) -> &[u8] {
        match self.signatureheader.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signatureheader(&mut self) {
        self.signatureheader.clear();
    }

    pub fn has_signatureheader(&self) -> bool {
        self.signatureheader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signatureheader(&mut self, v: ::std::vec::Vec<u8>) {
        self.signatureheader = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signatureheader(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signatureheader.is_none() {
            self.signatureheader.set_default();
        }
        self.signatureheader.as_mut().unwrap()
    }

    // Take field
    pub fn take_signatureheader(&mut self) -> ::std::vec::Vec<u8> {
        self.signatureheader.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 filesize = 8;


    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }
    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional uint32 getlasterror = 9;


    pub fn get_getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }
    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 evalvesignaturecheckdetail = 10;


    pub fn get_evalvesignaturecheckdetail(&self) -> u32 {
        self.evalvesignaturecheckdetail.unwrap_or(0)
    }
    pub fn clear_evalvesignaturecheckdetail(&mut self) {
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
    }

    pub fn has_evalvesignaturecheckdetail(&self) -> bool {
        self.evalvesignaturecheckdetail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evalvesignaturecheckdetail(&mut self, v: u32) {
        self.evalvesignaturecheckdetail = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCheckFileSignatureResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.esignatureresult = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signatureheader)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filesize = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.getlasterror = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.evalvesignaturecheckdetail = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.esignatureresult {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.signatureheader.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.esignatureresult {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.signatureheader.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.evalvesignaturecheckdetail {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckFileSignatureResponse {
        CMsgClientCheckFileSignatureResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.app_id },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pid",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.pid },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.pid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.eresult },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.filename },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "esignatureresult",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.esignatureresult },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.esignatureresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.sha_file },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signatureheader",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.signatureheader },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.signatureheader },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "filesize",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.filesize },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.filesize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "getlasterror",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.getlasterror },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.getlasterror },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "evalvesignaturecheckdetail",
                |m: &CMsgClientCheckFileSignatureResponse| { &m.evalvesignaturecheckdetail },
                |m: &mut CMsgClientCheckFileSignatureResponse| { &mut m.evalvesignaturecheckdetail },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCheckFileSignatureResponse>(
                "CMsgClientCheckFileSignatureResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckFileSignatureResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCheckFileSignatureResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCheckFileSignatureResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckFileSignatureResponse {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.pid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.filename.clear();
        self.esignatureresult = ::std::option::Option::None;
        self.sha_file.clear();
        self.signatureheader.clear();
        self.filesize = ::std::option::Option::None;
        self.getlasterror = ::std::option::Option::None;
        self.evalvesignaturecheckdetail = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckFileSignatureResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckFileSignatureResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientReadMachineAuth {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u32>,
    cubtoread: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuth {
    fn default() -> &'a CMsgClientReadMachineAuth {
        <CMsgClientReadMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuth {
    pub fn new() -> CMsgClientReadMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;


    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtoread = 3;


    pub fn get_cubtoread(&self) -> u32 {
        self.cubtoread.unwrap_or(0)
    }
    pub fn clear_cubtoread(&mut self) {
        self.cubtoread = ::std::option::Option::None;
    }

    pub fn has_cubtoread(&self) -> bool {
        self.cubtoread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtoread(&mut self, v: u32) {
        self.cubtoread = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cubtoread = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubtoread {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtoread {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientReadMachineAuth {
        CMsgClientReadMachineAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientReadMachineAuth| { &m.filename },
                |m: &mut CMsgClientReadMachineAuth| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "offset",
                |m: &CMsgClientReadMachineAuth| { &m.offset },
                |m: &mut CMsgClientReadMachineAuth| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cubtoread",
                |m: &CMsgClientReadMachineAuth| { &m.cubtoread },
                |m: &mut CMsgClientReadMachineAuth| { &mut m.cubtoread },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientReadMachineAuth>(
                "CMsgClientReadMachineAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuth {
        static instance: ::protobuf::rt::LazyV2<CMsgClientReadMachineAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientReadMachineAuth::new)
    }
}

impl ::protobuf::Clear for CMsgClientReadMachineAuth {
    fn clear(&mut self) {
        self.filename.clear();
        self.offset = ::std::option::Option::None;
        self.cubtoread = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientReadMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReadMachineAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientReadMachineAuthResponse {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    eresult: ::std::option::Option<u32>,
    filesize: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    getlasterror: ::std::option::Option<u32>,
    offset: ::std::option::Option<u32>,
    cubread: ::std::option::Option<u32>,
    bytes_read: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    filename_sentry: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientReadMachineAuthResponse {
    fn default() -> &'a CMsgClientReadMachineAuthResponse {
        <CMsgClientReadMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientReadMachineAuthResponse {
    pub fn new() -> CMsgClientReadMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;


    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }
    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;


    pub fn get_getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }
    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;


    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubread = 7;


    pub fn get_cubread(&self) -> u32 {
        self.cubread.unwrap_or(0)
    }
    pub fn clear_cubread(&mut self) {
        self.cubread = ::std::option::Option::None;
    }

    pub fn has_cubread(&self) -> bool {
        self.cubread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubread(&mut self, v: u32) {
        self.cubread = ::std::option::Option::Some(v);
    }

    // optional bytes bytes_read = 8;


    pub fn get_bytes_read(&self) -> &[u8] {
        match self.bytes_read.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_bytes_read(&mut self) {
        self.bytes_read.clear();
    }

    pub fn has_bytes_read(&self) -> bool {
        self.bytes_read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_read(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes_read = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_read(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes_read.is_none() {
            self.bytes_read.set_default();
        }
        self.bytes_read.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_read(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes_read.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string filename_sentry = 9;


    pub fn get_filename_sentry(&self) -> &str {
        match self.filename_sentry.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename_sentry(&mut self) {
        self.filename_sentry.clear();
    }

    pub fn has_filename_sentry(&self) -> bool {
        self.filename_sentry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename_sentry(&mut self, v: ::std::string::String) {
        self.filename_sentry = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename_sentry(&mut self) -> &mut ::std::string::String {
        if self.filename_sentry.is_none() {
            self.filename_sentry.set_default();
        }
        self.filename_sentry.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename_sentry(&mut self) -> ::std::string::String {
        self.filename_sentry.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientReadMachineAuthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filesize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.getlasterror = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cubread = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.bytes_read)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename_sentry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubread {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bytes_read.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.filename_sentry.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubread {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.bytes_read.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.filename_sentry.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientReadMachineAuthResponse {
        CMsgClientReadMachineAuthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientReadMachineAuthResponse| { &m.filename },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientReadMachineAuthResponse| { &m.eresult },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "filesize",
                |m: &CMsgClientReadMachineAuthResponse| { &m.filesize },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filesize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientReadMachineAuthResponse| { &m.sha_file },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "getlasterror",
                |m: &CMsgClientReadMachineAuthResponse| { &m.getlasterror },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.getlasterror },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "offset",
                |m: &CMsgClientReadMachineAuthResponse| { &m.offset },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cubread",
                |m: &CMsgClientReadMachineAuthResponse| { &m.cubread },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.cubread },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bytes_read",
                |m: &CMsgClientReadMachineAuthResponse| { &m.bytes_read },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.bytes_read },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename_sentry",
                |m: &CMsgClientReadMachineAuthResponse| { &m.filename_sentry },
                |m: &mut CMsgClientReadMachineAuthResponse| { &mut m.filename_sentry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientReadMachineAuthResponse>(
                "CMsgClientReadMachineAuthResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientReadMachineAuthResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientReadMachineAuthResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientReadMachineAuthResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientReadMachineAuthResponse {
    fn clear(&mut self) {
        self.filename.clear();
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file.clear();
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubread = ::std::option::Option::None;
        self.bytes_read.clear();
        self.filename_sentry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientReadMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientReadMachineAuthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateMachineAuth {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u32>,
    cubtowrite: ::std::option::Option<u32>,
    bytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    otp_type: ::std::option::Option<u32>,
    otp_identifier: ::protobuf::SingularField<::std::string::String>,
    otp_sharedsecret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    otp_timedrift: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuth {
    fn default() -> &'a CMsgClientUpdateMachineAuth {
        <CMsgClientUpdateMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuth {
    pub fn new() -> CMsgClientUpdateMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 offset = 2;


    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubtowrite = 3;


    pub fn get_cubtowrite(&self) -> u32 {
        self.cubtowrite.unwrap_or(0)
    }
    pub fn clear_cubtowrite(&mut self) {
        self.cubtowrite = ::std::option::Option::None;
    }

    pub fn has_cubtowrite(&self) -> bool {
        self.cubtowrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubtowrite(&mut self, v: u32) {
        self.cubtowrite = ::std::option::Option::Some(v);
    }

    // optional bytes bytes = 4;


    pub fn get_bytes(&self) -> &[u8] {
        match self.bytes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bytes.is_none() {
            self.bytes.set_default();
        }
        self.bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_type = 5;


    pub fn get_otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }
    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 6;


    pub fn get_otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier.clear();
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier.set_default();
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 7;


    pub fn get_otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret.clear();
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret.set_default();
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_timedrift = 8;


    pub fn get_otp_timedrift(&self) -> u32 {
        self.otp_timedrift.unwrap_or(0)
    }
    pub fn clear_otp_timedrift(&mut self) {
        self.otp_timedrift = ::std::option::Option::None;
    }

    pub fn has_otp_timedrift(&self) -> bool {
        self.otp_timedrift.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_timedrift(&mut self, v: u32) {
        self.otp_timedrift = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cubtowrite = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.bytes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.otp_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.otp_identifier)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.otp_sharedsecret)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.otp_timedrift = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubtowrite {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.otp_timedrift {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cubtowrite {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.bytes.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.otp_identifier.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.otp_timedrift {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateMachineAuth {
        CMsgClientUpdateMachineAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientUpdateMachineAuth| { &m.filename },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "offset",
                |m: &CMsgClientUpdateMachineAuth| { &m.offset },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cubtowrite",
                |m: &CMsgClientUpdateMachineAuth| { &m.cubtowrite },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.cubtowrite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bytes",
                |m: &CMsgClientUpdateMachineAuth| { &m.bytes },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "otp_type",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_type },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "otp_identifier",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_identifier },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "otp_sharedsecret",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_sharedsecret },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_sharedsecret },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "otp_timedrift",
                |m: &CMsgClientUpdateMachineAuth| { &m.otp_timedrift },
                |m: &mut CMsgClientUpdateMachineAuth| { &mut m.otp_timedrift },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUpdateMachineAuth>(
                "CMsgClientUpdateMachineAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuth {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUpdateMachineAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUpdateMachineAuth::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateMachineAuth {
    fn clear(&mut self) {
        self.filename.clear();
        self.offset = ::std::option::Option::None;
        self.cubtowrite = ::std::option::Option::None;
        self.bytes.clear();
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier.clear();
        self.otp_sharedsecret.clear();
        self.otp_timedrift = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateMachineAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateMachineAuthResponse {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    eresult: ::std::option::Option<u32>,
    filesize: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    getlasterror: ::std::option::Option<u32>,
    offset: ::std::option::Option<u32>,
    cubwrote: ::std::option::Option<u32>,
    otp_type: ::std::option::Option<i32>,
    otp_value: ::std::option::Option<u32>,
    otp_identifier: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateMachineAuthResponse {
    fn default() -> &'a CMsgClientUpdateMachineAuthResponse {
        <CMsgClientUpdateMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateMachineAuthResponse {
    pub fn new() -> CMsgClientUpdateMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult = 2;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;


    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }
    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_file = 4;


    pub fn get_sha_file(&self) -> &[u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        }
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 getlasterror = 5;


    pub fn get_getlasterror(&self) -> u32 {
        self.getlasterror.unwrap_or(0)
    }
    pub fn clear_getlasterror(&mut self) {
        self.getlasterror = ::std::option::Option::None;
    }

    pub fn has_getlasterror(&self) -> bool {
        self.getlasterror.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getlasterror(&mut self, v: u32) {
        self.getlasterror = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 6;


    pub fn get_offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional uint32 cubwrote = 7;


    pub fn get_cubwrote(&self) -> u32 {
        self.cubwrote.unwrap_or(0)
    }
    pub fn clear_cubwrote(&mut self) {
        self.cubwrote = ::std::option::Option::None;
    }

    pub fn has_cubwrote(&self) -> bool {
        self.cubwrote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cubwrote(&mut self, v: u32) {
        self.cubwrote = ::std::option::Option::Some(v);
    }

    // optional int32 otp_type = 8;


    pub fn get_otp_type(&self) -> i32 {
        self.otp_type.unwrap_or(0)
    }
    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: i32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_value = 9;


    pub fn get_otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }
    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 10;


    pub fn get_otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier.clear();
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier.set_default();
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientUpdateMachineAuthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filesize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.getlasterror = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cubwrote = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.otp_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.otp_value = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.otp_identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.getlasterror {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cubwrote {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.sha_file.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.getlasterror {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cubwrote {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.otp_identifier.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateMachineAuthResponse {
        CMsgClientUpdateMachineAuthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.filename },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.eresult },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "filesize",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.filesize },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.filesize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_file",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.sha_file },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.sha_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "getlasterror",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.getlasterror },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.getlasterror },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "offset",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.offset },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cubwrote",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.cubwrote },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.cubwrote },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "otp_type",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_type },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "otp_value",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_value },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "otp_identifier",
                |m: &CMsgClientUpdateMachineAuthResponse| { &m.otp_identifier },
                |m: &mut CMsgClientUpdateMachineAuthResponse| { &mut m.otp_identifier },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUpdateMachineAuthResponse>(
                "CMsgClientUpdateMachineAuthResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateMachineAuthResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUpdateMachineAuthResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUpdateMachineAuthResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateMachineAuthResponse {
    fn clear(&mut self) {
        self.filename.clear();
        self.eresult = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_file.clear();
        self.getlasterror = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.cubwrote = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_value = ::std::option::Option::None;
        self.otp_identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateMachineAuthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestMachineAuth {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    eresult_sentryfile: ::std::option::Option<u32>,
    filesize: ::std::option::Option<u32>,
    sha_sentryfile: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    lock_account_action: ::std::option::Option<i32>,
    otp_type: ::std::option::Option<u32>,
    otp_identifier: ::protobuf::SingularField<::std::string::String>,
    otp_sharedsecret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    otp_value: ::std::option::Option<u32>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    machine_name_userchosen: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuth {
    fn default() -> &'a CMsgClientRequestMachineAuth {
        <CMsgClientRequestMachineAuth as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuth {
    pub fn new() -> CMsgClientRequestMachineAuth {
        ::std::default::Default::default()
    }

    // optional string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 eresult_sentryfile = 2;


    pub fn get_eresult_sentryfile(&self) -> u32 {
        self.eresult_sentryfile.unwrap_or(0)
    }
    pub fn clear_eresult_sentryfile(&mut self) {
        self.eresult_sentryfile = ::std::option::Option::None;
    }

    pub fn has_eresult_sentryfile(&self) -> bool {
        self.eresult_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult_sentryfile(&mut self, v: u32) {
        self.eresult_sentryfile = ::std::option::Option::Some(v);
    }

    // optional uint32 filesize = 3;


    pub fn get_filesize(&self) -> u32 {
        self.filesize.unwrap_or(0)
    }
    pub fn clear_filesize(&mut self) {
        self.filesize = ::std::option::Option::None;
    }

    pub fn has_filesize(&self) -> bool {
        self.filesize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesize(&mut self, v: u32) {
        self.filesize = ::std::option::Option::Some(v);
    }

    // optional bytes sha_sentryfile = 4;


    pub fn get_sha_sentryfile(&self) -> &[u8] {
        match self.sha_sentryfile.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sha_sentryfile(&mut self) {
        self.sha_sentryfile.clear();
    }

    pub fn has_sha_sentryfile(&self) -> bool {
        self.sha_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_sentryfile(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_sentryfile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_sentryfile(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_sentryfile.is_none() {
            self.sha_sentryfile.set_default();
        }
        self.sha_sentryfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_sentryfile(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_sentryfile.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 lock_account_action = 6;


    pub fn get_lock_account_action(&self) -> i32 {
        self.lock_account_action.unwrap_or(0)
    }
    pub fn clear_lock_account_action(&mut self) {
        self.lock_account_action = ::std::option::Option::None;
    }

    pub fn has_lock_account_action(&self) -> bool {
        self.lock_account_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_account_action(&mut self, v: i32) {
        self.lock_account_action = ::std::option::Option::Some(v);
    }

    // optional uint32 otp_type = 7;


    pub fn get_otp_type(&self) -> u32 {
        self.otp_type.unwrap_or(0)
    }
    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: u32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    // optional string otp_identifier = 8;


    pub fn get_otp_identifier(&self) -> &str {
        match self.otp_identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier.clear();
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier(&mut self) -> &mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier.set_default();
        }
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes otp_sharedsecret = 9;


    pub fn get_otp_sharedsecret(&self) -> &[u8] {
        match self.otp_sharedsecret.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_otp_sharedsecret(&mut self) {
        self.otp_sharedsecret.clear();
    }

    pub fn has_otp_sharedsecret(&self) -> bool {
        self.otp_sharedsecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_sharedsecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.otp_sharedsecret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_sharedsecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.otp_sharedsecret.is_none() {
            self.otp_sharedsecret.set_default();
        }
        self.otp_sharedsecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_sharedsecret(&mut self) -> ::std::vec::Vec<u8> {
        self.otp_sharedsecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 otp_value = 10;


    pub fn get_otp_value(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }
    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 11;


    pub fn get_machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string machine_name_userchosen = 12;


    pub fn get_machine_name_userchosen(&self) -> &str {
        match self.machine_name_userchosen.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_machine_name_userchosen(&mut self) {
        self.machine_name_userchosen.clear();
    }

    pub fn has_machine_name_userchosen(&self) -> bool {
        self.machine_name_userchosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name_userchosen(&mut self, v: ::std::string::String) {
        self.machine_name_userchosen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name_userchosen(&mut self) -> &mut ::std::string::String {
        if self.machine_name_userchosen.is_none() {
            self.machine_name_userchosen.set_default();
        }
        self.machine_name_userchosen.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name_userchosen(&mut self) -> ::std::string::String {
        self.machine_name_userchosen.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult_sentryfile = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.filesize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_sentryfile)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lock_account_action = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.otp_type = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.otp_identifier)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.otp_sharedsecret)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.otp_value = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name_userchosen)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eresult_sentryfile {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sha_sentryfile.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.lock_account_action {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.otp_type {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.otp_identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.otp_sharedsecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.otp_value {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.machine_name_userchosen.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.eresult_sentryfile {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.filesize {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.sha_sentryfile.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.lock_account_action {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.otp_type {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.otp_identifier.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.otp_sharedsecret.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if let Some(v) = self.otp_value {
            os.write_uint32(10, v)?;
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.machine_name_userchosen.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestMachineAuth {
        CMsgClientRequestMachineAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CMsgClientRequestMachineAuth| { &m.filename },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult_sentryfile",
                |m: &CMsgClientRequestMachineAuth| { &m.eresult_sentryfile },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.eresult_sentryfile },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "filesize",
                |m: &CMsgClientRequestMachineAuth| { &m.filesize },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.filesize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sha_sentryfile",
                |m: &CMsgClientRequestMachineAuth| { &m.sha_sentryfile },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.sha_sentryfile },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lock_account_action",
                |m: &CMsgClientRequestMachineAuth| { &m.lock_account_action },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.lock_account_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "otp_type",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_type },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "otp_identifier",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_identifier },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "otp_sharedsecret",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_sharedsecret },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_sharedsecret },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "otp_value",
                |m: &CMsgClientRequestMachineAuth| { &m.otp_value },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.otp_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "machine_name",
                |m: &CMsgClientRequestMachineAuth| { &m.machine_name },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "machine_name_userchosen",
                |m: &CMsgClientRequestMachineAuth| { &m.machine_name_userchosen },
                |m: &mut CMsgClientRequestMachineAuth| { &mut m.machine_name_userchosen },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestMachineAuth>(
                "CMsgClientRequestMachineAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuth {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestMachineAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestMachineAuth::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestMachineAuth {
    fn clear(&mut self) {
        self.filename.clear();
        self.eresult_sentryfile = ::std::option::Option::None;
        self.filesize = ::std::option::Option::None;
        self.sha_sentryfile.clear();
        self.lock_account_action = ::std::option::Option::None;
        self.otp_type = ::std::option::Option::None;
        self.otp_identifier.clear();
        self.otp_sharedsecret.clear();
        self.otp_value = ::std::option::Option::None;
        self.machine_name.clear();
        self.machine_name_userchosen.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestMachineAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestMachineAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestMachineAuthResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestMachineAuthResponse {
    fn default() -> &'a CMsgClientRequestMachineAuthResponse {
        <CMsgClientRequestMachineAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestMachineAuthResponse {
    pub fn new() -> CMsgClientRequestMachineAuthResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestMachineAuthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestMachineAuthResponse {
        CMsgClientRequestMachineAuthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientRequestMachineAuthResponse| { &m.eresult },
                |m: &mut CMsgClientRequestMachineAuthResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestMachineAuthResponse>(
                "CMsgClientRequestMachineAuthResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestMachineAuthResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestMachineAuthResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestMachineAuthResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestMachineAuthResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestMachineAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestMachineAuthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterKey {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterKey {
    fn default() -> &'a CMsgClientRegisterKey {
        <CMsgClientRegisterKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterKey {
    pub fn new() -> CMsgClientRegisterKey {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRegisterKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterKey {
        CMsgClientRegisterKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &CMsgClientRegisterKey| { &m.key },
                |m: &mut CMsgClientRegisterKey| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRegisterKey>(
                "CMsgClientRegisterKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterKey {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRegisterKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRegisterKey::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterKey {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPurchaseResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    purchase_result_details: ::std::option::Option<i32>,
    purchase_receipt_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseResponse {
    fn default() -> &'a CMsgClientPurchaseResponse {
        <CMsgClientPurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseResponse {
    pub fn new() -> CMsgClientPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 purchase_result_details = 2;


    pub fn get_purchase_result_details(&self) -> i32 {
        self.purchase_result_details.unwrap_or(0)
    }
    pub fn clear_purchase_result_details(&mut self) {
        self.purchase_result_details = ::std::option::Option::None;
    }

    pub fn has_purchase_result_details(&self) -> bool {
        self.purchase_result_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_result_details(&mut self, v: i32) {
        self.purchase_result_details = ::std::option::Option::Some(v);
    }

    // optional bytes purchase_receipt_info = 3;


    pub fn get_purchase_receipt_info(&self) -> &[u8] {
        match self.purchase_receipt_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_purchase_receipt_info(&mut self) {
        self.purchase_receipt_info.clear();
    }

    pub fn has_purchase_receipt_info(&self) -> bool {
        self.purchase_receipt_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_receipt_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.purchase_receipt_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_receipt_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.purchase_receipt_info.is_none() {
            self.purchase_receipt_info.set_default();
        }
        self.purchase_receipt_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_purchase_receipt_info(&mut self) -> ::std::vec::Vec<u8> {
        self.purchase_receipt_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPurchaseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.purchase_result_details = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.purchase_receipt_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_result_details {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.purchase_receipt_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.purchase_result_details {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.purchase_receipt_info.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPurchaseResponse {
        CMsgClientPurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientPurchaseResponse| { &m.eresult },
                |m: &mut CMsgClientPurchaseResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "purchase_result_details",
                |m: &CMsgClientPurchaseResponse| { &m.purchase_result_details },
                |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_result_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "purchase_receipt_info",
                |m: &CMsgClientPurchaseResponse| { &m.purchase_receipt_info },
                |m: &mut CMsgClientPurchaseResponse| { &mut m.purchase_receipt_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPurchaseResponse>(
                "CMsgClientPurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPurchaseResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPurchaseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPurchaseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientPurchaseResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.purchase_result_details = ::std::option::Option::None;
        self.purchase_receipt_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientActivateOEMLicense {
    // message fields
    bios_manufacturer: ::protobuf::SingularField<::std::string::String>,
    bios_serialnumber: ::protobuf::SingularField<::std::string::String>,
    license_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mainboard_manufacturer: ::protobuf::SingularField<::std::string::String>,
    mainboard_product: ::protobuf::SingularField<::std::string::String>,
    mainboard_serialnumber: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientActivateOEMLicense {
    fn default() -> &'a CMsgClientActivateOEMLicense {
        <CMsgClientActivateOEMLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientActivateOEMLicense {
    pub fn new() -> CMsgClientActivateOEMLicense {
        ::std::default::Default::default()
    }

    // optional string bios_manufacturer = 1;


    pub fn get_bios_manufacturer(&self) -> &str {
        match self.bios_manufacturer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bios_manufacturer(&mut self) {
        self.bios_manufacturer.clear();
    }

    pub fn has_bios_manufacturer(&self) -> bool {
        self.bios_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_manufacturer(&mut self, v: ::std::string::String) {
        self.bios_manufacturer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.bios_manufacturer.is_none() {
            self.bios_manufacturer.set_default();
        }
        self.bios_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_manufacturer(&mut self) -> ::std::string::String {
        self.bios_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bios_serialnumber = 2;


    pub fn get_bios_serialnumber(&self) -> &str {
        match self.bios_serialnumber.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bios_serialnumber(&mut self) {
        self.bios_serialnumber.clear();
    }

    pub fn has_bios_serialnumber(&self) -> bool {
        self.bios_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bios_serialnumber(&mut self, v: ::std::string::String) {
        self.bios_serialnumber = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bios_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.bios_serialnumber.is_none() {
            self.bios_serialnumber.set_default();
        }
        self.bios_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_bios_serialnumber(&mut self) -> ::std::string::String {
        self.bios_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes license_file = 3;


    pub fn get_license_file(&self) -> &[u8] {
        match self.license_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_license_file(&mut self) {
        self.license_file.clear();
    }

    pub fn has_license_file(&self) -> bool {
        self.license_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.license_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.license_file.is_none() {
            self.license_file.set_default();
        }
        self.license_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_license_file(&mut self) -> ::std::vec::Vec<u8> {
        self.license_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mainboard_manufacturer = 4;


    pub fn get_mainboard_manufacturer(&self) -> &str {
        match self.mainboard_manufacturer.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mainboard_manufacturer(&mut self) {
        self.mainboard_manufacturer.clear();
    }

    pub fn has_mainboard_manufacturer(&self) -> bool {
        self.mainboard_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_manufacturer(&mut self, v: ::std::string::String) {
        self.mainboard_manufacturer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.mainboard_manufacturer.is_none() {
            self.mainboard_manufacturer.set_default();
        }
        self.mainboard_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_manufacturer(&mut self) -> ::std::string::String {
        self.mainboard_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_product = 5;


    pub fn get_mainboard_product(&self) -> &str {
        match self.mainboard_product.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mainboard_product(&mut self) {
        self.mainboard_product.clear();
    }

    pub fn has_mainboard_product(&self) -> bool {
        self.mainboard_product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_product(&mut self, v: ::std::string::String) {
        self.mainboard_product = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_product(&mut self) -> &mut ::std::string::String {
        if self.mainboard_product.is_none() {
            self.mainboard_product.set_default();
        }
        self.mainboard_product.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_product(&mut self) -> ::std::string::String {
        self.mainboard_product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mainboard_serialnumber = 6;


    pub fn get_mainboard_serialnumber(&self) -> &str {
        match self.mainboard_serialnumber.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mainboard_serialnumber(&mut self) {
        self.mainboard_serialnumber.clear();
    }

    pub fn has_mainboard_serialnumber(&self) -> bool {
        self.mainboard_serialnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard_serialnumber(&mut self, v: ::std::string::String) {
        self.mainboard_serialnumber = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard_serialnumber(&mut self) -> &mut ::std::string::String {
        if self.mainboard_serialnumber.is_none() {
            self.mainboard_serialnumber.set_default();
        }
        self.mainboard_serialnumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard_serialnumber(&mut self) -> ::std::string::String {
        self.mainboard_serialnumber.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientActivateOEMLicense {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bios_manufacturer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bios_serialnumber)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.license_file)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mainboard_manufacturer)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mainboard_product)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mainboard_serialnumber)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bios_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.bios_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.license_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.mainboard_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.mainboard_product.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.mainboard_serialnumber.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bios_manufacturer.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.bios_serialnumber.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.license_file.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.mainboard_manufacturer.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.mainboard_product.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.mainboard_serialnumber.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientActivateOEMLicense {
        CMsgClientActivateOEMLicense::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bios_manufacturer",
                |m: &CMsgClientActivateOEMLicense| { &m.bios_manufacturer },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_manufacturer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bios_serialnumber",
                |m: &CMsgClientActivateOEMLicense| { &m.bios_serialnumber },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.bios_serialnumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "license_file",
                |m: &CMsgClientActivateOEMLicense| { &m.license_file },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.license_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mainboard_manufacturer",
                |m: &CMsgClientActivateOEMLicense| { &m.mainboard_manufacturer },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_manufacturer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mainboard_product",
                |m: &CMsgClientActivateOEMLicense| { &m.mainboard_product },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_product },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mainboard_serialnumber",
                |m: &CMsgClientActivateOEMLicense| { &m.mainboard_serialnumber },
                |m: &mut CMsgClientActivateOEMLicense| { &mut m.mainboard_serialnumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientActivateOEMLicense>(
                "CMsgClientActivateOEMLicense",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientActivateOEMLicense {
        static instance: ::protobuf::rt::LazyV2<CMsgClientActivateOEMLicense> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientActivateOEMLicense::new)
    }
}

impl ::protobuf::Clear for CMsgClientActivateOEMLicense {
    fn clear(&mut self) {
        self.bios_manufacturer.clear();
        self.bios_serialnumber.clear();
        self.license_file.clear();
        self.mainboard_manufacturer.clear();
        self.mainboard_product.clear();
        self.mainboard_serialnumber.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientActivateOEMLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientActivateOEMLicense {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterOEMMachine {
    // message fields
    oem_register_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachine {
    fn default() -> &'a CMsgClientRegisterOEMMachine {
        <CMsgClientRegisterOEMMachine as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachine {
    pub fn new() -> CMsgClientRegisterOEMMachine {
        ::std::default::Default::default()
    }

    // optional bytes oem_register_file = 1;


    pub fn get_oem_register_file(&self) -> &[u8] {
        match self.oem_register_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_oem_register_file(&mut self) {
        self.oem_register_file.clear();
    }

    pub fn has_oem_register_file(&self) -> bool {
        self.oem_register_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oem_register_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.oem_register_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oem_register_file(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.oem_register_file.is_none() {
            self.oem_register_file.set_default();
        }
        self.oem_register_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_oem_register_file(&mut self) -> ::std::vec::Vec<u8> {
        self.oem_register_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachine {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.oem_register_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.oem_register_file.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.oem_register_file.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterOEMMachine {
        CMsgClientRegisterOEMMachine::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "oem_register_file",
                |m: &CMsgClientRegisterOEMMachine| { &m.oem_register_file },
                |m: &mut CMsgClientRegisterOEMMachine| { &mut m.oem_register_file },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRegisterOEMMachine>(
                "CMsgClientRegisterOEMMachine",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachine {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRegisterOEMMachine> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRegisterOEMMachine::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterOEMMachine {
    fn clear(&mut self) {
        self.oem_register_file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterOEMMachine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterOEMMachine {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRegisterOEMMachineResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRegisterOEMMachineResponse {
    fn default() -> &'a CMsgClientRegisterOEMMachineResponse {
        <CMsgClientRegisterOEMMachineResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRegisterOEMMachineResponse {
    pub fn new() -> CMsgClientRegisterOEMMachineResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRegisterOEMMachineResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRegisterOEMMachineResponse {
        CMsgClientRegisterOEMMachineResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientRegisterOEMMachineResponse| { &m.eresult },
                |m: &mut CMsgClientRegisterOEMMachineResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRegisterOEMMachineResponse>(
                "CMsgClientRegisterOEMMachineResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRegisterOEMMachineResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRegisterOEMMachineResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRegisterOEMMachineResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRegisterOEMMachineResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterOEMMachineResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRegisterOEMMachineResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPurchaseWithMachineID {
    // message fields
    package_id: ::std::option::Option<u32>,
    machine_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPurchaseWithMachineID {
    fn default() -> &'a CMsgClientPurchaseWithMachineID {
        <CMsgClientPurchaseWithMachineID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPurchaseWithMachineID {
    pub fn new() -> CMsgClientPurchaseWithMachineID {
        ::std::default::Default::default()
    }

    // optional uint32 package_id = 1;


    pub fn get_package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }
    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional bytes machine_info = 2;


    pub fn get_machine_info(&self) -> &[u8] {
        match self.machine_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_machine_info(&mut self) {
        self.machine_info.clear();
    }

    pub fn has_machine_info(&self) -> bool {
        self.machine_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.machine_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.machine_info.is_none() {
            self.machine_info.set_default();
        }
        self.machine_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_info(&mut self) -> ::std::vec::Vec<u8> {
        self.machine_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientPurchaseWithMachineID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.package_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.machine_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.machine_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.machine_info.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPurchaseWithMachineID {
        CMsgClientPurchaseWithMachineID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "package_id",
                |m: &CMsgClientPurchaseWithMachineID| { &m.package_id },
                |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.package_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "machine_info",
                |m: &CMsgClientPurchaseWithMachineID| { &m.machine_info },
                |m: &mut CMsgClientPurchaseWithMachineID| { &mut m.machine_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPurchaseWithMachineID>(
                "CMsgClientPurchaseWithMachineID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPurchaseWithMachineID {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPurchaseWithMachineID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPurchaseWithMachineID::new)
    }
}

impl ::protobuf::Clear for CMsgClientPurchaseWithMachineID {
    fn clear(&mut self) {
        self.package_id = ::std::option::Option::None;
        self.machine_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPurchaseWithMachineID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPurchaseWithMachineID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_InitiateTradeRequest {
    // message fields
    trade_request_id: ::std::option::Option<u32>,
    other_steamid: ::std::option::Option<u64>,
    other_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeRequest {
    fn default() -> &'a CMsgTrading_InitiateTradeRequest {
        <CMsgTrading_InitiateTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeRequest {
    pub fn new() -> CMsgTrading_InitiateTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint32 trade_request_id = 1;


    pub fn get_trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }
    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 2;


    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }
    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional string other_name = 3;


    pub fn get_other_name(&self) -> &str {
        match self.other_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_other_name(&mut self) {
        self.other_name.clear();
    }

    pub fn has_other_name(&self) -> bool {
        self.other_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_name(&mut self, v: ::std::string::String) {
        self.other_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_name(&mut self) -> &mut ::std::string::String {
        if self.other_name.is_none() {
            self.other_name.set_default();
        }
        self.other_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_name(&mut self) -> ::std::string::String {
        self.other_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trade_request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.other_steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.other_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.other_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.trade_request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.other_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_InitiateTradeRequest {
        CMsgTrading_InitiateTradeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "trade_request_id",
                |m: &CMsgTrading_InitiateTradeRequest| { &m.trade_request_id },
                |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.trade_request_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "other_steamid",
                |m: &CMsgTrading_InitiateTradeRequest| { &m.other_steamid },
                |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "other_name",
                |m: &CMsgTrading_InitiateTradeRequest| { &m.other_name },
                |m: &mut CMsgTrading_InitiateTradeRequest| { &mut m.other_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTrading_InitiateTradeRequest>(
                "CMsgTrading_InitiateTradeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgTrading_InitiateTradeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTrading_InitiateTradeRequest::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_InitiateTradeRequest {
    fn clear(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.other_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_InitiateTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_InitiateTradeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_InitiateTradeResponse {
    // message fields
    response: ::std::option::Option<u32>,
    trade_request_id: ::std::option::Option<u32>,
    other_steamid: ::std::option::Option<u64>,
    steamguard_required_days: ::std::option::Option<u32>,
    new_device_cooldown_days: ::std::option::Option<u32>,
    default_password_reset_probation_days: ::std::option::Option<u32>,
    password_reset_probation_days: ::std::option::Option<u32>,
    default_email_change_probation_days: ::std::option::Option<u32>,
    email_change_probation_days: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_InitiateTradeResponse {
    fn default() -> &'a CMsgTrading_InitiateTradeResponse {
        <CMsgTrading_InitiateTradeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_InitiateTradeResponse {
    pub fn new() -> CMsgTrading_InitiateTradeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;


    pub fn get_response(&self) -> u32 {
        self.response.unwrap_or(0)
    }
    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional uint32 trade_request_id = 2;


    pub fn get_trade_request_id(&self) -> u32 {
        self.trade_request_id.unwrap_or(0)
    }
    pub fn clear_trade_request_id(&mut self) {
        self.trade_request_id = ::std::option::Option::None;
    }

    pub fn has_trade_request_id(&self) -> bool {
        self.trade_request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_request_id(&mut self, v: u32) {
        self.trade_request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 other_steamid = 3;


    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }
    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 steamguard_required_days = 4;


    pub fn get_steamguard_required_days(&self) -> u32 {
        self.steamguard_required_days.unwrap_or(0)
    }
    pub fn clear_steamguard_required_days(&mut self) {
        self.steamguard_required_days = ::std::option::Option::None;
    }

    pub fn has_steamguard_required_days(&self) -> bool {
        self.steamguard_required_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_required_days(&mut self, v: u32) {
        self.steamguard_required_days = ::std::option::Option::Some(v);
    }

    // optional uint32 new_device_cooldown_days = 5;


    pub fn get_new_device_cooldown_days(&self) -> u32 {
        self.new_device_cooldown_days.unwrap_or(0)
    }
    pub fn clear_new_device_cooldown_days(&mut self) {
        self.new_device_cooldown_days = ::std::option::Option::None;
    }

    pub fn has_new_device_cooldown_days(&self) -> bool {
        self.new_device_cooldown_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_device_cooldown_days(&mut self, v: u32) {
        self.new_device_cooldown_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_password_reset_probation_days = 6;


    pub fn get_default_password_reset_probation_days(&self) -> u32 {
        self.default_password_reset_probation_days.unwrap_or(0)
    }
    pub fn clear_default_password_reset_probation_days(&mut self) {
        self.default_password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_password_reset_probation_days(&self) -> bool {
        self.default_password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_password_reset_probation_days(&mut self, v: u32) {
        self.default_password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 password_reset_probation_days = 7;


    pub fn get_password_reset_probation_days(&self) -> u32 {
        self.password_reset_probation_days.unwrap_or(0)
    }
    pub fn clear_password_reset_probation_days(&mut self) {
        self.password_reset_probation_days = ::std::option::Option::None;
    }

    pub fn has_password_reset_probation_days(&self) -> bool {
        self.password_reset_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_reset_probation_days(&mut self, v: u32) {
        self.password_reset_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 default_email_change_probation_days = 8;


    pub fn get_default_email_change_probation_days(&self) -> u32 {
        self.default_email_change_probation_days.unwrap_or(0)
    }
    pub fn clear_default_email_change_probation_days(&mut self) {
        self.default_email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_default_email_change_probation_days(&self) -> bool {
        self.default_email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_email_change_probation_days(&mut self, v: u32) {
        self.default_email_change_probation_days = ::std::option::Option::Some(v);
    }

    // optional uint32 email_change_probation_days = 9;


    pub fn get_email_change_probation_days(&self) -> u32 {
        self.email_change_probation_days.unwrap_or(0)
    }
    pub fn clear_email_change_probation_days(&mut self) {
        self.email_change_probation_days = ::std::option::Option::None;
    }

    pub fn has_email_change_probation_days(&self) -> bool {
        self.email_change_probation_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_change_probation_days(&mut self, v: u32) {
        self.email_change_probation_days = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_InitiateTradeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.trade_request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.other_steamid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.steamguard_required_days = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_device_cooldown_days = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_password_reset_probation_days = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.password_reset_probation_days = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.default_email_change_probation_days = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.email_change_probation_days = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trade_request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamguard_required_days {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_device_cooldown_days {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_password_reset_probation_days {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.password_reset_probation_days {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.default_email_change_probation_days {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.email_change_probation_days {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trade_request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.other_steamid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamguard_required_days {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.new_device_cooldown_days {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.default_password_reset_probation_days {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.password_reset_probation_days {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.default_email_change_probation_days {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.email_change_probation_days {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_InitiateTradeResponse {
        CMsgTrading_InitiateTradeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "response",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.response },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.response },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "trade_request_id",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.trade_request_id },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.trade_request_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "other_steamid",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.other_steamid },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.other_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "steamguard_required_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.steamguard_required_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.steamguard_required_days },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_device_cooldown_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.new_device_cooldown_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.new_device_cooldown_days },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_password_reset_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.default_password_reset_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_password_reset_probation_days },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "password_reset_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.password_reset_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.password_reset_probation_days },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "default_email_change_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.default_email_change_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.default_email_change_probation_days },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "email_change_probation_days",
                |m: &CMsgTrading_InitiateTradeResponse| { &m.email_change_probation_days },
                |m: &mut CMsgTrading_InitiateTradeResponse| { &mut m.email_change_probation_days },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTrading_InitiateTradeResponse>(
                "CMsgTrading_InitiateTradeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_InitiateTradeResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgTrading_InitiateTradeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTrading_InitiateTradeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_InitiateTradeResponse {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.trade_request_id = ::std::option::Option::None;
        self.other_steamid = ::std::option::Option::None;
        self.steamguard_required_days = ::std::option::Option::None;
        self.new_device_cooldown_days = ::std::option::Option::None;
        self.default_password_reset_probation_days = ::std::option::Option::None;
        self.password_reset_probation_days = ::std::option::Option::None;
        self.default_email_change_probation_days = ::std::option::Option::None;
        self.email_change_probation_days = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_InitiateTradeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_InitiateTradeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_CancelTradeRequest {
    // message fields
    other_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_CancelTradeRequest {
    fn default() -> &'a CMsgTrading_CancelTradeRequest {
        <CMsgTrading_CancelTradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_CancelTradeRequest {
    pub fn new() -> CMsgTrading_CancelTradeRequest {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;


    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }
    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_CancelTradeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.other_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_CancelTradeRequest {
        CMsgTrading_CancelTradeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "other_steamid",
                |m: &CMsgTrading_CancelTradeRequest| { &m.other_steamid },
                |m: &mut CMsgTrading_CancelTradeRequest| { &mut m.other_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTrading_CancelTradeRequest>(
                "CMsgTrading_CancelTradeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_CancelTradeRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgTrading_CancelTradeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTrading_CancelTradeRequest::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_CancelTradeRequest {
    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_CancelTradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_CancelTradeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrading_StartSession {
    // message fields
    other_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrading_StartSession {
    fn default() -> &'a CMsgTrading_StartSession {
        <CMsgTrading_StartSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrading_StartSession {
    pub fn new() -> CMsgTrading_StartSession {
        ::std::default::Default::default()
    }

    // optional uint64 other_steamid = 1;


    pub fn get_other_steamid(&self) -> u64 {
        self.other_steamid.unwrap_or(0)
    }
    pub fn clear_other_steamid(&mut self) {
        self.other_steamid = ::std::option::Option::None;
    }

    pub fn has_other_steamid(&self) -> bool {
        self.other_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_steamid(&mut self, v: u64) {
        self.other_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrading_StartSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.other_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.other_steamid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.other_steamid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrading_StartSession {
        CMsgTrading_StartSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "other_steamid",
                |m: &CMsgTrading_StartSession| { &m.other_steamid },
                |m: &mut CMsgTrading_StartSession| { &mut m.other_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTrading_StartSession>(
                "CMsgTrading_StartSession",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrading_StartSession {
        static instance: ::protobuf::rt::LazyV2<CMsgTrading_StartSession> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTrading_StartSession::new)
    }
}

impl ::protobuf::Clear for CMsgTrading_StartSession {
    fn clear(&mut self) {
        self.other_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrading_StartSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrading_StartSession {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetCDNAuthToken {
    // message fields
    depot_id: ::std::option::Option<u32>,
    host_name: ::protobuf::SingularField<::std::string::String>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthToken {
    fn default() -> &'a CMsgClientGetCDNAuthToken {
        <CMsgClientGetCDNAuthToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthToken {
    pub fn new() -> CMsgClientGetCDNAuthToken {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;


    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }
    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional string host_name = 2;


    pub fn get_host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host_name(&mut self) {
        self.host_name.clear();
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name.set_default();
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 app_id = 3;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depot_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.host_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetCDNAuthToken {
        CMsgClientGetCDNAuthToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depot_id",
                |m: &CMsgClientGetCDNAuthToken| { &m.depot_id },
                |m: &mut CMsgClientGetCDNAuthToken| { &mut m.depot_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_name",
                |m: &CMsgClientGetCDNAuthToken| { &m.host_name },
                |m: &mut CMsgClientGetCDNAuthToken| { &mut m.host_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientGetCDNAuthToken| { &m.app_id },
                |m: &mut CMsgClientGetCDNAuthToken| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetCDNAuthToken>(
                "CMsgClientGetCDNAuthToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthToken {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetCDNAuthToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetCDNAuthToken::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetCDNAuthToken {
    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.host_name.clear();
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetCDNAuthToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetCDNAuthToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetDepotDecryptionKey {
    // message fields
    depot_id: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKey {
    fn default() -> &'a CMsgClientGetDepotDecryptionKey {
        <CMsgClientGetDepotDecryptionKey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKey {
    pub fn new() -> CMsgClientGetDepotDecryptionKey {
        ::std::default::Default::default()
    }

    // optional uint32 depot_id = 1;


    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }
    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depot_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.depot_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetDepotDecryptionKey {
        CMsgClientGetDepotDecryptionKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depot_id",
                |m: &CMsgClientGetDepotDecryptionKey| { &m.depot_id },
                |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.depot_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientGetDepotDecryptionKey| { &m.app_id },
                |m: &mut CMsgClientGetDepotDecryptionKey| { &mut m.app_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetDepotDecryptionKey>(
                "CMsgClientGetDepotDecryptionKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKey {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetDepotDecryptionKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetDepotDecryptionKey::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetDepotDecryptionKey {
    fn clear(&mut self) {
        self.depot_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetDepotDecryptionKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetDepotDecryptionKeyResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    depot_id: ::std::option::Option<u32>,
    depot_encryption_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetDepotDecryptionKeyResponse {
    fn default() -> &'a CMsgClientGetDepotDecryptionKeyResponse {
        <CMsgClientGetDepotDecryptionKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetDepotDecryptionKeyResponse {
    pub fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 depot_id = 2;


    pub fn get_depot_id(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }
    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    // optional bytes depot_encryption_key = 3;


    pub fn get_depot_encryption_key(&self) -> &[u8] {
        match self.depot_encryption_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_depot_encryption_key(&mut self) {
        self.depot_encryption_key.clear();
    }

    pub fn has_depot_encryption_key(&self) -> bool {
        self.depot_encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.depot_encryption_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_depot_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.depot_encryption_key.is_none() {
            self.depot_encryption_key.set_default();
        }
        self.depot_encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_depot_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.depot_encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetDepotDecryptionKeyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depot_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.depot_encryption_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.depot_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.depot_encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.depot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.depot_encryption_key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetDepotDecryptionKeyResponse {
        CMsgClientGetDepotDecryptionKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.eresult },
                |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depot_id",
                |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_id },
                |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "depot_encryption_key",
                |m: &CMsgClientGetDepotDecryptionKeyResponse| { &m.depot_encryption_key },
                |m: &mut CMsgClientGetDepotDecryptionKeyResponse| { &mut m.depot_encryption_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetDepotDecryptionKeyResponse>(
                "CMsgClientGetDepotDecryptionKeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetDepotDecryptionKeyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetDepotDecryptionKeyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetDepotDecryptionKeyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetDepotDecryptionKeyResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.depot_id = ::std::option::Option::None;
        self.depot_encryption_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetDepotDecryptionKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetDepotDecryptionKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckAppBetaPassword {
    // message fields
    app_id: ::std::option::Option<u32>,
    betapassword: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPassword {
    fn default() -> &'a CMsgClientCheckAppBetaPassword {
        <CMsgClientCheckAppBetaPassword as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPassword {
    pub fn new() -> CMsgClientCheckAppBetaPassword {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string betapassword = 2;


    pub fn get_betapassword(&self) -> &str {
        match self.betapassword.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_betapassword(&mut self) {
        self.betapassword.clear();
    }

    pub fn has_betapassword(&self) -> bool {
        self.betapassword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_betapassword(&mut self, v: ::std::string::String) {
        self.betapassword = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
        if self.betapassword.is_none() {
            self.betapassword.set_default();
        }
        self.betapassword.as_mut().unwrap()
    }

    // Take field
    pub fn take_betapassword(&mut self) -> ::std::string::String {
        self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPassword {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.betapassword)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.betapassword.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.betapassword.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckAppBetaPassword {
        CMsgClientCheckAppBetaPassword::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientCheckAppBetaPassword| { &m.app_id },
                |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "betapassword",
                |m: &CMsgClientCheckAppBetaPassword| { &m.betapassword },
                |m: &mut CMsgClientCheckAppBetaPassword| { &mut m.betapassword },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCheckAppBetaPassword>(
                "CMsgClientCheckAppBetaPassword",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPassword {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCheckAppBetaPassword> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCheckAppBetaPassword::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckAppBetaPassword {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.betapassword.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckAppBetaPassword {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckAppBetaPassword {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckAppBetaPasswordResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub betapasswords: ::protobuf::RepeatedField<CMsgClientCheckAppBetaPasswordResponse_BetaPassword>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPasswordResponse {
    fn default() -> &'a CMsgClientCheckAppBetaPasswordResponse {
        <CMsgClientCheckAppBetaPasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPasswordResponse {
    pub fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientCheckAppBetaPasswordResponse.BetaPassword betapasswords = 4;


    pub fn get_betapasswords(&self) -> &[CMsgClientCheckAppBetaPasswordResponse_BetaPassword] {
        &self.betapasswords
    }
    pub fn clear_betapasswords(&mut self) {
        self.betapasswords.clear();
    }

    // Param is passed by value, moved
    pub fn set_betapasswords(&mut self, v: ::protobuf::RepeatedField<CMsgClientCheckAppBetaPasswordResponse_BetaPassword>) {
        self.betapasswords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_betapasswords(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientCheckAppBetaPasswordResponse_BetaPassword> {
        &mut self.betapasswords
    }

    // Take field
    pub fn take_betapasswords(&mut self) -> ::protobuf::RepeatedField<CMsgClientCheckAppBetaPasswordResponse_BetaPassword> {
        ::std::mem::replace(&mut self.betapasswords, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPasswordResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.betapasswords {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.betapasswords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.betapasswords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.betapasswords {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckAppBetaPasswordResponse {
        CMsgClientCheckAppBetaPasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.eresult },
                |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientCheckAppBetaPasswordResponse_BetaPassword>>(
                "betapasswords",
                |m: &CMsgClientCheckAppBetaPasswordResponse| { &m.betapasswords },
                |m: &mut CMsgClientCheckAppBetaPasswordResponse| { &mut m.betapasswords },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCheckAppBetaPasswordResponse>(
                "CMsgClientCheckAppBetaPasswordResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPasswordResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCheckAppBetaPasswordResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCheckAppBetaPasswordResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckAppBetaPasswordResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.betapasswords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckAppBetaPasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckAppBetaPasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    // message fields
    betaname: ::protobuf::SingularField<::std::string::String>,
    betapassword: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    fn default() -> &'a CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
        <CMsgClientCheckAppBetaPasswordResponse_BetaPassword as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    pub fn new() -> CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
        ::std::default::Default::default()
    }

    // optional string betaname = 1;


    pub fn get_betaname(&self) -> &str {
        match self.betaname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_betaname(&mut self) {
        self.betaname.clear();
    }

    pub fn has_betaname(&self) -> bool {
        self.betaname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_betaname(&mut self, v: ::std::string::String) {
        self.betaname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_betaname(&mut self) -> &mut ::std::string::String {
        if self.betaname.is_none() {
            self.betaname.set_default();
        }
        self.betaname.as_mut().unwrap()
    }

    // Take field
    pub fn take_betaname(&mut self) -> ::std::string::String {
        self.betaname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string betapassword = 2;


    pub fn get_betapassword(&self) -> &str {
        match self.betapassword.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_betapassword(&mut self) {
        self.betapassword.clear();
    }

    pub fn has_betapassword(&self) -> bool {
        self.betapassword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_betapassword(&mut self, v: ::std::string::String) {
        self.betapassword = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_betapassword(&mut self) -> &mut ::std::string::String {
        if self.betapassword.is_none() {
            self.betapassword.set_default();
        }
        self.betapassword.as_mut().unwrap()
    }

    // Take field
    pub fn take_betapassword(&mut self) -> ::std::string::String {
        self.betapassword.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.betaname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.betapassword)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.betaname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.betapassword.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.betaname.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.betapassword.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
        CMsgClientCheckAppBetaPasswordResponse_BetaPassword::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "betaname",
                |m: &CMsgClientCheckAppBetaPasswordResponse_BetaPassword| { &m.betaname },
                |m: &mut CMsgClientCheckAppBetaPasswordResponse_BetaPassword| { &mut m.betaname },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "betapassword",
                |m: &CMsgClientCheckAppBetaPasswordResponse_BetaPassword| { &m.betapassword },
                |m: &mut CMsgClientCheckAppBetaPasswordResponse_BetaPassword| { &mut m.betapassword },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCheckAppBetaPasswordResponse_BetaPassword>(
                "CMsgClientCheckAppBetaPasswordResponse.BetaPassword",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCheckAppBetaPasswordResponse_BetaPassword> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCheckAppBetaPasswordResponse_BetaPassword::new)
    }
}

impl ::protobuf::Clear for CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    fn clear(&mut self) {
        self.betaname.clear();
        self.betapassword.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUpdateAppJobReport {
    // message fields
    app_id: ::std::option::Option<u32>,
    pub depot_ids: ::std::vec::Vec<u32>,
    app_state: ::std::option::Option<u32>,
    job_app_error: ::std::option::Option<u32>,
    error_details: ::protobuf::SingularField<::std::string::String>,
    job_duration: ::std::option::Option<u32>,
    files_validation_failed: ::std::option::Option<u32>,
    job_bytes_downloaded: ::std::option::Option<u64>,
    job_bytes_staged: ::std::option::Option<u64>,
    bytes_comitted: ::std::option::Option<u64>,
    start_app_state: ::std::option::Option<u32>,
    stats_machine_id: ::std::option::Option<u64>,
    branch_name: ::protobuf::SingularField<::std::string::String>,
    total_bytes_downloaded: ::std::option::Option<u64>,
    total_bytes_staged: ::std::option::Option<u64>,
    total_bytes_restored: ::std::option::Option<u64>,
    is_borrowed: ::std::option::Option<bool>,
    is_free_weekend: ::std::option::Option<bool>,
    total_bytes_legacy: ::std::option::Option<u64>,
    total_bytes_patched: ::std::option::Option<u64>,
    total_bytes_saved: ::std::option::Option<u64>,
    cell_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUpdateAppJobReport {
    fn default() -> &'a CMsgClientUpdateAppJobReport {
        <CMsgClientUpdateAppJobReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUpdateAppJobReport {
    pub fn new() -> CMsgClientUpdateAppJobReport {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 depot_ids = 2;


    pub fn get_depot_ids(&self) -> &[u32] {
        &self.depot_ids
    }
    pub fn clear_depot_ids(&mut self) {
        self.depot_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_depot_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.depot_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_depot_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.depot_ids
    }

    // Take field
    pub fn take_depot_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.depot_ids, ::std::vec::Vec::new())
    }

    // optional uint32 app_state = 3;


    pub fn get_app_state(&self) -> u32 {
        self.app_state.unwrap_or(0)
    }
    pub fn clear_app_state(&mut self) {
        self.app_state = ::std::option::Option::None;
    }

    pub fn has_app_state(&self) -> bool {
        self.app_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_state(&mut self, v: u32) {
        self.app_state = ::std::option::Option::Some(v);
    }

    // optional uint32 job_app_error = 4;


    pub fn get_job_app_error(&self) -> u32 {
        self.job_app_error.unwrap_or(0)
    }
    pub fn clear_job_app_error(&mut self) {
        self.job_app_error = ::std::option::Option::None;
    }

    pub fn has_job_app_error(&self) -> bool {
        self.job_app_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_app_error(&mut self, v: u32) {
        self.job_app_error = ::std::option::Option::Some(v);
    }

    // optional string error_details = 5;


    pub fn get_error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_details(&mut self) {
        self.error_details.clear();
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details.set_default();
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 job_duration = 6;


    pub fn get_job_duration(&self) -> u32 {
        self.job_duration.unwrap_or(0)
    }
    pub fn clear_job_duration(&mut self) {
        self.job_duration = ::std::option::Option::None;
    }

    pub fn has_job_duration(&self) -> bool {
        self.job_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_duration(&mut self, v: u32) {
        self.job_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 files_validation_failed = 7;


    pub fn get_files_validation_failed(&self) -> u32 {
        self.files_validation_failed.unwrap_or(0)
    }
    pub fn clear_files_validation_failed(&mut self) {
        self.files_validation_failed = ::std::option::Option::None;
    }

    pub fn has_files_validation_failed(&self) -> bool {
        self.files_validation_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_validation_failed(&mut self, v: u32) {
        self.files_validation_failed = ::std::option::Option::Some(v);
    }

    // optional uint64 job_bytes_downloaded = 8;


    pub fn get_job_bytes_downloaded(&self) -> u64 {
        self.job_bytes_downloaded.unwrap_or(0)
    }
    pub fn clear_job_bytes_downloaded(&mut self) {
        self.job_bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_job_bytes_downloaded(&self) -> bool {
        self.job_bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_bytes_downloaded(&mut self, v: u64) {
        self.job_bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 job_bytes_staged = 9;


    pub fn get_job_bytes_staged(&self) -> u64 {
        self.job_bytes_staged.unwrap_or(0)
    }
    pub fn clear_job_bytes_staged(&mut self) {
        self.job_bytes_staged = ::std::option::Option::None;
    }

    pub fn has_job_bytes_staged(&self) -> bool {
        self.job_bytes_staged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_bytes_staged(&mut self, v: u64) {
        self.job_bytes_staged = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes_comitted = 10;


    pub fn get_bytes_comitted(&self) -> u64 {
        self.bytes_comitted.unwrap_or(0)
    }
    pub fn clear_bytes_comitted(&mut self) {
        self.bytes_comitted = ::std::option::Option::None;
    }

    pub fn has_bytes_comitted(&self) -> bool {
        self.bytes_comitted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_comitted(&mut self, v: u64) {
        self.bytes_comitted = ::std::option::Option::Some(v);
    }

    // optional uint32 start_app_state = 11;


    pub fn get_start_app_state(&self) -> u32 {
        self.start_app_state.unwrap_or(0)
    }
    pub fn clear_start_app_state(&mut self) {
        self.start_app_state = ::std::option::Option::None;
    }

    pub fn has_start_app_state(&self) -> bool {
        self.start_app_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_app_state(&mut self, v: u32) {
        self.start_app_state = ::std::option::Option::Some(v);
    }

    // optional fixed64 stats_machine_id = 12;


    pub fn get_stats_machine_id(&self) -> u64 {
        self.stats_machine_id.unwrap_or(0)
    }
    pub fn clear_stats_machine_id(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
    }

    pub fn has_stats_machine_id(&self) -> bool {
        self.stats_machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_machine_id(&mut self, v: u64) {
        self.stats_machine_id = ::std::option::Option::Some(v);
    }

    // optional string branch_name = 13;


    pub fn get_branch_name(&self) -> &str {
        match self.branch_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_branch_name(&mut self) {
        self.branch_name.clear();
    }

    pub fn has_branch_name(&self) -> bool {
        self.branch_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_name(&mut self, v: ::std::string::String) {
        self.branch_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch_name(&mut self) -> &mut ::std::string::String {
        if self.branch_name.is_none() {
            self.branch_name.set_default();
        }
        self.branch_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_branch_name(&mut self) -> ::std::string::String {
        self.branch_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 total_bytes_downloaded = 14;


    pub fn get_total_bytes_downloaded(&self) -> u64 {
        self.total_bytes_downloaded.unwrap_or(0)
    }
    pub fn clear_total_bytes_downloaded(&mut self) {
        self.total_bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_total_bytes_downloaded(&self) -> bool {
        self.total_bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_downloaded(&mut self, v: u64) {
        self.total_bytes_downloaded = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_staged = 15;


    pub fn get_total_bytes_staged(&self) -> u64 {
        self.total_bytes_staged.unwrap_or(0)
    }
    pub fn clear_total_bytes_staged(&mut self) {
        self.total_bytes_staged = ::std::option::Option::None;
    }

    pub fn has_total_bytes_staged(&self) -> bool {
        self.total_bytes_staged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_staged(&mut self, v: u64) {
        self.total_bytes_staged = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_restored = 16;


    pub fn get_total_bytes_restored(&self) -> u64 {
        self.total_bytes_restored.unwrap_or(0)
    }
    pub fn clear_total_bytes_restored(&mut self) {
        self.total_bytes_restored = ::std::option::Option::None;
    }

    pub fn has_total_bytes_restored(&self) -> bool {
        self.total_bytes_restored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_restored(&mut self, v: u64) {
        self.total_bytes_restored = ::std::option::Option::Some(v);
    }

    // optional bool is_borrowed = 17;


    pub fn get_is_borrowed(&self) -> bool {
        self.is_borrowed.unwrap_or(false)
    }
    pub fn clear_is_borrowed(&mut self) {
        self.is_borrowed = ::std::option::Option::None;
    }

    pub fn has_is_borrowed(&self) -> bool {
        self.is_borrowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_borrowed(&mut self, v: bool) {
        self.is_borrowed = ::std::option::Option::Some(v);
    }

    // optional bool is_free_weekend = 18;


    pub fn get_is_free_weekend(&self) -> bool {
        self.is_free_weekend.unwrap_or(false)
    }
    pub fn clear_is_free_weekend(&mut self) {
        self.is_free_weekend = ::std::option::Option::None;
    }

    pub fn has_is_free_weekend(&self) -> bool {
        self.is_free_weekend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_free_weekend(&mut self, v: bool) {
        self.is_free_weekend = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_legacy = 19;


    pub fn get_total_bytes_legacy(&self) -> u64 {
        self.total_bytes_legacy.unwrap_or(0)
    }
    pub fn clear_total_bytes_legacy(&mut self) {
        self.total_bytes_legacy = ::std::option::Option::None;
    }

    pub fn has_total_bytes_legacy(&self) -> bool {
        self.total_bytes_legacy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_legacy(&mut self, v: u64) {
        self.total_bytes_legacy = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_patched = 20;


    pub fn get_total_bytes_patched(&self) -> u64 {
        self.total_bytes_patched.unwrap_or(0)
    }
    pub fn clear_total_bytes_patched(&mut self) {
        self.total_bytes_patched = ::std::option::Option::None;
    }

    pub fn has_total_bytes_patched(&self) -> bool {
        self.total_bytes_patched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_patched(&mut self, v: u64) {
        self.total_bytes_patched = ::std::option::Option::Some(v);
    }

    // optional uint64 total_bytes_saved = 21;


    pub fn get_total_bytes_saved(&self) -> u64 {
        self.total_bytes_saved.unwrap_or(0)
    }
    pub fn clear_total_bytes_saved(&mut self) {
        self.total_bytes_saved = ::std::option::Option::None;
    }

    pub fn has_total_bytes_saved(&self) -> bool {
        self.total_bytes_saved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_bytes_saved(&mut self, v: u64) {
        self.total_bytes_saved = ::std::option::Option::Some(v);
    }

    // optional uint32 cell_id = 22;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUpdateAppJobReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.depot_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_state = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.job_app_error = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_details)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.job_duration = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.files_validation_failed = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.job_bytes_downloaded = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.job_bytes_staged = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_comitted = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_app_state = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.stats_machine_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.branch_name)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes_downloaded = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes_staged = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes_restored = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_borrowed = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_free_weekend = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes_legacy = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes_patched = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes_saved = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.depot_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.app_state {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.job_app_error {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.job_duration {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.files_validation_failed {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.job_bytes_downloaded {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.job_bytes_staged {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_comitted {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_app_state {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stats_machine_id {
            my_size += 9;
        }
        if let Some(ref v) = self.branch_name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.total_bytes_downloaded {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_staged {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_restored {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_borrowed {
            my_size += 3;
        }
        if let Some(v) = self.is_free_weekend {
            my_size += 3;
        }
        if let Some(v) = self.total_bytes_legacy {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_patched {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_bytes_saved {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.depot_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.app_state {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.job_app_error {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.error_details.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.job_duration {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.files_validation_failed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.job_bytes_downloaded {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.job_bytes_staged {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.bytes_comitted {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.start_app_state {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.stats_machine_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(ref v) = self.branch_name.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.total_bytes_downloaded {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.total_bytes_staged {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.total_bytes_restored {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.is_borrowed {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.is_free_weekend {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.total_bytes_legacy {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.total_bytes_patched {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.total_bytes_saved {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.cell_id {
            os.write_uint32(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUpdateAppJobReport {
        CMsgClientUpdateAppJobReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientUpdateAppJobReport| { &m.app_id },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "depot_ids",
                |m: &CMsgClientUpdateAppJobReport| { &m.depot_ids },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.depot_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_state",
                |m: &CMsgClientUpdateAppJobReport| { &m.app_state },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.app_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "job_app_error",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_app_error },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_app_error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_details",
                |m: &CMsgClientUpdateAppJobReport| { &m.error_details },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.error_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "job_duration",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_duration },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "files_validation_failed",
                |m: &CMsgClientUpdateAppJobReport| { &m.files_validation_failed },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.files_validation_failed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "job_bytes_downloaded",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_bytes_downloaded },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_bytes_downloaded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "job_bytes_staged",
                |m: &CMsgClientUpdateAppJobReport| { &m.job_bytes_staged },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.job_bytes_staged },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes_comitted",
                |m: &CMsgClientUpdateAppJobReport| { &m.bytes_comitted },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.bytes_comitted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_app_state",
                |m: &CMsgClientUpdateAppJobReport| { &m.start_app_state },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.start_app_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "stats_machine_id",
                |m: &CMsgClientUpdateAppJobReport| { &m.stats_machine_id },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.stats_machine_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "branch_name",
                |m: &CMsgClientUpdateAppJobReport| { &m.branch_name },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.branch_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_bytes_downloaded",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_downloaded },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_downloaded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_bytes_staged",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_staged },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_staged },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_bytes_restored",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_restored },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_restored },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_borrowed",
                |m: &CMsgClientUpdateAppJobReport| { &m.is_borrowed },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.is_borrowed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_free_weekend",
                |m: &CMsgClientUpdateAppJobReport| { &m.is_free_weekend },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.is_free_weekend },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_bytes_legacy",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_legacy },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_legacy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_bytes_patched",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_patched },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_patched },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_bytes_saved",
                |m: &CMsgClientUpdateAppJobReport| { &m.total_bytes_saved },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.total_bytes_saved },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cell_id",
                |m: &CMsgClientUpdateAppJobReport| { &m.cell_id },
                |m: &mut CMsgClientUpdateAppJobReport| { &mut m.cell_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUpdateAppJobReport>(
                "CMsgClientUpdateAppJobReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUpdateAppJobReport {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUpdateAppJobReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUpdateAppJobReport::new)
    }
}

impl ::protobuf::Clear for CMsgClientUpdateAppJobReport {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.depot_ids.clear();
        self.app_state = ::std::option::Option::None;
        self.job_app_error = ::std::option::Option::None;
        self.error_details.clear();
        self.job_duration = ::std::option::Option::None;
        self.files_validation_failed = ::std::option::Option::None;
        self.job_bytes_downloaded = ::std::option::Option::None;
        self.job_bytes_staged = ::std::option::Option::None;
        self.bytes_comitted = ::std::option::Option::None;
        self.start_app_state = ::std::option::Option::None;
        self.stats_machine_id = ::std::option::Option::None;
        self.branch_name.clear();
        self.total_bytes_downloaded = ::std::option::Option::None;
        self.total_bytes_staged = ::std::option::Option::None;
        self.total_bytes_restored = ::std::option::Option::None;
        self.is_borrowed = ::std::option::Option::None;
        self.is_free_weekend = ::std::option::Option::None;
        self.total_bytes_legacy = ::std::option::Option::None;
        self.total_bytes_patched = ::std::option::Option::None;
        self.total_bytes_saved = ::std::option::Option::None;
        self.cell_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUpdateAppJobReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUpdateAppJobReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPContentStatsReport {
    // message fields
    stats_machine_id: ::std::option::Option<u64>,
    country_code: ::protobuf::SingularField<::std::string::String>,
    os_type: ::std::option::Option<i32>,
    language: ::std::option::Option<i32>,
    num_install_folders: ::std::option::Option<u32>,
    num_installed_games: ::std::option::Option<u32>,
    size_installed_games: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPContentStatsReport {
    fn default() -> &'a CMsgClientDPContentStatsReport {
        <CMsgClientDPContentStatsReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPContentStatsReport {
    pub fn new() -> CMsgClientDPContentStatsReport {
        ::std::default::Default::default()
    }

    // optional fixed64 stats_machine_id = 1;


    pub fn get_stats_machine_id(&self) -> u64 {
        self.stats_machine_id.unwrap_or(0)
    }
    pub fn clear_stats_machine_id(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
    }

    pub fn has_stats_machine_id(&self) -> bool {
        self.stats_machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_machine_id(&mut self, v: u64) {
        self.stats_machine_id = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;


    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 os_type = 3;


    pub fn get_os_type(&self) -> i32 {
        self.os_type.unwrap_or(0)
    }
    pub fn clear_os_type(&mut self) {
        self.os_type = ::std::option::Option::None;
    }

    pub fn has_os_type(&self) -> bool {
        self.os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_type(&mut self, v: i32) {
        self.os_type = ::std::option::Option::Some(v);
    }

    // optional int32 language = 4;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint32 num_install_folders = 5;


    pub fn get_num_install_folders(&self) -> u32 {
        self.num_install_folders.unwrap_or(0)
    }
    pub fn clear_num_install_folders(&mut self) {
        self.num_install_folders = ::std::option::Option::None;
    }

    pub fn has_num_install_folders(&self) -> bool {
        self.num_install_folders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_install_folders(&mut self, v: u32) {
        self.num_install_folders = ::std::option::Option::Some(v);
    }

    // optional uint32 num_installed_games = 6;


    pub fn get_num_installed_games(&self) -> u32 {
        self.num_installed_games.unwrap_or(0)
    }
    pub fn clear_num_installed_games(&mut self) {
        self.num_installed_games = ::std::option::Option::None;
    }

    pub fn has_num_installed_games(&self) -> bool {
        self.num_installed_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_installed_games(&mut self, v: u32) {
        self.num_installed_games = ::std::option::Option::Some(v);
    }

    // optional uint64 size_installed_games = 7;


    pub fn get_size_installed_games(&self) -> u64 {
        self.size_installed_games.unwrap_or(0)
    }
    pub fn clear_size_installed_games(&mut self) {
        self.size_installed_games = ::std::option::Option::None;
    }

    pub fn has_size_installed_games(&self) -> bool {
        self.size_installed_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_installed_games(&mut self, v: u64) {
        self.size_installed_games = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDPContentStatsReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.stats_machine_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.os_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_install_folders = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_installed_games = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size_installed_games = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stats_machine_id {
            my_size += 9;
        }
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.os_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_install_folders {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_installed_games {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size_installed_games {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stats_machine_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.os_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.num_install_folders {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_installed_games {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.size_installed_games {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPContentStatsReport {
        CMsgClientDPContentStatsReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "stats_machine_id",
                |m: &CMsgClientDPContentStatsReport| { &m.stats_machine_id },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.stats_machine_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country_code",
                |m: &CMsgClientDPContentStatsReport| { &m.country_code },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.country_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "os_type",
                |m: &CMsgClientDPContentStatsReport| { &m.os_type },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.os_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "language",
                |m: &CMsgClientDPContentStatsReport| { &m.language },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_install_folders",
                |m: &CMsgClientDPContentStatsReport| { &m.num_install_folders },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.num_install_folders },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_installed_games",
                |m: &CMsgClientDPContentStatsReport| { &m.num_installed_games },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.num_installed_games },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "size_installed_games",
                |m: &CMsgClientDPContentStatsReport| { &m.size_installed_games },
                |m: &mut CMsgClientDPContentStatsReport| { &mut m.size_installed_games },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDPContentStatsReport>(
                "CMsgClientDPContentStatsReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPContentStatsReport {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDPContentStatsReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDPContentStatsReport::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPContentStatsReport {
    fn clear(&mut self) {
        self.stats_machine_id = ::std::option::Option::None;
        self.country_code.clear();
        self.os_type = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.num_install_folders = ::std::option::Option::None;
        self.num_installed_games = ::std::option::Option::None;
        self.size_installed_games = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPContentStatsReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPContentStatsReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetCDNAuthTokenResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::string::String>,
    expiration_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetCDNAuthTokenResponse {
    fn default() -> &'a CMsgClientGetCDNAuthTokenResponse {
        <CMsgClientGetCDNAuthTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetCDNAuthTokenResponse {
    pub fn new() -> CMsgClientGetCDNAuthTokenResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string token = 2;


    pub fn get_token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 expiration_time = 3;


    pub fn get_expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetCDNAuthTokenResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetCDNAuthTokenResponse {
        CMsgClientGetCDNAuthTokenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientGetCDNAuthTokenResponse| { &m.eresult },
                |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &CMsgClientGetCDNAuthTokenResponse| { &m.token },
                |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expiration_time",
                |m: &CMsgClientGetCDNAuthTokenResponse| { &m.expiration_time },
                |m: &mut CMsgClientGetCDNAuthTokenResponse| { &mut m.expiration_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetCDNAuthTokenResponse>(
                "CMsgClientGetCDNAuthTokenResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetCDNAuthTokenResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetCDNAuthTokenResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetCDNAuthTokenResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetCDNAuthTokenResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.token.clear();
        self.expiration_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetCDNAuthTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetCDNAuthTokenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDownloadRateStatistics {
    // message fields
    cell_id: ::std::option::Option<u32>,
    pub stats: ::protobuf::RepeatedField<CMsgDownloadRateStatistics_StatsInfo>,
    throttling_kbps: ::std::option::Option<u32>,
    steam_realm: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDownloadRateStatistics {
    fn default() -> &'a CMsgDownloadRateStatistics {
        <CMsgDownloadRateStatistics as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDownloadRateStatistics {
    pub fn new() -> CMsgDownloadRateStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 cell_id = 1;


    pub fn get_cell_id(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }
    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgDownloadRateStatistics.StatsInfo stats = 2;


    pub fn get_stats(&self) -> &[CMsgDownloadRateStatistics_StatsInfo] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CMsgDownloadRateStatistics_StatsInfo>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgDownloadRateStatistics_StatsInfo> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CMsgDownloadRateStatistics_StatsInfo> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    // optional uint32 throttling_kbps = 3;


    pub fn get_throttling_kbps(&self) -> u32 {
        self.throttling_kbps.unwrap_or(0)
    }
    pub fn clear_throttling_kbps(&mut self) {
        self.throttling_kbps = ::std::option::Option::None;
    }

    pub fn has_throttling_kbps(&self) -> bool {
        self.throttling_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttling_kbps(&mut self, v: u32) {
        self.throttling_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_realm = 4;


    pub fn get_steam_realm(&self) -> u32 {
        self.steam_realm.unwrap_or(0)
    }
    pub fn clear_steam_realm(&mut self) {
        self.steam_realm = ::std::option::Option::None;
    }

    pub fn has_steam_realm(&self) -> bool {
        self.steam_realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_realm(&mut self, v: u32) {
        self.steam_realm = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDownloadRateStatistics {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.throttling_kbps = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.steam_realm = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cell_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.throttling_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_realm {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cell_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.throttling_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steam_realm {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDownloadRateStatistics {
        CMsgDownloadRateStatistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cell_id",
                |m: &CMsgDownloadRateStatistics| { &m.cell_id },
                |m: &mut CMsgDownloadRateStatistics| { &mut m.cell_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgDownloadRateStatistics_StatsInfo>>(
                "stats",
                |m: &CMsgDownloadRateStatistics| { &m.stats },
                |m: &mut CMsgDownloadRateStatistics| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "throttling_kbps",
                |m: &CMsgDownloadRateStatistics| { &m.throttling_kbps },
                |m: &mut CMsgDownloadRateStatistics| { &mut m.throttling_kbps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "steam_realm",
                |m: &CMsgDownloadRateStatistics| { &m.steam_realm },
                |m: &mut CMsgDownloadRateStatistics| { &mut m.steam_realm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDownloadRateStatistics>(
                "CMsgDownloadRateStatistics",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDownloadRateStatistics {
        static instance: ::protobuf::rt::LazyV2<CMsgDownloadRateStatistics> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDownloadRateStatistics::new)
    }
}

impl ::protobuf::Clear for CMsgDownloadRateStatistics {
    fn clear(&mut self) {
        self.cell_id = ::std::option::Option::None;
        self.stats.clear();
        self.throttling_kbps = ::std::option::Option::None;
        self.steam_realm = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDownloadRateStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDownloadRateStatistics {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDownloadRateStatistics_StatsInfo {
    // message fields
    source_type: ::std::option::Option<u32>,
    source_id: ::std::option::Option<u32>,
    seconds: ::std::option::Option<u32>,
    bytes: ::std::option::Option<u64>,
    host_name: ::protobuf::SingularField<::std::string::String>,
    microseconds: ::std::option::Option<u64>,
    used_ipv6: ::std::option::Option<bool>,
    proxied: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDownloadRateStatistics_StatsInfo {
    fn default() -> &'a CMsgDownloadRateStatistics_StatsInfo {
        <CMsgDownloadRateStatistics_StatsInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDownloadRateStatistics_StatsInfo {
    pub fn new() -> CMsgDownloadRateStatistics_StatsInfo {
        ::std::default::Default::default()
    }

    // optional uint32 source_type = 1;


    pub fn get_source_type(&self) -> u32 {
        self.source_type.unwrap_or(0)
    }
    pub fn clear_source_type(&mut self) {
        self.source_type = ::std::option::Option::None;
    }

    pub fn has_source_type(&self) -> bool {
        self.source_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: u32) {
        self.source_type = ::std::option::Option::Some(v);
    }

    // optional uint32 source_id = 2;


    pub fn get_source_id(&self) -> u32 {
        self.source_id.unwrap_or(0)
    }
    pub fn clear_source_id(&mut self) {
        self.source_id = ::std::option::Option::None;
    }

    pub fn has_source_id(&self) -> bool {
        self.source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_id(&mut self, v: u32) {
        self.source_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 3;


    pub fn get_seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes = 4;


    pub fn get_bytes(&self) -> u64 {
        self.bytes.unwrap_or(0)
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = ::std::option::Option::Some(v);
    }

    // optional string host_name = 5;


    pub fn get_host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host_name(&mut self) {
        self.host_name.clear();
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name.set_default();
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 microseconds = 6;


    pub fn get_microseconds(&self) -> u64 {
        self.microseconds.unwrap_or(0)
    }
    pub fn clear_microseconds(&mut self) {
        self.microseconds = ::std::option::Option::None;
    }

    pub fn has_microseconds(&self) -> bool {
        self.microseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_microseconds(&mut self, v: u64) {
        self.microseconds = ::std::option::Option::Some(v);
    }

    // optional bool used_ipv6 = 7;


    pub fn get_used_ipv6(&self) -> bool {
        self.used_ipv6.unwrap_or(false)
    }
    pub fn clear_used_ipv6(&mut self) {
        self.used_ipv6 = ::std::option::Option::None;
    }

    pub fn has_used_ipv6(&self) -> bool {
        self.used_ipv6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used_ipv6(&mut self, v: bool) {
        self.used_ipv6 = ::std::option::Option::Some(v);
    }

    // optional bool proxied = 8;


    pub fn get_proxied(&self) -> bool {
        self.proxied.unwrap_or(false)
    }
    pub fn clear_proxied(&mut self) {
        self.proxied = ::std::option::Option::None;
    }

    pub fn has_proxied(&self) -> bool {
        self.proxied.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxied(&mut self, v: bool) {
        self.proxied = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDownloadRateStatistics_StatsInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.source_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.source_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.microseconds = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.used_ipv6 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.proxied = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.source_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.source_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.microseconds {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.used_ipv6 {
            my_size += 2;
        }
        if let Some(v) = self.proxied {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.source_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.source_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.bytes {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.host_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.microseconds {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.used_ipv6 {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.proxied {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDownloadRateStatistics_StatsInfo {
        CMsgDownloadRateStatistics_StatsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "source_type",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.source_type },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.source_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "source_id",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.source_id },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.source_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.seconds },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.bytes },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_name",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.host_name },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.host_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "microseconds",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.microseconds },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.microseconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "used_ipv6",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.used_ipv6 },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.used_ipv6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "proxied",
                |m: &CMsgDownloadRateStatistics_StatsInfo| { &m.proxied },
                |m: &mut CMsgDownloadRateStatistics_StatsInfo| { &mut m.proxied },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDownloadRateStatistics_StatsInfo>(
                "CMsgDownloadRateStatistics.StatsInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDownloadRateStatistics_StatsInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgDownloadRateStatistics_StatsInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDownloadRateStatistics_StatsInfo::new)
    }
}

impl ::protobuf::Clear for CMsgDownloadRateStatistics_StatsInfo {
    fn clear(&mut self) {
        self.source_type = ::std::option::Option::None;
        self.source_id = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.bytes = ::std::option::Option::None;
        self.host_name.clear();
        self.microseconds = ::std::option::Option::None;
        self.used_ipv6 = ::std::option::Option::None;
        self.proxied = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDownloadRateStatistics_StatsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDownloadRateStatistics_StatsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestAccountData {
    // message fields
    account_or_email: ::protobuf::SingularField<::std::string::String>,
    action: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountData {
    fn default() -> &'a CMsgClientRequestAccountData {
        <CMsgClientRequestAccountData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountData {
    pub fn new() -> CMsgClientRequestAccountData {
        ::std::default::Default::default()
    }

    // optional string account_or_email = 1;


    pub fn get_account_or_email(&self) -> &str {
        match self.account_or_email.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_account_or_email(&mut self) {
        self.account_or_email.clear();
    }

    pub fn has_account_or_email(&self) -> bool {
        self.account_or_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_or_email(&mut self, v: ::std::string::String) {
        self.account_or_email = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_or_email(&mut self) -> &mut ::std::string::String {
        if self.account_or_email.is_none() {
            self.account_or_email.set_default();
        }
        self.account_or_email.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_or_email(&mut self) -> ::std::string::String {
        self.account_or_email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 action = 2;


    pub fn get_action(&self) -> u32 {
        self.action.unwrap_or(0)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_or_email)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_or_email.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_or_email.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.action {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestAccountData {
        CMsgClientRequestAccountData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account_or_email",
                |m: &CMsgClientRequestAccountData| { &m.account_or_email },
                |m: &mut CMsgClientRequestAccountData| { &mut m.account_or_email },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "action",
                |m: &CMsgClientRequestAccountData| { &m.action },
                |m: &mut CMsgClientRequestAccountData| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestAccountData>(
                "CMsgClientRequestAccountData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestAccountData {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestAccountData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestAccountData::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestAccountData {
    fn clear(&mut self) {
        self.account_or_email.clear();
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestAccountData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestAccountData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestAccountDataResponse {
    // message fields
    action: ::std::option::Option<u32>,
    eresult: ::std::option::Option<u32>,
    account_name: ::protobuf::SingularField<::std::string::String>,
    ct_matches: ::std::option::Option<u32>,
    account_name_suggestion1: ::protobuf::SingularField<::std::string::String>,
    account_name_suggestion2: ::protobuf::SingularField<::std::string::String>,
    account_name_suggestion3: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestAccountDataResponse {
    fn default() -> &'a CMsgClientRequestAccountDataResponse {
        <CMsgClientRequestAccountDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestAccountDataResponse {
    pub fn new() -> CMsgClientRequestAccountDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 action = 1;


    pub fn get_action(&self) -> u32 {
        self.action.unwrap_or(0)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string account_name = 3;


    pub fn get_account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name.set_default();
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ct_matches = 4;


    pub fn get_ct_matches(&self) -> u32 {
        self.ct_matches.unwrap_or(0)
    }
    pub fn clear_ct_matches(&mut self) {
        self.ct_matches = ::std::option::Option::None;
    }

    pub fn has_ct_matches(&self) -> bool {
        self.ct_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_matches(&mut self, v: u32) {
        self.ct_matches = ::std::option::Option::Some(v);
    }

    // optional string account_name_suggestion1 = 5;


    pub fn get_account_name_suggestion1(&self) -> &str {
        match self.account_name_suggestion1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_account_name_suggestion1(&mut self) {
        self.account_name_suggestion1.clear();
    }

    pub fn has_account_name_suggestion1(&self) -> bool {
        self.account_name_suggestion1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion1(&mut self, v: ::std::string::String) {
        self.account_name_suggestion1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion1(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion1.is_none() {
            self.account_name_suggestion1.set_default();
        }
        self.account_name_suggestion1.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion1(&mut self) -> ::std::string::String {
        self.account_name_suggestion1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion2 = 6;


    pub fn get_account_name_suggestion2(&self) -> &str {
        match self.account_name_suggestion2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_account_name_suggestion2(&mut self) {
        self.account_name_suggestion2.clear();
    }

    pub fn has_account_name_suggestion2(&self) -> bool {
        self.account_name_suggestion2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion2(&mut self, v: ::std::string::String) {
        self.account_name_suggestion2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion2(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion2.is_none() {
            self.account_name_suggestion2.set_default();
        }
        self.account_name_suggestion2.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion2(&mut self) -> ::std::string::String {
        self.account_name_suggestion2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string account_name_suggestion3 = 7;


    pub fn get_account_name_suggestion3(&self) -> &str {
        match self.account_name_suggestion3.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_account_name_suggestion3(&mut self) {
        self.account_name_suggestion3.clear();
    }

    pub fn has_account_name_suggestion3(&self) -> bool {
        self.account_name_suggestion3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name_suggestion3(&mut self, v: ::std::string::String) {
        self.account_name_suggestion3 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name_suggestion3(&mut self) -> &mut ::std::string::String {
        if self.account_name_suggestion3.is_none() {
            self.account_name_suggestion3.set_default();
        }
        self.account_name_suggestion3.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name_suggestion3(&mut self) -> ::std::string::String {
        self.account_name_suggestion3.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestAccountDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ct_matches = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name_suggestion1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name_suggestion2)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name_suggestion3)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ct_matches {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.account_name_suggestion1.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.account_name_suggestion2.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.account_name_suggestion3.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.account_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.ct_matches {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.account_name_suggestion1.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.account_name_suggestion2.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.account_name_suggestion3.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestAccountDataResponse {
        CMsgClientRequestAccountDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "action",
                |m: &CMsgClientRequestAccountDataResponse| { &m.action },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientRequestAccountDataResponse| { &m.eresult },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account_name",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ct_matches",
                |m: &CMsgClientRequestAccountDataResponse| { &m.ct_matches },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.ct_matches },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account_name_suggestion1",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion1 },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account_name_suggestion2",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion2 },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account_name_suggestion3",
                |m: &CMsgClientRequestAccountDataResponse| { &m.account_name_suggestion3 },
                |m: &mut CMsgClientRequestAccountDataResponse| { &mut m.account_name_suggestion3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestAccountDataResponse>(
                "CMsgClientRequestAccountDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestAccountDataResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestAccountDataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestAccountDataResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestAccountDataResponse {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.account_name.clear();
        self.ct_matches = ::std::option::Option::None;
        self.account_name_suggestion1.clear();
        self.account_name_suggestion2.clear();
        self.account_name_suggestion3.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestAccountDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestAccountDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUGSGetGlobalStats {
    // message fields
    gameid: ::std::option::Option<u64>,
    history_days_requested: ::std::option::Option<u32>,
    time_last_requested: ::std::option::Option<u32>,
    first_day_cached: ::std::option::Option<u32>,
    days_cached: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStats {
    fn default() -> &'a CMsgClientUGSGetGlobalStats {
        <CMsgClientUGSGetGlobalStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStats {
    pub fn new() -> CMsgClientUGSGetGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint64 gameid = 1;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 history_days_requested = 2;


    pub fn get_history_days_requested(&self) -> u32 {
        self.history_days_requested.unwrap_or(0)
    }
    pub fn clear_history_days_requested(&mut self) {
        self.history_days_requested = ::std::option::Option::None;
    }

    pub fn has_history_days_requested(&self) -> bool {
        self.history_days_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history_days_requested(&mut self, v: u32) {
        self.history_days_requested = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_last_requested = 3;


    pub fn get_time_last_requested(&self) -> u32 {
        self.time_last_requested.unwrap_or(0)
    }
    pub fn clear_time_last_requested(&mut self) {
        self.time_last_requested = ::std::option::Option::None;
    }

    pub fn has_time_last_requested(&self) -> bool {
        self.time_last_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_requested(&mut self, v: u32) {
        self.time_last_requested = ::std::option::Option::Some(v);
    }

    // optional uint32 first_day_cached = 4;


    pub fn get_first_day_cached(&self) -> u32 {
        self.first_day_cached.unwrap_or(0)
    }
    pub fn clear_first_day_cached(&mut self) {
        self.first_day_cached = ::std::option::Option::None;
    }

    pub fn has_first_day_cached(&self) -> bool {
        self.first_day_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_day_cached(&mut self, v: u32) {
        self.first_day_cached = ::std::option::Option::Some(v);
    }

    // optional uint32 days_cached = 5;


    pub fn get_days_cached(&self) -> u32 {
        self.days_cached.unwrap_or(0)
    }
    pub fn clear_days_cached(&mut self) {
        self.days_cached = ::std::option::Option::None;
    }

    pub fn has_days_cached(&self) -> bool {
        self.days_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_days_cached(&mut self, v: u32) {
        self.days_cached = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.history_days_requested = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.time_last_requested = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_day_cached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.days_cached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gameid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.history_days_requested {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_requested {
            my_size += 5;
        }
        if let Some(v) = self.first_day_cached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.days_cached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gameid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.history_days_requested {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_requested {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.first_day_cached {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.days_cached {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUGSGetGlobalStats {
        CMsgClientUGSGetGlobalStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gameid",
                |m: &CMsgClientUGSGetGlobalStats| { &m.gameid },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "history_days_requested",
                |m: &CMsgClientUGSGetGlobalStats| { &m.history_days_requested },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.history_days_requested },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "time_last_requested",
                |m: &CMsgClientUGSGetGlobalStats| { &m.time_last_requested },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.time_last_requested },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "first_day_cached",
                |m: &CMsgClientUGSGetGlobalStats| { &m.first_day_cached },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.first_day_cached },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "days_cached",
                |m: &CMsgClientUGSGetGlobalStats| { &m.days_cached },
                |m: &mut CMsgClientUGSGetGlobalStats| { &mut m.days_cached },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUGSGetGlobalStats>(
                "CMsgClientUGSGetGlobalStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStats {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUGSGetGlobalStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUGSGetGlobalStats::new)
    }
}

impl ::protobuf::Clear for CMsgClientUGSGetGlobalStats {
    fn clear(&mut self) {
        self.gameid = ::std::option::Option::None;
        self.history_days_requested = ::std::option::Option::None;
        self.time_last_requested = ::std::option::Option::None;
        self.first_day_cached = ::std::option::Option::None;
        self.days_cached = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUGSGetGlobalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUGSGetGlobalStatsResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    timestamp: ::std::option::Option<u32>,
    day_current: ::std::option::Option<i32>,
    pub days: ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStatsResponse {
    fn default() -> &'a CMsgClientUGSGetGlobalStatsResponse {
        <CMsgClientUGSGetGlobalStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStatsResponse {
    pub fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 day_current = 3;


    pub fn get_day_current(&self) -> i32 {
        self.day_current.unwrap_or(0)
    }
    pub fn clear_day_current(&mut self) {
        self.day_current = ::std::option::Option::None;
    }

    pub fn has_day_current(&self) -> bool {
        self.day_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day_current(&mut self, v: i32) {
        self.day_current = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUGSGetGlobalStatsResponse.Day days = 4;


    pub fn get_days(&self) -> &[CMsgClientUGSGetGlobalStatsResponse_Day] {
        &self.days
    }
    pub fn clear_days(&mut self) {
        self.days.clear();
    }

    // Param is passed by value, moved
    pub fn set_days(&mut self, v: ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day>) {
        self.days = v;
    }

    // Mutable pointer to the field.
    pub fn mut_days(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day> {
        &mut self.days
    }

    // Take field
    pub fn take_days(&mut self) -> ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day> {
        ::std::mem::replace(&mut self.days, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.days {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.day_current = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.days)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        if let Some(v) = self.day_current {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.days {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.day_current {
            os.write_int32(3, v)?;
        }
        for v in &self.days {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUGSGetGlobalStatsResponse {
        CMsgClientUGSGetGlobalStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.eresult },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "timestamp",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.timestamp },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "day_current",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.day_current },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.day_current },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUGSGetGlobalStatsResponse_Day>>(
                "days",
                |m: &CMsgClientUGSGetGlobalStatsResponse| { &m.days },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse| { &mut m.days },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUGSGetGlobalStatsResponse>(
                "CMsgClientUGSGetGlobalStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStatsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUGSGetGlobalStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUGSGetGlobalStatsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientUGSGetGlobalStatsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.day_current = ::std::option::Option::None;
        self.days.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUGSGetGlobalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUGSGetGlobalStatsResponse_Day {
    // message fields
    day_id: ::std::option::Option<u32>,
    pub stats: ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day_Stat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStatsResponse_Day {
    fn default() -> &'a CMsgClientUGSGetGlobalStatsResponse_Day {
        <CMsgClientUGSGetGlobalStatsResponse_Day as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStatsResponse_Day {
    pub fn new() -> CMsgClientUGSGetGlobalStatsResponse_Day {
        ::std::default::Default::default()
    }

    // optional uint32 day_id = 1;


    pub fn get_day_id(&self) -> u32 {
        self.day_id.unwrap_or(0)
    }
    pub fn clear_day_id(&mut self) {
        self.day_id = ::std::option::Option::None;
    }

    pub fn has_day_id(&self) -> bool {
        self.day_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_day_id(&mut self, v: u32) {
        self.day_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientUGSGetGlobalStatsResponse.Day.Stat stats = 2;


    pub fn get_stats(&self) -> &[CMsgClientUGSGetGlobalStatsResponse_Day_Stat] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day_Stat>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day_Stat> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientUGSGetGlobalStatsResponse_Day_Stat> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStatsResponse_Day {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.day_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.day_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.day_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUGSGetGlobalStatsResponse_Day {
        CMsgClientUGSGetGlobalStatsResponse_Day::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "day_id",
                |m: &CMsgClientUGSGetGlobalStatsResponse_Day| { &m.day_id },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse_Day| { &mut m.day_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUGSGetGlobalStatsResponse_Day_Stat>>(
                "stats",
                |m: &CMsgClientUGSGetGlobalStatsResponse_Day| { &m.stats },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse_Day| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUGSGetGlobalStatsResponse_Day>(
                "CMsgClientUGSGetGlobalStatsResponse.Day",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStatsResponse_Day {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUGSGetGlobalStatsResponse_Day> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUGSGetGlobalStatsResponse_Day::new)
    }
}

impl ::protobuf::Clear for CMsgClientUGSGetGlobalStatsResponse_Day {
    fn clear(&mut self) {
        self.day_id = ::std::option::Option::None;
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUGSGetGlobalStatsResponse_Day {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStatsResponse_Day {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    // message fields
    stat_id: ::std::option::Option<i32>,
    data: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    fn default() -> &'a CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
        <CMsgClientUGSGetGlobalStatsResponse_Day_Stat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    pub fn new() -> CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
        ::std::default::Default::default()
    }

    // optional int32 stat_id = 1;


    pub fn get_stat_id(&self) -> i32 {
        self.stat_id.unwrap_or(0)
    }
    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: i32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    // optional int64 data = 2;


    pub fn get_data(&self) -> i64 {
        self.data.unwrap_or(0)
    }
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i64) {
        self.data = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
        CMsgClientUGSGetGlobalStatsResponse_Day_Stat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "stat_id",
                |m: &CMsgClientUGSGetGlobalStatsResponse_Day_Stat| { &m.stat_id },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse_Day_Stat| { &mut m.stat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "data",
                |m: &CMsgClientUGSGetGlobalStatsResponse_Day_Stat| { &m.data },
                |m: &mut CMsgClientUGSGetGlobalStatsResponse_Day_Stat| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUGSGetGlobalStatsResponse_Day_Stat>(
                "CMsgClientUGSGetGlobalStatsResponse.Day.Stat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUGSGetGlobalStatsResponse_Day_Stat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUGSGetGlobalStatsResponse_Day_Stat::new)
    }
}

impl ::protobuf::Clear for CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    fn clear(&mut self) {
        self.stat_id = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUGSGetGlobalStatsResponse_Day_Stat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerData {
    // message fields
    steam_id_gs: ::std::option::Option<u64>,
    deprecated_ip: ::std::option::Option<u32>,
    query_port: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    sourcetv_port: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub game_ip_address: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    app_id: ::std::option::Option<u32>,
    gamedir: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    product: ::protobuf::SingularField<::std::string::String>,
    region: ::protobuf::SingularField<::std::string::String>,
    pub players: ::protobuf::RepeatedField<CMsgGameServerData_Player>,
    max_players: ::std::option::Option<u32>,
    bot_count: ::std::option::Option<u32>,
    password: ::std::option::Option<bool>,
    secure: ::std::option::Option<bool>,
    dedicated: ::std::option::Option<bool>,
    os: ::protobuf::SingularField<::std::string::String>,
    game_data: ::protobuf::SingularField<::std::string::String>,
    game_data_version: ::std::option::Option<u32>,
    game_type: ::protobuf::SingularField<::std::string::String>,
    map: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerData {
    fn default() -> &'a CMsgGameServerData {
        <CMsgGameServerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerData {
    pub fn new() -> CMsgGameServerData {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_gs = 1;


    pub fn get_steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }
    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_ip = 2;


    pub fn get_deprecated_ip(&self) -> u32 {
        self.deprecated_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_ip(&mut self) {
        self.deprecated_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_ip(&self) -> bool {
        self.deprecated_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_ip(&mut self, v: u32) {
        self.deprecated_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 query_port = 3;


    pub fn get_query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }
    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    // optional uint32 game_port = 4;


    pub fn get_game_port(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }
    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional uint32 sourcetv_port = 5;


    pub fn get_sourcetv_port(&self) -> u32 {
        self.sourcetv_port.unwrap_or(0)
    }
    pub fn clear_sourcetv_port(&mut self) {
        self.sourcetv_port = ::std::option::Option::None;
    }

    pub fn has_sourcetv_port(&self) -> bool {
        self.sourcetv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourcetv_port(&mut self, v: u32) {
        self.sourcetv_port = ::std::option::Option::Some(v);
    }

    // optional string name = 22;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgIPAddress game_ip_address = 23;


    pub fn get_game_ip_address(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.game_ip_address.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_game_ip_address(&mut self) {
        self.game_ip_address.clear();
    }

    pub fn has_game_ip_address(&self) -> bool {
        self.game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip_address(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.game_ip_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_ip_address(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.game_ip_address.is_none() {
            self.game_ip_address.set_default();
        }
        self.game_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_ip_address(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.game_ip_address.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }

    // optional uint32 app_id = 6;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional string gamedir = 7;


    pub fn get_gamedir(&self) -> &str {
        match self.gamedir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gamedir(&mut self) {
        self.gamedir.clear();
    }

    pub fn has_gamedir(&self) -> bool {
        self.gamedir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamedir(&mut self, v: ::std::string::String) {
        self.gamedir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamedir(&mut self) -> &mut ::std::string::String {
        if self.gamedir.is_none() {
            self.gamedir.set_default();
        }
        self.gamedir.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamedir(&mut self) -> ::std::string::String {
        self.gamedir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 8;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product = 9;


    pub fn get_product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string region = 10;


    pub fn get_region(&self) -> &str {
        match self.region.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_region(&mut self) {
        self.region.clear();
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: ::std::string::String) {
        self.region = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region(&mut self) -> &mut ::std::string::String {
        if self.region.is_none() {
            self.region.set_default();
        }
        self.region.as_mut().unwrap()
    }

    // Take field
    pub fn take_region(&mut self) -> ::std::string::String {
        self.region.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgGameServerData.Player players = 11;


    pub fn get_players(&self) -> &[CMsgGameServerData_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgGameServerData_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameServerData_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgGameServerData_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    // optional uint32 max_players = 12;


    pub fn get_max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }
    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_count = 13;


    pub fn get_bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }
    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional bool password = 14;


    pub fn get_password(&self) -> bool {
        self.password.unwrap_or(false)
    }
    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: bool) {
        self.password = ::std::option::Option::Some(v);
    }

    // optional bool secure = 15;


    pub fn get_secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }
    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool dedicated = 16;


    pub fn get_dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }
    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional string os = 17;


    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_data = 18;


    pub fn get_game_data(&self) -> &str {
        match self.game_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_data(&mut self) {
        self.game_data.clear();
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::string::String) {
        self.game_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::string::String {
        if self.game_data.is_none() {
            self.game_data.set_default();
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::string::String {
        self.game_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_data_version = 19;


    pub fn get_game_data_version(&self) -> u32 {
        self.game_data_version.unwrap_or(0)
    }
    pub fn clear_game_data_version(&mut self) {
        self.game_data_version = ::std::option::Option::None;
    }

    pub fn has_game_data_version(&self) -> bool {
        self.game_data_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_version(&mut self, v: u32) {
        self.game_data_version = ::std::option::Option::Some(v);
    }

    // optional string game_type = 20;


    pub fn get_game_type(&self) -> &str {
        match self.game_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_type(&mut self) {
        self.game_type.clear();
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: ::std::string::String) {
        self.game_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_type(&mut self) -> &mut ::std::string::String {
        if self.game_type.is_none() {
            self.game_type.set_default();
        }
        self.game_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_type(&mut self) -> ::std::string::String {
        self.game_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map = 21;


    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGameServerData {
    fn is_initialized(&self) -> bool {
        for v in &self.game_ip_address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_gs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.query_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sourcetv_port = ::std::option::Option::Some(tmp);
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.game_ip_address)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gamedir)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.product)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.region)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_players = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bot_count = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.password = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.secure = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dedicated = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_data)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_data_version = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_type)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sourcetv_port {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(ref v) = self.game_ip_address.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.gamedir.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.region.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.max_players {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bot_count {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.password {
            my_size += 2;
        }
        if let Some(v) = self.secure {
            my_size += 2;
        }
        if let Some(v) = self.dedicated {
            my_size += 3;
        }
        if let Some(ref v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_data_version {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_type.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sourcetv_port {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(22, &v)?;
        }
        if let Some(ref v) = self.game_ip_address.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.gamedir.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.product.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.region.as_ref() {
            os.write_string(10, &v)?;
        }
        for v in &self.players {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.max_players {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.password {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.dedicated {
            os.write_bool(16, v)?;
        }
        if let Some(ref v) = self.os.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.game_data.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(v) = self.game_data_version {
            os.write_uint32(19, v)?;
        }
        if let Some(ref v) = self.game_type.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(21, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerData {
        CMsgGameServerData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_gs",
                |m: &CMsgGameServerData| { &m.steam_id_gs },
                |m: &mut CMsgGameServerData| { &mut m.steam_id_gs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_ip",
                |m: &CMsgGameServerData| { &m.deprecated_ip },
                |m: &mut CMsgGameServerData| { &mut m.deprecated_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "query_port",
                |m: &CMsgGameServerData| { &m.query_port },
                |m: &mut CMsgGameServerData| { &mut m.query_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_port",
                |m: &CMsgGameServerData| { &m.game_port },
                |m: &mut CMsgGameServerData| { &mut m.game_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sourcetv_port",
                |m: &CMsgGameServerData| { &m.sourcetv_port },
                |m: &mut CMsgGameServerData| { &mut m.sourcetv_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgGameServerData| { &m.name },
                |m: &mut CMsgGameServerData| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "game_ip_address",
                |m: &CMsgGameServerData| { &m.game_ip_address },
                |m: &mut CMsgGameServerData| { &mut m.game_ip_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgGameServerData| { &m.app_id },
                |m: &mut CMsgGameServerData| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gamedir",
                |m: &CMsgGameServerData| { &m.gamedir },
                |m: &mut CMsgGameServerData| { &mut m.gamedir },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &CMsgGameServerData| { &m.version },
                |m: &mut CMsgGameServerData| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product",
                |m: &CMsgGameServerData| { &m.product },
                |m: &mut CMsgGameServerData| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "region",
                |m: &CMsgGameServerData| { &m.region },
                |m: &mut CMsgGameServerData| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameServerData_Player>>(
                "players",
                |m: &CMsgGameServerData| { &m.players },
                |m: &mut CMsgGameServerData| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_players",
                |m: &CMsgGameServerData| { &m.max_players },
                |m: &mut CMsgGameServerData| { &mut m.max_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bot_count",
                |m: &CMsgGameServerData| { &m.bot_count },
                |m: &mut CMsgGameServerData| { &mut m.bot_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "password",
                |m: &CMsgGameServerData| { &m.password },
                |m: &mut CMsgGameServerData| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "secure",
                |m: &CMsgGameServerData| { &m.secure },
                |m: &mut CMsgGameServerData| { &mut m.secure },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dedicated",
                |m: &CMsgGameServerData| { &m.dedicated },
                |m: &mut CMsgGameServerData| { &mut m.dedicated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os",
                |m: &CMsgGameServerData| { &m.os },
                |m: &mut CMsgGameServerData| { &mut m.os },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_data",
                |m: &CMsgGameServerData| { &m.game_data },
                |m: &mut CMsgGameServerData| { &mut m.game_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_data_version",
                |m: &CMsgGameServerData| { &m.game_data_version },
                |m: &mut CMsgGameServerData| { &mut m.game_data_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_type",
                |m: &CMsgGameServerData| { &m.game_type },
                |m: &mut CMsgGameServerData| { &mut m.game_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map",
                |m: &CMsgGameServerData| { &m.map },
                |m: &mut CMsgGameServerData| { &mut m.map },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerData>(
                "CMsgGameServerData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerData {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerData::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerData {
    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.deprecated_ip = ::std::option::Option::None;
        self.query_port = ::std::option::Option::None;
        self.game_port = ::std::option::Option::None;
        self.sourcetv_port = ::std::option::Option::None;
        self.name.clear();
        self.game_ip_address.clear();
        self.app_id = ::std::option::Option::None;
        self.gamedir.clear();
        self.version.clear();
        self.product.clear();
        self.region.clear();
        self.players.clear();
        self.max_players = ::std::option::Option::None;
        self.bot_count = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.secure = ::std::option::Option::None;
        self.dedicated = ::std::option::Option::None;
        self.os.clear();
        self.game_data.clear();
        self.game_data_version = ::std::option::Option::None;
        self.game_type.clear();
        self.map.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerData_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerData_Player {
    fn default() -> &'a CMsgGameServerData_Player {
        <CMsgGameServerData_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerData_Player {
    pub fn new() -> CMsgGameServerData_Player {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerData_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerData_Player {
        CMsgGameServerData_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGameServerData_Player| { &m.steam_id },
                |m: &mut CMsgGameServerData_Player| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerData_Player>(
                "CMsgGameServerData.Player",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerData_Player {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerData_Player> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerData_Player::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerData_Player {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerData_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerData_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerRemove {
    // message fields
    steam_id: ::std::option::Option<u64>,
    deprecated_ip: ::std::option::Option<u32>,
    query_port: ::std::option::Option<u32>,
    pub ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerRemove {
    fn default() -> &'a CMsgGameServerRemove {
        <CMsgGameServerRemove as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerRemove {
    pub fn new() -> CMsgGameServerRemove {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_ip = 2;


    pub fn get_deprecated_ip(&self) -> u32 {
        self.deprecated_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_ip(&mut self) {
        self.deprecated_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_ip(&self) -> bool {
        self.deprecated_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_ip(&mut self, v: u32) {
        self.deprecated_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 query_port = 3;


    pub fn get_query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }
    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    // optional .CMsgIPAddress ip = 4;


    pub fn get_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgGameServerRemove {
    fn is_initialized(&self) -> bool {
        for v in &self.ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.query_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.deprecated_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.query_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.deprecated_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.ip.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerRemove {
        CMsgGameServerRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGameServerRemove| { &m.steam_id },
                |m: &mut CMsgGameServerRemove| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_ip",
                |m: &CMsgGameServerRemove| { &m.deprecated_ip },
                |m: &mut CMsgGameServerRemove| { &mut m.deprecated_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "query_port",
                |m: &CMsgGameServerRemove| { &m.query_port },
                |m: &mut CMsgGameServerRemove| { &mut m.query_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "ip",
                |m: &CMsgGameServerRemove| { &m.ip },
                |m: &mut CMsgGameServerRemove| { &mut m.ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerRemove>(
                "CMsgGameServerRemove",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerRemove {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerRemove> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerRemove::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerRemove {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.deprecated_ip = ::std::option::Option::None;
        self.query_port = ::std::option::Option::None;
        self.ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGMSServerQuery {
    // message fields
    app_id: ::std::option::Option<u32>,
    geo_location_ip: ::std::option::Option<u32>,
    region_code: ::std::option::Option<u32>,
    filter_text: ::protobuf::SingularField<::std::string::String>,
    max_servers: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGMSServerQuery {
    fn default() -> &'a CMsgClientGMSServerQuery {
        <CMsgClientGMSServerQuery as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGMSServerQuery {
    pub fn new() -> CMsgClientGMSServerQuery {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 geo_location_ip = 2;


    pub fn get_geo_location_ip(&self) -> u32 {
        self.geo_location_ip.unwrap_or(0)
    }
    pub fn clear_geo_location_ip(&mut self) {
        self.geo_location_ip = ::std::option::Option::None;
    }

    pub fn has_geo_location_ip(&self) -> bool {
        self.geo_location_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_geo_location_ip(&mut self, v: u32) {
        self.geo_location_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 region_code = 3;


    pub fn get_region_code(&self) -> u32 {
        self.region_code.unwrap_or(0)
    }
    pub fn clear_region_code(&mut self) {
        self.region_code = ::std::option::Option::None;
    }

    pub fn has_region_code(&self) -> bool {
        self.region_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_code(&mut self, v: u32) {
        self.region_code = ::std::option::Option::Some(v);
    }

    // optional string filter_text = 4;


    pub fn get_filter_text(&self) -> &str {
        match self.filter_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filter_text(&mut self) {
        self.filter_text.clear();
    }

    pub fn has_filter_text(&self) -> bool {
        self.filter_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_text(&mut self, v: ::std::string::String) {
        self.filter_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_text(&mut self) -> &mut ::std::string::String {
        if self.filter_text.is_none() {
            self.filter_text.set_default();
        }
        self.filter_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_text(&mut self) -> ::std::string::String {
        self.filter_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_servers = 5;


    pub fn get_max_servers(&self) -> u32 {
        self.max_servers.unwrap_or(0)
    }
    pub fn clear_max_servers(&mut self) {
        self.max_servers = ::std::option::Option::None;
    }

    pub fn has_max_servers(&self) -> bool {
        self.max_servers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_servers(&mut self, v: u32) {
        self.max_servers = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGMSServerQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.geo_location_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.region_code = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filter_text)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_servers = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.geo_location_ip {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.region_code {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filter_text.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.max_servers {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.geo_location_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.region_code {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.filter_text.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.max_servers {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGMSServerQuery {
        CMsgClientGMSServerQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientGMSServerQuery| { &m.app_id },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "geo_location_ip",
                |m: &CMsgClientGMSServerQuery| { &m.geo_location_ip },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.geo_location_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "region_code",
                |m: &CMsgClientGMSServerQuery| { &m.region_code },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.region_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter_text",
                |m: &CMsgClientGMSServerQuery| { &m.filter_text },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.filter_text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_servers",
                |m: &CMsgClientGMSServerQuery| { &m.max_servers },
                |m: &mut CMsgClientGMSServerQuery| { &mut m.max_servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGMSServerQuery>(
                "CMsgClientGMSServerQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGMSServerQuery {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGMSServerQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGMSServerQuery::new)
    }
}

impl ::protobuf::Clear for CMsgClientGMSServerQuery {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.geo_location_ip = ::std::option::Option::None;
        self.region_code = ::std::option::Option::None;
        self.filter_text.clear();
        self.max_servers = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGMSServerQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGMSServerQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGMSClientServerQueryResponse {
    // message fields
    pub servers: ::protobuf::RepeatedField<CMsgGMSClientServerQueryResponse_Server>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGMSClientServerQueryResponse {
    fn default() -> &'a CMsgGMSClientServerQueryResponse {
        <CMsgGMSClientServerQueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGMSClientServerQueryResponse {
    pub fn new() -> CMsgGMSClientServerQueryResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgGMSClientServerQueryResponse.Server servers = 1;


    pub fn get_servers(&self) -> &[CMsgGMSClientServerQueryResponse_Server] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CMsgGMSClientServerQueryResponse_Server>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGMSClientServerQueryResponse_Server> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CMsgGMSClientServerQueryResponse_Server> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }

    // optional string error = 2;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGMSClientServerQueryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGMSClientServerQueryResponse {
        CMsgGMSClientServerQueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGMSClientServerQueryResponse_Server>>(
                "servers",
                |m: &CMsgGMSClientServerQueryResponse| { &m.servers },
                |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.servers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &CMsgGMSClientServerQueryResponse| { &m.error },
                |m: &mut CMsgGMSClientServerQueryResponse| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGMSClientServerQueryResponse>(
                "CMsgGMSClientServerQueryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGMSClientServerQueryResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGMSClientServerQueryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGMSClientServerQueryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGMSClientServerQueryResponse {
    fn clear(&mut self) {
        self.servers.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGMSClientServerQueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGMSClientServerQueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGMSClientServerQueryResponse_Server {
    // message fields
    deprecated_server_ip: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    auth_players: ::std::option::Option<u32>,
    pub server_ip: ::protobuf::SingularPtrField<super::steammessages_base::CMsgIPAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGMSClientServerQueryResponse_Server {
    fn default() -> &'a CMsgGMSClientServerQueryResponse_Server {
        <CMsgGMSClientServerQueryResponse_Server as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGMSClientServerQueryResponse_Server {
    pub fn new() -> CMsgGMSClientServerQueryResponse_Server {
        ::std::default::Default::default()
    }

    // optional uint32 deprecated_server_ip = 1;


    pub fn get_deprecated_server_ip(&self) -> u32 {
        self.deprecated_server_ip.unwrap_or(0)
    }
    pub fn clear_deprecated_server_ip(&mut self) {
        self.deprecated_server_ip = ::std::option::Option::None;
    }

    pub fn has_deprecated_server_ip(&self) -> bool {
        self.deprecated_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_server_ip(&mut self, v: u32) {
        self.deprecated_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 2;


    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 auth_players = 3;


    pub fn get_auth_players(&self) -> u32 {
        self.auth_players.unwrap_or(0)
    }
    pub fn clear_auth_players(&mut self) {
        self.auth_players = ::std::option::Option::None;
    }

    pub fn has_auth_players(&self) -> bool {
        self.auth_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_players(&mut self, v: u32) {
        self.auth_players = ::std::option::Option::Some(v);
    }

    // optional .CMsgIPAddress server_ip = 4;


    pub fn get_server_ip(&self) -> &super::steammessages_base::CMsgIPAddress {
        self.server_ip.as_ref().unwrap_or_else(|| <super::steammessages_base::CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_ip(&mut self) {
        self.server_ip.clear();
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: super::steammessages_base::CMsgIPAddress) {
        self.server_ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_ip(&mut self) -> &mut super::steammessages_base::CMsgIPAddress {
        if self.server_ip.is_none() {
            self.server_ip.set_default();
        }
        self.server_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_ip(&mut self) -> super::steammessages_base::CMsgIPAddress {
        self.server_ip.take().unwrap_or_else(|| super::steammessages_base::CMsgIPAddress::new())
    }
}

impl ::protobuf::Message for CMsgGMSClientServerQueryResponse_Server {
    fn is_initialized(&self) -> bool {
        for v in &self.server_ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deprecated_server_ip = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.auth_players = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated_server_ip {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.auth_players {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deprecated_server_ip {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.auth_players {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.server_ip.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGMSClientServerQueryResponse_Server {
        CMsgGMSClientServerQueryResponse_Server::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deprecated_server_ip",
                |m: &CMsgGMSClientServerQueryResponse_Server| { &m.deprecated_server_ip },
                |m: &mut CMsgGMSClientServerQueryResponse_Server| { &mut m.deprecated_server_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_port",
                |m: &CMsgGMSClientServerQueryResponse_Server| { &m.server_port },
                |m: &mut CMsgGMSClientServerQueryResponse_Server| { &mut m.server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "auth_players",
                |m: &CMsgGMSClientServerQueryResponse_Server| { &m.auth_players },
                |m: &mut CMsgGMSClientServerQueryResponse_Server| { &mut m.auth_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::steammessages_base::CMsgIPAddress>>(
                "server_ip",
                |m: &CMsgGMSClientServerQueryResponse_Server| { &m.server_ip },
                |m: &mut CMsgGMSClientServerQueryResponse_Server| { &mut m.server_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGMSClientServerQueryResponse_Server>(
                "CMsgGMSClientServerQueryResponse.Server",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGMSClientServerQueryResponse_Server {
        static instance: ::protobuf::rt::LazyV2<CMsgGMSClientServerQueryResponse_Server> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGMSClientServerQueryResponse_Server::new)
    }
}

impl ::protobuf::Clear for CMsgGMSClientServerQueryResponse_Server {
    fn clear(&mut self) {
        self.deprecated_server_ip = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.auth_players = ::std::option::Option::None;
        self.server_ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGMSClientServerQueryResponse_Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGMSClientServerQueryResponse_Server {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerOutOfDate {
    // message fields
    steam_id_gs: ::std::option::Option<u64>,
    reject: ::std::option::Option<bool>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerOutOfDate {
    fn default() -> &'a CMsgGameServerOutOfDate {
        <CMsgGameServerOutOfDate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerOutOfDate {
    pub fn new() -> CMsgGameServerOutOfDate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_gs = 1;


    pub fn get_steam_id_gs(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }
    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    // optional bool reject = 2;


    pub fn get_reject(&self) -> bool {
        self.reject.unwrap_or(false)
    }
    pub fn clear_reject(&mut self) {
        self.reject = ::std::option::Option::None;
    }

    pub fn has_reject(&self) -> bool {
        self.reject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reject(&mut self, v: bool) {
        self.reject = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGameServerOutOfDate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_gs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reject = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_gs {
            my_size += 9;
        }
        if let Some(v) = self.reject {
            my_size += 2;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_gs {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.reject {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerOutOfDate {
        CMsgGameServerOutOfDate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_gs",
                |m: &CMsgGameServerOutOfDate| { &m.steam_id_gs },
                |m: &mut CMsgGameServerOutOfDate| { &mut m.steam_id_gs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reject",
                |m: &CMsgGameServerOutOfDate| { &m.reject },
                |m: &mut CMsgGameServerOutOfDate| { &mut m.reject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CMsgGameServerOutOfDate| { &m.message },
                |m: &mut CMsgGameServerOutOfDate| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerOutOfDate>(
                "CMsgGameServerOutOfDate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerOutOfDate {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerOutOfDate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerOutOfDate::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerOutOfDate {
    fn clear(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
        self.reject = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerOutOfDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerOutOfDate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRedeemGuestPass {
    // message fields
    guest_pass_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPass {
    fn default() -> &'a CMsgClientRedeemGuestPass {
        <CMsgClientRedeemGuestPass as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPass {
    pub fn new() -> CMsgClientRedeemGuestPass {
        ::std::default::Default::default()
    }

    // optional fixed64 guest_pass_id = 1;


    pub fn get_guest_pass_id(&self) -> u64 {
        self.guest_pass_id.unwrap_or(0)
    }
    pub fn clear_guest_pass_id(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
    }

    pub fn has_guest_pass_id(&self) -> bool {
        self.guest_pass_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guest_pass_id(&mut self, v: u64) {
        self.guest_pass_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.guest_pass_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.guest_pass_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.guest_pass_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRedeemGuestPass {
        CMsgClientRedeemGuestPass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "guest_pass_id",
                |m: &CMsgClientRedeemGuestPass| { &m.guest_pass_id },
                |m: &mut CMsgClientRedeemGuestPass| { &mut m.guest_pass_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRedeemGuestPass>(
                "CMsgClientRedeemGuestPass",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPass {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRedeemGuestPass> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRedeemGuestPass::new)
    }
}

impl ::protobuf::Clear for CMsgClientRedeemGuestPass {
    fn clear(&mut self) {
        self.guest_pass_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRedeemGuestPass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRedeemGuestPass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRedeemGuestPassResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    package_id: ::std::option::Option<u32>,
    must_own_appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRedeemGuestPassResponse {
    fn default() -> &'a CMsgClientRedeemGuestPassResponse {
        <CMsgClientRedeemGuestPassResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRedeemGuestPassResponse {
    pub fn new() -> CMsgClientRedeemGuestPassResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 package_id = 2;


    pub fn get_package_id(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }
    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_appid = 3;


    pub fn get_must_own_appid(&self) -> u32 {
        self.must_own_appid.unwrap_or(0)
    }
    pub fn clear_must_own_appid(&mut self) {
        self.must_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_own_appid(&self) -> bool {
        self.must_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_appid(&mut self, v: u32) {
        self.must_own_appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRedeemGuestPassResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.package_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.must_own_appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.package_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.must_own_appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.package_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.must_own_appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRedeemGuestPassResponse {
        CMsgClientRedeemGuestPassResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientRedeemGuestPassResponse| { &m.eresult },
                |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "package_id",
                |m: &CMsgClientRedeemGuestPassResponse| { &m.package_id },
                |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.package_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "must_own_appid",
                |m: &CMsgClientRedeemGuestPassResponse| { &m.must_own_appid },
                |m: &mut CMsgClientRedeemGuestPassResponse| { &mut m.must_own_appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRedeemGuestPassResponse>(
                "CMsgClientRedeemGuestPassResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRedeemGuestPassResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRedeemGuestPassResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRedeemGuestPassResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRedeemGuestPassResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.package_id = ::std::option::Option::None;
        self.must_own_appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRedeemGuestPassResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRedeemGuestPassResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClanActivityCounts {
    // message fields
    pub steamid_clans: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCounts {
    fn default() -> &'a CMsgClientGetClanActivityCounts {
        <CMsgClientGetClanActivityCounts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCounts {
    pub fn new() -> CMsgClientGetClanActivityCounts {
        ::std::default::Default::default()
    }

    // repeated uint64 steamid_clans = 1;


    pub fn get_steamid_clans(&self) -> &[u64] {
        &self.steamid_clans
    }
    pub fn clear_steamid_clans(&mut self) {
        self.steamid_clans.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_clans(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_clans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_clans(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_clans
    }

    // Take field
    pub fn take_steamid_clans(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_clans, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.steamid_clans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.steamid_clans {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.steamid_clans {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClanActivityCounts {
        CMsgClientGetClanActivityCounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steamid_clans",
                |m: &CMsgClientGetClanActivityCounts| { &m.steamid_clans },
                |m: &mut CMsgClientGetClanActivityCounts| { &mut m.steamid_clans },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClanActivityCounts>(
                "CMsgClientGetClanActivityCounts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCounts {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClanActivityCounts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClanActivityCounts::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClanActivityCounts {
    fn clear(&mut self) {
        self.steamid_clans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClanActivityCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClanActivityCounts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetClanActivityCountsResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetClanActivityCountsResponse {
    fn default() -> &'a CMsgClientGetClanActivityCountsResponse {
        <CMsgClientGetClanActivityCountsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetClanActivityCountsResponse {
    pub fn new() -> CMsgClientGetClanActivityCountsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetClanActivityCountsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetClanActivityCountsResponse {
        CMsgClientGetClanActivityCountsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientGetClanActivityCountsResponse| { &m.eresult },
                |m: &mut CMsgClientGetClanActivityCountsResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetClanActivityCountsResponse>(
                "CMsgClientGetClanActivityCountsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetClanActivityCountsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetClanActivityCountsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetClanActivityCountsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetClanActivityCountsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetClanActivityCountsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetClanActivityCountsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientOGSReportString {
    // message fields
    accumulated: ::std::option::Option<bool>,
    sessionid: ::std::option::Option<u64>,
    severity: ::std::option::Option<i32>,
    formatter: ::protobuf::SingularField<::std::string::String>,
    varargs: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportString {
    fn default() -> &'a CMsgClientOGSReportString {
        <CMsgClientOGSReportString as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportString {
    pub fn new() -> CMsgClientOGSReportString {
        ::std::default::Default::default()
    }

    // optional bool accumulated = 1;


    pub fn get_accumulated(&self) -> bool {
        self.accumulated.unwrap_or(false)
    }
    pub fn clear_accumulated(&mut self) {
        self.accumulated = ::std::option::Option::None;
    }

    pub fn has_accumulated(&self) -> bool {
        self.accumulated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accumulated(&mut self, v: bool) {
        self.accumulated = ::std::option::Option::Some(v);
    }

    // optional uint64 sessionid = 2;


    pub fn get_sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }
    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 3;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string formatter = 4;


    pub fn get_formatter(&self) -> &str {
        match self.formatter.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_formatter(&mut self) {
        self.formatter.clear();
    }

    pub fn has_formatter(&self) -> bool {
        self.formatter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formatter(&mut self, v: ::std::string::String) {
        self.formatter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_formatter(&mut self) -> &mut ::std::string::String {
        if self.formatter.is_none() {
            self.formatter.set_default();
        }
        self.formatter.as_mut().unwrap()
    }

    // Take field
    pub fn take_formatter(&mut self) -> ::std::string::String {
        self.formatter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes varargs = 5;


    pub fn get_varargs(&self) -> &[u8] {
        match self.varargs.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_varargs(&mut self) {
        self.varargs.clear();
    }

    pub fn has_varargs(&self) -> bool {
        self.varargs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_varargs(&mut self, v: ::std::vec::Vec<u8>) {
        self.varargs = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_varargs(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.varargs.is_none() {
            self.varargs.set_default();
        }
        self.varargs.as_mut().unwrap()
    }

    // Take field
    pub fn take_varargs(&mut self) -> ::std::vec::Vec<u8> {
        self.varargs.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientOGSReportString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.accumulated = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sessionid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.formatter)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.varargs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accumulated {
            my_size += 2;
        }
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.formatter.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.varargs.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accumulated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.sessionid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.formatter.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.varargs.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientOGSReportString {
        CMsgClientOGSReportString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "accumulated",
                |m: &CMsgClientOGSReportString| { &m.accumulated },
                |m: &mut CMsgClientOGSReportString| { &mut m.accumulated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sessionid",
                |m: &CMsgClientOGSReportString| { &m.sessionid },
                |m: &mut CMsgClientOGSReportString| { &mut m.sessionid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &CMsgClientOGSReportString| { &m.severity },
                |m: &mut CMsgClientOGSReportString| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "formatter",
                |m: &CMsgClientOGSReportString| { &m.formatter },
                |m: &mut CMsgClientOGSReportString| { &mut m.formatter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "varargs",
                |m: &CMsgClientOGSReportString| { &m.varargs },
                |m: &mut CMsgClientOGSReportString| { &mut m.varargs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientOGSReportString>(
                "CMsgClientOGSReportString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientOGSReportString {
        static instance: ::protobuf::rt::LazyV2<CMsgClientOGSReportString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientOGSReportString::new)
    }
}

impl ::protobuf::Clear for CMsgClientOGSReportString {
    fn clear(&mut self) {
        self.accumulated = ::std::option::Option::None;
        self.sessionid = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.formatter.clear();
        self.varargs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientOGSReportString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOGSReportString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientOGSReportBug {
    // message fields
    sessionid: ::std::option::Option<u64>,
    bugtext: ::protobuf::SingularField<::std::string::String>,
    screenshot: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientOGSReportBug {
    fn default() -> &'a CMsgClientOGSReportBug {
        <CMsgClientOGSReportBug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOGSReportBug {
    pub fn new() -> CMsgClientOGSReportBug {
        ::std::default::Default::default()
    }

    // optional uint64 sessionid = 1;


    pub fn get_sessionid(&self) -> u64 {
        self.sessionid.unwrap_or(0)
    }
    pub fn clear_sessionid(&mut self) {
        self.sessionid = ::std::option::Option::None;
    }

    pub fn has_sessionid(&self) -> bool {
        self.sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionid(&mut self, v: u64) {
        self.sessionid = ::std::option::Option::Some(v);
    }

    // optional string bugtext = 2;


    pub fn get_bugtext(&self) -> &str {
        match self.bugtext.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bugtext(&mut self) {
        self.bugtext.clear();
    }

    pub fn has_bugtext(&self) -> bool {
        self.bugtext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bugtext(&mut self, v: ::std::string::String) {
        self.bugtext = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bugtext(&mut self) -> &mut ::std::string::String {
        if self.bugtext.is_none() {
            self.bugtext.set_default();
        }
        self.bugtext.as_mut().unwrap()
    }

    // Take field
    pub fn take_bugtext(&mut self) -> ::std::string::String {
        self.bugtext.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes screenshot = 3;


    pub fn get_screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_screenshot(&mut self) {
        self.screenshot.clear();
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot.set_default();
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientOGSReportBug {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sessionid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bugtext)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.screenshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sessionid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bugtext.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sessionid {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.bugtext.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.screenshot.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientOGSReportBug {
        CMsgClientOGSReportBug::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sessionid",
                |m: &CMsgClientOGSReportBug| { &m.sessionid },
                |m: &mut CMsgClientOGSReportBug| { &mut m.sessionid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bugtext",
                |m: &CMsgClientOGSReportBug| { &m.bugtext },
                |m: &mut CMsgClientOGSReportBug| { &mut m.bugtext },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "screenshot",
                |m: &CMsgClientOGSReportBug| { &m.screenshot },
                |m: &mut CMsgClientOGSReportBug| { &mut m.screenshot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientOGSReportBug>(
                "CMsgClientOGSReportBug",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientOGSReportBug {
        static instance: ::protobuf::rt::LazyV2<CMsgClientOGSReportBug> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientOGSReportBug::new)
    }
}

impl ::protobuf::Clear for CMsgClientOGSReportBug {
    fn clear(&mut self) {
        self.sessionid = ::std::option::Option::None;
        self.bugtext.clear();
        self.screenshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientOGSReportBug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOGSReportBug {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSAssociateWithClan {
    // message fields
    steam_id_clan: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClan {
    fn default() -> &'a CMsgGSAssociateWithClan {
        <CMsgGSAssociateWithClan as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClan {
    pub fn new() -> CMsgGSAssociateWithClan {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;


    pub fn get_steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }
    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClan {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_clan = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSAssociateWithClan {
        CMsgGSAssociateWithClan::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_clan",
                |m: &CMsgGSAssociateWithClan| { &m.steam_id_clan },
                |m: &mut CMsgGSAssociateWithClan| { &mut m.steam_id_clan },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSAssociateWithClan>(
                "CMsgGSAssociateWithClan",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClan {
        static instance: ::protobuf::rt::LazyV2<CMsgGSAssociateWithClan> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSAssociateWithClan::new)
    }
}

impl ::protobuf::Clear for CMsgGSAssociateWithClan {
    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSAssociateWithClan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSAssociateWithClan {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSAssociateWithClanResponse {
    // message fields
    steam_id_clan: ::std::option::Option<u64>,
    eresult: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSAssociateWithClanResponse {
    fn default() -> &'a CMsgGSAssociateWithClanResponse {
        <CMsgGSAssociateWithClanResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSAssociateWithClanResponse {
    pub fn new() -> CMsgGSAssociateWithClanResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_clan = 1;


    pub fn get_steam_id_clan(&self) -> u64 {
        self.steam_id_clan.unwrap_or(0)
    }
    pub fn clear_steam_id_clan(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
    }

    pub fn has_steam_id_clan(&self) -> bool {
        self.steam_id_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_clan(&mut self, v: u64) {
        self.steam_id_clan = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSAssociateWithClanResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_clan = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_clan {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_clan {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSAssociateWithClanResponse {
        CMsgGSAssociateWithClanResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_clan",
                |m: &CMsgGSAssociateWithClanResponse| { &m.steam_id_clan },
                |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.steam_id_clan },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgGSAssociateWithClanResponse| { &m.eresult },
                |m: &mut CMsgGSAssociateWithClanResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSAssociateWithClanResponse>(
                "CMsgGSAssociateWithClanResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSAssociateWithClanResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGSAssociateWithClanResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSAssociateWithClanResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGSAssociateWithClanResponse {
    fn clear(&mut self) {
        self.steam_id_clan = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSAssociateWithClanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSAssociateWithClanResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSComputeNewPlayerCompatibility {
    // message fields
    steam_id_candidate: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibility {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibility {
        <CMsgGSComputeNewPlayerCompatibility as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibility {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibility {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;


    pub fn get_steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }
    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibility {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_candidate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibility {
        CMsgGSComputeNewPlayerCompatibility::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_candidate",
                |m: &CMsgGSComputeNewPlayerCompatibility| { &m.steam_id_candidate },
                |m: &mut CMsgGSComputeNewPlayerCompatibility| { &mut m.steam_id_candidate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSComputeNewPlayerCompatibility>(
                "CMsgGSComputeNewPlayerCompatibility",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibility {
        static instance: ::protobuf::rt::LazyV2<CMsgGSComputeNewPlayerCompatibility> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSComputeNewPlayerCompatibility::new)
    }
}

impl ::protobuf::Clear for CMsgGSComputeNewPlayerCompatibility {
    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSComputeNewPlayerCompatibility {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibility {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGSComputeNewPlayerCompatibilityResponse {
    // message fields
    steam_id_candidate: ::std::option::Option<u64>,
    eresult: ::std::option::Option<u32>,
    is_clan_member: ::std::option::Option<bool>,
    ct_dont_like_you: ::std::option::Option<i32>,
    ct_you_dont_like: ::std::option::Option<i32>,
    ct_clanmembers_dont_like_you: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGSComputeNewPlayerCompatibilityResponse {
    fn default() -> &'a CMsgGSComputeNewPlayerCompatibilityResponse {
        <CMsgGSComputeNewPlayerCompatibilityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGSComputeNewPlayerCompatibilityResponse {
    pub fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id_candidate = 1;


    pub fn get_steam_id_candidate(&self) -> u64 {
        self.steam_id_candidate.unwrap_or(0)
    }
    pub fn clear_steam_id_candidate(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
    }

    pub fn has_steam_id_candidate(&self) -> bool {
        self.steam_id_candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_candidate(&mut self, v: u64) {
        self.steam_id_candidate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_clan_member = 3;


    pub fn get_is_clan_member(&self) -> bool {
        self.is_clan_member.unwrap_or(false)
    }
    pub fn clear_is_clan_member(&mut self) {
        self.is_clan_member = ::std::option::Option::None;
    }

    pub fn has_is_clan_member(&self) -> bool {
        self.is_clan_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_clan_member(&mut self, v: bool) {
        self.is_clan_member = ::std::option::Option::Some(v);
    }

    // optional int32 ct_dont_like_you = 4;


    pub fn get_ct_dont_like_you(&self) -> i32 {
        self.ct_dont_like_you.unwrap_or(0)
    }
    pub fn clear_ct_dont_like_you(&mut self) {
        self.ct_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_dont_like_you(&self) -> bool {
        self.ct_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_dont_like_you(&mut self, v: i32) {
        self.ct_dont_like_you = ::std::option::Option::Some(v);
    }

    // optional int32 ct_you_dont_like = 5;


    pub fn get_ct_you_dont_like(&self) -> i32 {
        self.ct_you_dont_like.unwrap_or(0)
    }
    pub fn clear_ct_you_dont_like(&mut self) {
        self.ct_you_dont_like = ::std::option::Option::None;
    }

    pub fn has_ct_you_dont_like(&self) -> bool {
        self.ct_you_dont_like.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_you_dont_like(&mut self, v: i32) {
        self.ct_you_dont_like = ::std::option::Option::Some(v);
    }

    // optional int32 ct_clanmembers_dont_like_you = 6;


    pub fn get_ct_clanmembers_dont_like_you(&self) -> i32 {
        self.ct_clanmembers_dont_like_you.unwrap_or(0)
    }
    pub fn clear_ct_clanmembers_dont_like_you(&mut self) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
    }

    pub fn has_ct_clanmembers_dont_like_you(&self) -> bool {
        self.ct_clanmembers_dont_like_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_clanmembers_dont_like_you(&mut self, v: i32) {
        self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_candidate = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_clan_member = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ct_dont_like_you = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ct_you_dont_like = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ct_clanmembers_dont_like_you = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id_candidate {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_clan_member {
            my_size += 2;
        }
        if let Some(v) = self.ct_dont_like_you {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ct_you_dont_like {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_candidate {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_clan_member {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ct_dont_like_you {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ct_you_dont_like {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ct_clanmembers_dont_like_you {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGSComputeNewPlayerCompatibilityResponse {
        CMsgGSComputeNewPlayerCompatibilityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_candidate",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.steam_id_candidate },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.steam_id_candidate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.eresult },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_clan_member",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.is_clan_member },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.is_clan_member },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ct_dont_like_you",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_dont_like_you },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_dont_like_you },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ct_you_dont_like",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_you_dont_like },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_you_dont_like },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ct_clanmembers_dont_like_you",
                |m: &CMsgGSComputeNewPlayerCompatibilityResponse| { &m.ct_clanmembers_dont_like_you },
                |m: &mut CMsgGSComputeNewPlayerCompatibilityResponse| { &mut m.ct_clanmembers_dont_like_you },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGSComputeNewPlayerCompatibilityResponse>(
                "CMsgGSComputeNewPlayerCompatibilityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGSComputeNewPlayerCompatibilityResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGSComputeNewPlayerCompatibilityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGSComputeNewPlayerCompatibilityResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn clear(&mut self) {
        self.steam_id_candidate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.is_clan_member = ::std::option::Option::None;
        self.ct_dont_like_you = ::std::option::Option::None;
        self.ct_you_dont_like = ::std::option::Option::None;
        self.ct_clanmembers_dont_like_you = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGSComputeNewPlayerCompatibilityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSentLogs {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSentLogs {
    fn default() -> &'a CMsgClientSentLogs {
        <CMsgClientSentLogs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSentLogs {
    pub fn new() -> CMsgClientSentLogs {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientSentLogs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSentLogs {
        CMsgClientSentLogs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSentLogs>(
                "CMsgClientSentLogs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSentLogs {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSentLogs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSentLogs::new)
    }
}

impl ::protobuf::Clear for CMsgClientSentLogs {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSentLogs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSentLogs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClient {
    // message fields
    appid: ::std::option::Option<u32>,
    msgtype: ::std::option::Option<u32>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    steamid: ::std::option::Option<u64>,
    gcname: ::protobuf::SingularField<::std::string::String>,
    ip: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClient {
    fn default() -> &'a CMsgGCClient {
        <CMsgGCClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClient {
    pub fn new() -> CMsgGCClient {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 msgtype = 2;


    pub fn get_msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }
    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 steamid = 4;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string gcname = 5;


    pub fn get_gcname(&self) -> &str {
        match self.gcname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gcname(&mut self) {
        self.gcname.clear();
    }

    pub fn has_gcname(&self) -> bool {
        self.gcname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcname(&mut self, v: ::std::string::String) {
        self.gcname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcname(&mut self) -> &mut ::std::string::String {
        if self.gcname.is_none() {
            self.gcname.set_default();
        }
        self.gcname.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcname(&mut self) -> ::std::string::String {
        self.gcname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ip = 6;


    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }
    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msgtype = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gcname)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.gcname.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.msgtype {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(ref v) = self.gcname.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClient {
        CMsgGCClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgGCClient| { &m.appid },
                |m: &mut CMsgGCClient| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "msgtype",
                |m: &CMsgGCClient| { &m.msgtype },
                |m: &mut CMsgGCClient| { &mut m.msgtype },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &CMsgGCClient| { &m.payload },
                |m: &mut CMsgGCClient| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgGCClient| { &m.steamid },
                |m: &mut CMsgGCClient| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gcname",
                |m: &CMsgGCClient| { &m.gcname },
                |m: &mut CMsgGCClient| { &mut m.gcname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ip",
                |m: &CMsgGCClient| { &m.ip },
                |m: &mut CMsgGCClient| { &mut m.ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClient>(
                "CMsgGCClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClient {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClient::new)
    }
}

impl ::protobuf::Clear for CMsgGCClient {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.msgtype = ::std::option::Option::None;
        self.payload.clear();
        self.steamid = ::std::option::Option::None;
        self.gcname.clear();
        self.ip = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestFreeLicense {
    // message fields
    pub appids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicense {
    fn default() -> &'a CMsgClientRequestFreeLicense {
        <CMsgClientRequestFreeLicense as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicense {
    pub fn new() -> CMsgClientRequestFreeLicense {
        ::std::default::Default::default()
    }

    // repeated uint32 appids = 2;


    pub fn get_appids(&self) -> &[u32] {
        &self.appids
    }
    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicense {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.appids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestFreeLicense {
        CMsgClientRequestFreeLicense::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appids",
                |m: &CMsgClientRequestFreeLicense| { &m.appids },
                |m: &mut CMsgClientRequestFreeLicense| { &mut m.appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestFreeLicense>(
                "CMsgClientRequestFreeLicense",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicense {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestFreeLicense> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestFreeLicense::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestFreeLicense {
    fn clear(&mut self) {
        self.appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestFreeLicense {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFreeLicense {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestFreeLicenseResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    pub granted_packageids: ::std::vec::Vec<u32>,
    pub granted_appids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFreeLicenseResponse {
    fn default() -> &'a CMsgClientRequestFreeLicenseResponse {
        <CMsgClientRequestFreeLicenseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFreeLicenseResponse {
    pub fn new() -> CMsgClientRequestFreeLicenseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated uint32 granted_packageids = 2;


    pub fn get_granted_packageids(&self) -> &[u32] {
        &self.granted_packageids
    }
    pub fn clear_granted_packageids(&mut self) {
        self.granted_packageids.clear();
    }

    // Param is passed by value, moved
    pub fn set_granted_packageids(&mut self, v: ::std::vec::Vec<u32>) {
        self.granted_packageids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_granted_packageids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_packageids
    }

    // Take field
    pub fn take_granted_packageids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.granted_packageids, ::std::vec::Vec::new())
    }

    // repeated uint32 granted_appids = 3;


    pub fn get_granted_appids(&self) -> &[u32] {
        &self.granted_appids
    }
    pub fn clear_granted_appids(&mut self) {
        self.granted_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_granted_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.granted_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_granted_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.granted_appids
    }

    // Take field
    pub fn take_granted_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.granted_appids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestFreeLicenseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.granted_packageids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.granted_appids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.granted_packageids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.granted_appids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        for v in &self.granted_packageids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.granted_appids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestFreeLicenseResponse {
        CMsgClientRequestFreeLicenseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientRequestFreeLicenseResponse| { &m.eresult },
                |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "granted_packageids",
                |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_packageids },
                |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_packageids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "granted_appids",
                |m: &CMsgClientRequestFreeLicenseResponse| { &m.granted_appids },
                |m: &mut CMsgClientRequestFreeLicenseResponse| { &mut m.granted_appids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestFreeLicenseResponse>(
                "CMsgClientRequestFreeLicenseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestFreeLicenseResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestFreeLicenseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestFreeLicenseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestFreeLicenseResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.granted_packageids.clear();
        self.granted_appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestFreeLicenseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFreeLicenseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDRMDownloadRequestWithCrashData {
    // message fields
    download_flags: ::std::option::Option<u32>,
    download_types_known: ::std::option::Option<u32>,
    guid_drm: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    guid_split: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    guid_merge: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    module_name: ::protobuf::SingularField<::std::string::String>,
    module_path: ::protobuf::SingularField<::std::string::String>,
    crash_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadRequestWithCrashData {
    fn default() -> &'a CMsgDRMDownloadRequestWithCrashData {
        <CMsgDRMDownloadRequestWithCrashData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadRequestWithCrashData {
    pub fn new() -> CMsgDRMDownloadRequestWithCrashData {
        ::std::default::Default::default()
    }

    // optional uint32 download_flags = 1;


    pub fn get_download_flags(&self) -> u32 {
        self.download_flags.unwrap_or(0)
    }
    pub fn clear_download_flags(&mut self) {
        self.download_flags = ::std::option::Option::None;
    }

    pub fn has_download_flags(&self) -> bool {
        self.download_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_flags(&mut self, v: u32) {
        self.download_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 download_types_known = 2;


    pub fn get_download_types_known(&self) -> u32 {
        self.download_types_known.unwrap_or(0)
    }
    pub fn clear_download_types_known(&mut self) {
        self.download_types_known = ::std::option::Option::None;
    }

    pub fn has_download_types_known(&self) -> bool {
        self.download_types_known.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_types_known(&mut self, v: u32) {
        self.download_types_known = ::std::option::Option::Some(v);
    }

    // optional bytes guid_drm = 3;


    pub fn get_guid_drm(&self) -> &[u8] {
        match self.guid_drm.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_guid_drm(&mut self) {
        self.guid_drm.clear();
    }

    pub fn has_guid_drm(&self) -> bool {
        self.guid_drm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_drm(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_drm = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_drm(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_drm.is_none() {
            self.guid_drm.set_default();
        }
        self.guid_drm.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_drm(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_drm.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_split = 4;


    pub fn get_guid_split(&self) -> &[u8] {
        match self.guid_split.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_guid_split(&mut self) {
        self.guid_split.clear();
    }

    pub fn has_guid_split(&self) -> bool {
        self.guid_split.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_split(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_split = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_split(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_split.is_none() {
            self.guid_split.set_default();
        }
        self.guid_split.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_split(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_split.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes guid_merge = 5;


    pub fn get_guid_merge(&self) -> &[u8] {
        match self.guid_merge.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_guid_merge(&mut self) {
        self.guid_merge.clear();
    }

    pub fn has_guid_merge(&self) -> bool {
        self.guid_merge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid_merge(&mut self, v: ::std::vec::Vec<u8>) {
        self.guid_merge = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_guid_merge(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.guid_merge.is_none() {
            self.guid_merge.set_default();
        }
        self.guid_merge.as_mut().unwrap()
    }

    // Take field
    pub fn take_guid_merge(&mut self) -> ::std::vec::Vec<u8> {
        self.guid_merge.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string module_name = 6;


    pub fn get_module_name(&self) -> &str {
        match self.module_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_module_name(&mut self) {
        self.module_name.clear();
    }

    pub fn has_module_name(&self) -> bool {
        self.module_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        if self.module_name.is_none() {
            self.module_name.set_default();
        }
        self.module_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        self.module_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 7;


    pub fn get_module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_module_path(&mut self) {
        self.module_path.clear();
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path.set_default();
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes crash_data = 8;


    pub fn get_crash_data(&self) -> &[u8] {
        match self.crash_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_crash_data(&mut self) {
        self.crash_data.clear();
    }

    pub fn has_crash_data(&self) -> bool {
        self.crash_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crash_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.crash_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crash_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.crash_data.is_none() {
            self.crash_data.set_default();
        }
        self.crash_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_crash_data(&mut self) -> ::std::vec::Vec<u8> {
        self.crash_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgDRMDownloadRequestWithCrashData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_flags = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_types_known = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.guid_drm)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.guid_split)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.guid_merge)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.module_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.module_path)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.crash_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.download_flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_types_known {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.guid_drm.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.guid_split.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.guid_merge.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.module_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.crash_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.download_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.download_types_known {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.guid_drm.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.guid_split.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.guid_merge.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.module_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.module_path.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.crash_data.as_ref() {
            os.write_bytes(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDRMDownloadRequestWithCrashData {
        CMsgDRMDownloadRequestWithCrashData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "download_flags",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_flags },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "download_types_known",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.download_types_known },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.download_types_known },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "guid_drm",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_drm },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_drm },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "guid_split",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_split },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_split },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "guid_merge",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.guid_merge },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.guid_merge },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "module_name",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_name },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "module_path",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.module_path },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.module_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "crash_data",
                |m: &CMsgDRMDownloadRequestWithCrashData| { &m.crash_data },
                |m: &mut CMsgDRMDownloadRequestWithCrashData| { &mut m.crash_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDRMDownloadRequestWithCrashData>(
                "CMsgDRMDownloadRequestWithCrashData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDRMDownloadRequestWithCrashData {
        static instance: ::protobuf::rt::LazyV2<CMsgDRMDownloadRequestWithCrashData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDRMDownloadRequestWithCrashData::new)
    }
}

impl ::protobuf::Clear for CMsgDRMDownloadRequestWithCrashData {
    fn clear(&mut self) {
        self.download_flags = ::std::option::Option::None;
        self.download_types_known = ::std::option::Option::None;
        self.guid_drm.clear();
        self.guid_split.clear();
        self.guid_merge.clear();
        self.module_name.clear();
        self.module_path.clear();
        self.crash_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDRMDownloadRequestWithCrashData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMDownloadRequestWithCrashData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDRMDownloadResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    blob_download_type: ::std::option::Option<u32>,
    merge_guid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    download_file_dfs_ip: ::std::option::Option<u32>,
    download_file_dfs_port: ::std::option::Option<u32>,
    download_file_url: ::protobuf::SingularField<::std::string::String>,
    module_path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDRMDownloadResponse {
    fn default() -> &'a CMsgDRMDownloadResponse {
        <CMsgDRMDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMDownloadResponse {
    pub fn new() -> CMsgDRMDownloadResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;


    pub fn get_blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }
    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 4;


    pub fn get_merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_merge_guid(&mut self) {
        self.merge_guid.clear();
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid.set_default();
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 5;


    pub fn get_download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }
    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 6;


    pub fn get_download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }
    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 7;


    pub fn get_download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_download_file_url(&mut self) {
        self.download_file_url.clear();
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url.set_default();
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string module_path = 8;


    pub fn get_module_path(&self) -> &str {
        match self.module_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_module_path(&mut self) {
        self.module_path.clear();
    }

    pub fn has_module_path(&self) -> bool {
        self.module_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_path(&mut self, v: ::std::string::String) {
        self.module_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_path(&mut self) -> &mut ::std::string::String {
        if self.module_path.is_none() {
            self.module_path.set_default();
        }
        self.module_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_path(&mut self) -> ::std::string::String {
        self.module_path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDRMDownloadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.blob_download_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.merge_guid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_file_dfs_ip = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_file_dfs_port = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.download_file_url)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.module_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.module_path.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.merge_guid.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.download_file_url.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.module_path.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDRMDownloadResponse {
        CMsgDRMDownloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgDRMDownloadResponse| { &m.eresult },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgDRMDownloadResponse| { &m.app_id },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "blob_download_type",
                |m: &CMsgDRMDownloadResponse| { &m.blob_download_type },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.blob_download_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "merge_guid",
                |m: &CMsgDRMDownloadResponse| { &m.merge_guid },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.merge_guid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "download_file_dfs_ip",
                |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_ip },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "download_file_dfs_port",
                |m: &CMsgDRMDownloadResponse| { &m.download_file_dfs_port },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_dfs_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "download_file_url",
                |m: &CMsgDRMDownloadResponse| { &m.download_file_url },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.download_file_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "module_path",
                |m: &CMsgDRMDownloadResponse| { &m.module_path },
                |m: &mut CMsgDRMDownloadResponse| { &mut m.module_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDRMDownloadResponse>(
                "CMsgDRMDownloadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDRMDownloadResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgDRMDownloadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDRMDownloadResponse::new)
    }
}

impl ::protobuf::Clear for CMsgDRMDownloadResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.merge_guid.clear();
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url.clear();
        self.module_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDRMDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMDownloadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDRMFinalResult {
    // message fields
    eResult: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    blob_download_type: ::std::option::Option<u32>,
    error_detail: ::std::option::Option<u32>,
    merge_guid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    download_file_dfs_ip: ::std::option::Option<u32>,
    download_file_dfs_port: ::std::option::Option<u32>,
    download_file_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDRMFinalResult {
    fn default() -> &'a CMsgDRMFinalResult {
        <CMsgDRMFinalResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDRMFinalResult {
    pub fn new() -> CMsgDRMFinalResult {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;


    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }
    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 2;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 blob_download_type = 3;


    pub fn get_blob_download_type(&self) -> u32 {
        self.blob_download_type.unwrap_or(0)
    }
    pub fn clear_blob_download_type(&mut self) {
        self.blob_download_type = ::std::option::Option::None;
    }

    pub fn has_blob_download_type(&self) -> bool {
        self.blob_download_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_download_type(&mut self, v: u32) {
        self.blob_download_type = ::std::option::Option::Some(v);
    }

    // optional uint32 error_detail = 4;


    pub fn get_error_detail(&self) -> u32 {
        self.error_detail.unwrap_or(0)
    }
    pub fn clear_error_detail(&mut self) {
        self.error_detail = ::std::option::Option::None;
    }

    pub fn has_error_detail(&self) -> bool {
        self.error_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_detail(&mut self, v: u32) {
        self.error_detail = ::std::option::Option::Some(v);
    }

    // optional bytes merge_guid = 5;


    pub fn get_merge_guid(&self) -> &[u8] {
        match self.merge_guid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_merge_guid(&mut self) {
        self.merge_guid.clear();
    }

    pub fn has_merge_guid(&self) -> bool {
        self.merge_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merge_guid(&mut self, v: ::std::vec::Vec<u8>) {
        self.merge_guid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merge_guid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.merge_guid.is_none() {
            self.merge_guid.set_default();
        }
        self.merge_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_merge_guid(&mut self) -> ::std::vec::Vec<u8> {
        self.merge_guid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 download_file_dfs_ip = 6;


    pub fn get_download_file_dfs_ip(&self) -> u32 {
        self.download_file_dfs_ip.unwrap_or(0)
    }
    pub fn clear_download_file_dfs_ip(&mut self) {
        self.download_file_dfs_ip = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_ip(&self) -> bool {
        self.download_file_dfs_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_ip(&mut self, v: u32) {
        self.download_file_dfs_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 download_file_dfs_port = 7;


    pub fn get_download_file_dfs_port(&self) -> u32 {
        self.download_file_dfs_port.unwrap_or(0)
    }
    pub fn clear_download_file_dfs_port(&mut self) {
        self.download_file_dfs_port = ::std::option::Option::None;
    }

    pub fn has_download_file_dfs_port(&self) -> bool {
        self.download_file_dfs_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_dfs_port(&mut self, v: u32) {
        self.download_file_dfs_port = ::std::option::Option::Some(v);
    }

    // optional string download_file_url = 8;


    pub fn get_download_file_url(&self) -> &str {
        match self.download_file_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_download_file_url(&mut self) {
        self.download_file_url.clear();
    }

    pub fn has_download_file_url(&self) -> bool {
        self.download_file_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_file_url(&mut self, v: ::std::string::String) {
        self.download_file_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_download_file_url(&mut self) -> &mut ::std::string::String {
        if self.download_file_url.is_none() {
            self.download_file_url.set_default();
        }
        self.download_file_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_download_file_url(&mut self) -> ::std::string::String {
        self.download_file_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDRMFinalResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eResult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.blob_download_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.error_detail = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.merge_guid)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_file_dfs_ip = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_file_dfs_port = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.download_file_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blob_download_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_detail {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.merge_guid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.download_file_dfs_ip {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.download_file_dfs_port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.download_file_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.blob_download_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.error_detail {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.merge_guid.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.download_file_dfs_ip {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.download_file_dfs_port {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.download_file_url.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDRMFinalResult {
        CMsgDRMFinalResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eResult",
                |m: &CMsgDRMFinalResult| { &m.eResult },
                |m: &mut CMsgDRMFinalResult| { &mut m.eResult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgDRMFinalResult| { &m.app_id },
                |m: &mut CMsgDRMFinalResult| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "blob_download_type",
                |m: &CMsgDRMFinalResult| { &m.blob_download_type },
                |m: &mut CMsgDRMFinalResult| { &mut m.blob_download_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "error_detail",
                |m: &CMsgDRMFinalResult| { &m.error_detail },
                |m: &mut CMsgDRMFinalResult| { &mut m.error_detail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "merge_guid",
                |m: &CMsgDRMFinalResult| { &m.merge_guid },
                |m: &mut CMsgDRMFinalResult| { &mut m.merge_guid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "download_file_dfs_ip",
                |m: &CMsgDRMFinalResult| { &m.download_file_dfs_ip },
                |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "download_file_dfs_port",
                |m: &CMsgDRMFinalResult| { &m.download_file_dfs_port },
                |m: &mut CMsgDRMFinalResult| { &mut m.download_file_dfs_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "download_file_url",
                |m: &CMsgDRMFinalResult| { &m.download_file_url },
                |m: &mut CMsgDRMFinalResult| { &mut m.download_file_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDRMFinalResult>(
                "CMsgDRMFinalResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDRMFinalResult {
        static instance: ::protobuf::rt::LazyV2<CMsgDRMFinalResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDRMFinalResult::new)
    }
}

impl ::protobuf::Clear for CMsgDRMFinalResult {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.blob_download_type = ::std::option::Option::None;
        self.error_detail = ::std::option::Option::None;
        self.merge_guid.clear();
        self.download_file_dfs_ip = ::std::option::Option::None;
        self.download_file_dfs_port = ::std::option::Option::None;
        self.download_file_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDRMFinalResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDRMFinalResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPCheckSpecialSurvey {
    // message fields
    survey_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurvey {
    fn default() -> &'a CMsgClientDPCheckSpecialSurvey {
        <CMsgClientDPCheckSpecialSurvey as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurvey {
    pub fn new() -> CMsgClientDPCheckSpecialSurvey {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;


    pub fn get_survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }
    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurvey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.survey_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPCheckSpecialSurvey {
        CMsgClientDPCheckSpecialSurvey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "survey_id",
                |m: &CMsgClientDPCheckSpecialSurvey| { &m.survey_id },
                |m: &mut CMsgClientDPCheckSpecialSurvey| { &mut m.survey_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDPCheckSpecialSurvey>(
                "CMsgClientDPCheckSpecialSurvey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurvey {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDPCheckSpecialSurvey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDPCheckSpecialSurvey::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPCheckSpecialSurvey {
    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPCheckSpecialSurvey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurvey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPCheckSpecialSurveyResponse {
    // message fields
    eResult: ::std::option::Option<u32>,
    state: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    custom_url: ::protobuf::SingularField<::std::string::String>,
    include_software: ::std::option::Option<bool>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPCheckSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPCheckSpecialSurveyResponse {
        <CMsgClientDPCheckSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPCheckSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;


    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }
    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional uint32 state = 2;


    pub fn get_state(&self) -> u32 {
        self.state.unwrap_or(0)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: u32) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_url = 4;


    pub fn get_custom_url(&self) -> &str {
        match self.custom_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_custom_url(&mut self) {
        self.custom_url.clear();
    }

    pub fn has_custom_url(&self) -> bool {
        self.custom_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_url(&mut self, v: ::std::string::String) {
        self.custom_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_url(&mut self) -> &mut ::std::string::String {
        if self.custom_url.is_none() {
            self.custom_url.set_default();
        }
        self.custom_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_url(&mut self) -> ::std::string::String {
        self.custom_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool include_software = 5;


    pub fn get_include_software(&self) -> bool {
        self.include_software.unwrap_or(false)
    }
    pub fn clear_include_software(&mut self) {
        self.include_software = ::std::option::Option::None;
    }

    pub fn has_include_software(&self) -> bool {
        self.include_software.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_software(&mut self, v: bool) {
        self.include_software = ::std::option::Option::Some(v);
    }

    // optional bytes token = 6;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPCheckSpecialSurveyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eResult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_software = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.custom_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.include_software {
            my_size += 2;
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.custom_url.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.include_software {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPCheckSpecialSurveyResponse {
        CMsgClientDPCheckSpecialSurveyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eResult",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.eResult },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.eResult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "state",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.state },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.name },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_url",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.custom_url },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.custom_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_software",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.include_software },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.include_software },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CMsgClientDPCheckSpecialSurveyResponse| { &m.token },
                |m: &mut CMsgClientDPCheckSpecialSurveyResponse| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDPCheckSpecialSurveyResponse>(
                "CMsgClientDPCheckSpecialSurveyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPCheckSpecialSurveyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDPCheckSpecialSurveyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDPCheckSpecialSurveyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPCheckSpecialSurveyResponse {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.name.clear();
        self.custom_url.clear();
        self.include_software = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPCheckSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPCheckSpecialSurveyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPSendSpecialSurveyResponse {
    // message fields
    survey_id: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponse {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponse {
        <CMsgClientDPSendSpecialSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponse {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;


    pub fn get_survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }
    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.survey_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponse {
        CMsgClientDPSendSpecialSurveyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "survey_id",
                |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.survey_id },
                |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.survey_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CMsgClientDPSendSpecialSurveyResponse| { &m.data },
                |m: &mut CMsgClientDPSendSpecialSurveyResponse| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDPSendSpecialSurveyResponse>(
                "CMsgClientDPSendSpecialSurveyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDPSendSpecialSurveyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDPSendSpecialSurveyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPSendSpecialSurveyResponse {
    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPSendSpecialSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDPSendSpecialSurveyResponseReply {
    // message fields
    eResult: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDPSendSpecialSurveyResponseReply {
    fn default() -> &'a CMsgClientDPSendSpecialSurveyResponseReply {
        <CMsgClientDPSendSpecialSurveyResponseReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDPSendSpecialSurveyResponseReply {
    pub fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;


    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(2u32)
    }
    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bytes token = 2;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientDPSendSpecialSurveyResponseReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eResult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDPSendSpecialSurveyResponseReply {
        CMsgClientDPSendSpecialSurveyResponseReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eResult",
                |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.eResult },
                |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.eResult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &CMsgClientDPSendSpecialSurveyResponseReply| { &m.token },
                |m: &mut CMsgClientDPSendSpecialSurveyResponseReply| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDPSendSpecialSurveyResponseReply>(
                "CMsgClientDPSendSpecialSurveyResponseReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDPSendSpecialSurveyResponseReply {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDPSendSpecialSurveyResponseReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDPSendSpecialSurveyResponseReply::new)
    }
}

impl ::protobuf::Clear for CMsgClientDPSendSpecialSurveyResponseReply {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDPSendSpecialSurveyResponseReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDPSendSpecialSurveyResponseReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestForgottenPasswordEmail {
    // message fields
    account_name: ::protobuf::SingularField<::std::string::String>,
    password_tried: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmail {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmail {
        <CMsgClientRequestForgottenPasswordEmail as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmail {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmail {
        ::std::default::Default::default()
    }

    // optional string account_name = 1;


    pub fn get_account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name.set_default();
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password_tried = 2;


    pub fn get_password_tried(&self) -> &str {
        match self.password_tried.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_password_tried(&mut self) {
        self.password_tried.clear();
    }

    pub fn has_password_tried(&self) -> bool {
        self.password_tried.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_tried(&mut self, v: ::std::string::String) {
        self.password_tried = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password_tried(&mut self) -> &mut ::std::string::String {
        if self.password_tried.is_none() {
            self.password_tried.set_default();
        }
        self.password_tried.as_mut().unwrap()
    }

    // Take field
    pub fn take_password_tried(&mut self) -> ::std::string::String {
        self.password_tried.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password_tried)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.password_tried.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.password_tried.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmail {
        CMsgClientRequestForgottenPasswordEmail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account_name",
                |m: &CMsgClientRequestForgottenPasswordEmail| { &m.account_name },
                |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.account_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password_tried",
                |m: &CMsgClientRequestForgottenPasswordEmail| { &m.password_tried },
                |m: &mut CMsgClientRequestForgottenPasswordEmail| { &mut m.password_tried },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestForgottenPasswordEmail>(
                "CMsgClientRequestForgottenPasswordEmail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmail {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestForgottenPasswordEmail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestForgottenPasswordEmail::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestForgottenPasswordEmail {
    fn clear(&mut self) {
        self.account_name.clear();
        self.password_tried.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestForgottenPasswordEmail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestForgottenPasswordEmailResponse {
    // message fields
    eResult: ::std::option::Option<u32>,
    use_secret_question: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestForgottenPasswordEmailResponse {
    fn default() -> &'a CMsgClientRequestForgottenPasswordEmailResponse {
        <CMsgClientRequestForgottenPasswordEmailResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestForgottenPasswordEmailResponse {
    pub fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eResult = 1;


    pub fn get_eResult(&self) -> u32 {
        self.eResult.unwrap_or(0)
    }
    pub fn clear_eResult(&mut self) {
        self.eResult = ::std::option::Option::None;
    }

    pub fn has_eResult(&self) -> bool {
        self.eResult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eResult(&mut self, v: u32) {
        self.eResult = ::std::option::Option::Some(v);
    }

    // optional bool use_secret_question = 2;


    pub fn get_use_secret_question(&self) -> bool {
        self.use_secret_question.unwrap_or(false)
    }
    pub fn clear_use_secret_question(&mut self) {
        self.use_secret_question = ::std::option::Option::None;
    }

    pub fn has_use_secret_question(&self) -> bool {
        self.use_secret_question.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_secret_question(&mut self, v: bool) {
        self.use_secret_question = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRequestForgottenPasswordEmailResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eResult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_secret_question = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eResult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_secret_question {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eResult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.use_secret_question {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestForgottenPasswordEmailResponse {
        CMsgClientRequestForgottenPasswordEmailResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eResult",
                |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.eResult },
                |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.eResult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_secret_question",
                |m: &CMsgClientRequestForgottenPasswordEmailResponse| { &m.use_secret_question },
                |m: &mut CMsgClientRequestForgottenPasswordEmailResponse| { &mut m.use_secret_question },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestForgottenPasswordEmailResponse>(
                "CMsgClientRequestForgottenPasswordEmailResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestForgottenPasswordEmailResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestForgottenPasswordEmailResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestForgottenPasswordEmailResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestForgottenPasswordEmailResponse {
    fn clear(&mut self) {
        self.eResult = ::std::option::Option::None;
        self.use_secret_question = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestForgottenPasswordEmailResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestForgottenPasswordEmailResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientItemAnnouncements {
    // message fields
    count_new_items: ::std::option::Option<u32>,
    pub unseen_items: ::protobuf::RepeatedField<CMsgClientItemAnnouncements_UnseenItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientItemAnnouncements {
    fn default() -> &'a CMsgClientItemAnnouncements {
        <CMsgClientItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientItemAnnouncements {
    pub fn new() -> CMsgClientItemAnnouncements {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_items = 1;


    pub fn get_count_new_items(&self) -> u32 {
        self.count_new_items.unwrap_or(0)
    }
    pub fn clear_count_new_items(&mut self) {
        self.count_new_items = ::std::option::Option::None;
    }

    pub fn has_count_new_items(&self) -> bool {
        self.count_new_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_items(&mut self, v: u32) {
        self.count_new_items = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientItemAnnouncements.UnseenItem unseen_items = 2;


    pub fn get_unseen_items(&self) -> &[CMsgClientItemAnnouncements_UnseenItem] {
        &self.unseen_items
    }
    pub fn clear_unseen_items(&mut self) {
        self.unseen_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_unseen_items(&mut self, v: ::protobuf::RepeatedField<CMsgClientItemAnnouncements_UnseenItem>) {
        self.unseen_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unseen_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientItemAnnouncements_UnseenItem> {
        &mut self.unseen_items
    }

    // Take field
    pub fn take_unseen_items(&mut self) -> ::protobuf::RepeatedField<CMsgClientItemAnnouncements_UnseenItem> {
        ::std::mem::replace(&mut self.unseen_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientItemAnnouncements {
    fn is_initialized(&self) -> bool {
        for v in &self.unseen_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count_new_items = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unseen_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_items {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.unseen_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count_new_items {
            os.write_uint32(1, v)?;
        }
        for v in &self.unseen_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientItemAnnouncements {
        CMsgClientItemAnnouncements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count_new_items",
                |m: &CMsgClientItemAnnouncements| { &m.count_new_items },
                |m: &mut CMsgClientItemAnnouncements| { &mut m.count_new_items },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientItemAnnouncements_UnseenItem>>(
                "unseen_items",
                |m: &CMsgClientItemAnnouncements| { &m.unseen_items },
                |m: &mut CMsgClientItemAnnouncements| { &mut m.unseen_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientItemAnnouncements>(
                "CMsgClientItemAnnouncements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientItemAnnouncements {
        static instance: ::protobuf::rt::LazyV2<CMsgClientItemAnnouncements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientItemAnnouncements::new)
    }
}

impl ::protobuf::Clear for CMsgClientItemAnnouncements {
    fn clear(&mut self) {
        self.count_new_items = ::std::option::Option::None;
        self.unseen_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientItemAnnouncements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientItemAnnouncements_UnseenItem {
    // message fields
    appid: ::std::option::Option<u32>,
    context_id: ::std::option::Option<u64>,
    asset_id: ::std::option::Option<u64>,
    amount: ::std::option::Option<u64>,
    rtime32_gained: ::std::option::Option<u32>,
    source_appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientItemAnnouncements_UnseenItem {
    fn default() -> &'a CMsgClientItemAnnouncements_UnseenItem {
        <CMsgClientItemAnnouncements_UnseenItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientItemAnnouncements_UnseenItem {
    pub fn new() -> CMsgClientItemAnnouncements_UnseenItem {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 context_id = 2;


    pub fn get_context_id(&self) -> u64 {
        self.context_id.unwrap_or(0)
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = ::std::option::Option::None;
    }

    pub fn has_context_id(&self) -> bool {
        self.context_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = ::std::option::Option::Some(v);
    }

    // optional uint64 asset_id = 3;


    pub fn get_asset_id(&self) -> u64 {
        self.asset_id.unwrap_or(0)
    }
    pub fn clear_asset_id(&mut self) {
        self.asset_id = ::std::option::Option::None;
    }

    pub fn has_asset_id(&self) -> bool {
        self.asset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asset_id(&mut self, v: u64) {
        self.asset_id = ::std::option::Option::Some(v);
    }

    // optional uint64 amount = 4;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime32_gained = 5;


    pub fn get_rtime32_gained(&self) -> u32 {
        self.rtime32_gained.unwrap_or(0)
    }
    pub fn clear_rtime32_gained(&mut self) {
        self.rtime32_gained = ::std::option::Option::None;
    }

    pub fn has_rtime32_gained(&self) -> bool {
        self.rtime32_gained.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_gained(&mut self, v: u32) {
        self.rtime32_gained = ::std::option::Option::Some(v);
    }

    // optional uint32 source_appid = 6;


    pub fn get_source_appid(&self) -> u32 {
        self.source_appid.unwrap_or(0)
    }
    pub fn clear_source_appid(&mut self) {
        self.source_appid = ::std::option::Option::None;
    }

    pub fn has_source_appid(&self) -> bool {
        self.source_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_appid(&mut self, v: u32) {
        self.source_appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientItemAnnouncements_UnseenItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.context_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.asset_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_gained = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.source_appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.context_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.asset_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime32_gained {
            my_size += 5;
        }
        if let Some(v) = self.source_appid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.context_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.asset_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.rtime32_gained {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.source_appid {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientItemAnnouncements_UnseenItem {
        CMsgClientItemAnnouncements_UnseenItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientItemAnnouncements_UnseenItem| { &m.appid },
                |m: &mut CMsgClientItemAnnouncements_UnseenItem| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "context_id",
                |m: &CMsgClientItemAnnouncements_UnseenItem| { &m.context_id },
                |m: &mut CMsgClientItemAnnouncements_UnseenItem| { &mut m.context_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "asset_id",
                |m: &CMsgClientItemAnnouncements_UnseenItem| { &m.asset_id },
                |m: &mut CMsgClientItemAnnouncements_UnseenItem| { &mut m.asset_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amount",
                |m: &CMsgClientItemAnnouncements_UnseenItem| { &m.amount },
                |m: &mut CMsgClientItemAnnouncements_UnseenItem| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_gained",
                |m: &CMsgClientItemAnnouncements_UnseenItem| { &m.rtime32_gained },
                |m: &mut CMsgClientItemAnnouncements_UnseenItem| { &mut m.rtime32_gained },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "source_appid",
                |m: &CMsgClientItemAnnouncements_UnseenItem| { &m.source_appid },
                |m: &mut CMsgClientItemAnnouncements_UnseenItem| { &mut m.source_appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientItemAnnouncements_UnseenItem>(
                "CMsgClientItemAnnouncements.UnseenItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientItemAnnouncements_UnseenItem {
        static instance: ::protobuf::rt::LazyV2<CMsgClientItemAnnouncements_UnseenItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientItemAnnouncements_UnseenItem::new)
    }
}

impl ::protobuf::Clear for CMsgClientItemAnnouncements_UnseenItem {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.context_id = ::std::option::Option::None;
        self.asset_id = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.rtime32_gained = ::std::option::Option::None;
        self.source_appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientItemAnnouncements_UnseenItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientItemAnnouncements_UnseenItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestItemAnnouncements {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestItemAnnouncements {
    fn default() -> &'a CMsgClientRequestItemAnnouncements {
        <CMsgClientRequestItemAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestItemAnnouncements {
    pub fn new() -> CMsgClientRequestItemAnnouncements {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestItemAnnouncements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestItemAnnouncements {
        CMsgClientRequestItemAnnouncements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestItemAnnouncements>(
                "CMsgClientRequestItemAnnouncements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestItemAnnouncements {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestItemAnnouncements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestItemAnnouncements::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestItemAnnouncements {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestItemAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestItemAnnouncements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUserNotifications {
    // message fields
    pub notifications: ::protobuf::RepeatedField<CMsgClientUserNotifications_Notification>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUserNotifications {
    fn default() -> &'a CMsgClientUserNotifications {
        <CMsgClientUserNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUserNotifications {
    pub fn new() -> CMsgClientUserNotifications {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientUserNotifications.Notification notifications = 1;


    pub fn get_notifications(&self) -> &[CMsgClientUserNotifications_Notification] {
        &self.notifications
    }
    pub fn clear_notifications(&mut self) {
        self.notifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: ::protobuf::RepeatedField<CMsgClientUserNotifications_Notification>) {
        self.notifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUserNotifications_Notification> {
        &mut self.notifications
    }

    // Take field
    pub fn take_notifications(&mut self) -> ::protobuf::RepeatedField<CMsgClientUserNotifications_Notification> {
        ::std::mem::replace(&mut self.notifications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientUserNotifications {
    fn is_initialized(&self) -> bool {
        for v in &self.notifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notifications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notifications {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUserNotifications {
        CMsgClientUserNotifications::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUserNotifications_Notification>>(
                "notifications",
                |m: &CMsgClientUserNotifications| { &m.notifications },
                |m: &mut CMsgClientUserNotifications| { &mut m.notifications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUserNotifications>(
                "CMsgClientUserNotifications",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUserNotifications {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUserNotifications> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUserNotifications::new)
    }
}

impl ::protobuf::Clear for CMsgClientUserNotifications {
    fn clear(&mut self) {
        self.notifications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUserNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUserNotifications {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUserNotifications_Notification {
    // message fields
    user_notification_type: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUserNotifications_Notification {
    fn default() -> &'a CMsgClientUserNotifications_Notification {
        <CMsgClientUserNotifications_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUserNotifications_Notification {
    pub fn new() -> CMsgClientUserNotifications_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 user_notification_type = 1;


    pub fn get_user_notification_type(&self) -> u32 {
        self.user_notification_type.unwrap_or(0)
    }
    pub fn clear_user_notification_type(&mut self) {
        self.user_notification_type = ::std::option::Option::None;
    }

    pub fn has_user_notification_type(&self) -> bool {
        self.user_notification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_notification_type(&mut self, v: u32) {
        self.user_notification_type = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 2;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUserNotifications_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_notification_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_notification_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_notification_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUserNotifications_Notification {
        CMsgClientUserNotifications_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "user_notification_type",
                |m: &CMsgClientUserNotifications_Notification| { &m.user_notification_type },
                |m: &mut CMsgClientUserNotifications_Notification| { &mut m.user_notification_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CMsgClientUserNotifications_Notification| { &m.count },
                |m: &mut CMsgClientUserNotifications_Notification| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUserNotifications_Notification>(
                "CMsgClientUserNotifications.Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUserNotifications_Notification {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUserNotifications_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUserNotifications_Notification::new)
    }
}

impl ::protobuf::Clear for CMsgClientUserNotifications_Notification {
    fn clear(&mut self) {
        self.user_notification_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUserNotifications_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUserNotifications_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientCommentNotifications {
    // message fields
    count_new_comments: ::std::option::Option<u32>,
    count_new_comments_owner: ::std::option::Option<u32>,
    count_new_comments_subscriptions: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCommentNotifications {
    fn default() -> &'a CMsgClientCommentNotifications {
        <CMsgClientCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCommentNotifications {
    pub fn new() -> CMsgClientCommentNotifications {
        ::std::default::Default::default()
    }

    // optional uint32 count_new_comments = 1;


    pub fn get_count_new_comments(&self) -> u32 {
        self.count_new_comments.unwrap_or(0)
    }
    pub fn clear_count_new_comments(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
    }

    pub fn has_count_new_comments(&self) -> bool {
        self.count_new_comments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments(&mut self, v: u32) {
        self.count_new_comments = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_owner = 2;


    pub fn get_count_new_comments_owner(&self) -> u32 {
        self.count_new_comments_owner.unwrap_or(0)
    }
    pub fn clear_count_new_comments_owner(&mut self) {
        self.count_new_comments_owner = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_owner(&self) -> bool {
        self.count_new_comments_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_owner(&mut self, v: u32) {
        self.count_new_comments_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 count_new_comments_subscriptions = 3;


    pub fn get_count_new_comments_subscriptions(&self) -> u32 {
        self.count_new_comments_subscriptions.unwrap_or(0)
    }
    pub fn clear_count_new_comments_subscriptions(&mut self) {
        self.count_new_comments_subscriptions = ::std::option::Option::None;
    }

    pub fn has_count_new_comments_subscriptions(&self) -> bool {
        self.count_new_comments_subscriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_new_comments_subscriptions(&mut self, v: u32) {
        self.count_new_comments_subscriptions = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCommentNotifications {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count_new_comments = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count_new_comments_owner = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count_new_comments_subscriptions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count_new_comments {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count_new_comments_owner {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count_new_comments {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count_new_comments_owner {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count_new_comments_subscriptions {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCommentNotifications {
        CMsgClientCommentNotifications::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count_new_comments",
                |m: &CMsgClientCommentNotifications| { &m.count_new_comments },
                |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count_new_comments_owner",
                |m: &CMsgClientCommentNotifications| { &m.count_new_comments_owner },
                |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count_new_comments_subscriptions",
                |m: &CMsgClientCommentNotifications| { &m.count_new_comments_subscriptions },
                |m: &mut CMsgClientCommentNotifications| { &mut m.count_new_comments_subscriptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCommentNotifications>(
                "CMsgClientCommentNotifications",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCommentNotifications {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCommentNotifications> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCommentNotifications::new)
    }
}

impl ::protobuf::Clear for CMsgClientCommentNotifications {
    fn clear(&mut self) {
        self.count_new_comments = ::std::option::Option::None;
        self.count_new_comments_owner = ::std::option::Option::None;
        self.count_new_comments_subscriptions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCommentNotifications {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestCommentNotifications {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestCommentNotifications {
    fn default() -> &'a CMsgClientRequestCommentNotifications {
        <CMsgClientRequestCommentNotifications as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestCommentNotifications {
    pub fn new() -> CMsgClientRequestCommentNotifications {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestCommentNotifications {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestCommentNotifications {
        CMsgClientRequestCommentNotifications::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestCommentNotifications>(
                "CMsgClientRequestCommentNotifications",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestCommentNotifications {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestCommentNotifications> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestCommentNotifications::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestCommentNotifications {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestCommentNotifications {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestCommentNotifications {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientOfflineMessageNotification {
    // message fields
    offline_messages: ::std::option::Option<u32>,
    pub friends_with_offline_messages: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientOfflineMessageNotification {
    fn default() -> &'a CMsgClientOfflineMessageNotification {
        <CMsgClientOfflineMessageNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientOfflineMessageNotification {
    pub fn new() -> CMsgClientOfflineMessageNotification {
        ::std::default::Default::default()
    }

    // optional uint32 offline_messages = 1;


    pub fn get_offline_messages(&self) -> u32 {
        self.offline_messages.unwrap_or(0)
    }
    pub fn clear_offline_messages(&mut self) {
        self.offline_messages = ::std::option::Option::None;
    }

    pub fn has_offline_messages(&self) -> bool {
        self.offline_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline_messages(&mut self, v: u32) {
        self.offline_messages = ::std::option::Option::Some(v);
    }

    // repeated uint32 friends_with_offline_messages = 2;


    pub fn get_friends_with_offline_messages(&self) -> &[u32] {
        &self.friends_with_offline_messages
    }
    pub fn clear_friends_with_offline_messages(&mut self) {
        self.friends_with_offline_messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends_with_offline_messages(&mut self, v: ::std::vec::Vec<u32>) {
        self.friends_with_offline_messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends_with_offline_messages(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.friends_with_offline_messages
    }

    // Take field
    pub fn take_friends_with_offline_messages(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.friends_with_offline_messages, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientOfflineMessageNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offline_messages = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.friends_with_offline_messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offline_messages {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.friends_with_offline_messages {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offline_messages {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends_with_offline_messages {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientOfflineMessageNotification {
        CMsgClientOfflineMessageNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "offline_messages",
                |m: &CMsgClientOfflineMessageNotification| { &m.offline_messages },
                |m: &mut CMsgClientOfflineMessageNotification| { &mut m.offline_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "friends_with_offline_messages",
                |m: &CMsgClientOfflineMessageNotification| { &m.friends_with_offline_messages },
                |m: &mut CMsgClientOfflineMessageNotification| { &mut m.friends_with_offline_messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientOfflineMessageNotification>(
                "CMsgClientOfflineMessageNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientOfflineMessageNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgClientOfflineMessageNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientOfflineMessageNotification::new)
    }
}

impl ::protobuf::Clear for CMsgClientOfflineMessageNotification {
    fn clear(&mut self) {
        self.offline_messages = ::std::option::Option::None;
        self.friends_with_offline_messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientOfflineMessageNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientOfflineMessageNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientRequestOfflineMessageCount {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestOfflineMessageCount {
    fn default() -> &'a CMsgClientRequestOfflineMessageCount {
        <CMsgClientRequestOfflineMessageCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestOfflineMessageCount {
    pub fn new() -> CMsgClientRequestOfflineMessageCount {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientRequestOfflineMessageCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestOfflineMessageCount {
        CMsgClientRequestOfflineMessageCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestOfflineMessageCount>(
                "CMsgClientRequestOfflineMessageCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestOfflineMessageCount {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestOfflineMessageCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestOfflineMessageCount::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestOfflineMessageCount {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestOfflineMessageCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestOfflineMessageCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatGetFriendMessageHistory {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistory {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistory {
        <CMsgClientChatGetFriendMessageHistory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistory {
    pub fn new() -> CMsgClientChatGetFriendMessageHistory {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatGetFriendMessageHistory {
        CMsgClientChatGetFriendMessageHistory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientChatGetFriendMessageHistory| { &m.steamid },
                |m: &mut CMsgClientChatGetFriendMessageHistory| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientChatGetFriendMessageHistory>(
                "CMsgClientChatGetFriendMessageHistory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistory {
        static instance: ::protobuf::rt::LazyV2<CMsgClientChatGetFriendMessageHistory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientChatGetFriendMessageHistory::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatGetFriendMessageHistory {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatGetFriendMessageHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatGetFriendMessageHistoryResponse {
    // message fields
    steamid: ::std::option::Option<u64>,
    success: ::std::option::Option<u32>,
    pub messages: ::protobuf::RepeatedField<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryResponse {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryResponse {
        <CMsgClientChatGetFriendMessageHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryResponse {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 success = 2;


    pub fn get_success(&self) -> u32 {
        self.success.unwrap_or(0)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage messages = 3;


    pub fn get_messages(&self) -> &[CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.success {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.success {
            os.write_uint32(2, v)?;
        }
        for v in &self.messages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryResponse {
        CMsgClientChatGetFriendMessageHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.steamid },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "success",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.success },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage>>(
                "messages",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse| { &m.messages },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientChatGetFriendMessageHistoryResponse>(
                "CMsgClientChatGetFriendMessageHistoryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientChatGetFriendMessageHistoryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientChatGetFriendMessageHistoryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatGetFriendMessageHistoryResponse {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatGetFriendMessageHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    // message fields
    accountid: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    unread: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
        <CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unread = 4;


    pub fn get_unread(&self) -> bool {
        self.unread.unwrap_or(false)
    }
    pub fn clear_unread(&mut self) {
        self.unread = ::std::option::Option::None;
    }

    pub fn has_unread(&self) -> bool {
        self.unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread(&mut self, v: bool) {
        self.unread = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unread = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.unread {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.unread {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
        CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &m.accountid },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &m.timestamp },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &m.message },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unread",
                |m: &CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &m.unread },
                |m: &mut CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage| { &mut m.unread },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage>(
                "CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
        static instance: ::protobuf::rt::LazyV2<CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.message.clear();
        self.unread = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn default() -> &'a CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        <CMsgClientChatGetFriendMessageHistoryForOfflineMessages as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    pub fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        CMsgClientChatGetFriendMessageHistoryForOfflineMessages::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientChatGetFriendMessageHistoryForOfflineMessages>(
                "CMsgClientChatGetFriendMessageHistoryForOfflineMessages",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
        static instance: ::protobuf::rt::LazyV2<CMsgClientChatGetFriendMessageHistoryForOfflineMessages> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientChatGetFriendMessageHistoryForOfflineMessages::new)
    }
}

impl ::protobuf::Clear for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFSGetFriendsSteamLevels {
    // message fields
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevels {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevels {
        <CMsgClientFSGetFriendsSteamLevels as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevels {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevels {
        ::std::default::Default::default()
    }

    // repeated uint32 accountids = 1;


    pub fn get_accountids(&self) -> &[u32] {
        &self.accountids
    }
    pub fn clear_accountids(&mut self) {
        self.accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }

    // Take field
    pub fn take_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accountids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevels {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accountids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accountids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevels {
        CMsgClientFSGetFriendsSteamLevels::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountids",
                |m: &CMsgClientFSGetFriendsSteamLevels| { &m.accountids },
                |m: &mut CMsgClientFSGetFriendsSteamLevels| { &mut m.accountids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFSGetFriendsSteamLevels>(
                "CMsgClientFSGetFriendsSteamLevels",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevels {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFSGetFriendsSteamLevels> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFSGetFriendsSteamLevels::new)
    }
}

impl ::protobuf::Clear for CMsgClientFSGetFriendsSteamLevels {
    fn clear(&mut self) {
        self.accountids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFSGetFriendsSteamLevels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevels {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFSGetFriendsSteamLevelsResponse {
    // message fields
    pub friends: ::protobuf::RepeatedField<CMsgClientFSGetFriendsSteamLevelsResponse_Friend>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevelsResponse {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevelsResponse {
        <CMsgClientFSGetFriendsSteamLevelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevelsResponse {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientFSGetFriendsSteamLevelsResponse.Friend friends = 1;


    pub fn get_friends(&self) -> &[CMsgClientFSGetFriendsSteamLevelsResponse_Friend] {
        &self.friends
    }
    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<CMsgClientFSGetFriendsSteamLevelsResponse_Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientFSGetFriendsSteamLevelsResponse_Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<CMsgClientFSGetFriendsSteamLevelsResponse_Friend> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.friends {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse {
        CMsgClientFSGetFriendsSteamLevelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientFSGetFriendsSteamLevelsResponse_Friend>>(
                "friends",
                |m: &CMsgClientFSGetFriendsSteamLevelsResponse| { &m.friends },
                |m: &mut CMsgClientFSGetFriendsSteamLevelsResponse| { &mut m.friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFSGetFriendsSteamLevelsResponse>(
                "CMsgClientFSGetFriendsSteamLevelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevelsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFSGetFriendsSteamLevelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFSGetFriendsSteamLevelsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn clear(&mut self) {
        self.friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    // message fields
    accountid: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    fn default() -> &'a CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
        <CMsgClientFSGetFriendsSteamLevelsResponse_Friend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    pub fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 2;


    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }
    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
        CMsgClientFSGetFriendsSteamLevelsResponse_Friend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CMsgClientFSGetFriendsSteamLevelsResponse_Friend| { &m.accountid },
                |m: &mut CMsgClientFSGetFriendsSteamLevelsResponse_Friend| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level",
                |m: &CMsgClientFSGetFriendsSteamLevelsResponse_Friend| { &m.level },
                |m: &mut CMsgClientFSGetFriendsSteamLevelsResponse_Friend| { &mut m.level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFSGetFriendsSteamLevelsResponse_Friend>(
                "CMsgClientFSGetFriendsSteamLevelsResponse.Friend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFSGetFriendsSteamLevelsResponse_Friend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFSGetFriendsSteamLevelsResponse_Friend::new)
    }
}

impl ::protobuf::Clear for CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientEmailAddrInfo {
    // message fields
    email_address: ::protobuf::SingularField<::std::string::String>,
    email_is_validated: ::std::option::Option<bool>,
    email_validation_changed: ::std::option::Option<bool>,
    credential_change_requires_code: ::std::option::Option<bool>,
    password_or_secretqa_change_requires_code: ::std::option::Option<bool>,
    remind_user_about_email: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmailAddrInfo {
    fn default() -> &'a CMsgClientEmailAddrInfo {
        <CMsgClientEmailAddrInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmailAddrInfo {
    pub fn new() -> CMsgClientEmailAddrInfo {
        ::std::default::Default::default()
    }

    // optional string email_address = 1;


    pub fn get_email_address(&self) -> &str {
        match self.email_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    pub fn has_email_address(&self) -> bool {
        self.email_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        if self.email_address.is_none() {
            self.email_address.set_default();
        }
        self.email_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool email_is_validated = 2;


    pub fn get_email_is_validated(&self) -> bool {
        self.email_is_validated.unwrap_or(false)
    }
    pub fn clear_email_is_validated(&mut self) {
        self.email_is_validated = ::std::option::Option::None;
    }

    pub fn has_email_is_validated(&self) -> bool {
        self.email_is_validated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_is_validated(&mut self, v: bool) {
        self.email_is_validated = ::std::option::Option::Some(v);
    }

    // optional bool email_validation_changed = 3;


    pub fn get_email_validation_changed(&self) -> bool {
        self.email_validation_changed.unwrap_or(false)
    }
    pub fn clear_email_validation_changed(&mut self) {
        self.email_validation_changed = ::std::option::Option::None;
    }

    pub fn has_email_validation_changed(&self) -> bool {
        self.email_validation_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_validation_changed(&mut self, v: bool) {
        self.email_validation_changed = ::std::option::Option::Some(v);
    }

    // optional bool credential_change_requires_code = 4;


    pub fn get_credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.unwrap_or(false)
    }
    pub fn clear_credential_change_requires_code(&mut self) {
        self.credential_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_credential_change_requires_code(&self) -> bool {
        self.credential_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential_change_requires_code(&mut self, v: bool) {
        self.credential_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool password_or_secretqa_change_requires_code = 5;


    pub fn get_password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.unwrap_or(false)
    }
    pub fn clear_password_or_secretqa_change_requires_code(&mut self) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
    }

    pub fn has_password_or_secretqa_change_requires_code(&self) -> bool {
        self.password_or_secretqa_change_requires_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password_or_secretqa_change_requires_code(&mut self, v: bool) {
        self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(v);
    }

    // optional bool remind_user_about_email = 6;


    pub fn get_remind_user_about_email(&self) -> bool {
        self.remind_user_about_email.unwrap_or(false)
    }
    pub fn clear_remind_user_about_email(&mut self) {
        self.remind_user_about_email = ::std::option::Option::None;
    }

    pub fn has_remind_user_about_email(&self) -> bool {
        self.remind_user_about_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remind_user_about_email(&mut self, v: bool) {
        self.remind_user_about_email = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEmailAddrInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.email_is_validated = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.email_validation_changed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.credential_change_requires_code = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.password_or_secretqa_change_requires_code = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remind_user_about_email = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.email_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.email_is_validated {
            my_size += 2;
        }
        if let Some(v) = self.email_validation_changed {
            my_size += 2;
        }
        if let Some(v) = self.credential_change_requires_code {
            my_size += 2;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            my_size += 2;
        }
        if let Some(v) = self.remind_user_about_email {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.email_address.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.email_is_validated {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.email_validation_changed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.credential_change_requires_code {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.password_or_secretqa_change_requires_code {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.remind_user_about_email {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientEmailAddrInfo {
        CMsgClientEmailAddrInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email_address",
                |m: &CMsgClientEmailAddrInfo| { &m.email_address },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "email_is_validated",
                |m: &CMsgClientEmailAddrInfo| { &m.email_is_validated },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_is_validated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "email_validation_changed",
                |m: &CMsgClientEmailAddrInfo| { &m.email_validation_changed },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.email_validation_changed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "credential_change_requires_code",
                |m: &CMsgClientEmailAddrInfo| { &m.credential_change_requires_code },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.credential_change_requires_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "password_or_secretqa_change_requires_code",
                |m: &CMsgClientEmailAddrInfo| { &m.password_or_secretqa_change_requires_code },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.password_or_secretqa_change_requires_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remind_user_about_email",
                |m: &CMsgClientEmailAddrInfo| { &m.remind_user_about_email },
                |m: &mut CMsgClientEmailAddrInfo| { &mut m.remind_user_about_email },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientEmailAddrInfo>(
                "CMsgClientEmailAddrInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientEmailAddrInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientEmailAddrInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientEmailAddrInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientEmailAddrInfo {
    fn clear(&mut self) {
        self.email_address.clear();
        self.email_is_validated = ::std::option::Option::None;
        self.email_validation_changed = ::std::option::Option::None;
        self.credential_change_requires_code = ::std::option::Option::None;
        self.password_or_secretqa_change_requires_code = ::std::option::Option::None;
        self.remind_user_about_email = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientEmailAddrInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmailAddrInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREItemVoteSummary {
    // message fields
    pub published_file_ids: ::protobuf::RepeatedField<CMsgCREItemVoteSummary_PublishedFileId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummary {
    fn default() -> &'a CMsgCREItemVoteSummary {
        <CMsgCREItemVoteSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummary {
    pub fn new() -> CMsgCREItemVoteSummary {
        ::std::default::Default::default()
    }

    // repeated .CMsgCREItemVoteSummary.PublishedFileId published_file_ids = 1;


    pub fn get_published_file_ids(&self) -> &[CMsgCREItemVoteSummary_PublishedFileId] {
        &self.published_file_ids
    }
    pub fn clear_published_file_ids(&mut self) {
        self.published_file_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_file_ids(&mut self, v: ::protobuf::RepeatedField<CMsgCREItemVoteSummary_PublishedFileId>) {
        self.published_file_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_file_ids(&mut self) -> &mut ::protobuf::RepeatedField<CMsgCREItemVoteSummary_PublishedFileId> {
        &mut self.published_file_ids
    }

    // Take field
    pub fn take_published_file_ids(&mut self) -> ::protobuf::RepeatedField<CMsgCREItemVoteSummary_PublishedFileId> {
        ::std::mem::replace(&mut self.published_file_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummary {
    fn is_initialized(&self) -> bool {
        for v in &self.published_file_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.published_file_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.published_file_ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREItemVoteSummary {
        CMsgCREItemVoteSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgCREItemVoteSummary_PublishedFileId>>(
                "published_file_ids",
                |m: &CMsgCREItemVoteSummary| { &m.published_file_ids },
                |m: &mut CMsgCREItemVoteSummary| { &mut m.published_file_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREItemVoteSummary>(
                "CMsgCREItemVoteSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummary {
        static instance: ::protobuf::rt::LazyV2<CMsgCREItemVoteSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREItemVoteSummary::new)
    }
}

impl ::protobuf::Clear for CMsgCREItemVoteSummary {
    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREItemVoteSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREItemVoteSummary_PublishedFileId {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummary_PublishedFileId {
    fn default() -> &'a CMsgCREItemVoteSummary_PublishedFileId {
        <CMsgCREItemVoteSummary_PublishedFileId as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummary_PublishedFileId {
    pub fn new() -> CMsgCREItemVoteSummary_PublishedFileId {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummary_PublishedFileId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREItemVoteSummary_PublishedFileId {
        CMsgCREItemVoteSummary_PublishedFileId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgCREItemVoteSummary_PublishedFileId| { &m.published_file_id },
                |m: &mut CMsgCREItemVoteSummary_PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREItemVoteSummary_PublishedFileId>(
                "CMsgCREItemVoteSummary.PublishedFileId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummary_PublishedFileId {
        static instance: ::protobuf::rt::LazyV2<CMsgCREItemVoteSummary_PublishedFileId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREItemVoteSummary_PublishedFileId::new)
    }
}

impl ::protobuf::Clear for CMsgCREItemVoteSummary_PublishedFileId {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREItemVoteSummary_PublishedFileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummary_PublishedFileId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREItemVoteSummaryResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub item_vote_summaries: ::protobuf::RepeatedField<CMsgCREItemVoteSummaryResponse_ItemVoteSummary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummaryResponse {
    fn default() -> &'a CMsgCREItemVoteSummaryResponse {
        <CMsgCREItemVoteSummaryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummaryResponse {
    pub fn new() -> CMsgCREItemVoteSummaryResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgCREItemVoteSummaryResponse.ItemVoteSummary item_vote_summaries = 2;


    pub fn get_item_vote_summaries(&self) -> &[CMsgCREItemVoteSummaryResponse_ItemVoteSummary] {
        &self.item_vote_summaries
    }
    pub fn clear_item_vote_summaries(&mut self) {
        self.item_vote_summaries.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_vote_summaries(&mut self, v: ::protobuf::RepeatedField<CMsgCREItemVoteSummaryResponse_ItemVoteSummary>) {
        self.item_vote_summaries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_vote_summaries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgCREItemVoteSummaryResponse_ItemVoteSummary> {
        &mut self.item_vote_summaries
    }

    // Take field
    pub fn take_item_vote_summaries(&mut self) -> ::protobuf::RepeatedField<CMsgCREItemVoteSummaryResponse_ItemVoteSummary> {
        ::std::mem::replace(&mut self.item_vote_summaries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummaryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.item_vote_summaries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item_vote_summaries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_vote_summaries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.item_vote_summaries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREItemVoteSummaryResponse {
        CMsgCREItemVoteSummaryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgCREItemVoteSummaryResponse| { &m.eresult },
                |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgCREItemVoteSummaryResponse_ItemVoteSummary>>(
                "item_vote_summaries",
                |m: &CMsgCREItemVoteSummaryResponse| { &m.item_vote_summaries },
                |m: &mut CMsgCREItemVoteSummaryResponse| { &mut m.item_vote_summaries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREItemVoteSummaryResponse>(
                "CMsgCREItemVoteSummaryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummaryResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgCREItemVoteSummaryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREItemVoteSummaryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCREItemVoteSummaryResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.item_vote_summaries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREItemVoteSummaryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummaryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    votes_for: ::std::option::Option<i32>,
    votes_against: ::std::option::Option<i32>,
    reports: ::std::option::Option<i32>,
    score: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    fn default() -> &'a CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
        <CMsgCREItemVoteSummaryResponse_ItemVoteSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    pub fn new() -> CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional int32 votes_for = 2;


    pub fn get_votes_for(&self) -> i32 {
        self.votes_for.unwrap_or(0)
    }
    pub fn clear_votes_for(&mut self) {
        self.votes_for = ::std::option::Option::None;
    }

    pub fn has_votes_for(&self) -> bool {
        self.votes_for.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_for(&mut self, v: i32) {
        self.votes_for = ::std::option::Option::Some(v);
    }

    // optional int32 votes_against = 3;


    pub fn get_votes_against(&self) -> i32 {
        self.votes_against.unwrap_or(0)
    }
    pub fn clear_votes_against(&mut self) {
        self.votes_against = ::std::option::Option::None;
    }

    pub fn has_votes_against(&self) -> bool {
        self.votes_against.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_against(&mut self, v: i32) {
        self.votes_against = ::std::option::Option::Some(v);
    }

    // optional int32 reports = 4;


    pub fn get_reports(&self) -> i32 {
        self.reports.unwrap_or(0)
    }
    pub fn clear_reports(&mut self) {
        self.reports = ::std::option::Option::None;
    }

    pub fn has_reports(&self) -> bool {
        self.reports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: i32) {
        self.reports = ::std::option::Option::Some(v);
    }

    // optional float score = 5;


    pub fn get_score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.votes_for = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.votes_against = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reports = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.votes_for {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.votes_against {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reports {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.votes_for {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.votes_against {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.reports {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.score {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
        CMsgCREItemVoteSummaryResponse_ItemVoteSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &m.published_file_id },
                |m: &mut CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "votes_for",
                |m: &CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &m.votes_for },
                |m: &mut CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &mut m.votes_for },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "votes_against",
                |m: &CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &m.votes_against },
                |m: &mut CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &mut m.votes_against },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "reports",
                |m: &CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &m.reports },
                |m: &mut CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &mut m.reports },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "score",
                |m: &CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &m.score },
                |m: &mut CMsgCREItemVoteSummaryResponse_ItemVoteSummary| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREItemVoteSummaryResponse_ItemVoteSummary>(
                "CMsgCREItemVoteSummaryResponse.ItemVoteSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
        static instance: ::protobuf::rt::LazyV2<CMsgCREItemVoteSummaryResponse_ItemVoteSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREItemVoteSummaryResponse_ItemVoteSummary::new)
    }
}

impl ::protobuf::Clear for CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.votes_for = ::std::option::Option::None;
        self.votes_against = ::std::option::Option::None;
        self.reports = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREUpdateUserPublishedItemVote {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    vote_up: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVote {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVote {
        <CMsgCREUpdateUserPublishedItemVote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVote {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVote {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional bool vote_up = 2;


    pub fn get_vote_up(&self) -> bool {
        self.vote_up.unwrap_or(false)
    }
    pub fn clear_vote_up(&mut self) {
        self.vote_up = ::std::option::Option::None;
    }

    pub fn has_vote_up(&self) -> bool {
        self.vote_up.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_up(&mut self, v: bool) {
        self.vote_up = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vote_up = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.vote_up {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote_up {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVote {
        CMsgCREUpdateUserPublishedItemVote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgCREUpdateUserPublishedItemVote| { &m.published_file_id },
                |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "vote_up",
                |m: &CMsgCREUpdateUserPublishedItemVote| { &m.vote_up },
                |m: &mut CMsgCREUpdateUserPublishedItemVote| { &mut m.vote_up },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREUpdateUserPublishedItemVote>(
                "CMsgCREUpdateUserPublishedItemVote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVote {
        static instance: ::protobuf::rt::LazyV2<CMsgCREUpdateUserPublishedItemVote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREUpdateUserPublishedItemVote::new)
    }
}

impl ::protobuf::Clear for CMsgCREUpdateUserPublishedItemVote {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.vote_up = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREUpdateUserPublishedItemVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREUpdateUserPublishedItemVoteResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREUpdateUserPublishedItemVoteResponse {
    fn default() -> &'a CMsgCREUpdateUserPublishedItemVoteResponse {
        <CMsgCREUpdateUserPublishedItemVoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREUpdateUserPublishedItemVoteResponse {
    pub fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREUpdateUserPublishedItemVoteResponse {
        CMsgCREUpdateUserPublishedItemVoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgCREUpdateUserPublishedItemVoteResponse| { &m.eresult },
                |m: &mut CMsgCREUpdateUserPublishedItemVoteResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREUpdateUserPublishedItemVoteResponse>(
                "CMsgCREUpdateUserPublishedItemVoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREUpdateUserPublishedItemVoteResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgCREUpdateUserPublishedItemVoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREUpdateUserPublishedItemVoteResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREUpdateUserPublishedItemVoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREGetUserPublishedItemVoteDetails {
    // message fields
    pub published_file_ids: ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetails {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetails {
        <CMsgCREGetUserPublishedItemVoteDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetails {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        ::std::default::Default::default()
    }

    // repeated .CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId published_file_ids = 1;


    pub fn get_published_file_ids(&self) -> &[CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId] {
        &self.published_file_ids
    }
    pub fn clear_published_file_ids(&mut self) {
        self.published_file_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_published_file_ids(&mut self, v: ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId>) {
        self.published_file_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_published_file_ids(&mut self) -> &mut ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId> {
        &mut self.published_file_ids
    }

    // Take field
    pub fn take_published_file_ids(&mut self) -> ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId> {
        ::std::mem::replace(&mut self.published_file_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.published_file_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.published_file_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.published_file_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.published_file_ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetails {
        CMsgCREGetUserPublishedItemVoteDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId>>(
                "published_file_ids",
                |m: &CMsgCREGetUserPublishedItemVoteDetails| { &m.published_file_ids },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetails| { &mut m.published_file_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREGetUserPublishedItemVoteDetails>(
                "CMsgCREGetUserPublishedItemVoteDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetails {
        static instance: ::protobuf::rt::LazyV2<CMsgCREGetUserPublishedItemVoteDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREGetUserPublishedItemVoteDetails::new)
    }
}

impl ::protobuf::Clear for CMsgCREGetUserPublishedItemVoteDetails {
    fn clear(&mut self) {
        self.published_file_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREGetUserPublishedItemVoteDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
        <CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
        CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId| { &m.published_file_id },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId| { &mut m.published_file_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId>(
                "CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
        static instance: ::protobuf::rt::LazyV2<CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId::new)
    }
}

impl ::protobuf::Clear for CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub user_item_vote_details: ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetailsResponse {
        <CMsgCREGetUserPublishedItemVoteDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetailsResponse {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail user_item_vote_details = 2;


    pub fn get_user_item_vote_details(&self) -> &[CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail] {
        &self.user_item_vote_details
    }
    pub fn clear_user_item_vote_details(&mut self) {
        self.user_item_vote_details.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_item_vote_details(&mut self, v: ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail>) {
        self.user_item_vote_details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_item_vote_details(&mut self) -> &mut ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail> {
        &mut self.user_item_vote_details
    }

    // Take field
    pub fn take_user_item_vote_details(&mut self) -> ::protobuf::RepeatedField<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail> {
        ::std::mem::replace(&mut self.user_item_vote_details, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.user_item_vote_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.user_item_vote_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.user_item_vote_details {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.user_item_vote_details {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse {
        CMsgCREGetUserPublishedItemVoteDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.eresult },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail>>(
                "user_item_vote_details",
                |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse| { &m.user_item_vote_details },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse| { &mut m.user_item_vote_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREGetUserPublishedItemVoteDetailsResponse>(
                "CMsgCREGetUserPublishedItemVoteDetailsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetailsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgCREGetUserPublishedItemVoteDetailsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREGetUserPublishedItemVoteDetailsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.user_item_vote_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    // message fields
    published_file_id: ::std::option::Option<u64>,
    vote: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    fn default() -> &'a CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
        <CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    pub fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
        ::std::default::Default::default()
    }

    // optional fixed64 published_file_id = 1;


    pub fn get_published_file_id(&self) -> u64 {
        self.published_file_id.unwrap_or(0)
    }
    pub fn clear_published_file_id(&mut self) {
        self.published_file_id = ::std::option::Option::None;
    }

    pub fn has_published_file_id(&self) -> bool {
        self.published_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_file_id(&mut self, v: u64) {
        self.published_file_id = ::std::option::Option::Some(v);
    }

    // optional int32 vote = 2;


    pub fn get_vote(&self) -> i32 {
        self.vote.unwrap_or(0i32)
    }
    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: i32) {
        self.vote = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.published_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vote = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.published_file_id {
            my_size += 9;
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.published_file_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
        CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "published_file_id",
                |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail| { &m.published_file_id },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail| { &mut m.published_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vote",
                |m: &CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail| { &m.vote },
                |m: &mut CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail| { &mut m.vote },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail>(
                "CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
        static instance: ::protobuf::rt::LazyV2<CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail::new)
    }
}

impl ::protobuf::Clear for CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    fn clear(&mut self) {
        self.published_file_id = ::std::option::Option::None;
        self.vote = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerPingSample {
    // message fields
    my_ip: ::std::option::Option<u32>,
    gs_app_id: ::std::option::Option<i32>,
    pub gs_samples: ::protobuf::RepeatedField<CMsgGameServerPingSample_Sample>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerPingSample {
    fn default() -> &'a CMsgGameServerPingSample {
        <CMsgGameServerPingSample as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerPingSample {
    pub fn new() -> CMsgGameServerPingSample {
        ::std::default::Default::default()
    }

    // optional fixed32 my_ip = 1;


    pub fn get_my_ip(&self) -> u32 {
        self.my_ip.unwrap_or(0)
    }
    pub fn clear_my_ip(&mut self) {
        self.my_ip = ::std::option::Option::None;
    }

    pub fn has_my_ip(&self) -> bool {
        self.my_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_my_ip(&mut self, v: u32) {
        self.my_ip = ::std::option::Option::Some(v);
    }

    // optional int32 gs_app_id = 2;


    pub fn get_gs_app_id(&self) -> i32 {
        self.gs_app_id.unwrap_or(0)
    }
    pub fn clear_gs_app_id(&mut self) {
        self.gs_app_id = ::std::option::Option::None;
    }

    pub fn has_gs_app_id(&self) -> bool {
        self.gs_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gs_app_id(&mut self, v: i32) {
        self.gs_app_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGameServerPingSample.Sample gs_samples = 3;


    pub fn get_gs_samples(&self) -> &[CMsgGameServerPingSample_Sample] {
        &self.gs_samples
    }
    pub fn clear_gs_samples(&mut self) {
        self.gs_samples.clear();
    }

    // Param is passed by value, moved
    pub fn set_gs_samples(&mut self, v: ::protobuf::RepeatedField<CMsgGameServerPingSample_Sample>) {
        self.gs_samples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gs_samples(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameServerPingSample_Sample> {
        &mut self.gs_samples
    }

    // Take field
    pub fn take_gs_samples(&mut self) -> ::protobuf::RepeatedField<CMsgGameServerPingSample_Sample> {
        ::std::mem::replace(&mut self.gs_samples, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGameServerPingSample {
    fn is_initialized(&self) -> bool {
        for v in &self.gs_samples {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.my_ip = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.gs_app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gs_samples)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.my_ip {
            my_size += 5;
        }
        if let Some(v) = self.gs_app_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.gs_samples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.my_ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.gs_app_id {
            os.write_int32(2, v)?;
        }
        for v in &self.gs_samples {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerPingSample {
        CMsgGameServerPingSample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "my_ip",
                |m: &CMsgGameServerPingSample| { &m.my_ip },
                |m: &mut CMsgGameServerPingSample| { &mut m.my_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "gs_app_id",
                |m: &CMsgGameServerPingSample| { &m.gs_app_id },
                |m: &mut CMsgGameServerPingSample| { &mut m.gs_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameServerPingSample_Sample>>(
                "gs_samples",
                |m: &CMsgGameServerPingSample| { &m.gs_samples },
                |m: &mut CMsgGameServerPingSample| { &mut m.gs_samples },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerPingSample>(
                "CMsgGameServerPingSample",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerPingSample {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerPingSample> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerPingSample::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerPingSample {
    fn clear(&mut self) {
        self.my_ip = ::std::option::Option::None;
        self.gs_app_id = ::std::option::Option::None;
        self.gs_samples.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerPingSample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerPingSample {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerPingSample_Sample {
    // message fields
    ip: ::std::option::Option<u32>,
    avg_ping_ms: ::std::option::Option<u32>,
    stddev_ping_ms_x10: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerPingSample_Sample {
    fn default() -> &'a CMsgGameServerPingSample_Sample {
        <CMsgGameServerPingSample_Sample as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerPingSample_Sample {
    pub fn new() -> CMsgGameServerPingSample_Sample {
        ::std::default::Default::default()
    }

    // optional fixed32 ip = 1;


    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }
    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_ping_ms = 2;


    pub fn get_avg_ping_ms(&self) -> u32 {
        self.avg_ping_ms.unwrap_or(0)
    }
    pub fn clear_avg_ping_ms(&mut self) {
        self.avg_ping_ms = ::std::option::Option::None;
    }

    pub fn has_avg_ping_ms(&self) -> bool {
        self.avg_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_ping_ms(&mut self, v: u32) {
        self.avg_ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 stddev_ping_ms_x10 = 3;


    pub fn get_stddev_ping_ms_x10(&self) -> u32 {
        self.stddev_ping_ms_x10.unwrap_or(0)
    }
    pub fn clear_stddev_ping_ms_x10(&mut self) {
        self.stddev_ping_ms_x10 = ::std::option::Option::None;
    }

    pub fn has_stddev_ping_ms_x10(&self) -> bool {
        self.stddev_ping_ms_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_ping_ms_x10(&mut self, v: u32) {
        self.stddev_ping_ms_x10 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerPingSample_Sample {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_ping_ms = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stddev_ping_ms_x10 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += 5;
        }
        if let Some(v) = self.avg_ping_ms {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stddev_ping_ms_x10 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.avg_ping_ms {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.stddev_ping_ms_x10 {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerPingSample_Sample {
        CMsgGameServerPingSample_Sample::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ip",
                |m: &CMsgGameServerPingSample_Sample| { &m.ip },
                |m: &mut CMsgGameServerPingSample_Sample| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_ping_ms",
                |m: &CMsgGameServerPingSample_Sample| { &m.avg_ping_ms },
                |m: &mut CMsgGameServerPingSample_Sample| { &mut m.avg_ping_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stddev_ping_ms_x10",
                |m: &CMsgGameServerPingSample_Sample| { &m.stddev_ping_ms_x10 },
                |m: &mut CMsgGameServerPingSample_Sample| { &mut m.stddev_ping_ms_x10 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerPingSample_Sample>(
                "CMsgGameServerPingSample.Sample",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerPingSample_Sample {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerPingSample_Sample> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerPingSample_Sample::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerPingSample_Sample {
    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.avg_ping_ms = ::std::option::Option::None;
        self.stddev_ping_ms_x10 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerPingSample_Sample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerPingSample_Sample {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetFollowerCount {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCount {
    fn default() -> &'a CMsgFSGetFollowerCount {
        <CMsgFSGetFollowerCount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCount {
    pub fn new() -> CMsgFSGetFollowerCount {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetFollowerCount {
        CMsgFSGetFollowerCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgFSGetFollowerCount| { &m.steam_id },
                |m: &mut CMsgFSGetFollowerCount| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFSGetFollowerCount>(
                "CMsgFSGetFollowerCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCount {
        static instance: ::protobuf::rt::LazyV2<CMsgFSGetFollowerCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFSGetFollowerCount::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetFollowerCount {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetFollowerCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetFollowerCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetFollowerCountResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetFollowerCountResponse {
    fn default() -> &'a CMsgFSGetFollowerCountResponse {
        <CMsgFSGetFollowerCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetFollowerCountResponse {
    pub fn new() -> CMsgFSGetFollowerCountResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0i32)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetFollowerCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetFollowerCountResponse {
        CMsgFSGetFollowerCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgFSGetFollowerCountResponse| { &m.eresult },
                |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CMsgFSGetFollowerCountResponse| { &m.count },
                |m: &mut CMsgFSGetFollowerCountResponse| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFSGetFollowerCountResponse>(
                "CMsgFSGetFollowerCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetFollowerCountResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgFSGetFollowerCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFSGetFollowerCountResponse::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetFollowerCountResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetFollowerCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetFollowerCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetIsFollowing {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowing {
    fn default() -> &'a CMsgFSGetIsFollowing {
        <CMsgFSGetIsFollowing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowing {
    pub fn new() -> CMsgFSGetIsFollowing {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetIsFollowing {
        CMsgFSGetIsFollowing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgFSGetIsFollowing| { &m.steam_id },
                |m: &mut CMsgFSGetIsFollowing| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFSGetIsFollowing>(
                "CMsgFSGetIsFollowing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowing {
        static instance: ::protobuf::rt::LazyV2<CMsgFSGetIsFollowing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFSGetIsFollowing::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetIsFollowing {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetIsFollowing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetIsFollowing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSGetIsFollowingResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    is_following: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSGetIsFollowingResponse {
    fn default() -> &'a CMsgFSGetIsFollowingResponse {
        <CMsgFSGetIsFollowingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSGetIsFollowingResponse {
    pub fn new() -> CMsgFSGetIsFollowingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bool is_following = 2;


    pub fn get_is_following(&self) -> bool {
        self.is_following.unwrap_or(false)
    }
    pub fn clear_is_following(&mut self) {
        self.is_following = ::std::option::Option::None;
    }

    pub fn has_is_following(&self) -> bool {
        self.is_following.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_following(&mut self, v: bool) {
        self.is_following = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSGetIsFollowingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_following = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_following {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.is_following {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSGetIsFollowingResponse {
        CMsgFSGetIsFollowingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgFSGetIsFollowingResponse| { &m.eresult },
                |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_following",
                |m: &CMsgFSGetIsFollowingResponse| { &m.is_following },
                |m: &mut CMsgFSGetIsFollowingResponse| { &mut m.is_following },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFSGetIsFollowingResponse>(
                "CMsgFSGetIsFollowingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSGetIsFollowingResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgFSGetIsFollowingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFSGetIsFollowingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgFSGetIsFollowingResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.is_following = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSGetIsFollowingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSGetIsFollowingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSEnumerateFollowingList {
    // message fields
    start_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingList {
    fn default() -> &'a CMsgFSEnumerateFollowingList {
        <CMsgFSEnumerateFollowingList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingList {
    pub fn new() -> CMsgFSEnumerateFollowingList {
        ::std::default::Default::default()
    }

    // optional uint32 start_index = 1;


    pub fn get_start_index(&self) -> u32 {
        self.start_index.unwrap_or(0)
    }
    pub fn clear_start_index(&mut self) {
        self.start_index = ::std::option::Option::None;
    }

    pub fn has_start_index(&self) -> bool {
        self.start_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_index(&mut self, v: u32) {
        self.start_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSEnumerateFollowingList {
        CMsgFSEnumerateFollowingList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_index",
                |m: &CMsgFSEnumerateFollowingList| { &m.start_index },
                |m: &mut CMsgFSEnumerateFollowingList| { &mut m.start_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFSEnumerateFollowingList>(
                "CMsgFSEnumerateFollowingList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingList {
        static instance: ::protobuf::rt::LazyV2<CMsgFSEnumerateFollowingList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFSEnumerateFollowingList::new)
    }
}

impl ::protobuf::Clear for CMsgFSEnumerateFollowingList {
    fn clear(&mut self) {
        self.start_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSEnumerateFollowingList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSEnumerateFollowingList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFSEnumerateFollowingListResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    total_results: ::std::option::Option<i32>,
    pub steam_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFSEnumerateFollowingListResponse {
    fn default() -> &'a CMsgFSEnumerateFollowingListResponse {
        <CMsgFSEnumerateFollowingListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFSEnumerateFollowingListResponse {
    pub fn new() -> CMsgFSEnumerateFollowingListResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 total_results = 2;


    pub fn get_total_results(&self) -> i32 {
        self.total_results.unwrap_or(0)
    }
    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: i32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    // repeated fixed64 steam_ids = 3;


    pub fn get_steam_ids(&self) -> &[u64] {
        &self.steam_ids
    }
    pub fn clear_steam_ids(&mut self) {
        self.steam_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_steam_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.steam_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steam_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steam_ids
    }

    // Take field
    pub fn take_steam_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steam_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgFSEnumerateFollowingListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_results = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steam_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_results {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.steam_ids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.total_results {
            os.write_int32(2, v)?;
        }
        for v in &self.steam_ids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFSEnumerateFollowingListResponse {
        CMsgFSEnumerateFollowingListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgFSEnumerateFollowingListResponse| { &m.eresult },
                |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_results",
                |m: &CMsgFSEnumerateFollowingListResponse| { &m.total_results },
                |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.total_results },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_ids",
                |m: &CMsgFSEnumerateFollowingListResponse| { &m.steam_ids },
                |m: &mut CMsgFSEnumerateFollowingListResponse| { &mut m.steam_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFSEnumerateFollowingListResponse>(
                "CMsgFSEnumerateFollowingListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFSEnumerateFollowingListResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgFSEnumerateFollowingListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFSEnumerateFollowingListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgFSEnumerateFollowingListResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.total_results = ::std::option::Option::None;
        self.steam_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFSEnumerateFollowingListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFSEnumerateFollowingListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDPGetNumberOfCurrentPlayers {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayers {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayers {
        <CMsgDPGetNumberOfCurrentPlayers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayers {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayers {
        CMsgDPGetNumberOfCurrentPlayers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgDPGetNumberOfCurrentPlayers| { &m.appid },
                |m: &mut CMsgDPGetNumberOfCurrentPlayers| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDPGetNumberOfCurrentPlayers>(
                "CMsgDPGetNumberOfCurrentPlayers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayers {
        static instance: ::protobuf::rt::LazyV2<CMsgDPGetNumberOfCurrentPlayers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDPGetNumberOfCurrentPlayers::new)
    }
}

impl ::protobuf::Clear for CMsgDPGetNumberOfCurrentPlayers {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDPGetNumberOfCurrentPlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDPGetNumberOfCurrentPlayersResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    player_count: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDPGetNumberOfCurrentPlayersResponse {
    fn default() -> &'a CMsgDPGetNumberOfCurrentPlayersResponse {
        <CMsgDPGetNumberOfCurrentPlayersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDPGetNumberOfCurrentPlayersResponse {
    pub fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 player_count = 2;


    pub fn get_player_count(&self) -> i32 {
        self.player_count.unwrap_or(0)
    }
    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: i32) {
        self.player_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.player_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.player_count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDPGetNumberOfCurrentPlayersResponse {
        CMsgDPGetNumberOfCurrentPlayersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.eresult },
                |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "player_count",
                |m: &CMsgDPGetNumberOfCurrentPlayersResponse| { &m.player_count },
                |m: &mut CMsgDPGetNumberOfCurrentPlayersResponse| { &mut m.player_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDPGetNumberOfCurrentPlayersResponse>(
                "CMsgDPGetNumberOfCurrentPlayersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDPGetNumberOfCurrentPlayersResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgDPGetNumberOfCurrentPlayersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDPGetNumberOfCurrentPlayersResponse::new)
    }
}

impl ::protobuf::Clear for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.player_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDPGetNumberOfCurrentPlayersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientFriendUserStatusPublished {
    // message fields
    friend_steamid: ::std::option::Option<u64>,
    appid: ::std::option::Option<u32>,
    status_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendUserStatusPublished {
    fn default() -> &'a CMsgClientFriendUserStatusPublished {
        <CMsgClientFriendUserStatusPublished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendUserStatusPublished {
    pub fn new() -> CMsgClientFriendUserStatusPublished {
        ::std::default::Default::default()
    }

    // optional fixed64 friend_steamid = 1;


    pub fn get_friend_steamid(&self) -> u64 {
        self.friend_steamid.unwrap_or(0)
    }
    pub fn clear_friend_steamid(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
    }

    pub fn has_friend_steamid(&self) -> bool {
        self.friend_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_steamid(&mut self, v: u64) {
        self.friend_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 2;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string status_text = 3;


    pub fn get_status_text(&self) -> &str {
        match self.status_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: ::std::string::String) {
        self.status_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut ::std::string::String {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> ::std::string::String {
        self.status_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendUserStatusPublished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.friend_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friend_steamid {
            my_size += 9;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.status_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friend_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.status_text.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendUserStatusPublished {
        CMsgClientFriendUserStatusPublished::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "friend_steamid",
                |m: &CMsgClientFriendUserStatusPublished| { &m.friend_steamid },
                |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.friend_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientFriendUserStatusPublished| { &m.appid },
                |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_text",
                |m: &CMsgClientFriendUserStatusPublished| { &m.status_text },
                |m: &mut CMsgClientFriendUserStatusPublished| { &mut m.status_text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendUserStatusPublished>(
                "CMsgClientFriendUserStatusPublished",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendUserStatusPublished {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendUserStatusPublished> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendUserStatusPublished::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendUserStatusPublished {
    fn clear(&mut self) {
        self.friend_steamid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.status_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendUserStatusPublished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendUserStatusPublished {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceMethodLegacy {
    // message fields
    method_name: ::protobuf::SingularField<::std::string::String>,
    serialized_method: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    is_notification: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacy {
    fn default() -> &'a CMsgClientServiceMethodLegacy {
        <CMsgClientServiceMethodLegacy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacy {
    pub fn new() -> CMsgClientServiceMethodLegacy {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;


    pub fn get_method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name.set_default();
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method = 2;


    pub fn get_serialized_method(&self) -> &[u8] {
        match self.serialized_method.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_serialized_method(&mut self) {
        self.serialized_method.clear();
    }

    pub fn has_serialized_method(&self) -> bool {
        self.serialized_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method.is_none() {
            self.serialized_method.set_default();
        }
        self.serialized_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_notification = 3;


    pub fn get_is_notification(&self) -> bool {
        self.is_notification.unwrap_or(false)
    }
    pub fn clear_is_notification(&mut self) {
        self.is_notification = ::std::option::Option::None;
    }

    pub fn has_is_notification(&self) -> bool {
        self.is_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_notification(&mut self, v: bool) {
        self.is_notification = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.method_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serialized_method)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_notification = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.serialized_method.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.is_notification {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.method_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.serialized_method.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.is_notification {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceMethodLegacy {
        CMsgClientServiceMethodLegacy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "method_name",
                |m: &CMsgClientServiceMethodLegacy| { &m.method_name },
                |m: &mut CMsgClientServiceMethodLegacy| { &mut m.method_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serialized_method",
                |m: &CMsgClientServiceMethodLegacy| { &m.serialized_method },
                |m: &mut CMsgClientServiceMethodLegacy| { &mut m.serialized_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_notification",
                |m: &CMsgClientServiceMethodLegacy| { &m.is_notification },
                |m: &mut CMsgClientServiceMethodLegacy| { &mut m.is_notification },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientServiceMethodLegacy>(
                "CMsgClientServiceMethodLegacy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacy {
        static instance: ::protobuf::rt::LazyV2<CMsgClientServiceMethodLegacy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientServiceMethodLegacy::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceMethodLegacy {
    fn clear(&mut self) {
        self.method_name.clear();
        self.serialized_method.clear();
        self.is_notification = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceMethodLegacy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceMethodLegacy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceMethodLegacyResponse {
    // message fields
    method_name: ::protobuf::SingularField<::std::string::String>,
    serialized_method_response: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceMethodLegacyResponse {
    fn default() -> &'a CMsgClientServiceMethodLegacyResponse {
        <CMsgClientServiceMethodLegacyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceMethodLegacyResponse {
    pub fn new() -> CMsgClientServiceMethodLegacyResponse {
        ::std::default::Default::default()
    }

    // optional string method_name = 1;


    pub fn get_method_name(&self) -> &str {
        match self.method_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    pub fn has_method_name(&self) -> bool {
        self.method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        if self.method_name.is_none() {
            self.method_name.set_default();
        }
        self.method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        self.method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes serialized_method_response = 2;


    pub fn get_serialized_method_response(&self) -> &[u8] {
        match self.serialized_method_response.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_serialized_method_response(&mut self) {
        self.serialized_method_response.clear();
    }

    pub fn has_serialized_method_response(&self) -> bool {
        self.serialized_method_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_method_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_method_response = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_method_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_method_response.is_none() {
            self.serialized_method_response.set_default();
        }
        self.serialized_method_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_method_response(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_method_response.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientServiceMethodLegacyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.method_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serialized_method_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.serialized_method_response.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.method_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.serialized_method_response.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceMethodLegacyResponse {
        CMsgClientServiceMethodLegacyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "method_name",
                |m: &CMsgClientServiceMethodLegacyResponse| { &m.method_name },
                |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.method_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serialized_method_response",
                |m: &CMsgClientServiceMethodLegacyResponse| { &m.serialized_method_response },
                |m: &mut CMsgClientServiceMethodLegacyResponse| { &mut m.serialized_method_response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientServiceMethodLegacyResponse>(
                "CMsgClientServiceMethodLegacyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceMethodLegacyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientServiceMethodLegacyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientServiceMethodLegacyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceMethodLegacyResponse {
    fn clear(&mut self) {
        self.method_name.clear();
        self.serialized_method_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceMethodLegacyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceMethodLegacyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUIMode {
    // message fields
    uimode: ::std::option::Option<u32>,
    chat_mode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUIMode {
    fn default() -> &'a CMsgClientUIMode {
        <CMsgClientUIMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUIMode {
    pub fn new() -> CMsgClientUIMode {
        ::std::default::Default::default()
    }

    // optional uint32 uimode = 1;


    pub fn get_uimode(&self) -> u32 {
        self.uimode.unwrap_or(0)
    }
    pub fn clear_uimode(&mut self) {
        self.uimode = ::std::option::Option::None;
    }

    pub fn has_uimode(&self) -> bool {
        self.uimode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uimode(&mut self, v: u32) {
        self.uimode = ::std::option::Option::Some(v);
    }

    // optional uint32 chat_mode = 2;


    pub fn get_chat_mode(&self) -> u32 {
        self.chat_mode.unwrap_or(0)
    }
    pub fn clear_chat_mode(&mut self) {
        self.chat_mode = ::std::option::Option::None;
    }

    pub fn has_chat_mode(&self) -> bool {
        self.chat_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_mode(&mut self, v: u32) {
        self.chat_mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUIMode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.uimode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chat_mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.uimode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_mode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.uimode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.chat_mode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUIMode {
        CMsgClientUIMode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "uimode",
                |m: &CMsgClientUIMode| { &m.uimode },
                |m: &mut CMsgClientUIMode| { &mut m.uimode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "chat_mode",
                |m: &CMsgClientUIMode| { &m.chat_mode },
                |m: &mut CMsgClientUIMode| { &mut m.chat_mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUIMode>(
                "CMsgClientUIMode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUIMode {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUIMode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUIMode::new)
    }
}

impl ::protobuf::Clear for CMsgClientUIMode {
    fn clear(&mut self) {
        self.uimode = ::std::option::Option::None;
        self.chat_mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUIMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUIMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientVanityURLChangedNotification {
    // message fields
    vanity_url: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientVanityURLChangedNotification {
    fn default() -> &'a CMsgClientVanityURLChangedNotification {
        <CMsgClientVanityURLChangedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVanityURLChangedNotification {
    pub fn new() -> CMsgClientVanityURLChangedNotification {
        ::std::default::Default::default()
    }

    // optional string vanity_url = 1;


    pub fn get_vanity_url(&self) -> &str {
        match self.vanity_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vanity_url(&mut self) {
        self.vanity_url.clear();
    }

    pub fn has_vanity_url(&self) -> bool {
        self.vanity_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vanity_url(&mut self, v: ::std::string::String) {
        self.vanity_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vanity_url(&mut self) -> &mut ::std::string::String {
        if self.vanity_url.is_none() {
            self.vanity_url.set_default();
        }
        self.vanity_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_vanity_url(&mut self) -> ::std::string::String {
        self.vanity_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientVanityURLChangedNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vanity_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vanity_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vanity_url.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientVanityURLChangedNotification {
        CMsgClientVanityURLChangedNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vanity_url",
                |m: &CMsgClientVanityURLChangedNotification| { &m.vanity_url },
                |m: &mut CMsgClientVanityURLChangedNotification| { &mut m.vanity_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientVanityURLChangedNotification>(
                "CMsgClientVanityURLChangedNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientVanityURLChangedNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgClientVanityURLChangedNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientVanityURLChangedNotification::new)
    }
}

impl ::protobuf::Clear for CMsgClientVanityURLChangedNotification {
    fn clear(&mut self) {
        self.vanity_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientVanityURLChangedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVanityURLChangedNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthorizeLocalDeviceRequest {
    // message fields
    device_description: ::protobuf::SingularField<::std::string::String>,
    owner_account_id: ::std::option::Option<u32>,
    local_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceRequest {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceRequest {
        <CMsgClientAuthorizeLocalDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceRequest {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        ::std::default::Default::default()
    }

    // optional string device_description = 1;


    pub fn get_device_description(&self) -> &str {
        match self.device_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_description(&mut self) {
        self.device_description.clear();
    }

    pub fn has_device_description(&self) -> bool {
        self.device_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_description(&mut self, v: ::std::string::String) {
        self.device_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_description(&mut self) -> &mut ::std::string::String {
        if self.device_description.is_none() {
            self.device_description.set_default();
        }
        self.device_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_description(&mut self) -> ::std::string::String {
        self.device_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 owner_account_id = 2;


    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }
    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;


    pub fn get_local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }
    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_description)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.local_device_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_description.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_description.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceRequest {
        CMsgClientAuthorizeLocalDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_description",
                |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.device_description },
                |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.device_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_account_id",
                |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.owner_account_id },
                |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.owner_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "local_device_token",
                |m: &CMsgClientAuthorizeLocalDeviceRequest| { &m.local_device_token },
                |m: &mut CMsgClientAuthorizeLocalDeviceRequest| { &mut m.local_device_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAuthorizeLocalDeviceRequest>(
                "CMsgClientAuthorizeLocalDeviceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAuthorizeLocalDeviceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAuthorizeLocalDeviceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthorizeLocalDeviceRequest {
    fn clear(&mut self) {
        self.device_description.clear();
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthorizeLocalDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthorizeLocalDevice {
    // message fields
    eresult: ::std::option::Option<i32>,
    owner_account_id: ::std::option::Option<u32>,
    authed_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDevice {
    fn default() -> &'a CMsgClientAuthorizeLocalDevice {
        <CMsgClientAuthorizeLocalDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDevice {
    pub fn new() -> CMsgClientAuthorizeLocalDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;


    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }
    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 authed_device_token = 3;


    pub fn get_authed_device_token(&self) -> u64 {
        self.authed_device_token.unwrap_or(0)
    }
    pub fn clear_authed_device_token(&mut self) {
        self.authed_device_token = ::std::option::Option::None;
    }

    pub fn has_authed_device_token(&self) -> bool {
        self.authed_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authed_device_token(&mut self, v: u64) {
        self.authed_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.authed_device_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.authed_device_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.authed_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthorizeLocalDevice {
        CMsgClientAuthorizeLocalDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientAuthorizeLocalDevice| { &m.eresult },
                |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_account_id",
                |m: &CMsgClientAuthorizeLocalDevice| { &m.owner_account_id },
                |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.owner_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "authed_device_token",
                |m: &CMsgClientAuthorizeLocalDevice| { &m.authed_device_token },
                |m: &mut CMsgClientAuthorizeLocalDevice| { &mut m.authed_device_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAuthorizeLocalDevice>(
                "CMsgClientAuthorizeLocalDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDevice {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAuthorizeLocalDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAuthorizeLocalDevice::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthorizeLocalDevice {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.authed_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthorizeLocalDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientAuthorizeLocalDeviceNotification {
    // message fields
    eresult: ::std::option::Option<i32>,
    owner_account_id: ::std::option::Option<u32>,
    local_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAuthorizeLocalDeviceNotification {
    fn default() -> &'a CMsgClientAuthorizeLocalDeviceNotification {
        <CMsgClientAuthorizeLocalDeviceNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAuthorizeLocalDeviceNotification {
    pub fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_account_id = 2;


    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }
    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 local_device_token = 3;


    pub fn get_local_device_token(&self) -> u64 {
        self.local_device_token.unwrap_or(0)
    }
    pub fn clear_local_device_token(&mut self) {
        self.local_device_token = ::std::option::Option::None;
    }

    pub fn has_local_device_token(&self) -> bool {
        self.local_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_device_token(&mut self, v: u64) {
        self.local_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAuthorizeLocalDeviceNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.local_device_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_device_token {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.owner_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.local_device_token {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAuthorizeLocalDeviceNotification {
        CMsgClientAuthorizeLocalDeviceNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.eresult },
                |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_account_id",
                |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.owner_account_id },
                |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.owner_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "local_device_token",
                |m: &CMsgClientAuthorizeLocalDeviceNotification| { &m.local_device_token },
                |m: &mut CMsgClientAuthorizeLocalDeviceNotification| { &mut m.local_device_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAuthorizeLocalDeviceNotification>(
                "CMsgClientAuthorizeLocalDeviceNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAuthorizeLocalDeviceNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAuthorizeLocalDeviceNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAuthorizeLocalDeviceNotification::new)
    }
}

impl ::protobuf::Clear for CMsgClientAuthorizeLocalDeviceNotification {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.owner_account_id = ::std::option::Option::None;
        self.local_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAuthorizeLocalDeviceNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAuthorizeLocalDeviceNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeauthorizeDeviceRequest {
    // message fields
    deauthorization_account_id: ::std::option::Option<u32>,
    deauthorization_device_token: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDeviceRequest {
    fn default() -> &'a CMsgClientDeauthorizeDeviceRequest {
        <CMsgClientDeauthorizeDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDeviceRequest {
    pub fn new() -> CMsgClientDeauthorizeDeviceRequest {
        ::std::default::Default::default()
    }

    // optional uint32 deauthorization_account_id = 1;


    pub fn get_deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }
    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 deauthorization_device_token = 2;


    pub fn get_deauthorization_device_token(&self) -> u64 {
        self.deauthorization_device_token.unwrap_or(0)
    }
    pub fn clear_deauthorization_device_token(&mut self) {
        self.deauthorization_device_token = ::std::option::Option::None;
    }

    pub fn has_deauthorization_device_token(&self) -> bool {
        self.deauthorization_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_device_token(&mut self, v: u64) {
        self.deauthorization_device_token = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDeviceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deauthorization_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.deauthorization_device_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deauthorization_device_token {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.deauthorization_device_token {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeauthorizeDeviceRequest {
        CMsgClientDeauthorizeDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deauthorization_account_id",
                |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_account_id },
                |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "deauthorization_device_token",
                |m: &CMsgClientDeauthorizeDeviceRequest| { &m.deauthorization_device_token },
                |m: &mut CMsgClientDeauthorizeDeviceRequest| { &mut m.deauthorization_device_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDeauthorizeDeviceRequest>(
                "CMsgClientDeauthorizeDeviceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDeviceRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDeauthorizeDeviceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDeauthorizeDeviceRequest::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeauthorizeDeviceRequest {
    fn clear(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
        self.deauthorization_device_token = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeauthorizeDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeauthorizeDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientDeauthorizeDevice {
    // message fields
    eresult: ::std::option::Option<i32>,
    deauthorization_account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeauthorizeDevice {
    fn default() -> &'a CMsgClientDeauthorizeDevice {
        <CMsgClientDeauthorizeDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeauthorizeDevice {
    pub fn new() -> CMsgClientDeauthorizeDevice {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional uint32 deauthorization_account_id = 2;


    pub fn get_deauthorization_account_id(&self) -> u32 {
        self.deauthorization_account_id.unwrap_or(0)
    }
    pub fn clear_deauthorization_account_id(&mut self) {
        self.deauthorization_account_id = ::std::option::Option::None;
    }

    pub fn has_deauthorization_account_id(&self) -> bool {
        self.deauthorization_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deauthorization_account_id(&mut self, v: u32) {
        self.deauthorization_account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeauthorizeDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deauthorization_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deauthorization_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deauthorization_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeauthorizeDevice {
        CMsgClientDeauthorizeDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientDeauthorizeDevice| { &m.eresult },
                |m: &mut CMsgClientDeauthorizeDevice| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deauthorization_account_id",
                |m: &CMsgClientDeauthorizeDevice| { &m.deauthorization_account_id },
                |m: &mut CMsgClientDeauthorizeDevice| { &mut m.deauthorization_account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDeauthorizeDevice>(
                "CMsgClientDeauthorizeDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeauthorizeDevice {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDeauthorizeDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDeauthorizeDevice::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeauthorizeDevice {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.deauthorization_account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeauthorizeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeauthorizeDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUseLocalDeviceAuthorizations {
    // message fields
    pub authorization_account_id: ::std::vec::Vec<u32>,
    pub device_tokens: ::protobuf::RepeatedField<CMsgClientUseLocalDeviceAuthorizations_DeviceToken>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUseLocalDeviceAuthorizations {
    fn default() -> &'a CMsgClientUseLocalDeviceAuthorizations {
        <CMsgClientUseLocalDeviceAuthorizations as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUseLocalDeviceAuthorizations {
    pub fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        ::std::default::Default::default()
    }

    // repeated uint32 authorization_account_id = 1;


    pub fn get_authorization_account_id(&self) -> &[u32] {
        &self.authorization_account_id
    }
    pub fn clear_authorization_account_id(&mut self) {
        self.authorization_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorization_account_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.authorization_account_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorization_account_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.authorization_account_id
    }

    // Take field
    pub fn take_authorization_account_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.authorization_account_id, ::std::vec::Vec::new())
    }

    // repeated .CMsgClientUseLocalDeviceAuthorizations.DeviceToken device_tokens = 2;


    pub fn get_device_tokens(&self) -> &[CMsgClientUseLocalDeviceAuthorizations_DeviceToken] {
        &self.device_tokens
    }
    pub fn clear_device_tokens(&mut self) {
        self.device_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_tokens(&mut self, v: ::protobuf::RepeatedField<CMsgClientUseLocalDeviceAuthorizations_DeviceToken>) {
        self.device_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_tokens(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientUseLocalDeviceAuthorizations_DeviceToken> {
        &mut self.device_tokens
    }

    // Take field
    pub fn take_device_tokens(&mut self) -> ::protobuf::RepeatedField<CMsgClientUseLocalDeviceAuthorizations_DeviceToken> {
        ::std::mem::replace(&mut self.device_tokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientUseLocalDeviceAuthorizations {
    fn is_initialized(&self) -> bool {
        for v in &self.device_tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.authorization_account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.device_tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.authorization_account_id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.device_tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.authorization_account_id {
            os.write_uint32(1, *v)?;
        };
        for v in &self.device_tokens {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUseLocalDeviceAuthorizations {
        CMsgClientUseLocalDeviceAuthorizations::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "authorization_account_id",
                |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.authorization_account_id },
                |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.authorization_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientUseLocalDeviceAuthorizations_DeviceToken>>(
                "device_tokens",
                |m: &CMsgClientUseLocalDeviceAuthorizations| { &m.device_tokens },
                |m: &mut CMsgClientUseLocalDeviceAuthorizations| { &mut m.device_tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUseLocalDeviceAuthorizations>(
                "CMsgClientUseLocalDeviceAuthorizations",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUseLocalDeviceAuthorizations {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUseLocalDeviceAuthorizations> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUseLocalDeviceAuthorizations::new)
    }
}

impl ::protobuf::Clear for CMsgClientUseLocalDeviceAuthorizations {
    fn clear(&mut self) {
        self.authorization_account_id.clear();
        self.device_tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUseLocalDeviceAuthorizations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUseLocalDeviceAuthorizations {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    // message fields
    owner_account_id: ::std::option::Option<u32>,
    token_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    fn default() -> &'a CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
        <CMsgClientUseLocalDeviceAuthorizations_DeviceToken as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    pub fn new() -> CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
        ::std::default::Default::default()
    }

    // optional uint32 owner_account_id = 1;


    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }
    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 token_id = 2;


    pub fn get_token_id(&self) -> u64 {
        self.token_id.unwrap_or(0)
    }
    pub fn clear_token_id(&mut self) {
        self.token_id = ::std::option::Option::None;
    }

    pub fn has_token_id(&self) -> bool {
        self.token_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: u64) {
        self.token_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.token_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.token_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
        CMsgClientUseLocalDeviceAuthorizations_DeviceToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_account_id",
                |m: &CMsgClientUseLocalDeviceAuthorizations_DeviceToken| { &m.owner_account_id },
                |m: &mut CMsgClientUseLocalDeviceAuthorizations_DeviceToken| { &mut m.owner_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "token_id",
                |m: &CMsgClientUseLocalDeviceAuthorizations_DeviceToken| { &m.token_id },
                |m: &mut CMsgClientUseLocalDeviceAuthorizations_DeviceToken| { &mut m.token_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientUseLocalDeviceAuthorizations_DeviceToken>(
                "CMsgClientUseLocalDeviceAuthorizations.DeviceToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
        static instance: ::protobuf::rt::LazyV2<CMsgClientUseLocalDeviceAuthorizations_DeviceToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientUseLocalDeviceAuthorizations_DeviceToken::new)
    }
}

impl ::protobuf::Clear for CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    fn clear(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
        self.token_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAuthorizedDevices {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevices {
    fn default() -> &'a CMsgClientGetAuthorizedDevices {
        <CMsgClientGetAuthorizedDevices as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevices {
    pub fn new() -> CMsgClientGetAuthorizedDevices {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevices {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAuthorizedDevices {
        CMsgClientGetAuthorizedDevices::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetAuthorizedDevices>(
                "CMsgClientGetAuthorizedDevices",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevices {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetAuthorizedDevices> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetAuthorizedDevices::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAuthorizedDevices {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAuthorizedDevices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAuthorizedDevices {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAuthorizedDevicesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    pub authorized_device: ::protobuf::RepeatedField<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevicesResponse {
    fn default() -> &'a CMsgClientGetAuthorizedDevicesResponse {
        <CMsgClientGetAuthorizedDevicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevicesResponse {
    pub fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice authorized_device = 2;


    pub fn get_authorized_device(&self) -> &[CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice] {
        &self.authorized_device
    }
    pub fn clear_authorized_device(&mut self) {
        self.authorized_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorized_device(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice>) {
        self.authorized_device = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorized_device(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice> {
        &mut self.authorized_device
    }

    // Take field
    pub fn take_authorized_device(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice> {
        ::std::mem::replace(&mut self.authorized_device, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevicesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.authorized_device {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.authorized_device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.authorized_device {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        for v in &self.authorized_device {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAuthorizedDevicesResponse {
        CMsgClientGetAuthorizedDevicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.eresult },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice>>(
                "authorized_device",
                |m: &CMsgClientGetAuthorizedDevicesResponse| { &m.authorized_device },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse| { &mut m.authorized_device },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetAuthorizedDevicesResponse>(
                "CMsgClientGetAuthorizedDevicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevicesResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetAuthorizedDevicesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetAuthorizedDevicesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAuthorizedDevicesResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.authorized_device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAuthorizedDevicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAuthorizedDevicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    // message fields
    auth_device_token: ::std::option::Option<u64>,
    device_name: ::protobuf::SingularField<::std::string::String>,
    last_access_time: ::std::option::Option<u32>,
    borrower_id: ::std::option::Option<u32>,
    is_pending: ::std::option::Option<bool>,
    app_played: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    fn default() -> &'a CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
        <CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    pub fn new() -> CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
        ::std::default::Default::default()
    }

    // optional uint64 auth_device_token = 1;


    pub fn get_auth_device_token(&self) -> u64 {
        self.auth_device_token.unwrap_or(0)
    }
    pub fn clear_auth_device_token(&mut self) {
        self.auth_device_token = ::std::option::Option::None;
    }

    pub fn has_auth_device_token(&self) -> bool {
        self.auth_device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_device_token(&mut self, v: u64) {
        self.auth_device_token = ::std::option::Option::Some(v);
    }

    // optional string device_name = 2;


    pub fn get_device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name.set_default();
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 last_access_time = 3;


    pub fn get_last_access_time(&self) -> u32 {
        self.last_access_time.unwrap_or(0)
    }
    pub fn clear_last_access_time(&mut self) {
        self.last_access_time = ::std::option::Option::None;
    }

    pub fn has_last_access_time(&self) -> bool {
        self.last_access_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_access_time(&mut self, v: u32) {
        self.last_access_time = ::std::option::Option::Some(v);
    }

    // optional uint32 borrower_id = 4;


    pub fn get_borrower_id(&self) -> u32 {
        self.borrower_id.unwrap_or(0)
    }
    pub fn clear_borrower_id(&mut self) {
        self.borrower_id = ::std::option::Option::None;
    }

    pub fn has_borrower_id(&self) -> bool {
        self.borrower_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_borrower_id(&mut self, v: u32) {
        self.borrower_id = ::std::option::Option::Some(v);
    }

    // optional bool is_pending = 5;


    pub fn get_is_pending(&self) -> bool {
        self.is_pending.unwrap_or(false)
    }
    pub fn clear_is_pending(&mut self) {
        self.is_pending = ::std::option::Option::None;
    }

    pub fn has_is_pending(&self) -> bool {
        self.is_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_pending(&mut self, v: bool) {
        self.is_pending = ::std::option::Option::Some(v);
    }

    // optional uint32 app_played = 6;


    pub fn get_app_played(&self) -> u32 {
        self.app_played.unwrap_or(0)
    }
    pub fn clear_app_played(&mut self) {
        self.app_played = ::std::option::Option::None;
    }

    pub fn has_app_played(&self) -> bool {
        self.app_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_played(&mut self, v: u32) {
        self.app_played = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.auth_device_token = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_access_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.borrower_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_pending = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_played = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.auth_device_token {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.last_access_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.borrower_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_pending {
            my_size += 2;
        }
        if let Some(v) = self.app_played {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.auth_device_token {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.device_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.last_access_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.borrower_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.is_pending {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.app_played {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
        CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "auth_device_token",
                |m: &CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &m.auth_device_token },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &mut m.auth_device_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &m.device_name },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_access_time",
                |m: &CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &m.last_access_time },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &mut m.last_access_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "borrower_id",
                |m: &CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &m.borrower_id },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &mut m.borrower_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_pending",
                |m: &CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &m.is_pending },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &mut m.is_pending },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_played",
                |m: &CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &m.app_played },
                |m: &mut CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice| { &mut m.app_played },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice>(
                "CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    fn clear(&mut self) {
        self.auth_device_token = ::std::option::Option::None;
        self.device_name.clear();
        self.last_access_time = ::std::option::Option::None;
        self.borrower_id = ::std::option::Option::None;
        self.is_pending = ::std::option::Option::None;
        self.app_played = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSharedLibraryLockStatus {
    // message fields
    pub locked_library: ::protobuf::RepeatedField<CMsgClientSharedLibraryLockStatus_LockedLibrary>,
    own_library_locked_by: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryLockStatus {
    fn default() -> &'a CMsgClientSharedLibraryLockStatus {
        <CMsgClientSharedLibraryLockStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryLockStatus {
    pub fn new() -> CMsgClientSharedLibraryLockStatus {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientSharedLibraryLockStatus.LockedLibrary locked_library = 1;


    pub fn get_locked_library(&self) -> &[CMsgClientSharedLibraryLockStatus_LockedLibrary] {
        &self.locked_library
    }
    pub fn clear_locked_library(&mut self) {
        self.locked_library.clear();
    }

    // Param is passed by value, moved
    pub fn set_locked_library(&mut self, v: ::protobuf::RepeatedField<CMsgClientSharedLibraryLockStatus_LockedLibrary>) {
        self.locked_library = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locked_library(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientSharedLibraryLockStatus_LockedLibrary> {
        &mut self.locked_library
    }

    // Take field
    pub fn take_locked_library(&mut self) -> ::protobuf::RepeatedField<CMsgClientSharedLibraryLockStatus_LockedLibrary> {
        ::std::mem::replace(&mut self.locked_library, ::protobuf::RepeatedField::new())
    }

    // optional uint32 own_library_locked_by = 2;


    pub fn get_own_library_locked_by(&self) -> u32 {
        self.own_library_locked_by.unwrap_or(0)
    }
    pub fn clear_own_library_locked_by(&mut self) {
        self.own_library_locked_by = ::std::option::Option::None;
    }

    pub fn has_own_library_locked_by(&self) -> bool {
        self.own_library_locked_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_own_library_locked_by(&mut self, v: u32) {
        self.own_library_locked_by = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryLockStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.locked_library {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locked_library)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.own_library_locked_by = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.locked_library {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.own_library_locked_by {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.locked_library {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.own_library_locked_by {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSharedLibraryLockStatus {
        CMsgClientSharedLibraryLockStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientSharedLibraryLockStatus_LockedLibrary>>(
                "locked_library",
                |m: &CMsgClientSharedLibraryLockStatus| { &m.locked_library },
                |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.locked_library },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "own_library_locked_by",
                |m: &CMsgClientSharedLibraryLockStatus| { &m.own_library_locked_by },
                |m: &mut CMsgClientSharedLibraryLockStatus| { &mut m.own_library_locked_by },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSharedLibraryLockStatus>(
                "CMsgClientSharedLibraryLockStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryLockStatus {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSharedLibraryLockStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSharedLibraryLockStatus::new)
    }
}

impl ::protobuf::Clear for CMsgClientSharedLibraryLockStatus {
    fn clear(&mut self) {
        self.locked_library.clear();
        self.own_library_locked_by = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSharedLibraryLockStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryLockStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSharedLibraryLockStatus_LockedLibrary {
    // message fields
    owner_id: ::std::option::Option<u32>,
    locked_by: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryLockStatus_LockedLibrary {
    fn default() -> &'a CMsgClientSharedLibraryLockStatus_LockedLibrary {
        <CMsgClientSharedLibraryLockStatus_LockedLibrary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryLockStatus_LockedLibrary {
    pub fn new() -> CMsgClientSharedLibraryLockStatus_LockedLibrary {
        ::std::default::Default::default()
    }

    // optional uint32 owner_id = 1;


    pub fn get_owner_id(&self) -> u32 {
        self.owner_id.unwrap_or(0)
    }
    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: u32) {
        self.owner_id = ::std::option::Option::Some(v);
    }

    // optional uint32 locked_by = 2;


    pub fn get_locked_by(&self) -> u32 {
        self.locked_by.unwrap_or(0)
    }
    pub fn clear_locked_by(&mut self) {
        self.locked_by = ::std::option::Option::None;
    }

    pub fn has_locked_by(&self) -> bool {
        self.locked_by.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locked_by(&mut self, v: u32) {
        self.locked_by = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryLockStatus_LockedLibrary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.locked_by = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.locked_by {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.locked_by {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSharedLibraryLockStatus_LockedLibrary {
        CMsgClientSharedLibraryLockStatus_LockedLibrary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_id",
                |m: &CMsgClientSharedLibraryLockStatus_LockedLibrary| { &m.owner_id },
                |m: &mut CMsgClientSharedLibraryLockStatus_LockedLibrary| { &mut m.owner_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "locked_by",
                |m: &CMsgClientSharedLibraryLockStatus_LockedLibrary| { &m.locked_by },
                |m: &mut CMsgClientSharedLibraryLockStatus_LockedLibrary| { &mut m.locked_by },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSharedLibraryLockStatus_LockedLibrary>(
                "CMsgClientSharedLibraryLockStatus.LockedLibrary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryLockStatus_LockedLibrary {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSharedLibraryLockStatus_LockedLibrary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSharedLibraryLockStatus_LockedLibrary::new)
    }
}

impl ::protobuf::Clear for CMsgClientSharedLibraryLockStatus_LockedLibrary {
    fn clear(&mut self) {
        self.owner_id = ::std::option::Option::None;
        self.locked_by = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSharedLibraryLockStatus_LockedLibrary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryLockStatus_LockedLibrary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSharedLibraryStopPlaying {
    // message fields
    seconds_left: ::std::option::Option<i32>,
    pub stop_apps: ::protobuf::RepeatedField<CMsgClientSharedLibraryStopPlaying_StopApp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryStopPlaying {
    fn default() -> &'a CMsgClientSharedLibraryStopPlaying {
        <CMsgClientSharedLibraryStopPlaying as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryStopPlaying {
    pub fn new() -> CMsgClientSharedLibraryStopPlaying {
        ::std::default::Default::default()
    }

    // optional int32 seconds_left = 1;


    pub fn get_seconds_left(&self) -> i32 {
        self.seconds_left.unwrap_or(0)
    }
    pub fn clear_seconds_left(&mut self) {
        self.seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        self.seconds_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: i32) {
        self.seconds_left = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientSharedLibraryStopPlaying.StopApp stop_apps = 2;


    pub fn get_stop_apps(&self) -> &[CMsgClientSharedLibraryStopPlaying_StopApp] {
        &self.stop_apps
    }
    pub fn clear_stop_apps(&mut self) {
        self.stop_apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_stop_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientSharedLibraryStopPlaying_StopApp>) {
        self.stop_apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stop_apps(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientSharedLibraryStopPlaying_StopApp> {
        &mut self.stop_apps
    }

    // Take field
    pub fn take_stop_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientSharedLibraryStopPlaying_StopApp> {
        ::std::mem::replace(&mut self.stop_apps, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryStopPlaying {
    fn is_initialized(&self) -> bool {
        for v in &self.stop_apps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_left = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stop_apps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_left {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stop_apps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds_left {
            os.write_int32(1, v)?;
        }
        for v in &self.stop_apps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSharedLibraryStopPlaying {
        CMsgClientSharedLibraryStopPlaying::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seconds_left",
                |m: &CMsgClientSharedLibraryStopPlaying| { &m.seconds_left },
                |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.seconds_left },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientSharedLibraryStopPlaying_StopApp>>(
                "stop_apps",
                |m: &CMsgClientSharedLibraryStopPlaying| { &m.stop_apps },
                |m: &mut CMsgClientSharedLibraryStopPlaying| { &mut m.stop_apps },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSharedLibraryStopPlaying>(
                "CMsgClientSharedLibraryStopPlaying",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryStopPlaying {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSharedLibraryStopPlaying> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSharedLibraryStopPlaying::new)
    }
}

impl ::protobuf::Clear for CMsgClientSharedLibraryStopPlaying {
    fn clear(&mut self) {
        self.seconds_left = ::std::option::Option::None;
        self.stop_apps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSharedLibraryStopPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryStopPlaying {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientSharedLibraryStopPlaying_StopApp {
    // message fields
    app_id: ::std::option::Option<u32>,
    owner_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSharedLibraryStopPlaying_StopApp {
    fn default() -> &'a CMsgClientSharedLibraryStopPlaying_StopApp {
        <CMsgClientSharedLibraryStopPlaying_StopApp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSharedLibraryStopPlaying_StopApp {
    pub fn new() -> CMsgClientSharedLibraryStopPlaying_StopApp {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;


    pub fn get_app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 owner_id = 2;


    pub fn get_owner_id(&self) -> u32 {
        self.owner_id.unwrap_or(0)
    }
    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: u32) {
        self.owner_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSharedLibraryStopPlaying_StopApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSharedLibraryStopPlaying_StopApp {
        CMsgClientSharedLibraryStopPlaying_StopApp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "app_id",
                |m: &CMsgClientSharedLibraryStopPlaying_StopApp| { &m.app_id },
                |m: &mut CMsgClientSharedLibraryStopPlaying_StopApp| { &mut m.app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_id",
                |m: &CMsgClientSharedLibraryStopPlaying_StopApp| { &m.owner_id },
                |m: &mut CMsgClientSharedLibraryStopPlaying_StopApp| { &mut m.owner_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSharedLibraryStopPlaying_StopApp>(
                "CMsgClientSharedLibraryStopPlaying.StopApp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSharedLibraryStopPlaying_StopApp {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSharedLibraryStopPlaying_StopApp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSharedLibraryStopPlaying_StopApp::new)
    }
}

impl ::protobuf::Clear for CMsgClientSharedLibraryStopPlaying_StopApp {
    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.owner_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSharedLibraryStopPlaying_StopApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSharedLibraryStopPlaying_StopApp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceCall {
    // message fields
    sysid_routing: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    call_handle: ::std::option::Option<u32>,
    module_crc: ::std::option::Option<u32>,
    module_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    function_id: ::std::option::Option<u32>,
    cub_output_max: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    callparameter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ping_only: ::std::option::Option<bool>,
    max_outstanding_calls: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCall {
    fn default() -> &'a CMsgClientServiceCall {
        <CMsgClientServiceCall as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCall {
    pub fn new() -> CMsgClientServiceCall {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;


    pub fn get_sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing.clear();
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing.set_default();
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;


    pub fn get_call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }
    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;


    pub fn get_module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }
    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;


    pub fn get_module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_module_hash(&mut self) {
        self.module_hash.clear();
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash.set_default();
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 function_id = 5;


    pub fn get_function_id(&self) -> u32 {
        self.function_id.unwrap_or(0)
    }
    pub fn clear_function_id(&mut self) {
        self.function_id = ::std::option::Option::None;
    }

    pub fn has_function_id(&self) -> bool {
        self.function_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: u32) {
        self.function_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cub_output_max = 6;


    pub fn get_cub_output_max(&self) -> u32 {
        self.cub_output_max.unwrap_or(0)
    }
    pub fn clear_cub_output_max(&mut self) {
        self.cub_output_max = ::std::option::Option::None;
    }

    pub fn has_cub_output_max(&self) -> bool {
        self.cub_output_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cub_output_max(&mut self, v: u32) {
        self.cub_output_max = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 7;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes callparameter = 8;


    pub fn get_callparameter(&self) -> &[u8] {
        match self.callparameter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_callparameter(&mut self) {
        self.callparameter.clear();
    }

    pub fn has_callparameter(&self) -> bool {
        self.callparameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callparameter(&mut self, v: ::std::vec::Vec<u8>) {
        self.callparameter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callparameter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callparameter.is_none() {
            self.callparameter.set_default();
        }
        self.callparameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_callparameter(&mut self) -> ::std::vec::Vec<u8> {
        self.callparameter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool ping_only = 9;


    pub fn get_ping_only(&self) -> bool {
        self.ping_only.unwrap_or(false)
    }
    pub fn clear_ping_only(&mut self) {
        self.ping_only = ::std::option::Option::None;
    }

    pub fn has_ping_only(&self) -> bool {
        self.ping_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_only(&mut self, v: bool) {
        self.ping_only = ::std::option::Option::Some(v);
    }

    // optional uint32 max_outstanding_calls = 10;


    pub fn get_max_outstanding_calls(&self) -> u32 {
        self.max_outstanding_calls.unwrap_or(0)
    }
    pub fn clear_max_outstanding_calls(&mut self) {
        self.max_outstanding_calls = ::std::option::Option::None;
    }

    pub fn has_max_outstanding_calls(&self) -> bool {
        self.max_outstanding_calls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_outstanding_calls(&mut self, v: u32) {
        self.max_outstanding_calls = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceCall {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sysid_routing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.call_handle = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.module_crc = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.function_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cub_output_max = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.callparameter)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ping_only = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_outstanding_calls = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.function_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cub_output_max {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.callparameter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.ping_only {
            my_size += 2;
        }
        if let Some(v) = self.max_outstanding_calls {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.module_hash.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.function_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cub_output_max {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.callparameter.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.ping_only {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.max_outstanding_calls {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceCall {
        CMsgClientServiceCall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sysid_routing",
                |m: &CMsgClientServiceCall| { &m.sysid_routing },
                |m: &mut CMsgClientServiceCall| { &mut m.sysid_routing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "call_handle",
                |m: &CMsgClientServiceCall| { &m.call_handle },
                |m: &mut CMsgClientServiceCall| { &mut m.call_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "module_crc",
                |m: &CMsgClientServiceCall| { &m.module_crc },
                |m: &mut CMsgClientServiceCall| { &mut m.module_crc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "module_hash",
                |m: &CMsgClientServiceCall| { &m.module_hash },
                |m: &mut CMsgClientServiceCall| { &mut m.module_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "function_id",
                |m: &CMsgClientServiceCall| { &m.function_id },
                |m: &mut CMsgClientServiceCall| { &mut m.function_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cub_output_max",
                |m: &CMsgClientServiceCall| { &m.cub_output_max },
                |m: &mut CMsgClientServiceCall| { &mut m.cub_output_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgClientServiceCall| { &m.flags },
                |m: &mut CMsgClientServiceCall| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "callparameter",
                |m: &CMsgClientServiceCall| { &m.callparameter },
                |m: &mut CMsgClientServiceCall| { &mut m.callparameter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ping_only",
                |m: &CMsgClientServiceCall| { &m.ping_only },
                |m: &mut CMsgClientServiceCall| { &mut m.ping_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_outstanding_calls",
                |m: &CMsgClientServiceCall| { &m.max_outstanding_calls },
                |m: &mut CMsgClientServiceCall| { &mut m.max_outstanding_calls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientServiceCall>(
                "CMsgClientServiceCall",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceCall {
        static instance: ::protobuf::rt::LazyV2<CMsgClientServiceCall> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientServiceCall::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceCall {
    fn clear(&mut self) {
        self.sysid_routing.clear();
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash.clear();
        self.function_id = ::std::option::Option::None;
        self.cub_output_max = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.callparameter.clear();
        self.ping_only = ::std::option::Option::None;
        self.max_outstanding_calls = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceCall {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceModule {
    // message fields
    module_crc: ::std::option::Option<u32>,
    module_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    module_content: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceModule {
    fn default() -> &'a CMsgClientServiceModule {
        <CMsgClientServiceModule as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceModule {
    pub fn new() -> CMsgClientServiceModule {
        ::std::default::Default::default()
    }

    // optional uint32 module_crc = 1;


    pub fn get_module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }
    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 2;


    pub fn get_module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_module_hash(&mut self) {
        self.module_hash.clear();
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash.set_default();
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes module_content = 3;


    pub fn get_module_content(&self) -> &[u8] {
        match self.module_content.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_module_content(&mut self) {
        self.module_content.clear();
    }

    pub fn has_module_content(&self) -> bool {
        self.module_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_content.is_none() {
            self.module_content.set_default();
        }
        self.module_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_content(&mut self) -> ::std::vec::Vec<u8> {
        self.module_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientServiceModule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.module_crc = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.module_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.module_crc {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.module_hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.module_content.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceModule {
        CMsgClientServiceModule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "module_crc",
                |m: &CMsgClientServiceModule| { &m.module_crc },
                |m: &mut CMsgClientServiceModule| { &mut m.module_crc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "module_hash",
                |m: &CMsgClientServiceModule| { &m.module_hash },
                |m: &mut CMsgClientServiceModule| { &mut m.module_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "module_content",
                |m: &CMsgClientServiceModule| { &m.module_content },
                |m: &mut CMsgClientServiceModule| { &mut m.module_content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientServiceModule>(
                "CMsgClientServiceModule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceModule {
        static instance: ::protobuf::rt::LazyV2<CMsgClientServiceModule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientServiceModule::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceModule {
    fn clear(&mut self) {
        self.module_crc = ::std::option::Option::None;
        self.module_hash.clear();
        self.module_content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceModule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientServiceCallResponse {
    // message fields
    sysid_routing: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    call_handle: ::std::option::Option<u32>,
    module_crc: ::std::option::Option<u32>,
    module_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ecallresult: ::std::option::Option<u32>,
    result_content: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    os_version_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    system_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    load_address: ::std::option::Option<u64>,
    exception_record: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    portable_os_version_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    portable_system_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    was_converted: ::std::option::Option<bool>,
    internal_result: ::std::option::Option<u32>,
    current_count: ::std::option::Option<u32>,
    last_call_handle: ::std::option::Option<u32>,
    last_call_module_crc: ::std::option::Option<u32>,
    last_call_sysid_routing: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    last_ecallresult: ::std::option::Option<u32>,
    last_callissue_delta: ::std::option::Option<u32>,
    last_callcomplete_delta: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientServiceCallResponse {
    fn default() -> &'a CMsgClientServiceCallResponse {
        <CMsgClientServiceCallResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientServiceCallResponse {
    pub fn new() -> CMsgClientServiceCallResponse {
        ::std::default::Default::default()
    }

    // optional bytes sysid_routing = 1;


    pub fn get_sysid_routing(&self) -> &[u8] {
        match self.sysid_routing.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sysid_routing(&mut self) {
        self.sysid_routing.clear();
    }

    pub fn has_sysid_routing(&self) -> bool {
        self.sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.sysid_routing = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sysid_routing.is_none() {
            self.sysid_routing.set_default();
        }
        self.sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 call_handle = 2;


    pub fn get_call_handle(&self) -> u32 {
        self.call_handle.unwrap_or(0)
    }
    pub fn clear_call_handle(&mut self) {
        self.call_handle = ::std::option::Option::None;
    }

    pub fn has_call_handle(&self) -> bool {
        self.call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_call_handle(&mut self, v: u32) {
        self.call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 module_crc = 3;


    pub fn get_module_crc(&self) -> u32 {
        self.module_crc.unwrap_or(0)
    }
    pub fn clear_module_crc(&mut self) {
        self.module_crc = ::std::option::Option::None;
    }

    pub fn has_module_crc(&self) -> bool {
        self.module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_crc(&mut self, v: u32) {
        self.module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes module_hash = 4;


    pub fn get_module_hash(&self) -> &[u8] {
        match self.module_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_module_hash(&mut self) {
        self.module_hash.clear();
    }

    pub fn has_module_hash(&self) -> bool {
        self.module_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.module_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.module_hash.is_none() {
            self.module_hash.set_default();
        }
        self.module_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_module_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.module_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ecallresult = 5;


    pub fn get_ecallresult(&self) -> u32 {
        self.ecallresult.unwrap_or(0)
    }
    pub fn clear_ecallresult(&mut self) {
        self.ecallresult = ::std::option::Option::None;
    }

    pub fn has_ecallresult(&self) -> bool {
        self.ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecallresult(&mut self, v: u32) {
        self.ecallresult = ::std::option::Option::Some(v);
    }

    // optional bytes result_content = 6;


    pub fn get_result_content(&self) -> &[u8] {
        match self.result_content.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_result_content(&mut self) {
        self.result_content.clear();
    }

    pub fn has_result_content(&self) -> bool {
        self.result_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.result_content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.result_content.is_none() {
            self.result_content.set_default();
        }
        self.result_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_content(&mut self) -> ::std::vec::Vec<u8> {
        self.result_content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes os_version_info = 7;


    pub fn get_os_version_info(&self) -> &[u8] {
        match self.os_version_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_os_version_info(&mut self) {
        self.os_version_info.clear();
    }

    pub fn has_os_version_info(&self) -> bool {
        self.os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.os_version_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.os_version_info.is_none() {
            self.os_version_info.set_default();
        }
        self.os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes system_info = 8;


    pub fn get_system_info(&self) -> &[u8] {
        match self.system_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_system_info(&mut self) {
        self.system_info.clear();
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.system_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.system_info.is_none() {
            self.system_info.set_default();
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 load_address = 9;


    pub fn get_load_address(&self) -> u64 {
        self.load_address.unwrap_or(0)
    }
    pub fn clear_load_address(&mut self) {
        self.load_address = ::std::option::Option::None;
    }

    pub fn has_load_address(&self) -> bool {
        self.load_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_address(&mut self, v: u64) {
        self.load_address = ::std::option::Option::Some(v);
    }

    // optional bytes exception_record = 10;


    pub fn get_exception_record(&self) -> &[u8] {
        match self.exception_record.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_exception_record(&mut self) {
        self.exception_record.clear();
    }

    pub fn has_exception_record(&self) -> bool {
        self.exception_record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception_record(&mut self, v: ::std::vec::Vec<u8>) {
        self.exception_record = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception_record(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.exception_record.is_none() {
            self.exception_record.set_default();
        }
        self.exception_record.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception_record(&mut self) -> ::std::vec::Vec<u8> {
        self.exception_record.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_os_version_info = 11;


    pub fn get_portable_os_version_info(&self) -> &[u8] {
        match self.portable_os_version_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_portable_os_version_info(&mut self) {
        self.portable_os_version_info.clear();
    }

    pub fn has_portable_os_version_info(&self) -> bool {
        self.portable_os_version_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_os_version_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_os_version_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_os_version_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_os_version_info.is_none() {
            self.portable_os_version_info.set_default();
        }
        self.portable_os_version_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_os_version_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_os_version_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes portable_system_info = 12;


    pub fn get_portable_system_info(&self) -> &[u8] {
        match self.portable_system_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_portable_system_info(&mut self) {
        self.portable_system_info.clear();
    }

    pub fn has_portable_system_info(&self) -> bool {
        self.portable_system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portable_system_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.portable_system_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portable_system_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.portable_system_info.is_none() {
            self.portable_system_info.set_default();
        }
        self.portable_system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_portable_system_info(&mut self) -> ::std::vec::Vec<u8> {
        self.portable_system_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool was_converted = 13;


    pub fn get_was_converted(&self) -> bool {
        self.was_converted.unwrap_or(false)
    }
    pub fn clear_was_converted(&mut self) {
        self.was_converted = ::std::option::Option::None;
    }

    pub fn has_was_converted(&self) -> bool {
        self.was_converted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_converted(&mut self, v: bool) {
        self.was_converted = ::std::option::Option::Some(v);
    }

    // optional uint32 internal_result = 14;


    pub fn get_internal_result(&self) -> u32 {
        self.internal_result.unwrap_or(0)
    }
    pub fn clear_internal_result(&mut self) {
        self.internal_result = ::std::option::Option::None;
    }

    pub fn has_internal_result(&self) -> bool {
        self.internal_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_result(&mut self, v: u32) {
        self.internal_result = ::std::option::Option::Some(v);
    }

    // optional uint32 current_count = 15;


    pub fn get_current_count(&self) -> u32 {
        self.current_count.unwrap_or(0)
    }
    pub fn clear_current_count(&mut self) {
        self.current_count = ::std::option::Option::None;
    }

    pub fn has_current_count(&self) -> bool {
        self.current_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_count(&mut self, v: u32) {
        self.current_count = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_handle = 16;


    pub fn get_last_call_handle(&self) -> u32 {
        self.last_call_handle.unwrap_or(0)
    }
    pub fn clear_last_call_handle(&mut self) {
        self.last_call_handle = ::std::option::Option::None;
    }

    pub fn has_last_call_handle(&self) -> bool {
        self.last_call_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_handle(&mut self, v: u32) {
        self.last_call_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 last_call_module_crc = 17;


    pub fn get_last_call_module_crc(&self) -> u32 {
        self.last_call_module_crc.unwrap_or(0)
    }
    pub fn clear_last_call_module_crc(&mut self) {
        self.last_call_module_crc = ::std::option::Option::None;
    }

    pub fn has_last_call_module_crc(&self) -> bool {
        self.last_call_module_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_module_crc(&mut self, v: u32) {
        self.last_call_module_crc = ::std::option::Option::Some(v);
    }

    // optional bytes last_call_sysid_routing = 18;


    pub fn get_last_call_sysid_routing(&self) -> &[u8] {
        match self.last_call_sysid_routing.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_last_call_sysid_routing(&mut self) {
        self.last_call_sysid_routing.clear();
    }

    pub fn has_last_call_sysid_routing(&self) -> bool {
        self.last_call_sysid_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_call_sysid_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.last_call_sysid_routing = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_call_sysid_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.last_call_sysid_routing.is_none() {
            self.last_call_sysid_routing.set_default();
        }
        self.last_call_sysid_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_call_sysid_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.last_call_sysid_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 last_ecallresult = 19;


    pub fn get_last_ecallresult(&self) -> u32 {
        self.last_ecallresult.unwrap_or(0)
    }
    pub fn clear_last_ecallresult(&mut self) {
        self.last_ecallresult = ::std::option::Option::None;
    }

    pub fn has_last_ecallresult(&self) -> bool {
        self.last_ecallresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ecallresult(&mut self, v: u32) {
        self.last_ecallresult = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callissue_delta = 20;


    pub fn get_last_callissue_delta(&self) -> u32 {
        self.last_callissue_delta.unwrap_or(0)
    }
    pub fn clear_last_callissue_delta(&mut self) {
        self.last_callissue_delta = ::std::option::Option::None;
    }

    pub fn has_last_callissue_delta(&self) -> bool {
        self.last_callissue_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callissue_delta(&mut self, v: u32) {
        self.last_callissue_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 last_callcomplete_delta = 21;


    pub fn get_last_callcomplete_delta(&self) -> u32 {
        self.last_callcomplete_delta.unwrap_or(0)
    }
    pub fn clear_last_callcomplete_delta(&mut self) {
        self.last_callcomplete_delta = ::std::option::Option::None;
    }

    pub fn has_last_callcomplete_delta(&self) -> bool {
        self.last_callcomplete_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_callcomplete_delta(&mut self, v: u32) {
        self.last_callcomplete_delta = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientServiceCallResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sysid_routing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.call_handle = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.module_crc = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.module_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ecallresult = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.result_content)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.os_version_info)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.system_info)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.load_address = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.exception_record)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.portable_os_version_info)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.portable_system_info)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.was_converted = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.internal_result = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_count = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_call_handle = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_call_module_crc = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.last_call_sysid_routing)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_ecallresult = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_callissue_delta = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_callcomplete_delta = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.call_handle {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.module_crc {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.module_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.ecallresult {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.result_content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.load_address {
            my_size += 9;
        }
        if let Some(ref v) = self.exception_record.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(ref v) = self.portable_os_version_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        if let Some(ref v) = self.portable_system_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.was_converted {
            my_size += 2;
        }
        if let Some(v) = self.internal_result {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.current_count {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_call_handle {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_call_module_crc {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.last_call_sysid_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.last_ecallresult {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_callissue_delta {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_callcomplete_delta {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sysid_routing.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.call_handle {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.module_crc {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.module_hash.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.ecallresult {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.result_content.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.os_version_info.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.system_info.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.load_address {
            os.write_fixed64(9, v)?;
        }
        if let Some(ref v) = self.exception_record.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(ref v) = self.portable_os_version_info.as_ref() {
            os.write_bytes(11, &v)?;
        }
        if let Some(ref v) = self.portable_system_info.as_ref() {
            os.write_bytes(12, &v)?;
        }
        if let Some(v) = self.was_converted {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.internal_result {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.current_count {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_call_handle {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.last_call_module_crc {
            os.write_uint32(17, v)?;
        }
        if let Some(ref v) = self.last_call_sysid_routing.as_ref() {
            os.write_bytes(18, &v)?;
        }
        if let Some(v) = self.last_ecallresult {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_callissue_delta {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.last_callcomplete_delta {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientServiceCallResponse {
        CMsgClientServiceCallResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sysid_routing",
                |m: &CMsgClientServiceCallResponse| { &m.sysid_routing },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.sysid_routing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "call_handle",
                |m: &CMsgClientServiceCallResponse| { &m.call_handle },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.call_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "module_crc",
                |m: &CMsgClientServiceCallResponse| { &m.module_crc },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.module_crc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "module_hash",
                |m: &CMsgClientServiceCallResponse| { &m.module_hash },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.module_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ecallresult",
                |m: &CMsgClientServiceCallResponse| { &m.ecallresult },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.ecallresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "result_content",
                |m: &CMsgClientServiceCallResponse| { &m.result_content },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.result_content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "os_version_info",
                |m: &CMsgClientServiceCallResponse| { &m.os_version_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.os_version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "system_info",
                |m: &CMsgClientServiceCallResponse| { &m.system_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.system_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "load_address",
                |m: &CMsgClientServiceCallResponse| { &m.load_address },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.load_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "exception_record",
                |m: &CMsgClientServiceCallResponse| { &m.exception_record },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.exception_record },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "portable_os_version_info",
                |m: &CMsgClientServiceCallResponse| { &m.portable_os_version_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_os_version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "portable_system_info",
                |m: &CMsgClientServiceCallResponse| { &m.portable_system_info },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.portable_system_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "was_converted",
                |m: &CMsgClientServiceCallResponse| { &m.was_converted },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.was_converted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "internal_result",
                |m: &CMsgClientServiceCallResponse| { &m.internal_result },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.internal_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "current_count",
                |m: &CMsgClientServiceCallResponse| { &m.current_count },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.current_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_call_handle",
                |m: &CMsgClientServiceCallResponse| { &m.last_call_handle },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_call_module_crc",
                |m: &CMsgClientServiceCallResponse| { &m.last_call_module_crc },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_module_crc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "last_call_sysid_routing",
                |m: &CMsgClientServiceCallResponse| { &m.last_call_sysid_routing },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_call_sysid_routing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_ecallresult",
                |m: &CMsgClientServiceCallResponse| { &m.last_ecallresult },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_ecallresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_callissue_delta",
                |m: &CMsgClientServiceCallResponse| { &m.last_callissue_delta },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callissue_delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_callcomplete_delta",
                |m: &CMsgClientServiceCallResponse| { &m.last_callcomplete_delta },
                |m: &mut CMsgClientServiceCallResponse| { &mut m.last_callcomplete_delta },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientServiceCallResponse>(
                "CMsgClientServiceCallResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientServiceCallResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientServiceCallResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientServiceCallResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientServiceCallResponse {
    fn clear(&mut self) {
        self.sysid_routing.clear();
        self.call_handle = ::std::option::Option::None;
        self.module_crc = ::std::option::Option::None;
        self.module_hash.clear();
        self.ecallresult = ::std::option::Option::None;
        self.result_content.clear();
        self.os_version_info.clear();
        self.system_info.clear();
        self.load_address = ::std::option::Option::None;
        self.exception_record.clear();
        self.portable_os_version_info.clear();
        self.portable_system_info.clear();
        self.was_converted = ::std::option::Option::None;
        self.internal_result = ::std::option::Option::None;
        self.current_count = ::std::option::Option::None;
        self.last_call_handle = ::std::option::Option::None;
        self.last_call_module_crc = ::std::option::Option::None;
        self.last_call_sysid_routing.clear();
        self.last_ecallresult = ::std::option::Option::None;
        self.last_callissue_delta = ::std::option::Option::None;
        self.last_callcomplete_delta = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientServiceCallResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientServiceCallResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockStreaming {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockStreaming {
    fn default() -> &'a CMsgAMUnlockStreaming {
        <CMsgAMUnlockStreaming as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockStreaming {
    pub fn new() -> CMsgAMUnlockStreaming {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgAMUnlockStreaming {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockStreaming {
        CMsgAMUnlockStreaming::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAMUnlockStreaming>(
                "CMsgAMUnlockStreaming",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockStreaming {
        static instance: ::protobuf::rt::LazyV2<CMsgAMUnlockStreaming> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAMUnlockStreaming::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockStreaming {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockStreaming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockStreaming {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockStreamingResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    encryption_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockStreamingResponse {
    fn default() -> &'a CMsgAMUnlockStreamingResponse {
        <CMsgAMUnlockStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockStreamingResponse {
    pub fn new() -> CMsgAMUnlockStreamingResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional bytes encryption_key = 2;


    pub fn get_encryption_key(&self) -> &[u8] {
        match self.encryption_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_encryption_key(&mut self) {
        self.encryption_key.clear();
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryption_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryption_key.is_none() {
            self.encryption_key.set_default();
        }
        self.encryption_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_key(&mut self) -> ::std::vec::Vec<u8> {
        self.encryption_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgAMUnlockStreamingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encryption_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encryption_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.encryption_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockStreamingResponse {
        CMsgAMUnlockStreamingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgAMUnlockStreamingResponse| { &m.eresult },
                |m: &mut CMsgAMUnlockStreamingResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encryption_key",
                |m: &CMsgAMUnlockStreamingResponse| { &m.encryption_key },
                |m: &mut CMsgAMUnlockStreamingResponse| { &mut m.encryption_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAMUnlockStreamingResponse>(
                "CMsgAMUnlockStreamingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockStreamingResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgAMUnlockStreamingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAMUnlockStreamingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockStreamingResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.encryption_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockStreamingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockHEVC {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockHEVC {
    fn default() -> &'a CMsgAMUnlockHEVC {
        <CMsgAMUnlockHEVC as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockHEVC {
    pub fn new() -> CMsgAMUnlockHEVC {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgAMUnlockHEVC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockHEVC {
        CMsgAMUnlockHEVC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAMUnlockHEVC>(
                "CMsgAMUnlockHEVC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockHEVC {
        static instance: ::protobuf::rt::LazyV2<CMsgAMUnlockHEVC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAMUnlockHEVC::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockHEVC {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockHEVC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockHEVC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAMUnlockHEVCResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAMUnlockHEVCResponse {
    fn default() -> &'a CMsgAMUnlockHEVCResponse {
        <CMsgAMUnlockHEVCResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAMUnlockHEVCResponse {
    pub fn new() -> CMsgAMUnlockHEVCResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAMUnlockHEVCResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAMUnlockHEVCResponse {
        CMsgAMUnlockHEVCResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgAMUnlockHEVCResponse| { &m.eresult },
                |m: &mut CMsgAMUnlockHEVCResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAMUnlockHEVCResponse>(
                "CMsgAMUnlockHEVCResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAMUnlockHEVCResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgAMUnlockHEVCResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAMUnlockHEVCResponse::new)
    }
}

impl ::protobuf::Clear for CMsgAMUnlockHEVCResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAMUnlockHEVCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAMUnlockHEVCResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientPlayingSessionState {
    // message fields
    playing_blocked: ::std::option::Option<bool>,
    playing_app: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayingSessionState {
    fn default() -> &'a CMsgClientPlayingSessionState {
        <CMsgClientPlayingSessionState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayingSessionState {
    pub fn new() -> CMsgClientPlayingSessionState {
        ::std::default::Default::default()
    }

    // optional bool playing_blocked = 2;


    pub fn get_playing_blocked(&self) -> bool {
        self.playing_blocked.unwrap_or(false)
    }
    pub fn clear_playing_blocked(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
    }

    pub fn has_playing_blocked(&self) -> bool {
        self.playing_blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_blocked(&mut self, v: bool) {
        self.playing_blocked = ::std::option::Option::Some(v);
    }

    // optional uint32 playing_app = 3;


    pub fn get_playing_app(&self) -> u32 {
        self.playing_app.unwrap_or(0)
    }
    pub fn clear_playing_app(&mut self) {
        self.playing_app = ::std::option::Option::None;
    }

    pub fn has_playing_app(&self) -> bool {
        self.playing_app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_app(&mut self, v: u32) {
        self.playing_app = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPlayingSessionState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.playing_blocked = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.playing_app = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.playing_blocked {
            my_size += 2;
        }
        if let Some(v) = self.playing_app {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.playing_blocked {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.playing_app {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPlayingSessionState {
        CMsgClientPlayingSessionState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "playing_blocked",
                |m: &CMsgClientPlayingSessionState| { &m.playing_blocked },
                |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_blocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "playing_app",
                |m: &CMsgClientPlayingSessionState| { &m.playing_app },
                |m: &mut CMsgClientPlayingSessionState| { &mut m.playing_app },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPlayingSessionState>(
                "CMsgClientPlayingSessionState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPlayingSessionState {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPlayingSessionState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPlayingSessionState::new)
    }
}

impl ::protobuf::Clear for CMsgClientPlayingSessionState {
    fn clear(&mut self) {
        self.playing_blocked = ::std::option::Option::None;
        self.playing_app = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPlayingSessionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPlayingSessionState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientKickPlayingSession {
    // message fields
    only_stop_game: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientKickPlayingSession {
    fn default() -> &'a CMsgClientKickPlayingSession {
        <CMsgClientKickPlayingSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientKickPlayingSession {
    pub fn new() -> CMsgClientKickPlayingSession {
        ::std::default::Default::default()
    }

    // optional bool only_stop_game = 1;


    pub fn get_only_stop_game(&self) -> bool {
        self.only_stop_game.unwrap_or(false)
    }
    pub fn clear_only_stop_game(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
    }

    pub fn has_only_stop_game(&self) -> bool {
        self.only_stop_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_stop_game(&mut self, v: bool) {
        self.only_stop_game = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientKickPlayingSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_stop_game = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.only_stop_game {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.only_stop_game {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientKickPlayingSession {
        CMsgClientKickPlayingSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "only_stop_game",
                |m: &CMsgClientKickPlayingSession| { &m.only_stop_game },
                |m: &mut CMsgClientKickPlayingSession| { &mut m.only_stop_game },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientKickPlayingSession>(
                "CMsgClientKickPlayingSession",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientKickPlayingSession {
        static instance: ::protobuf::rt::LazyV2<CMsgClientKickPlayingSession> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientKickPlayingSession::new)
    }
}

impl ::protobuf::Clear for CMsgClientKickPlayingSession {
    fn clear(&mut self) {
        self.only_stop_game = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientKickPlayingSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientKickPlayingSession {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientVoiceCallPreAuthorize {
    // message fields
    caller_steamid: ::std::option::Option<u64>,
    receiver_steamid: ::std::option::Option<u64>,
    caller_id: ::std::option::Option<i32>,
    hangup: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorize {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorize {
        <CMsgClientVoiceCallPreAuthorize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorize {
    pub fn new() -> CMsgClientVoiceCallPreAuthorize {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;


    pub fn get_caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }
    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;


    pub fn get_receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }
    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 3;


    pub fn get_caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }
    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }

    // optional bool hangup = 4;


    pub fn get_hangup(&self) -> bool {
        self.hangup.unwrap_or(false)
    }
    pub fn clear_hangup(&mut self) {
        self.hangup = ::std::option::Option::None;
    }

    pub fn has_hangup(&self) -> bool {
        self.hangup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hangup(&mut self, v: bool) {
        self.hangup = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.caller_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.receiver_steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.caller_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hangup = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 9;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 9;
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hangup {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hangup {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientVoiceCallPreAuthorize {
        CMsgClientVoiceCallPreAuthorize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "caller_steamid",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "receiver_steamid",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.receiver_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.receiver_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "caller_id",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.caller_id },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.caller_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hangup",
                |m: &CMsgClientVoiceCallPreAuthorize| { &m.hangup },
                |m: &mut CMsgClientVoiceCallPreAuthorize| { &mut m.hangup },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientVoiceCallPreAuthorize>(
                "CMsgClientVoiceCallPreAuthorize",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorize {
        static instance: ::protobuf::rt::LazyV2<CMsgClientVoiceCallPreAuthorize> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientVoiceCallPreAuthorize::new)
    }
}

impl ::protobuf::Clear for CMsgClientVoiceCallPreAuthorize {
    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.hangup = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientVoiceCallPreAuthorize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientVoiceCallPreAuthorizeResponse {
    // message fields
    caller_steamid: ::std::option::Option<u64>,
    receiver_steamid: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    caller_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientVoiceCallPreAuthorizeResponse {
    fn default() -> &'a CMsgClientVoiceCallPreAuthorizeResponse {
        <CMsgClientVoiceCallPreAuthorizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientVoiceCallPreAuthorizeResponse {
    pub fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 caller_steamid = 1;


    pub fn get_caller_steamid(&self) -> u64 {
        self.caller_steamid.unwrap_or(0)
    }
    pub fn clear_caller_steamid(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
    }

    pub fn has_caller_steamid(&self) -> bool {
        self.caller_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_steamid(&mut self, v: u64) {
        self.caller_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 receiver_steamid = 2;


    pub fn get_receiver_steamid(&self) -> u64 {
        self.receiver_steamid.unwrap_or(0)
    }
    pub fn clear_receiver_steamid(&mut self) {
        self.receiver_steamid = ::std::option::Option::None;
    }

    pub fn has_receiver_steamid(&self) -> bool {
        self.receiver_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_steamid(&mut self, v: u64) {
        self.receiver_steamid = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 3;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 caller_id = 4;


    pub fn get_caller_id(&self) -> i32 {
        self.caller_id.unwrap_or(0)
    }
    pub fn clear_caller_id(&mut self) {
        self.caller_id = ::std::option::Option::None;
    }

    pub fn has_caller_id(&self) -> bool {
        self.caller_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caller_id(&mut self, v: i32) {
        self.caller_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientVoiceCallPreAuthorizeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.caller_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.receiver_steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.caller_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.caller_steamid {
            my_size += 9;
        }
        if let Some(v) = self.receiver_steamid {
            my_size += 9;
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.caller_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.caller_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.receiver_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.caller_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientVoiceCallPreAuthorizeResponse {
        CMsgClientVoiceCallPreAuthorizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "caller_steamid",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "receiver_steamid",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.receiver_steamid },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.receiver_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.eresult },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "caller_id",
                |m: &CMsgClientVoiceCallPreAuthorizeResponse| { &m.caller_id },
                |m: &mut CMsgClientVoiceCallPreAuthorizeResponse| { &mut m.caller_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientVoiceCallPreAuthorizeResponse>(
                "CMsgClientVoiceCallPreAuthorizeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientVoiceCallPreAuthorizeResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientVoiceCallPreAuthorizeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientVoiceCallPreAuthorizeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientVoiceCallPreAuthorizeResponse {
    fn clear(&mut self) {
        self.caller_steamid = ::std::option::Option::None;
        self.receiver_steamid = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.caller_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientVoiceCallPreAuthorizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientVoiceCallPreAuthorizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgBadgeCraftedNotification {
    // message fields
    appid: ::std::option::Option<u32>,
    badge_level: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgBadgeCraftedNotification {
    fn default() -> &'a CMsgBadgeCraftedNotification {
        <CMsgBadgeCraftedNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgBadgeCraftedNotification {
    pub fn new() -> CMsgBadgeCraftedNotification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 2;


    pub fn get_badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }
    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgBadgeCraftedNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badge_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgBadgeCraftedNotification {
        CMsgBadgeCraftedNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgBadgeCraftedNotification| { &m.appid },
                |m: &mut CMsgBadgeCraftedNotification| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badge_level",
                |m: &CMsgBadgeCraftedNotification| { &m.badge_level },
                |m: &mut CMsgBadgeCraftedNotification| { &mut m.badge_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgBadgeCraftedNotification>(
                "CMsgBadgeCraftedNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgBadgeCraftedNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgBadgeCraftedNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgBadgeCraftedNotification::new)
    }
}

impl ::protobuf::Clear for CMsgBadgeCraftedNotification {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgBadgeCraftedNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgBadgeCraftedNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"steammessages_clientserver_2.proto\x1a\x18steammessages_base.proto\"\
    \xb6\x04\n\x1aCMsgClientUCMAddScreenshot\x12\x14\n\x05appid\x18\x01\x20\
    \x01(\rR\x05appid\x12\x1a\n\x08filename\x18\x02\x20\x01(\tR\x08filename\
    \x12\x1c\n\tthumbname\x18\x03\x20\x01(\tR\tthumbname\x12\x1f\n\x0bvr_fil\
    ename\x18\x0e\x20\x01(\tR\nvrFilename\x12'\n\x0frtime32_created\x18\x04\
    \x20\x01(\x07R\x0ertime32Created\x12\x14\n\x05width\x18\x05\x20\x01(\rR\
    \x05width\x12\x16\n\x06height\x18\x06\x20\x01(\rR\x06height\x12\x20\n\
    \x0bpermissions\x18\x07\x20\x01(\rR\x0bpermissions\x12\x18\n\x07caption\
    \x18\x08\x20\x01(\tR\x07caption\x12#\n\rshortcut_name\x18\t\x20\x01(\tR\
    \x0cshortcutName\x121\n\x03tag\x18\n\x20\x03(\x0b2\x1f.CMsgClientUCMAddS\
    creenshot.TagR\x03tag\x12%\n\x0etagged_steamid\x18\x0b\x20\x03(\x06R\rta\
    ggedSteamid\x12\x1f\n\x0bspoiler_tag\x18\x0c\x20\x01(\x08R\nspoilerTag\
    \x125\n\x16tagged_publishedfileid\x18\r\x20\x03(\x04R\x15taggedPublished\
    fileid\x1a=\n\x03Tag\x12\x19\n\x08tag_name\x18\x01\x20\x01(\tR\x07tagNam\
    e\x12\x1b\n\ttag_value\x18\x02\x20\x01(\tR\x08tagValue\"{\n\"CMsgClientU\
    CMAddScreenshotResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x128\n\x0cscreenshotid\x18\x02\x20\x01(\x06:\x14184467440737\
    09551615R\x0cscreenshotid\"Y\n\x1dCMsgClientUCMDeleteScreenshot\x128\n\
    \x0cscreenshotid\x18\x01\x20\x01(\x06:\x1418446744073709551615R\x0cscree\
    nshotid\"D\n%CMsgClientUCMDeleteScreenshotResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\"\x83\x04\n\x18CMsgClientUCMPubl\
    ishFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1b\n\tfile\
    _name\x18\x02\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\x18\
    \x03\x20\x01(\tR\x0fpreviewFileName\x12&\n\x0fconsumer_app_id\x18\x04\
    \x20\x01(\rR\rconsumerAppId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05ti\
    tle\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12\x12\
    \n\x04tags\x18\x08\x20\x03(\tR\x04tags\x12#\n\rworkshop_file\x18\t\x20\
    \x01(\x08R\x0cworkshopFile\x12\x1e\n\nvisibility\x18\n\x20\x01(\x05R\nvi\
    sibility\x12\x1b\n\tfile_type\x18\x0b\x20\x01(\rR\x08fileType\x12\x10\n\
    \x03url\x18\x0c\x20\x01(\tR\x03url\x12%\n\x0evideo_provider\x18\r\x20\
    \x01(\rR\rvideoProvider\x12,\n\x12video_account_name\x18\x0e\x20\x01(\tR\
    \x10videoAccountName\x12)\n\x10video_identifier\x18\x0f\x20\x01(\tR\x0fv\
    ideoIdentifier\x12\x1f\n\x0bin_progress\x18\x10\x20\x01(\x08R\ninProgres\
    s\"\xe2\x01\n\x20CMsgClientUCMPublishFileResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12@\n\x11published_file_id\x18\
    \x02\x20\x01(\x06:\x1418446744073709551615R\x0fpublishedFileId\x12_\n)ne\
    eds_workshop_legal_agreement_acceptance\x18\x03\x20\x01(\x08:\x05falseR%\
    needsWorkshopLegalAgreementAcceptance\"\x84\x0b\n\x20CMsgClientUCMUpdate\
    PublishedFile\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\
    \x11published_file_id\x18\x02\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\
    \tfile_name\x18\x03\x20\x01(\tR\x08fileName\x12*\n\x11preview_file_name\
    \x18\x04\x20\x01(\tR\x0fpreviewFileName\x12\x14\n\x05title\x18\x05\x20\
    \x01(\tR\x05title\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescri\
    ption\x12\x12\n\x04tags\x18\x07\x20\x03(\tR\x04tags\x12\x1e\n\nvisibilit\
    y\x18\x08\x20\x01(\x05R\nvisibility\x12\x1f\n\x0bupdate_file\x18\t\x20\
    \x01(\x08R\nupdateFile\x12.\n\x13update_preview_file\x18\n\x20\x01(\x08R\
    \x11updatePreviewFile\x12!\n\x0cupdate_title\x18\x0b\x20\x01(\x08R\x0bup\
    dateTitle\x12-\n\x12update_description\x18\x0c\x20\x01(\x08R\x11updateDe\
    scription\x12\x1f\n\x0bupdate_tags\x18\r\x20\x01(\x08R\nupdateTags\x12+\
    \n\x11update_visibility\x18\x0e\x20\x01(\x08R\x10updateVisibility\x12-\n\
    \x12change_description\x18\x0f\x20\x01(\tR\x11changeDescription\x12\x1d\
    \n\nupdate_url\x18\x10\x20\x01(\x08R\tupdateUrl\x12\x10\n\x03url\x18\x11\
    \x20\x01(\tR\x03url\x126\n\x17update_content_manifest\x18\x12\x20\x01(\
    \x08R\x15updateContentManifest\x12)\n\x10content_manifest\x18\x13\x20\
    \x01(\x06R\x0fcontentManifest\x12\x1a\n\x08metadata\x18\x14\x20\x01(\tR\
    \x08metadata\x12'\n\x0fupdate_metadata\x18\x15\x20\x01(\x08R\x0eupdateMe\
    tadata\x12\x1d\n\x08language\x18\x16\x20\x01(\x05:\x010R\x08language\x12\
    %\n\x0eremoved_kvtags\x18\x17\x20\x03(\tR\rremovedKvtags\x12E\n\x06kvtag\
    s\x18\x18\x20\x03(\x0b2-.CMsgClientUCMUpdatePublishedFile.KeyValueTagR\
    \x06kvtags\x12O\n\x08previews\x18\x19\x20\x03(\x0b23.CMsgClientUCMUpdate\
    PublishedFile.AdditionalPreviewR\x08previews\x12,\n\x12previews_to_remov\
    e\x18\x1a\x20\x03(\x05R\x10previewsToRemove\x12*\n\x11clear_in_progress\
    \x18\x1b\x20\x01(\x08R\x0fclearInProgress\x12*\n\x11remove_all_kvtags\
    \x18\x1c\x20\x01(\x08R\x0fremoveAllKvtags\x1a5\n\x0bKeyValueTag\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value\x1a\xd3\x01\n\x11AdditionalPreview\x12,\n\x12original_file_\
    name\x18\x01\x20\x01(\tR\x10originalFileName\x12,\n\x12internal_file_nam\
    e\x18\x02\x20\x01(\tR\x10internalFileName\x12\x18\n\x07videoid\x18\x03\
    \x20\x01(\tR\x07videoid\x12!\n\x0cpreview_type\x18\x04\x20\x01(\rR\x0bpr\
    eviewType\x12%\n\x0cupdate_index\x18\x05\x20\x01(\x05:\x02-1R\x0bupdateI\
    ndex\"\xa8\x01\n(CMsgClientUCMUpdatePublishedFileResponse\x12\x1b\n\x07e\
    result\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12_\n)needs_workshop_lega\
    l_agreement_acceptance\x18\x02\x20\x01(\x08:\x05falseR%needsWorkshopLega\
    lAgreementAcceptance\"e\n\x20CMsgClientUCMDeletePublishedFile\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06\
    app_id\x18\x02\x20\x01(\rR\x05appId\"G\n(CMsgClientUCMDeletePublishedFil\
    eResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\
    \x81\x01\n(CMsgClientUCMEnumerateUserPublishedFiles\x12\x15\n\x06app_id\
    \x18\x01\x20\x01(\rR\x05appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\
    \rR\nstartIndex\x12\x1d\n\nsort_order\x18\x03\x20\x01(\rR\tsortOrder\"\
    \x9f\x02\n0CMsgClientUCMEnumerateUserPublishedFilesResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12j\n\x0fpublished_f\
    iles\x18\x02\x20\x03(\x0b2A.CMsgClientUCMEnumerateUserPublishedFilesResp\
    onse.PublishedFileIdR\x0epublishedFiles\x12#\n\rtotal_results\x18\x03\
    \x20\x01(\rR\x0ctotalResults\x1a=\n\x0fPublishedFileId\x12*\n\x11publish\
    ed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\"\xce\x01\n)CMsgClie\
    ntUCMEnumerateUserSubscribedFiles\x12\x15\n\x06app_id\x18\x01\x20\x01(\r\
    R\x05appId\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\
    \x1e\n\tlist_type\x18\x03\x20\x01(\r:\x011R\x08listType\x12/\n\x12matchi\
    ng_file_type\x18\x04\x20\x01(\r:\x010R\x10matchingFileType\x12\x18\n\x05\
    count\x18\x05\x20\x01(\r:\x0250R\x05count\"\xd5\x02\n1CMsgClientUCMEnume\
    rateUserSubscribedFilesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12m\n\x10subscribed_files\x18\x02\x20\x03(\x0b2B\
    .CMsgClientUCMEnumerateUserSubscribedFilesResponse.PublishedFileIdR\x0fs\
    ubscribedFiles\x12#\n\rtotal_results\x18\x03\x20\x01(\rR\x0ctotalResults\
    \x1ao\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileId\x120\n\x12rtime32_subscribed\x18\x02\x20\x01(\
    \x07:\x010R\x11rtime32Subscribed\"\xbb\x01\n4CMsgClientUCMEnumerateUserS\
    ubscribedFilesWithUpdates\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x12\x1f\n\x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\x1d\n\ns\
    tart_time\x18\x03\x20\x01(\x07R\tstartTime\x12,\n\x10desired_revision\
    \x18\x04\x20\x01(\r:\x010R\x0fdesiredRevision\"\xa0\x04\n<CMsgClientUCME\
    numerateUserSubscribedFilesWithUpdatesResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\x05:\x012R\x07eresult\x12x\n\x10subscribed_files\x18\x02\
    \x20\x03(\x0b2M.CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResp\
    onse.PublishedFileIdR\x0fsubscribedFiles\x12#\n\rtotal_results\x18\x03\
    \x20\x01(\rR\x0ctotalResults\x1a\xa3\x02\n\x0fPublishedFileId\x12*\n\x11\
    published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x120\n\x12rti\
    me32_subscribed\x18\x02\x20\x01(\x07:\x010R\x11rtime32Subscribed\x12\x14\
    \n\x05appid\x18\x03\x20\x01(\rR\x05appid\x12#\n\rfile_hcontent\x18\x04\
    \x20\x01(\x06R\x0cfileHcontent\x12\x1b\n\tfile_size\x18\x05\x20\x01(\rR\
    \x08fileSize\x120\n\x14rtime32_last_updated\x18\x06\x20\x01(\x07R\x12rti\
    me32LastUpdated\x12(\n\x10is_depot_content\x18\x07\x20\x01(\x08R\x0eisDe\
    potContent\"\x88\x02\n!CMsgClientUCMPublishedFileUpdated\x12*\n\x11publi\
    shed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x15\n\x06app_i\
    d\x18\x02\x20\x01(\rR\x05appId\x12!\n\x0ctime_updated\x18\x03\x20\x01(\r\
    R\x0btimeUpdated\x12\x1a\n\x08hcontent\x18\x04\x20\x01(\x06R\x08hcontent\
    \x12\x1b\n\tfile_size\x18\x05\x20\x01(\x07R\x08fileSize\x12(\n\x10is_dep\
    ot_content\x18\x06\x20\x01(\x08R\x0eisDepotContent\x12\x1a\n\x08revision\
    \x18\x07\x20\x01(\rR\x08revision\"\x93\x01\n$CMsgClientWorkshopItemChang\
    esRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12*\n\x11las\
    t_time_updated\x18\x02\x20\x01(\rR\x0flastTimeUpdated\x12(\n\x10num_item\
    s_needed\x18\x03\x20\x01(\rR\x0enumItemsNeeded\"\xca\x02\n%CMsgClientWor\
    kshopItemChangesResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012\
    R\x07eresult\x12\x1f\n\x0bupdate_time\x18\x02\x20\x01(\rR\nupdateTime\
    \x12^\n\x0eworkshop_items\x18\x05\x20\x03(\x0b27.CMsgClientWorkshopItemC\
    hangesResponse.WorkshopItemInfoR\rworkshopItems\x1a\x82\x01\n\x10Worksho\
    pItemInfo\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublished\
    FileId\x12!\n\x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\x12\x1f\
    \n\x0bmanifest_id\x18\x03\x20\x01(\x06R\nmanifestId\"\x9d\x02\n!CMsgClie\
    ntWorkshopItemInfoRequest\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05app\
    Id\x12*\n\x11last_time_updated\x18\x02\x20\x01(\rR\x0flastTimeUpdated\
    \x12V\n\x0eworkshop_items\x18\x03\x20\x03(\x0b2/.CMsgClientWorkshopItemI\
    nfoRequest.WorkshopItemR\rworkshopItems\x1a]\n\x0cWorkshopItem\x12*\n\
    \x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\
    \x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\"\x86\x03\n\"CMsgCli\
    entWorkshopItemInfoResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\x12\x1f\n\x0bupdate_time\x18\x02\x20\x01(\rR\nupdateTi\
    me\x12[\n\x0eworkshop_items\x18\x03\x20\x03(\x0b24.CMsgClientWorkshopIte\
    mInfoResponse.WorkshopItemInfoR\rworkshopItems\x12#\n\rprivate_items\x18\
    \x04\x20\x03(\x06R\x0cprivateItems\x1a\x9f\x01\n\x10WorkshopItemInfo\x12\
    *\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12!\n\
    \x0ctime_updated\x18\x02\x20\x01(\rR\x0btimeUpdated\x12\x1f\n\x0bmanifes\
    t_id\x18\x03\x20\x01(\x06R\nmanifestId\x12\x1b\n\tis_legacy\x18\x04\x20\
    \x01(\x08R\x08isLegacy\"\xd3\x01\n%CMsgClientUCMGetPublishedFilesForUser\
    \x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12(\n\x10creator_stea\
    m_id\x18\x02\x20\x01(\x06R\x0ecreatorSteamId\x12#\n\rrequired_tags\x18\
    \x03\x20\x03(\tR\x0crequiredTags\x12#\n\rexcluded_tags\x18\x04\x20\x03(\
    \tR\x0cexcludedTags\x12\x1f\n\x0bstart_index\x18\x05\x20\x01(\rR\nstartI\
    ndex\"\x99\x02\n-CMsgClientUCMGetPublishedFilesForUserResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12g\n\x0fpublished_f\
    iles\x18\x02\x20\x03(\x0b2>.CMsgClientUCMGetPublishedFilesForUserRespons\
    e.PublishedFileIdR\x0epublishedFiles\x12#\n\rtotal_results\x18\x03\x20\
    \x01(\rR\x0ctotalResults\x1a=\n\x0fPublishedFileId\x12*\n\x11published_f\
    ile_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\"\x84\x01\n'CMsgClientUC\
    MSetUserPublishedFileAction\x12*\n\x11published_file_id\x18\x01\x20\x01(\
    \x06R\x0fpublishedFileId\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appI\
    d\x12\x16\n\x06action\x18\x03\x20\x01(\x05R\x06action\"N\n/CMsgClientUCM\
    SetUserPublishedFileActionResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\"\x82\x01\n0CMsgClientUCMEnumeratePublishedFilesB\
    yUserAction\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x1f\n\
    \x0bstart_index\x18\x02\x20\x01(\rR\nstartIndex\x12\x16\n\x06action\x18\
    \x03\x20\x01(\x05R\x06action\"\xdc\x02\n8CMsgClientUCMEnumeratePublished\
    FilesByUserActionResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x01\
    2R\x07eresult\x12r\n\x0fpublished_files\x18\x02\x20\x03(\x0b2I.CMsgClien\
    tUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileIdR\x0epubl\
    ishedFiles\x12#\n\rtotal_results\x18\x03\x20\x01(\rR\x0ctotalResults\x1a\
    j\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\
    \x0fpublishedFileId\x12+\n\x10rtime_time_stamp\x18\x02\x20\x01(\x07:\x01\
    0R\x0ertimeTimeStamp\"\x1e\n\x1cCMsgClientScreenshotsChanged\"\xa5\x01\n\
    \x1cCMsgClientUpdateUserGameInfo\x12!\n\x0csteamid_idgs\x18\x01\x20\x01(\
    \x06R\x0bsteamidIdgs\x12\x16\n\x06gameid\x18\x02\x20\x01(\x06R\x06gameid\
    \x12\x17\n\x07game_ip\x18\x03\x20\x01(\rR\x06gameIp\x12\x1b\n\tgame_port\
    \x18\x04\x20\x01(\rR\x08gamePort\x12\x14\n\x05token\x18\x05\x20\x01(\x0c\
    R\x05token\"u\n\x1cCMsgClientRichPresenceUpload\x12(\n\x10rich_presence_\
    kv\x18\x01\x20\x01(\x0cR\x0erichPresenceKv\x12+\n\x11steamid_broadcast\
    \x18\x02\x20\x03(\x06R\x10steamidBroadcast\"H\n\x1dCMsgClientRichPresenc\
    eRequest\x12'\n\x0fsteamid_request\x18\x01\x20\x03(\x06R\x0esteamidReque\
    st\"\xc8\x01\n\x1aCMsgClientRichPresenceInfo\x12M\n\rrich_presence\x18\
    \x01\x20\x03(\x0b2(.CMsgClientRichPresenceInfo.RichPresenceR\x0crichPres\
    ence\x1a[\n\x0cRichPresence\x12!\n\x0csteamid_user\x18\x01\x20\x01(\x06R\
    \x0bsteamidUser\x12(\n\x10rich_presence_kv\x18\x02\x20\x01(\x0cR\x0erich\
    PresenceKv\"5\n\x1cCMsgClientCheckFileSignature\x12\x15\n\x06app_id\x18\
    \x01\x20\x01(\rR\x05appId\"\xf6\x02\n$CMsgClientCheckFileSignatureRespon\
    se\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x10\n\x03pid\x18\
    \x02\x20\x01(\rR\x03pid\x12\x18\n\x07eresult\x18\x03\x20\x01(\rR\x07eres\
    ult\x12\x1a\n\x08filename\x18\x04\x20\x01(\tR\x08filename\x12*\n\x10esig\
    natureresult\x18\x05\x20\x01(\rR\x10esignatureresult\x12\x19\n\x08sha_fi\
    le\x18\x06\x20\x01(\x0cR\x07shaFile\x12(\n\x0fsignatureheader\x18\x07\
    \x20\x01(\x0cR\x0fsignatureheader\x12\x1a\n\x08filesize\x18\x08\x20\x01(\
    \rR\x08filesize\x12\"\n\x0cgetlasterror\x18\t\x20\x01(\rR\x0cgetlasterro\
    r\x12>\n\x1aevalvesignaturecheckdetail\x18\n\x20\x01(\rR\x1aevalvesignat\
    urecheckdetail\"m\n\x19CMsgClientReadMachineAuth\x12\x1a\n\x08filename\
    \x18\x01\x20\x01(\tR\x08filename\x12\x16\n\x06offset\x18\x02\x20\x01(\rR\
    \x06offset\x12\x1c\n\tcubtoread\x18\x03\x20\x01(\rR\tcubtoread\"\xae\x02\
    \n!CMsgClientReadMachineAuthResponse\x12\x1a\n\x08filename\x18\x01\x20\
    \x01(\tR\x08filename\x12\x18\n\x07eresult\x18\x02\x20\x01(\rR\x07eresult\
    \x12\x1a\n\x08filesize\x18\x03\x20\x01(\rR\x08filesize\x12\x19\n\x08sha_\
    file\x18\x04\x20\x01(\x0cR\x07shaFile\x12\"\n\x0cgetlasterror\x18\x05\
    \x20\x01(\rR\x0cgetlasterror\x12\x16\n\x06offset\x18\x06\x20\x01(\rR\x06\
    offset\x12\x18\n\x07cubread\x18\x07\x20\x01(\rR\x07cubread\x12\x1d\n\nby\
    tes_read\x18\x08\x20\x01(\x0cR\tbytesRead\x12'\n\x0ffilename_sentry\x18\
    \t\x20\x01(\tR\x0efilenameSentry\"\x99\x02\n\x1bCMsgClientUpdateMachineA\
    uth\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x16\n\x06o\
    ffset\x18\x02\x20\x01(\rR\x06offset\x12\x1e\n\ncubtowrite\x18\x03\x20\
    \x01(\rR\ncubtowrite\x12\x14\n\x05bytes\x18\x04\x20\x01(\x0cR\x05bytes\
    \x12\x19\n\x08otp_type\x18\x05\x20\x01(\rR\x07otpType\x12%\n\x0eotp_iden\
    tifier\x18\x06\x20\x01(\tR\rotpIdentifier\x12)\n\x10otp_sharedsecret\x18\
    \x07\x20\x01(\x0cR\x0fotpSharedsecret\x12#\n\rotp_timedrift\x18\x08\x20\
    \x01(\rR\x0cotpTimedrift\"\xc9\x02\n#CMsgClientUpdateMachineAuthResponse\
    \x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x18\n\x07eres\
    ult\x18\x02\x20\x01(\rR\x07eresult\x12\x1a\n\x08filesize\x18\x03\x20\x01\
    (\rR\x08filesize\x12\x19\n\x08sha_file\x18\x04\x20\x01(\x0cR\x07shaFile\
    \x12\"\n\x0cgetlasterror\x18\x05\x20\x01(\rR\x0cgetlasterror\x12\x16\n\
    \x06offset\x18\x06\x20\x01(\rR\x06offset\x12\x1a\n\x08cubwrote\x18\x07\
    \x20\x01(\rR\x08cubwrote\x12\x19\n\x08otp_type\x18\x08\x20\x01(\x05R\x07\
    otpType\x12\x1b\n\totp_value\x18\t\x20\x01(\rR\x08otpValue\x12%\n\x0eotp\
    _identifier\x18\n\x20\x01(\tR\rotpIdentifier\"\xc1\x03\n\x1cCMsgClientRe\
    questMachineAuth\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\
    \x12-\n\x12eresult_sentryfile\x18\x02\x20\x01(\rR\x11eresultSentryfile\
    \x12\x1a\n\x08filesize\x18\x03\x20\x01(\rR\x08filesize\x12%\n\x0esha_sen\
    tryfile\x18\x04\x20\x01(\x0cR\rshaSentryfile\x12.\n\x13lock_account_acti\
    on\x18\x06\x20\x01(\x05R\x11lockAccountAction\x12\x19\n\x08otp_type\x18\
    \x07\x20\x01(\rR\x07otpType\x12%\n\x0eotp_identifier\x18\x08\x20\x01(\tR\
    \rotpIdentifier\x12)\n\x10otp_sharedsecret\x18\t\x20\x01(\x0cR\x0fotpSha\
    redsecret\x12\x1b\n\totp_value\x18\n\x20\x01(\rR\x08otpValue\x12!\n\x0cm\
    achine_name\x18\x0b\x20\x01(\tR\x0bmachineName\x126\n\x17machine_name_us\
    erchosen\x18\x0c\x20\x01(\tR\x15machineNameUserchosen\"@\n$CMsgClientReq\
    uestMachineAuthResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eres\
    ult\")\n\x15CMsgClientRegisterKey\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\"\xa5\x01\n\x1aCMsgClientPurchaseResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x126\n\x17purchase_result_detail\
    s\x18\x02\x20\x01(\x05R\x15purchaseResultDetails\x122\n\x15purchase_rece\
    ipt_info\x18\x03\x20\x01(\x0cR\x13purchaseReceiptInfo\"\xb6\x02\n\x1cCMs\
    gClientActivateOEMLicense\x12+\n\x11bios_manufacturer\x18\x01\x20\x01(\t\
    R\x10biosManufacturer\x12+\n\x11bios_serialnumber\x18\x02\x20\x01(\tR\
    \x10biosSerialnumber\x12!\n\x0clicense_file\x18\x03\x20\x01(\x0cR\x0blic\
    enseFile\x125\n\x16mainboard_manufacturer\x18\x04\x20\x01(\tR\x15mainboa\
    rdManufacturer\x12+\n\x11mainboard_product\x18\x05\x20\x01(\tR\x10mainbo\
    ardProduct\x125\n\x16mainboard_serialnumber\x18\x06\x20\x01(\tR\x15mainb\
    oardSerialnumber\"J\n\x1cCMsgClientRegisterOEMMachine\x12*\n\x11oem_regi\
    ster_file\x18\x01\x20\x01(\x0cR\x0foemRegisterFile\"@\n$CMsgClientRegist\
    erOEMMachineResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\
    \"c\n\x1fCMsgClientPurchaseWithMachineID\x12\x1d\n\npackage_id\x18\x01\
    \x20\x01(\rR\tpackageId\x12!\n\x0cmachine_info\x18\x02\x20\x01(\x0cR\x0b\
    machineInfo\"\x90\x01\n\x20CMsgTrading_InitiateTradeRequest\x12(\n\x10tr\
    ade_request_id\x18\x01\x20\x01(\rR\x0etradeRequestId\x12#\n\rother_steam\
    id\x18\x02\x20\x01(\x04R\x0cotherSteamid\x12\x1d\n\nother_name\x18\x03\
    \x20\x01(\tR\totherName\"\xa3\x04\n!CMsgTrading_InitiateTradeResponse\
    \x12\x1a\n\x08response\x18\x01\x20\x01(\rR\x08response\x12(\n\x10trade_r\
    equest_id\x18\x02\x20\x01(\rR\x0etradeRequestId\x12#\n\rother_steamid\
    \x18\x03\x20\x01(\x04R\x0cotherSteamid\x128\n\x18steamguard_required_day\
    s\x18\x04\x20\x01(\rR\x16steamguardRequiredDays\x127\n\x18new_device_coo\
    ldown_days\x18\x05\x20\x01(\rR\x15newDeviceCooldownDays\x12P\n%default_p\
    assword_reset_probation_days\x18\x06\x20\x01(\rR!defaultPasswordResetPro\
    bationDays\x12A\n\x1dpassword_reset_probation_days\x18\x07\x20\x01(\rR\
    \x1apasswordResetProbationDays\x12L\n#default_email_change_probation_day\
    s\x18\x08\x20\x01(\rR\x1fdefaultEmailChangeProbationDays\x12=\n\x1bemail\
    _change_probation_days\x18\t\x20\x01(\rR\x18emailChangeProbationDays\"E\
    \n\x1eCMsgTrading_CancelTradeRequest\x12#\n\rother_steamid\x18\x01\x20\
    \x01(\x04R\x0cotherSteamid\"?\n\x18CMsgTrading_StartSession\x12#\n\rothe\
    r_steamid\x18\x01\x20\x01(\x04R\x0cotherSteamid\"j\n\x19CMsgClientGetCDN\
    AuthToken\x12\x19\n\x08depot_id\x18\x01\x20\x01(\rR\x07depotId\x12\x1b\n\
    \thost_name\x18\x02\x20\x01(\tR\x08hostName\x12\x15\n\x06app_id\x18\x03\
    \x20\x01(\rR\x05appId\"S\n\x1fCMsgClientGetDepotDecryptionKey\x12\x19\n\
    \x08depot_id\x18\x01\x20\x01(\rR\x07depotId\x12\x15\n\x06app_id\x18\x02\
    \x20\x01(\rR\x05appId\"\x93\x01\n'CMsgClientGetDepotDecryptionKeyRespons\
    e\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x19\n\
    \x08depot_id\x18\x02\x20\x01(\rR\x07depotId\x120\n\x14depot_encryption_k\
    ey\x18\x03\x20\x01(\x0cR\x12depotEncryptionKey\"[\n\x1eCMsgClientCheckAp\
    pBetaPassword\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\"\n\
    \x0cbetapassword\x18\x02\x20\x01(\tR\x0cbetapassword\"\xf1\x01\n&CMsgCli\
    entCheckAppBetaPasswordResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\
    \x05:\x012R\x07eresult\x12Z\n\rbetapasswords\x18\x04\x20\x03(\x0b24.CMsg\
    ClientCheckAppBetaPasswordResponse.BetaPasswordR\rbetapasswords\x1aN\n\
    \x0cBetaPassword\x12\x1a\n\x08betaname\x18\x01\x20\x01(\tR\x08betaname\
    \x12\"\n\x0cbetapassword\x18\x02\x20\x01(\tR\x0cbetapassword\"\x8b\x07\n\
    \x1cCMsgClientUpdateAppJobReport\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\
    \x05appId\x12\x1b\n\tdepot_ids\x18\x02\x20\x03(\rR\x08depotIds\x12\x1b\n\
    \tapp_state\x18\x03\x20\x01(\rR\x08appState\x12\"\n\rjob_app_error\x18\
    \x04\x20\x01(\rR\x0bjobAppError\x12#\n\rerror_details\x18\x05\x20\x01(\t\
    R\x0cerrorDetails\x12!\n\x0cjob_duration\x18\x06\x20\x01(\rR\x0bjobDurat\
    ion\x126\n\x17files_validation_failed\x18\x07\x20\x01(\rR\x15filesValida\
    tionFailed\x120\n\x14job_bytes_downloaded\x18\x08\x20\x01(\x04R\x12jobBy\
    tesDownloaded\x12(\n\x10job_bytes_staged\x18\t\x20\x01(\x04R\x0ejobBytes\
    Staged\x12%\n\x0ebytes_comitted\x18\n\x20\x01(\x04R\rbytesComitted\x12&\
    \n\x0fstart_app_state\x18\x0b\x20\x01(\rR\rstartAppState\x12(\n\x10stats\
    _machine_id\x18\x0c\x20\x01(\x06R\x0estatsMachineId\x12\x1f\n\x0bbranch_\
    name\x18\r\x20\x01(\tR\nbranchName\x124\n\x16total_bytes_downloaded\x18\
    \x0e\x20\x01(\x04R\x14totalBytesDownloaded\x12,\n\x12total_bytes_staged\
    \x18\x0f\x20\x01(\x04R\x10totalBytesStaged\x120\n\x14total_bytes_restore\
    d\x18\x10\x20\x01(\x04R\x12totalBytesRestored\x12\x1f\n\x0bis_borrowed\
    \x18\x11\x20\x01(\x08R\nisBorrowed\x12&\n\x0fis_free_weekend\x18\x12\x20\
    \x01(\x08R\risFreeWeekend\x12,\n\x12total_bytes_legacy\x18\x13\x20\x01(\
    \x04R\x10totalBytesLegacy\x12.\n\x13total_bytes_patched\x18\x14\x20\x01(\
    \x04R\x11totalBytesPatched\x12*\n\x11total_bytes_saved\x18\x15\x20\x01(\
    \x04R\x0ftotalBytesSaved\x12\x17\n\x07cell_id\x18\x16\x20\x01(\rR\x06cel\
    lId\"\xb4\x02\n\x1eCMsgClientDPContentStatsReport\x12(\n\x10stats_machin\
    e_id\x18\x01\x20\x01(\x06R\x0estatsMachineId\x12!\n\x0ccountry_code\x18\
    \x02\x20\x01(\tR\x0bcountryCode\x12\x17\n\x07os_type\x18\x03\x20\x01(\
    \x05R\x06osType\x12\x1a\n\x08language\x18\x04\x20\x01(\x05R\x08language\
    \x12.\n\x13num_install_folders\x18\x05\x20\x01(\rR\x11numInstallFolders\
    \x12.\n\x13num_installed_games\x18\x06\x20\x01(\rR\x11numInstalledGames\
    \x120\n\x14size_installed_games\x18\x07\x20\x01(\x04R\x12sizeInstalledGa\
    mes\"\x7f\n!CMsgClientGetCDNAuthTokenResponse\x12\x1b\n\x07eresult\x18\
    \x01\x20\x01(\r:\x012R\x07eresult\x12\x14\n\x05token\x18\x02\x20\x01(\tR\
    \x05token\x12'\n\x0fexpiration_time\x18\x03\x20\x01(\rR\x0eexpirationTim\
    e\"\xb0\x03\n\x1aCMsgDownloadRateStatistics\x12\x17\n\x07cell_id\x18\x01\
    \x20\x01(\rR\x06cellId\x12;\n\x05stats\x18\x02\x20\x03(\x0b2%.CMsgDownlo\
    adRateStatistics.StatsInfoR\x05stats\x12'\n\x0fthrottling_kbps\x18\x03\
    \x20\x01(\rR\x0ethrottlingKbps\x12\x1f\n\x0bsteam_realm\x18\x04\x20\x01(\
    \rR\nsteamRealm\x1a\xf1\x01\n\tStatsInfo\x12\x1f\n\x0bsource_type\x18\
    \x01\x20\x01(\rR\nsourceType\x12\x1b\n\tsource_id\x18\x02\x20\x01(\rR\
    \x08sourceId\x12\x18\n\x07seconds\x18\x03\x20\x01(\rR\x07seconds\x12\x14\
    \n\x05bytes\x18\x04\x20\x01(\x04R\x05bytes\x12\x1b\n\thost_name\x18\x05\
    \x20\x01(\tR\x08hostName\x12\"\n\x0cmicroseconds\x18\x06\x20\x01(\x04R\
    \x0cmicroseconds\x12\x1b\n\tused_ipv6\x18\x07\x20\x01(\x08R\x08usedIpv6\
    \x12\x18\n\x07proxied\x18\x08\x20\x01(\x08R\x07proxied\"`\n\x1cCMsgClien\
    tRequestAccountData\x12(\n\x10account_or_email\x18\x01\x20\x01(\tR\x0eac\
    countOrEmail\x12\x16\n\x06action\x18\x02\x20\x01(\rR\x06action\"\xc8\x02\
    \n$CMsgClientRequestAccountDataResponse\x12\x16\n\x06action\x18\x01\x20\
    \x01(\rR\x06action\x12\x18\n\x07eresult\x18\x02\x20\x01(\rR\x07eresult\
    \x12!\n\x0caccount_name\x18\x03\x20\x01(\tR\x0baccountName\x12\x1d\n\nct\
    _matches\x18\x04\x20\x01(\rR\tctMatches\x128\n\x18account_name_suggestio\
    n1\x18\x05\x20\x01(\tR\x16accountNameSuggestion1\x128\n\x18account_name_\
    suggestion2\x18\x06\x20\x01(\tR\x16accountNameSuggestion2\x128\n\x18acco\
    unt_name_suggestion3\x18\x07\x20\x01(\tR\x16accountNameSuggestion3\"\xe6\
    \x01\n\x1bCMsgClientUGSGetGlobalStats\x12\x16\n\x06gameid\x18\x01\x20\
    \x01(\x04R\x06gameid\x124\n\x16history_days_requested\x18\x02\x20\x01(\r\
    R\x14historyDaysRequested\x12.\n\x13time_last_requested\x18\x03\x20\x01(\
    \x07R\x11timeLastRequested\x12(\n\x10first_day_cached\x18\x04\x20\x01(\r\
    R\x0efirstDayCached\x12\x1f\n\x0bdays_cached\x18\x05\x20\x01(\rR\ndaysCa\
    ched\"\xd8\x02\n#CMsgClientUGSGetGlobalStatsResponse\x12\x1b\n\x07eresul\
    t\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x07R\ttimestamp\x12\x1f\n\x0bday_current\x18\x03\x20\x01(\x05R\
    \ndayCurrent\x12<\n\x04days\x18\x04\x20\x03(\x0b2(.CMsgClientUGSGetGloba\
    lStatsResponse.DayR\x04days\x1a\x96\x01\n\x03Day\x12\x15\n\x06day_id\x18\
    \x01\x20\x01(\rR\x05dayId\x12C\n\x05stats\x18\x02\x20\x03(\x0b2-.CMsgCli\
    entUGSGetGlobalStatsResponse.Day.StatR\x05stats\x1a3\n\x04Stat\x12\x17\n\
    \x07stat_id\x18\x01\x20\x01(\x05R\x06statId\x12\x12\n\x04data\x18\x02\
    \x20\x01(\x03R\x04data\"\xf6\x05\n\x12CMsgGameServerData\x12\x1e\n\x0bst\
    eam_id_gs\x18\x01\x20\x01(\x06R\tsteamIdGs\x12#\n\rdeprecated_ip\x18\x02\
    \x20\x01(\rR\x0cdeprecatedIp\x12\x1d\n\nquery_port\x18\x03\x20\x01(\rR\t\
    queryPort\x12\x1b\n\tgame_port\x18\x04\x20\x01(\rR\x08gamePort\x12#\n\rs\
    ourcetv_port\x18\x05\x20\x01(\rR\x0csourcetvPort\x12\x12\n\x04name\x18\
    \x16\x20\x01(\tR\x04name\x126\n\x0fgame_ip_address\x18\x17\x20\x01(\x0b2\
    \x0e.CMsgIPAddressR\rgameIpAddress\x12\x15\n\x06app_id\x18\x06\x20\x01(\
    \rR\x05appId\x12\x18\n\x07gamedir\x18\x07\x20\x01(\tR\x07gamedir\x12\x18\
    \n\x07version\x18\x08\x20\x01(\tR\x07version\x12\x18\n\x07product\x18\t\
    \x20\x01(\tR\x07product\x12\x16\n\x06region\x18\n\x20\x01(\tR\x06region\
    \x124\n\x07players\x18\x0b\x20\x03(\x0b2\x1a.CMsgGameServerData.PlayerR\
    \x07players\x12\x1f\n\x0bmax_players\x18\x0c\x20\x01(\rR\nmaxPlayers\x12\
    \x1b\n\tbot_count\x18\r\x20\x01(\rR\x08botCount\x12\x1a\n\x08password\
    \x18\x0e\x20\x01(\x08R\x08password\x12\x16\n\x06secure\x18\x0f\x20\x01(\
    \x08R\x06secure\x12\x1c\n\tdedicated\x18\x10\x20\x01(\x08R\tdedicated\
    \x12\x0e\n\x02os\x18\x11\x20\x01(\tR\x02os\x12\x1b\n\tgame_data\x18\x12\
    \x20\x01(\tR\x08gameData\x12*\n\x11game_data_version\x18\x13\x20\x01(\rR\
    \x0fgameDataVersion\x12\x1b\n\tgame_type\x18\x14\x20\x01(\tR\x08gameType\
    \x12\x10\n\x03map\x18\x15\x20\x01(\tR\x03map\x1a#\n\x06Player\x12\x19\n\
    \x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"\x95\x01\n\x14CMsgGameSer\
    verRemove\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12#\n\
    \rdeprecated_ip\x18\x02\x20\x01(\rR\x0cdeprecatedIp\x12\x1d\n\nquery_por\
    t\x18\x03\x20\x01(\rR\tqueryPort\x12\x1e\n\x02ip\x18\x04\x20\x01(\x0b2\
    \x0e.CMsgIPAddressR\x02ip\"\xbc\x01\n\x18CMsgClientGMSServerQuery\x12\
    \x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12&\n\x0fgeo_location_ip\
    \x18\x02\x20\x01(\rR\rgeoLocationIp\x12\x1f\n\x0bregion_code\x18\x03\x20\
    \x01(\rR\nregionCode\x12\x1f\n\x0bfilter_text\x18\x04\x20\x01(\tR\nfilte\
    rText\x12\x1f\n\x0bmax_servers\x18\x05\x20\x01(\rR\nmaxServers\"\xaa\x02\
    \n\x20CMsgGMSClientServerQueryResponse\x12B\n\x07servers\x18\x01\x20\x03\
    (\x0b2(.CMsgGMSClientServerQueryResponse.ServerR\x07servers\x12\x14\n\
    \x05error\x18\x02\x20\x01(\tR\x05error\x1a\xab\x01\n\x06Server\x120\n\
    \x14deprecated_server_ip\x18\x01\x20\x01(\rR\x12deprecatedServerIp\x12\
    \x1f\n\x0bserver_port\x18\x02\x20\x01(\rR\nserverPort\x12!\n\x0cauth_pla\
    yers\x18\x03\x20\x01(\rR\x0bauthPlayers\x12+\n\tserver_ip\x18\x04\x20\
    \x01(\x0b2\x0e.CMsgIPAddressR\x08serverIp\"k\n\x17CMsgGameServerOutOfDat\
    e\x12\x1e\n\x0bsteam_id_gs\x18\x01\x20\x01(\x06R\tsteamIdGs\x12\x16\n\
    \x06reject\x18\x02\x20\x01(\x08R\x06reject\x12\x18\n\x07message\x18\x03\
    \x20\x01(\tR\x07message\"?\n\x19CMsgClientRedeemGuestPass\x12\"\n\rguest\
    _pass_id\x18\x01\x20\x01(\x06R\x0bguestPassId\"\x85\x01\n!CMsgClientRede\
    emGuestPassResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07er\
    esult\x12\x1d\n\npackage_id\x18\x02\x20\x01(\rR\tpackageId\x12$\n\x0emus\
    t_own_appid\x18\x03\x20\x01(\rR\x0cmustOwnAppid\"F\n\x1fCMsgClientGetCla\
    nActivityCounts\x12#\n\rsteamid_clans\x18\x01\x20\x03(\x04R\x0csteamidCl\
    ans\"F\n'CMsgClientGetClanActivityCountsResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\r:\x012R\x07eresult\"\xaf\x01\n\x19CMsgClientOGSReport\
    String\x12\x20\n\x0baccumulated\x18\x01\x20\x01(\x08R\x0baccumulated\x12\
    \x1c\n\tsessionid\x18\x02\x20\x01(\x04R\tsessionid\x12\x1a\n\x08severity\
    \x18\x03\x20\x01(\x05R\x08severity\x12\x1c\n\tformatter\x18\x04\x20\x01(\
    \tR\tformatter\x12\x18\n\x07varargs\x18\x05\x20\x01(\x0cR\x07varargs\"p\
    \n\x16CMsgClientOGSReportBug\x12\x1c\n\tsessionid\x18\x01\x20\x01(\x04R\
    \tsessionid\x12\x18\n\x07bugtext\x18\x02\x20\x01(\tR\x07bugtext\x12\x1e\
    \n\nscreenshot\x18\x03\x20\x01(\x0cR\nscreenshot\"=\n\x17CMsgGSAssociate\
    WithClan\x12\"\n\rsteam_id_clan\x18\x01\x20\x01(\x06R\x0bsteamIdClan\"b\
    \n\x1fCMsgGSAssociateWithClanResponse\x12\"\n\rsteam_id_clan\x18\x01\x20\
    \x01(\x06R\x0bsteamIdClan\x12\x1b\n\x07eresult\x18\x02\x20\x01(\r:\x012R\
    \x07eresult\"S\n#CMsgGSComputeNewPlayerCompatibility\x12,\n\x12steam_id_\
    candidate\x18\x01\x20\x01(\x06R\x10steamIdCandidate\"\xb0\x02\n+CMsgGSCo\
    mputeNewPlayerCompatibilityResponse\x12,\n\x12steam_id_candidate\x18\x01\
    \x20\x01(\x06R\x10steamIdCandidate\x12\x1b\n\x07eresult\x18\x02\x20\x01(\
    \r:\x012R\x07eresult\x12$\n\x0eis_clan_member\x18\x03\x20\x01(\x08R\x0ci\
    sClanMember\x12'\n\x10ct_dont_like_you\x18\x04\x20\x01(\x05R\rctDontLike\
    You\x12'\n\x10ct_you_dont_like\x18\x05\x20\x01(\x05R\rctYouDontLike\x12>\
    \n\x1cct_clanmembers_dont_like_you\x18\x06\x20\x01(\x05R\x18ctClanmember\
    sDontLikeYou\"\x14\n\x12CMsgClientSentLogs\"\x9a\x01\n\x0cCMsgGCClient\
    \x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x18\n\x07msgtype\
    \x18\x02\x20\x01(\rR\x07msgtype\x12\x18\n\x07payload\x18\x03\x20\x01(\
    \x0cR\x07payload\x12\x18\n\x07steamid\x18\x04\x20\x01(\x06R\x07steamid\
    \x12\x16\n\x06gcname\x18\x05\x20\x01(\tR\x06gcname\x12\x0e\n\x02ip\x18\
    \x06\x20\x01(\rR\x02ip\"6\n\x1cCMsgClientRequestFreeLicense\x12\x16\n\
    \x06appids\x18\x02\x20\x03(\rR\x06appids\"\x99\x01\n$CMsgClientRequestFr\
    eeLicenseResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\r:\x012R\x07eres\
    ult\x12-\n\x12granted_packageids\x18\x02\x20\x03(\rR\x11grantedPackageid\
    s\x12%\n\x0egranted_appids\x18\x03\x20\x03(\rR\rgrantedAppids\"\xb8\x02\
    \n#CMsgDRMDownloadRequestWithCrashData\x12%\n\x0edownload_flags\x18\x01\
    \x20\x01(\rR\rdownloadFlags\x120\n\x14download_types_known\x18\x02\x20\
    \x01(\rR\x12downloadTypesKnown\x12\x19\n\x08guid_drm\x18\x03\x20\x01(\
    \x0cR\x07guidDrm\x12\x1d\n\nguid_split\x18\x04\x20\x01(\x0cR\tguidSplit\
    \x12\x1d\n\nguid_merge\x18\x05\x20\x01(\x0cR\tguidMerge\x12\x1f\n\x0bmod\
    ule_name\x18\x06\x20\x01(\tR\nmoduleName\x12\x1f\n\x0bmodule_path\x18\
    \x07\x20\x01(\tR\nmodulePath\x12\x1d\n\ncrash_data\x18\x08\x20\x01(\x0cR\
    \tcrashData\"\xcd\x02\n\x17CMsgDRMDownloadResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\r:\x012R\x07eresult\x12\x15\n\x06app_id\x18\x02\x20\
    \x01(\rR\x05appId\x12,\n\x12blob_download_type\x18\x03\x20\x01(\rR\x10bl\
    obDownloadType\x12\x1d\n\nmerge_guid\x18\x04\x20\x01(\x0cR\tmergeGuid\
    \x12/\n\x14download_file_dfs_ip\x18\x05\x20\x01(\rR\x11downloadFileDfsIp\
    \x123\n\x16download_file_dfs_port\x18\x06\x20\x01(\rR\x13downloadFileDfs\
    Port\x12*\n\x11download_file_url\x18\x07\x20\x01(\tR\x0fdownloadFileUrl\
    \x12\x1f\n\x0bmodule_path\x18\x08\x20\x01(\tR\nmodulePath\"\xca\x02\n\
    \x12CMsgDRMFinalResult\x12\x1b\n\x07eResult\x18\x01\x20\x01(\r:\x012R\
    \x07eResult\x12\x15\n\x06app_id\x18\x02\x20\x01(\rR\x05appId\x12,\n\x12b\
    lob_download_type\x18\x03\x20\x01(\rR\x10blobDownloadType\x12!\n\x0cerro\
    r_detail\x18\x04\x20\x01(\rR\x0berrorDetail\x12\x1d\n\nmerge_guid\x18\
    \x05\x20\x01(\x0cR\tmergeGuid\x12/\n\x14download_file_dfs_ip\x18\x06\x20\
    \x01(\rR\x11downloadFileDfsIp\x123\n\x16download_file_dfs_port\x18\x07\
    \x20\x01(\rR\x13downloadFileDfsPort\x12*\n\x11download_file_url\x18\x08\
    \x20\x01(\tR\x0fdownloadFileUrl\"=\n\x1eCMsgClientDPCheckSpecialSurvey\
    \x12\x1b\n\tsurvey_id\x18\x01\x20\x01(\rR\x08surveyId\"\xcf\x01\n&CMsgCl\
    ientDPCheckSpecialSurveyResponse\x12\x1b\n\x07eResult\x18\x01\x20\x01(\r\
    :\x012R\x07eResult\x12\x14\n\x05state\x18\x02\x20\x01(\rR\x05state\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1d\n\ncustom_url\x18\x04\
    \x20\x01(\tR\tcustomUrl\x12)\n\x10include_software\x18\x05\x20\x01(\x08R\
    \x0fincludeSoftware\x12\x14\n\x05token\x18\x06\x20\x01(\x0cR\x05token\"X\
    \n%CMsgClientDPSendSpecialSurveyResponse\x12\x1b\n\tsurvey_id\x18\x01\
    \x20\x01(\rR\x08surveyId\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \"_\n*CMsgClientDPSendSpecialSurveyResponseReply\x12\x1b\n\x07eResult\
    \x18\x01\x20\x01(\r:\x012R\x07eResult\x12\x14\n\x05token\x18\x02\x20\x01\
    (\x0cR\x05token\"s\n'CMsgClientRequestForgottenPasswordEmail\x12!\n\x0ca\
    ccount_name\x18\x01\x20\x01(\tR\x0baccountName\x12%\n\x0epassword_tried\
    \x18\x02\x20\x01(\tR\rpasswordTried\"{\n/CMsgClientRequestForgottenPassw\
    ordEmailResponse\x12\x18\n\x07eResult\x18\x01\x20\x01(\rR\x07eResult\x12\
    .\n\x13use_secret_question\x18\x02\x20\x01(\x08R\x11useSecretQuestion\"\
    \xd2\x02\n\x1bCMsgClientItemAnnouncements\x12&\n\x0fcount_new_items\x18\
    \x01\x20\x01(\rR\rcountNewItems\x12J\n\x0cunseen_items\x18\x02\x20\x03(\
    \x0b2'.CMsgClientItemAnnouncements.UnseenItemR\x0bunseenItems\x1a\xbe\
    \x01\n\nUnseenItem\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x1d\n\ncontext_id\x18\x02\x20\x01(\x04R\tcontextId\x12\x19\n\x08asset_i\
    d\x18\x03\x20\x01(\x04R\x07assetId\x12\x16\n\x06amount\x18\x04\x20\x01(\
    \x04R\x06amount\x12%\n\x0ertime32_gained\x18\x05\x20\x01(\x07R\rrtime32G\
    ained\x12!\n\x0csource_appid\x18\x06\x20\x01(\rR\x0bsourceAppid\"$\n\"CM\
    sgClientRequestItemAnnouncements\"\xca\x01\n\x1bCMsgClientUserNotificati\
    ons\x12O\n\rnotifications\x18\x01\x20\x03(\x0b2).CMsgClientUserNotificat\
    ions.NotificationR\rnotifications\x1aZ\n\x0cNotification\x124\n\x16user_\
    notification_type\x18\x01\x20\x01(\rR\x14userNotificationType\x12\x14\n\
    \x05count\x18\x02\x20\x01(\rR\x05count\"\xd0\x01\n\x1eCMsgClientCommentN\
    otifications\x12,\n\x12count_new_comments\x18\x01\x20\x01(\rR\x10countNe\
    wComments\x127\n\x18count_new_comments_owner\x18\x02\x20\x01(\rR\x15coun\
    tNewCommentsOwner\x12G\n\x20count_new_comments_subscriptions\x18\x03\x20\
    \x01(\rR\x1dcountNewCommentsSubscriptions\"'\n%CMsgClientRequestCommentN\
    otifications\"\x94\x01\n$CMsgClientOfflineMessageNotification\x12)\n\x10\
    offline_messages\x18\x01\x20\x01(\rR\x0fofflineMessages\x12A\n\x1dfriend\
    s_with_offline_messages\x18\x02\x20\x03(\rR\x1afriendsWithOfflineMessage\
    s\"&\n$CMsgClientRequestOfflineMessageCount\"A\n%CMsgClientChatGetFriend\
    MessageHistory\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"\
    \xbc\x02\n-CMsgClientChatGetFriendMessageHistoryResponse\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x18\n\x07success\x18\x02\x20\
    \x01(\rR\x07success\x12X\n\x08messages\x18\x03\x20\x03(\x0b2<.CMsgClient\
    ChatGetFriendMessageHistoryResponse.FriendMessageR\x08messages\x1a}\n\rF\
    riendMessage\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x1c\
    \n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x18\n\x07message\x18\
    \x03\x20\x01(\tR\x07message\x12\x16\n\x06unread\x18\x04\x20\x01(\x08R\
    \x06unread\"9\n7CMsgClientChatGetFriendMessageHistoryForOfflineMessages\
    \"C\n!CMsgClientFSGetFriendsSteamLevels\x12\x1e\n\naccountids\x18\x01\
    \x20\x03(\rR\naccountids\"\xb6\x01\n)CMsgClientFSGetFriendsSteamLevelsRe\
    sponse\x12K\n\x07friends\x18\x01\x20\x03(\x0b21.CMsgClientFSGetFriendsSt\
    eamLevelsResponse.FriendR\x07friends\x1a<\n\x06Friend\x12\x1c\n\taccount\
    id\x18\x01\x20\x01(\rR\taccountid\x12\x14\n\x05level\x18\x02\x20\x01(\rR\
    \x05level\"\xfd\x02\n\x17CMsgClientEmailAddrInfo\x12#\n\remail_address\
    \x18\x01\x20\x01(\tR\x0cemailAddress\x12,\n\x12email_is_validated\x18\
    \x02\x20\x01(\x08R\x10emailIsValidated\x128\n\x18email_validation_change\
    d\x18\x03\x20\x01(\x08R\x16emailValidationChanged\x12E\n\x1fcredential_c\
    hange_requires_code\x18\x04\x20\x01(\x08R\x1ccredentialChangeRequiresCod\
    e\x12W\n)password_or_secretqa_change_requires_code\x18\x05\x20\x01(\x08R\
    $passwordOrSecretqaChangeRequiresCode\x125\n\x17remind_user_about_email\
    \x18\x06\x20\x01(\x08R\x14remindUserAboutEmail\"\xae\x01\n\x16CMsgCREIte\
    mVoteSummary\x12U\n\x12published_file_ids\x18\x01\x20\x03(\x0b2'.CMsgCRE\
    ItemVoteSummary.PublishedFileIdR\x10publishedFileIds\x1a=\n\x0fPublished\
    FileId\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFil\
    eId\"\xd0\x02\n\x1eCMsgCREItemVoteSummaryResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\x12_\n\x13item_vote_summaries\
    \x18\x02\x20\x03(\x0b2/.CMsgCREItemVoteSummaryResponse.ItemVoteSummaryR\
    \x11itemVoteSummaries\x1a\xaf\x01\n\x0fItemVoteSummary\x12*\n\x11publish\
    ed_file_id\x18\x01\x20\x01(\x06R\x0fpublishedFileId\x12\x1b\n\tvotes_for\
    \x18\x02\x20\x01(\x05R\x08votesFor\x12#\n\rvotes_against\x18\x03\x20\x01\
    (\x05R\x0cvotesAgainst\x12\x18\n\x07reports\x18\x04\x20\x01(\x05R\x07rep\
    orts\x12\x14\n\x05score\x18\x05\x20\x01(\x02R\x05score\"i\n\"CMsgCREUpda\
    teUserPublishedItemVote\x12*\n\x11published_file_id\x18\x01\x20\x01(\x06\
    R\x0fpublishedFileId\x12\x17\n\x07vote_up\x18\x02\x20\x01(\x08R\x06voteU\
    p\"I\n*CMsgCREUpdateUserPublishedItemVoteResponse\x12\x1b\n\x07eresult\
    \x18\x01\x20\x01(\x05:\x012R\x07eresult\"\xce\x01\n&CMsgCREGetUserPublis\
    hedItemVoteDetails\x12e\n\x12published_file_ids\x18\x01\x20\x03(\x0b27.C\
    MsgCREGetUserPublishedItemVoteDetails.PublishedFileIdR\x10publishedFileI\
    ds\x1a=\n\x0fPublishedFileId\x12*\n\x11published_file_id\x18\x01\x20\x01\
    (\x06R\x0fpublishedFileId\"\x9f\x02\n.CMsgCREGetUserPublishedItemVoteDet\
    ailsResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\
    \x12w\n\x16user_item_vote_details\x18\x02\x20\x03(\x0b2B.CMsgCREGetUserP\
    ublishedItemVoteDetailsResponse.UserItemVoteDetailR\x13userItemVoteDetai\
    ls\x1aW\n\x12UserItemVoteDetail\x12*\n\x11published_file_id\x18\x01\x20\
    \x01(\x06R\x0fpublishedFileId\x12\x15\n\x04vote\x18\x02\x20\x01(\x05:\
    \x010R\x04vote\"\xf3\x01\n\x18CMsgGameServerPingSample\x12\x13\n\x05my_i\
    p\x18\x01\x20\x01(\x07R\x04myIp\x12\x1a\n\tgs_app_id\x18\x02\x20\x01(\
    \x05R\x07gsAppId\x12?\n\ngs_samples\x18\x03\x20\x03(\x0b2\x20.CMsgGameSe\
    rverPingSample.SampleR\tgsSamples\x1ae\n\x06Sample\x12\x0e\n\x02ip\x18\
    \x01\x20\x01(\x07R\x02ip\x12\x1e\n\x0bavg_ping_ms\x18\x02\x20\x01(\rR\ta\
    vgPingMs\x12+\n\x12stddev_ping_ms_x10\x18\x03\x20\x01(\rR\x0fstddevPingM\
    sX10\"3\n\x16CMsgFSGetFollowerCount\x12\x19\n\x08steam_id\x18\x01\x20\
    \x01(\x06R\x07steamId\"V\n\x1eCMsgFSGetFollowerCountResponse\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12\x17\n\x05count\
    \x18\x02\x20\x01(\x05:\x010R\x05count\"1\n\x14CMsgFSGetIsFollowing\x12\
    \x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"e\n\x1cCMsgFSGetIsF\
    ollowingResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07ere\
    sult\x12(\n\x0cis_following\x18\x02\x20\x01(\x08:\x05falseR\x0bisFollowi\
    ng\"?\n\x1cCMsgFSEnumerateFollowingList\x12\x1f\n\x0bstart_index\x18\x01\
    \x20\x01(\rR\nstartIndex\"\x85\x01\n$CMsgFSEnumerateFollowingListRespons\
    e\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12#\n\rto\
    tal_results\x18\x02\x20\x01(\x05R\x0ctotalResults\x12\x1b\n\tsteam_ids\
    \x18\x03\x20\x03(\x06R\x08steamIds\"7\n\x1fCMsgDPGetNumberOfCurrentPlaye\
    rs\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"i\n'CMsgDPGetNumberO\
    fCurrentPlayersResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12!\n\x0cplayer_count\x18\x02\x20\x01(\x05R\x0bplayerCount\
    \"\x83\x01\n#CMsgClientFriendUserStatusPublished\x12%\n\x0efriend_steami\
    d\x18\x01\x20\x01(\x06R\rfriendSteamid\x12\x14\n\x05appid\x18\x02\x20\
    \x01(\rR\x05appid\x12\x1f\n\x0bstatus_text\x18\x03\x20\x01(\tR\nstatusTe\
    xt\"\x96\x01\n\x1dCMsgClientServiceMethodLegacy\x12\x1f\n\x0bmethod_name\
    \x18\x01\x20\x01(\tR\nmethodName\x12+\n\x11serialized_method\x18\x02\x20\
    \x01(\x0cR\x10serializedMethod\x12'\n\x0fis_notification\x18\x03\x20\x01\
    (\x08R\x0eisNotification\"\x86\x01\n%CMsgClientServiceMethodLegacyRespon\
    se\x12\x1f\n\x0bmethod_name\x18\x01\x20\x01(\tR\nmethodName\x12<\n\x1ase\
    rialized_method_response\x18\x02\x20\x01(\x0cR\x18serializedMethodRespon\
    se\"G\n\x10CMsgClientUIMode\x12\x16\n\x06uimode\x18\x01\x20\x01(\rR\x06u\
    imode\x12\x1b\n\tchat_mode\x18\x02\x20\x01(\rR\x08chatMode\"G\n&CMsgClie\
    ntVanityURLChangedNotification\x12\x1d\n\nvanity_url\x18\x01\x20\x01(\tR\
    \tvanityUrl\"\xae\x01\n%CMsgClientAuthorizeLocalDeviceRequest\x12-\n\x12\
    device_description\x18\x01\x20\x01(\tR\x11deviceDescription\x12(\n\x10ow\
    ner_account_id\x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\n\x12local_dev\
    ice_token\x18\x03\x20\x01(\x04R\x10localDeviceToken\"\x97\x01\n\x1eCMsgC\
    lientAuthorizeLocalDevice\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x01\
    2R\x07eresult\x12(\n\x10owner_account_id\x18\x02\x20\x01(\rR\x0eownerAcc\
    ountId\x12.\n\x13authed_device_token\x18\x03\x20\x01(\x04R\x11authedDevi\
    ceToken\"\xa1\x01\n*CMsgClientAuthorizeLocalDeviceNotification\x12\x1b\n\
    \x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12(\n\x10owner_accou\
    nt_id\x18\x02\x20\x01(\rR\x0eownerAccountId\x12,\n\x12local_device_token\
    \x18\x03\x20\x01(\x04R\x10localDeviceToken\"\xa4\x01\n\"CMsgClientDeauth\
    orizeDeviceRequest\x12<\n\x1adeauthorization_account_id\x18\x01\x20\x01(\
    \rR\x18deauthorizationAccountId\x12@\n\x1cdeauthorization_device_token\
    \x18\x02\x20\x01(\x04R\x1adeauthorizationDeviceToken\"x\n\x1bCMsgClientD\
    eauthorizeDevice\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07ere\
    sult\x12<\n\x1adeauthorization_account_id\x18\x02\x20\x01(\rR\x18deautho\
    rizationAccountId\"\x90\x02\n&CMsgClientUseLocalDeviceAuthorizations\x12\
    8\n\x18authorization_account_id\x18\x01\x20\x03(\rR\x16authorizationAcco\
    untId\x12X\n\rdevice_tokens\x18\x02\x20\x03(\x0b23.CMsgClientUseLocalDev\
    iceAuthorizations.DeviceTokenR\x0cdeviceTokens\x1aR\n\x0bDeviceToken\x12\
    (\n\x10owner_account_id\x18\x01\x20\x01(\rR\x0eownerAccountId\x12\x19\n\
    \x08token_id\x18\x02\x20\x01(\x04R\x07tokenId\"\x20\n\x1eCMsgClientGetAu\
    thorizedDevices\"\x97\x03\n&CMsgClientGetAuthorizedDevicesResponse\x12\
    \x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12e\n\x11autho\
    rized_device\x18\x02\x20\x03(\x0b28.CMsgClientGetAuthorizedDevicesRespon\
    se.AuthorizedDeviceR\x10authorizedDevice\x1a\xe8\x01\n\x10AuthorizedDevi\
    ce\x12*\n\x11auth_device_token\x18\x01\x20\x01(\x04R\x0fauthDeviceToken\
    \x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\tR\ndeviceName\x12(\n\x10last\
    _access_time\x18\x03\x20\x01(\rR\x0elastAccessTime\x12\x1f\n\x0bborrower\
    _id\x18\x04\x20\x01(\rR\nborrowerId\x12\x1d\n\nis_pending\x18\x05\x20\
    \x01(\x08R\tisPending\x12\x1d\n\napp_played\x18\x06\x20\x01(\rR\tappPlay\
    ed\"\xf8\x01\n!CMsgClientSharedLibraryLockStatus\x12W\n\x0elocked_librar\
    y\x18\x01\x20\x03(\x0b20.CMsgClientSharedLibraryLockStatus.LockedLibrary\
    R\rlockedLibrary\x121\n\x15own_library_locked_by\x18\x02\x20\x01(\rR\x12\
    ownLibraryLockedBy\x1aG\n\rLockedLibrary\x12\x19\n\x08owner_id\x18\x01\
    \x20\x01(\rR\x07ownerId\x12\x1b\n\tlocked_by\x18\x02\x20\x01(\rR\x08lock\
    edBy\"\xce\x01\n\"CMsgClientSharedLibraryStopPlaying\x12!\n\x0cseconds_l\
    eft\x18\x01\x20\x01(\x05R\x0bsecondsLeft\x12H\n\tstop_apps\x18\x02\x20\
    \x03(\x0b2+.CMsgClientSharedLibraryStopPlaying.StopAppR\x08stopApps\x1a;\
    \n\x07StopApp\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12\x19\n\
    \x08owner_id\x18\x02\x20\x01(\rR\x07ownerId\"\xf1\x02\n\x15CMsgClientSer\
    viceCall\x12#\n\rsysid_routing\x18\x01\x20\x01(\x0cR\x0csysidRouting\x12\
    \x1f\n\x0bcall_handle\x18\x02\x20\x01(\rR\ncallHandle\x12\x1d\n\nmodule_\
    crc\x18\x03\x20\x01(\rR\tmoduleCrc\x12\x1f\n\x0bmodule_hash\x18\x04\x20\
    \x01(\x0cR\nmoduleHash\x12\x1f\n\x0bfunction_id\x18\x05\x20\x01(\rR\nfun\
    ctionId\x12$\n\x0ecub_output_max\x18\x06\x20\x01(\rR\x0ccubOutputMax\x12\
    \x14\n\x05flags\x18\x07\x20\x01(\rR\x05flags\x12$\n\rcallparameter\x18\
    \x08\x20\x01(\x0cR\rcallparameter\x12\x1b\n\tping_only\x18\t\x20\x01(\
    \x08R\x08pingOnly\x122\n\x15max_outstanding_calls\x18\n\x20\x01(\rR\x13m\
    axOutstandingCalls\"\x80\x01\n\x17CMsgClientServiceModule\x12\x1d\n\nmod\
    ule_crc\x18\x01\x20\x01(\rR\tmoduleCrc\x12\x1f\n\x0bmodule_hash\x18\x02\
    \x20\x01(\x0cR\nmoduleHash\x12%\n\x0emodule_content\x18\x03\x20\x01(\x0c\
    R\rmoduleContent\"\x8a\x07\n\x1dCMsgClientServiceCallResponse\x12#\n\rsy\
    sid_routing\x18\x01\x20\x01(\x0cR\x0csysidRouting\x12\x1f\n\x0bcall_hand\
    le\x18\x02\x20\x01(\rR\ncallHandle\x12\x1d\n\nmodule_crc\x18\x03\x20\x01\
    (\rR\tmoduleCrc\x12\x1f\n\x0bmodule_hash\x18\x04\x20\x01(\x0cR\nmoduleHa\
    sh\x12\x20\n\x0becallresult\x18\x05\x20\x01(\rR\x0becallresult\x12%\n\
    \x0eresult_content\x18\x06\x20\x01(\x0cR\rresultContent\x12&\n\x0fos_ver\
    sion_info\x18\x07\x20\x01(\x0cR\rosVersionInfo\x12\x1f\n\x0bsystem_info\
    \x18\x08\x20\x01(\x0cR\nsystemInfo\x12!\n\x0cload_address\x18\t\x20\x01(\
    \x06R\x0bloadAddress\x12)\n\x10exception_record\x18\n\x20\x01(\x0cR\x0fe\
    xceptionRecord\x127\n\x18portable_os_version_info\x18\x0b\x20\x01(\x0cR\
    \x15portableOsVersionInfo\x120\n\x14portable_system_info\x18\x0c\x20\x01\
    (\x0cR\x12portableSystemInfo\x12#\n\rwas_converted\x18\r\x20\x01(\x08R\
    \x0cwasConverted\x12'\n\x0finternal_result\x18\x0e\x20\x01(\rR\x0eintern\
    alResult\x12#\n\rcurrent_count\x18\x0f\x20\x01(\rR\x0ccurrentCount\x12(\
    \n\x10last_call_handle\x18\x10\x20\x01(\rR\x0elastCallHandle\x12/\n\x14l\
    ast_call_module_crc\x18\x11\x20\x01(\rR\x11lastCallModuleCrc\x125\n\x17l\
    ast_call_sysid_routing\x18\x12\x20\x01(\x0cR\x14lastCallSysidRouting\x12\
    )\n\x10last_ecallresult\x18\x13\x20\x01(\rR\x0flastEcallresult\x120\n\
    \x14last_callissue_delta\x18\x14\x20\x01(\rR\x12lastCallissueDelta\x126\
    \n\x17last_callcomplete_delta\x18\x15\x20\x01(\rR\x15lastCallcompleteDel\
    ta\"\x17\n\x15CMsgAMUnlockStreaming\"c\n\x1dCMsgAMUnlockStreamingRespons\
    e\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\x07eresult\x12%\n\x0e\
    encryption_key\x18\x02\x20\x01(\x0cR\rencryptionKey\"\x12\n\x10CMsgAMUnl\
    ockHEVC\"7\n\x18CMsgAMUnlockHEVCResponse\x12\x1b\n\x07eresult\x18\x01\
    \x20\x01(\x05:\x012R\x07eresult\"i\n\x1dCMsgClientPlayingSessionState\
    \x12'\n\x0fplaying_blocked\x18\x02\x20\x01(\x08R\x0eplayingBlocked\x12\
    \x1f\n\x0bplaying_app\x18\x03\x20\x01(\rR\nplayingApp\"D\n\x1cCMsgClient\
    KickPlayingSession\x12$\n\x0eonly_stop_game\x18\x01\x20\x01(\x08R\x0conl\
    yStopGame\"\xa8\x01\n\x1fCMsgClientVoiceCallPreAuthorize\x12%\n\x0ecalle\
    r_steamid\x18\x01\x20\x01(\x06R\rcallerSteamid\x12)\n\x10receiver_steami\
    d\x18\x02\x20\x01(\x06R\x0freceiverSteamid\x12\x1b\n\tcaller_id\x18\x03\
    \x20\x01(\x05R\x08callerId\x12\x16\n\x06hangup\x18\x04\x20\x01(\x08R\x06\
    hangup\"\xb5\x01\n'CMsgClientVoiceCallPreAuthorizeResponse\x12%\n\x0ecal\
    ler_steamid\x18\x01\x20\x01(\x06R\rcallerSteamid\x12)\n\x10receiver_stea\
    mid\x18\x02\x20\x01(\x06R\x0freceiverSteamid\x12\x1b\n\x07eresult\x18\
    \x03\x20\x01(\x05:\x012R\x07eresult\x12\x1b\n\tcaller_id\x18\x04\x20\x01\
    (\x05R\x08callerId\"U\n\x1cCMsgBadgeCraftedNotification\x12\x14\n\x05app\
    id\x18\x01\x20\x01(\rR\x05appid\x12\x1f\n\x0bbadge_level\x18\x02\x20\x01\
    (\rR\nbadgeLevelB\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
