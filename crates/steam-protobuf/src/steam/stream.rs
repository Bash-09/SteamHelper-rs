// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc 3.10.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `stream.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
pub struct CDiscoveryPingRequest {
    // message fields
    sequence: ::std::option::Option<u32>,
    packet_size_requested: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingRequest {
    fn default() -> &'a CDiscoveryPingRequest {
        <CDiscoveryPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CDiscoveryPingRequest {
    pub fn new() -> CDiscoveryPingRequest {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;

    pub fn get_sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_requested = 2;

    pub fn get_packet_size_requested(&self) -> u32 {
        self.packet_size_requested.unwrap_or(0)
    }

    pub fn clear_packet_size_requested(&mut self) {
        self.packet_size_requested = ::std::option::Option::None;
    }

    pub fn has_packet_size_requested(&self) -> bool {
        self.packet_size_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_requested(&mut self, v: u32) {
        self.packet_size_requested = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDiscoveryPingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.packet_size_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packet_size_requested {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_requested {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDiscoveryPingRequest {
        CDiscoveryPingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "sequence",
                |m: &CDiscoveryPingRequest| { &m.sequence },
                |m: &mut CDiscoveryPingRequest| { &mut m.sequence },
                CDiscoveryPingRequest::get_sequence,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "packet_size_requested",
                |m: &CDiscoveryPingRequest| { &m.packet_size_requested },
                |m: &mut CDiscoveryPingRequest| { &mut m.packet_size_requested },
                CDiscoveryPingRequest::get_packet_size_requested,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CDiscoveryPingRequest>(
                "CDiscoveryPingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDiscoveryPingRequest {
        static instance: ::protobuf::rt::Lazy<CDiscoveryPingRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CDiscoveryPingRequest::new)
    }
}

impl ::protobuf::Clear for CDiscoveryPingRequest {
    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_requested = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDiscoveryPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDiscoveryPingRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CDiscoveryPingResponse {
    // message fields
    sequence: ::std::option::Option<u32>,
    packet_size_received: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingResponse {
    fn default() -> &'a CDiscoveryPingResponse {
        <CDiscoveryPingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CDiscoveryPingResponse {
    pub fn new() -> CDiscoveryPingResponse {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;

    pub fn get_sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_received = 2;

    pub fn get_packet_size_received(&self) -> u32 {
        self.packet_size_received.unwrap_or(0)
    }

    pub fn clear_packet_size_received(&mut self) {
        self.packet_size_received = ::std::option::Option::None;
    }

    pub fn has_packet_size_received(&self) -> bool {
        self.packet_size_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_received(&mut self, v: u32) {
        self.packet_size_received = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDiscoveryPingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.packet_size_received = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.packet_size_received {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_received {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDiscoveryPingResponse {
        CDiscoveryPingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "sequence",
                |m: &CDiscoveryPingResponse| { &m.sequence },
                |m: &mut CDiscoveryPingResponse| { &mut m.sequence },
                CDiscoveryPingResponse::get_sequence,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "packet_size_received",
                |m: &CDiscoveryPingResponse| { &m.packet_size_received },
                |m: &mut CDiscoveryPingResponse| { &mut m.packet_size_received },
                CDiscoveryPingResponse::get_packet_size_received,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CDiscoveryPingResponse>(
                "CDiscoveryPingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDiscoveryPingResponse {
        static instance: ::protobuf::rt::Lazy<CDiscoveryPingResponse> = ::protobuf::rt::Lazy::INIT;
        instance.get(CDiscoveryPingResponse::new)
    }
}

impl ::protobuf::Clear for CDiscoveryPingResponse {
    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_received = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDiscoveryPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDiscoveryPingResponse {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientHandshakeInfo {
    // message fields
    network_test: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingClientHandshakeInfo {
    fn default() -> &'a CStreamingClientHandshakeInfo {
        <CStreamingClientHandshakeInfo as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientHandshakeInfo {
    pub fn new() -> CStreamingClientHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 network_test = 2;

    pub fn get_network_test(&self) -> i32 {
        self.network_test.unwrap_or(0)
    }

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: i32) {
        self.network_test = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientHandshakeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.network_test = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.network_test {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.network_test {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingClientHandshakeInfo {
        CStreamingClientHandshakeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "network_test",
                |m: &CStreamingClientHandshakeInfo| { &m.network_test },
                |m: &mut CStreamingClientHandshakeInfo| { &mut m.network_test },
                CStreamingClientHandshakeInfo::get_network_test,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamingClientHandshakeInfo>(
                "CStreamingClientHandshakeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingClientHandshakeInfo {
        static instance: ::protobuf::rt::Lazy<CStreamingClientHandshakeInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamingClientHandshakeInfo::new)
    }
}

impl ::protobuf::Clear for CStreamingClientHandshakeInfo {
    fn clear(&mut self) {
        self.network_test = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientHandshakeInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CClientHandshakeMsg {
    // message fields
    pub info: ::protobuf::SingularPtrField<CStreamingClientHandshakeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClientHandshakeMsg {
    fn default() -> &'a CClientHandshakeMsg {
        <CClientHandshakeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CClientHandshakeMsg {
    pub fn new() -> CClientHandshakeMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CClientHandshakeMsg {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CStreamingClientHandshakeInfo, _>(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClientHandshakeMsg {
        CClientHandshakeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CStreamingClientHandshakeInfo>, _>(
                "info",
                |m: &CClientHandshakeMsg| { &m.info },
                |m: &mut CClientHandshakeMsg| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CClientHandshakeMsg>(
                "CClientHandshakeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CClientHandshakeMsg {
        static instance: ::protobuf::rt::Lazy<CClientHandshakeMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CClientHandshakeMsg::new)
    }
}

impl ::protobuf::Clear for CClientHandshakeMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClientHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientHandshakeMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingServerHandshakeInfo {
    // message fields
    mtu: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingServerHandshakeInfo {
    fn default() -> &'a CStreamingServerHandshakeInfo {
        <CStreamingServerHandshakeInfo as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingServerHandshakeInfo {
    pub fn new() -> CStreamingServerHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 mtu = 1;

    pub fn get_mtu(&self) -> i32 {
        self.mtu.unwrap_or(0)
    }

    pub fn clear_mtu(&mut self) {
        self.mtu = ::std::option::Option::None;
    }

    pub fn has_mtu(&self) -> bool {
        self.mtu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtu(&mut self, v: i32) {
        self.mtu = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingServerHandshakeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mtu = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mtu {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mtu {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingServerHandshakeInfo {
        CStreamingServerHandshakeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "mtu",
                |m: &CStreamingServerHandshakeInfo| { &m.mtu },
                |m: &mut CStreamingServerHandshakeInfo| { &mut m.mtu },
                CStreamingServerHandshakeInfo::get_mtu,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamingServerHandshakeInfo>(
                "CStreamingServerHandshakeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingServerHandshakeInfo {
        static instance: ::protobuf::rt::Lazy<CStreamingServerHandshakeInfo> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamingServerHandshakeInfo::new)
    }
}

impl ::protobuf::Clear for CStreamingServerHandshakeInfo {
    fn clear(&mut self) {
        self.mtu = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingServerHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingServerHandshakeInfo {
}

#[derive(PartialEq,Clone,Default)]
pub struct CServerHandshakeMsg {
    // message fields
    pub info: ::protobuf::SingularPtrField<CStreamingServerHandshakeInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CServerHandshakeMsg {
    fn default() -> &'a CServerHandshakeMsg {
        <CServerHandshakeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CServerHandshakeMsg {
    pub fn new() -> CServerHandshakeMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CServerHandshakeMsg {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CStreamingServerHandshakeInfo, _>(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CServerHandshakeMsg {
        CServerHandshakeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CStreamingServerHandshakeInfo>, _>(
                "info",
                |m: &CServerHandshakeMsg| { &m.info },
                |m: &mut CServerHandshakeMsg| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CServerHandshakeMsg>(
                "CServerHandshakeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CServerHandshakeMsg {
        static instance: ::protobuf::rt::Lazy<CServerHandshakeMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CServerHandshakeMsg::new)
    }
}

impl ::protobuf::Clear for CServerHandshakeMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CServerHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CServerHandshakeMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CAuthenticationRequestMsg {
    // message fields
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamVersion>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAuthenticationRequestMsg {
    fn default() -> &'a CAuthenticationRequestMsg {
        <CAuthenticationRequestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CAuthenticationRequestMsg {
    pub fn new() -> CAuthenticationRequestMsg {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .EStreamVersion version = 2;

    pub fn get_version(&self) -> EStreamVersion {
        match self.version {
            Some(e) => e.enum_value_or(EStreamVersion::k_EStreamVersionNone),
            None => EStreamVersion::k_EStreamVersionNone,
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CAuthenticationRequestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.version = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAuthenticationRequestMsg {
        CAuthenticationRequestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "token",
                |m: &CAuthenticationRequestMsg| { &m.token },
                |m: &mut CAuthenticationRequestMsg| { &mut m.token },
                CAuthenticationRequestMsg::get_token,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamVersion>(
                "version",
                |m: &CAuthenticationRequestMsg| { &m.version },
                |m: &mut CAuthenticationRequestMsg| { &mut m.version },
                EStreamVersion::k_EStreamVersionNone,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CAuthenticationRequestMsg>(
                "CAuthenticationRequestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAuthenticationRequestMsg {
        static instance: ::protobuf::rt::Lazy<CAuthenticationRequestMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CAuthenticationRequestMsg::new)
    }
}

impl ::protobuf::Clear for CAuthenticationRequestMsg {
    fn clear(&mut self) {
        self.token.clear();
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAuthenticationRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationRequestMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CAuthenticationResponseMsg {
    // message fields
    result: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<cauthentication_response_msg::AuthenticationResult>>,
    version: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamVersion>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAuthenticationResponseMsg {
    fn default() -> &'a CAuthenticationResponseMsg {
        <CAuthenticationResponseMsg as ::protobuf::Message>::default_instance()
    }
}

impl CAuthenticationResponseMsg {
    pub fn new() -> CAuthenticationResponseMsg {
        ::std::default::Default::default()
    }

    // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1;

    pub fn get_result(&self) -> cauthentication_response_msg::AuthenticationResult {
        match self.result {
            Some(e) => e.enum_value_or(cauthentication_response_msg::AuthenticationResult::SUCCEEDED),
            None => cauthentication_response_msg::AuthenticationResult::SUCCEEDED,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cauthentication_response_msg::AuthenticationResult) {
        self.result = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .EStreamVersion version = 2;

    pub fn get_version(&self) -> EStreamVersion {
        match self.version {
            Some(e) => e.enum_value_or(EStreamVersion::k_EStreamVersionNone),
            None => EStreamVersion::k_EStreamVersionNone,
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CAuthenticationResponseMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.version = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAuthenticationResponseMsg {
        CAuthenticationResponseMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, cauthentication_response_msg::AuthenticationResult>(
                "result",
                |m: &CAuthenticationResponseMsg| { &m.result },
                |m: &mut CAuthenticationResponseMsg| { &mut m.result },
                cauthentication_response_msg::AuthenticationResult::SUCCEEDED,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamVersion>(
                "version",
                |m: &CAuthenticationResponseMsg| { &m.version },
                |m: &mut CAuthenticationResponseMsg| { &mut m.version },
                EStreamVersion::k_EStreamVersionNone,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CAuthenticationResponseMsg>(
                "CAuthenticationResponseMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAuthenticationResponseMsg {
        static instance: ::protobuf::rt::Lazy<CAuthenticationResponseMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CAuthenticationResponseMsg::new)
    }
}

impl ::protobuf::Clear for CAuthenticationResponseMsg {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAuthenticationResponseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAuthenticationResponseMsg {
}

/// Nested message and enums of message `CAuthenticationResponseMsg`
pub mod cauthentication_response_msg {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum AuthenticationResult {
        SUCCEEDED = 0,
        FAILED = 1,
    }

    impl ::protobuf::ProtobufEnum for AuthenticationResult {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AuthenticationResult> {
            match value {
                0 => ::std::option::Option::Some(AuthenticationResult::SUCCEEDED),
                1 => ::std::option::Option::Some(AuthenticationResult::FAILED),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [AuthenticationResult] = &[
                AuthenticationResult::SUCCEEDED,
                AuthenticationResult::FAILED,
            ];
            values
        }

        fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new::<AuthenticationResult>("CAuthenticationResponseMsg.AuthenticationResult", super::file_descriptor_proto())
            })
        }
    }

    impl ::std::default::Default for AuthenticationResult {
        fn default() -> Self {
            AuthenticationResult::SUCCEEDED
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AuthenticationResult {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CKeepAliveMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CKeepAliveMsg {
    fn default() -> &'a CKeepAliveMsg {
        <CKeepAliveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CKeepAliveMsg {
    pub fn new() -> CKeepAliveMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CKeepAliveMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CKeepAliveMsg {
        CKeepAliveMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CKeepAliveMsg>(
                "CKeepAliveMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CKeepAliveMsg {
        static instance: ::protobuf::rt::Lazy<CKeepAliveMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CKeepAliveMsg::new)
    }
}

impl ::protobuf::Clear for CKeepAliveMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CKeepAliveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CKeepAliveMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartNetworkTestMsg {
    // message fields
    frames: ::std::option::Option<u32>,
    framerate: ::std::option::Option<u32>,
    bitrate_kbps: ::std::option::Option<u32>,
    burst_bitrate_kbps: ::std::option::Option<u32>,
    bandwidth_test: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStartNetworkTestMsg {
    fn default() -> &'a CStartNetworkTestMsg {
        <CStartNetworkTestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartNetworkTestMsg {
    pub fn new() -> CStartNetworkTestMsg {
        ::std::default::Default::default()
    }

    // optional uint32 frames = 1;

    pub fn get_frames(&self) -> u32 {
        self.frames.unwrap_or(0)
    }

    pub fn clear_frames(&mut self) {
        self.frames = ::std::option::Option::None;
    }

    pub fn has_frames(&self) -> bool {
        self.frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frames(&mut self, v: u32) {
        self.frames = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate = 2;

    pub fn get_framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 bitrate_kbps = 3;

    pub fn get_bitrate_kbps(&self) -> u32 {
        self.bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_bitrate_kbps(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_bitrate_kbps(&self) -> bool {
        self.bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate_kbps(&mut self, v: u32) {
        self.bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 burst_bitrate_kbps = 4;

    pub fn get_burst_bitrate_kbps(&self) -> u32 {
        self.burst_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_burst_bitrate_kbps(&mut self) {
        self.burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_burst_bitrate_kbps(&self) -> bool {
        self.burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burst_bitrate_kbps(&mut self, v: u32) {
        self.burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool bandwidth_test = 5;

    pub fn get_bandwidth_test(&self) -> bool {
        self.bandwidth_test.unwrap_or(false)
    }

    pub fn clear_bandwidth_test(&mut self) {
        self.bandwidth_test = ::std::option::Option::None;
    }

    pub fn has_bandwidth_test(&self) -> bool {
        self.bandwidth_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth_test(&mut self, v: bool) {
        self.bandwidth_test = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartNetworkTestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frames = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bitrate_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.burst_bitrate_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bandwidth_test = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frames {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bitrate_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.burst_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bandwidth_test {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frames {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bitrate_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.burst_bitrate_kbps {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bandwidth_test {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStartNetworkTestMsg {
        CStartNetworkTestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "frames",
                |m: &CStartNetworkTestMsg| { &m.frames },
                |m: &mut CStartNetworkTestMsg| { &mut m.frames },
                CStartNetworkTestMsg::get_frames,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "framerate",
                |m: &CStartNetworkTestMsg| { &m.framerate },
                |m: &mut CStartNetworkTestMsg| { &mut m.framerate },
                CStartNetworkTestMsg::get_framerate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "bitrate_kbps",
                |m: &CStartNetworkTestMsg| { &m.bitrate_kbps },
                |m: &mut CStartNetworkTestMsg| { &mut m.bitrate_kbps },
                CStartNetworkTestMsg::get_bitrate_kbps,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "burst_bitrate_kbps",
                |m: &CStartNetworkTestMsg| { &m.burst_bitrate_kbps },
                |m: &mut CStartNetworkTestMsg| { &mut m.burst_bitrate_kbps },
                CStartNetworkTestMsg::get_burst_bitrate_kbps,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "bandwidth_test",
                |m: &CStartNetworkTestMsg| { &m.bandwidth_test },
                |m: &mut CStartNetworkTestMsg| { &mut m.bandwidth_test },
                CStartNetworkTestMsg::get_bandwidth_test,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStartNetworkTestMsg>(
                "CStartNetworkTestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStartNetworkTestMsg {
        static instance: ::protobuf::rt::Lazy<CStartNetworkTestMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStartNetworkTestMsg::new)
    }
}

impl ::protobuf::Clear for CStartNetworkTestMsg {
    fn clear(&mut self) {
        self.frames = ::std::option::Option::None;
        self.framerate = ::std::option::Option::None;
        self.bitrate_kbps = ::std::option::Option::None;
        self.burst_bitrate_kbps = ::std::option::Option::None;
        self.bandwidth_test = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartNetworkTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartNetworkTestMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamVideoMode {
    // message fields
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    refresh_rate: ::std::option::Option<u32>,
    refresh_rate_numerator: ::std::option::Option<u32>,
    refresh_rate_denominator: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamVideoMode {
    fn default() -> &'a CStreamVideoMode {
        <CStreamVideoMode as ::protobuf::Message>::default_instance()
    }
}

impl CStreamVideoMode {
    pub fn new() -> CStreamVideoMode {
        ::std::default::Default::default()
    }

    // required uint32 width = 1;

    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required uint32 height = 2;

    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate = 3;

    pub fn get_refresh_rate(&self) -> u32 {
        self.refresh_rate.unwrap_or(0)
    }

    pub fn clear_refresh_rate(&mut self) {
        self.refresh_rate = ::std::option::Option::None;
    }

    pub fn has_refresh_rate(&self) -> bool {
        self.refresh_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate(&mut self, v: u32) {
        self.refresh_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_numerator = 4;

    pub fn get_refresh_rate_numerator(&self) -> u32 {
        self.refresh_rate_numerator.unwrap_or(0)
    }

    pub fn clear_refresh_rate_numerator(&mut self) {
        self.refresh_rate_numerator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_numerator(&self) -> bool {
        self.refresh_rate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_numerator(&mut self, v: u32) {
        self.refresh_rate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_denominator = 5;

    pub fn get_refresh_rate_denominator(&self) -> u32 {
        self.refresh_rate_denominator.unwrap_or(0)
    }

    pub fn clear_refresh_rate_denominator(&mut self) {
        self.refresh_rate_denominator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_denominator(&self) -> bool {
        self.refresh_rate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_denominator(&mut self, v: u32) {
        self.refresh_rate_denominator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamVideoMode {
    fn is_initialized(&self) -> bool {
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.refresh_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.refresh_rate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.refresh_rate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refresh_rate {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refresh_rate_numerator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.refresh_rate_denominator {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.refresh_rate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.refresh_rate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.refresh_rate_denominator {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamVideoMode {
        CStreamVideoMode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "width",
                |m: &CStreamVideoMode| { &m.width },
                |m: &mut CStreamVideoMode| { &mut m.width },
                CStreamVideoMode::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "height",
                |m: &CStreamVideoMode| { &m.height },
                |m: &mut CStreamVideoMode| { &mut m.height },
                CStreamVideoMode::get_height,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "refresh_rate",
                |m: &CStreamVideoMode| { &m.refresh_rate },
                |m: &mut CStreamVideoMode| { &mut m.refresh_rate },
                CStreamVideoMode::get_refresh_rate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "refresh_rate_numerator",
                |m: &CStreamVideoMode| { &m.refresh_rate_numerator },
                |m: &mut CStreamVideoMode| { &mut m.refresh_rate_numerator },
                CStreamVideoMode::get_refresh_rate_numerator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "refresh_rate_denominator",
                |m: &CStreamVideoMode| { &m.refresh_rate_denominator },
                |m: &mut CStreamVideoMode| { &mut m.refresh_rate_denominator },
                CStreamVideoMode::get_refresh_rate_denominator,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamVideoMode>(
                "CStreamVideoMode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamVideoMode {
        static instance: ::protobuf::rt::Lazy<CStreamVideoMode> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamVideoMode::new)
    }
}

impl ::protobuf::Clear for CStreamVideoMode {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.refresh_rate = ::std::option::Option::None;
        self.refresh_rate_numerator = ::std::option::Option::None;
        self.refresh_rate_denominator = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamVideoMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamVideoMode {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientCaps {
    // message fields
    system_info: ::protobuf::SingularField<::std::string::String>,
    system_can_suspend: ::std::option::Option<bool>,
    maximum_decode_bitrate_kbps: ::std::option::Option<i32>,
    maximum_burst_bitrate_kbps: ::std::option::Option<i32>,
    supports_video_hevc: ::std::option::Option<bool>,
    disable_steam_store: ::std::option::Option<bool>,
    disable_client_cursor: ::std::option::Option<bool>,
    disable_intel_hardware_encoding: ::std::option::Option<bool>,
    disable_amd_hardware_encoding: ::std::option::Option<bool>,
    disable_nvidia_hardware_encoding: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingClientCaps {
    fn default() -> &'a CStreamingClientCaps {
        <CStreamingClientCaps as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientCaps {
    pub fn new() -> CStreamingClientCaps {
        ::std::default::Default::default()
    }

    // optional string system_info = 1;

    pub fn get_system_info(&self) -> &str {
        match self.system_info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_system_info(&mut self) {
        self.system_info.clear();
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::string::String) {
        self.system_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::string::String {
        if self.system_info.is_none() {
            self.system_info.set_default();
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::string::String {
        self.system_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool system_can_suspend = 2;

    pub fn get_system_can_suspend(&self) -> bool {
        self.system_can_suspend.unwrap_or(false)
    }

    pub fn clear_system_can_suspend(&mut self) {
        self.system_can_suspend = ::std::option::Option::None;
    }

    pub fn has_system_can_suspend(&self) -> bool {
        self.system_can_suspend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_can_suspend(&mut self, v: bool) {
        self.system_can_suspend = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_decode_bitrate_kbps = 3;

    pub fn get_maximum_decode_bitrate_kbps(&self) -> i32 {
        self.maximum_decode_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_maximum_decode_bitrate_kbps(&mut self) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_decode_bitrate_kbps(&self) -> bool {
        self.maximum_decode_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_decode_bitrate_kbps(&mut self, v: i32) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_burst_bitrate_kbps = 4;

    pub fn get_maximum_burst_bitrate_kbps(&self) -> i32 {
        self.maximum_burst_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_maximum_burst_bitrate_kbps(&mut self) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_burst_bitrate_kbps(&self) -> bool {
        self.maximum_burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_burst_bitrate_kbps(&mut self, v: i32) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool supports_video_hevc = 5;

    pub fn get_supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.unwrap_or(false)
    }

    pub fn clear_supports_video_hevc(&mut self) {
        self.supports_video_hevc = ::std::option::Option::None;
    }

    pub fn has_supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_video_hevc(&mut self, v: bool) {
        self.supports_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool disable_steam_store = 6;

    pub fn get_disable_steam_store(&self) -> bool {
        self.disable_steam_store.unwrap_or(false)
    }

    pub fn clear_disable_steam_store(&mut self) {
        self.disable_steam_store = ::std::option::Option::None;
    }

    pub fn has_disable_steam_store(&self) -> bool {
        self.disable_steam_store.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_steam_store(&mut self, v: bool) {
        self.disable_steam_store = ::std::option::Option::Some(v);
    }

    // optional bool disable_client_cursor = 7;

    pub fn get_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.unwrap_or(false)
    }

    pub fn clear_disable_client_cursor(&mut self) {
        self.disable_client_cursor = ::std::option::Option::None;
    }

    pub fn has_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_client_cursor(&mut self, v: bool) {
        self.disable_client_cursor = ::std::option::Option::Some(v);
    }

    // optional bool disable_intel_hardware_encoding = 8;

    pub fn get_disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_intel_hardware_encoding(&mut self) {
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_intel_hardware_encoding(&mut self, v: bool) {
        self.disable_intel_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_amd_hardware_encoding = 9;

    pub fn get_disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_amd_hardware_encoding(&mut self) {
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_amd_hardware_encoding(&mut self, v: bool) {
        self.disable_amd_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_nvidia_hardware_encoding = 10;

    pub fn get_disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_nvidia_hardware_encoding(&mut self) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_nvidia_hardware_encoding(&mut self, v: bool) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientCaps {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.system_info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.system_can_suspend = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.supports_video_hevc = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.disable_steam_store = ::std::option::Option::Some(is.read_bool()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.disable_client_cursor = ::std::option::Option::Some(is.read_bool()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.disable_intel_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.disable_amd_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.system_info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.system_can_suspend {
            my_size += 2;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.supports_video_hevc {
            my_size += 2;
        }
        if let Some(v) = self.disable_steam_store {
            my_size += 2;
        }
        if let Some(v) = self.disable_client_cursor {
            my_size += 2;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            my_size += 2;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            my_size += 2;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.system_info.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.system_can_suspend {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.supports_video_hevc {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.disable_steam_store {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.disable_client_cursor {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingClientCaps {
        CStreamingClientCaps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "system_info",
                |m: &CStreamingClientCaps| { &m.system_info },
                |m: &mut CStreamingClientCaps| { &mut m.system_info },
                CStreamingClientCaps::get_system_info,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "system_can_suspend",
                |m: &CStreamingClientCaps| { &m.system_can_suspend },
                |m: &mut CStreamingClientCaps| { &mut m.system_can_suspend },
                CStreamingClientCaps::get_system_can_suspend,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "maximum_decode_bitrate_kbps",
                |m: &CStreamingClientCaps| { &m.maximum_decode_bitrate_kbps },
                |m: &mut CStreamingClientCaps| { &mut m.maximum_decode_bitrate_kbps },
                CStreamingClientCaps::get_maximum_decode_bitrate_kbps,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "maximum_burst_bitrate_kbps",
                |m: &CStreamingClientCaps| { &m.maximum_burst_bitrate_kbps },
                |m: &mut CStreamingClientCaps| { &mut m.maximum_burst_bitrate_kbps },
                CStreamingClientCaps::get_maximum_burst_bitrate_kbps,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "supports_video_hevc",
                |m: &CStreamingClientCaps| { &m.supports_video_hevc },
                |m: &mut CStreamingClientCaps| { &mut m.supports_video_hevc },
                CStreamingClientCaps::get_supports_video_hevc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "disable_steam_store",
                |m: &CStreamingClientCaps| { &m.disable_steam_store },
                |m: &mut CStreamingClientCaps| { &mut m.disable_steam_store },
                CStreamingClientCaps::get_disable_steam_store,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "disable_client_cursor",
                |m: &CStreamingClientCaps| { &m.disable_client_cursor },
                |m: &mut CStreamingClientCaps| { &mut m.disable_client_cursor },
                CStreamingClientCaps::get_disable_client_cursor,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "disable_intel_hardware_encoding",
                |m: &CStreamingClientCaps| { &m.disable_intel_hardware_encoding },
                |m: &mut CStreamingClientCaps| { &mut m.disable_intel_hardware_encoding },
                CStreamingClientCaps::get_disable_intel_hardware_encoding,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "disable_amd_hardware_encoding",
                |m: &CStreamingClientCaps| { &m.disable_amd_hardware_encoding },
                |m: &mut CStreamingClientCaps| { &mut m.disable_amd_hardware_encoding },
                CStreamingClientCaps::get_disable_amd_hardware_encoding,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "disable_nvidia_hardware_encoding",
                |m: &CStreamingClientCaps| { &m.disable_nvidia_hardware_encoding },
                |m: &mut CStreamingClientCaps| { &mut m.disable_nvidia_hardware_encoding },
                CStreamingClientCaps::get_disable_nvidia_hardware_encoding,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamingClientCaps>(
                "CStreamingClientCaps",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingClientCaps {
        static instance: ::protobuf::rt::Lazy<CStreamingClientCaps> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamingClientCaps::new)
    }
}

impl ::protobuf::Clear for CStreamingClientCaps {
    fn clear(&mut self) {
        self.system_info.clear();
        self.system_can_suspend = ::std::option::Option::None;
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
        self.supports_video_hevc = ::std::option::Option::None;
        self.disable_steam_store = ::std::option::Option::None;
        self.disable_client_cursor = ::std::option::Option::None;
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientCaps {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingClientConfig {
    // message fields
    quality: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamQualityPreference>>,
    maximum_resolution_x: ::std::option::Option<u32>,
    maximum_resolution_y: ::std::option::Option<u32>,
    maximum_framerate_numerator: ::std::option::Option<u32>,
    maximum_framerate_denominator: ::std::option::Option<u32>,
    maximum_bitrate_kbps: ::std::option::Option<i32>,
    enable_hardware_decoding: ::std::option::Option<bool>,
    enable_performance_overlay: ::std::option::Option<bool>,
    enable_video_streaming: ::std::option::Option<bool>,
    enable_audio_streaming: ::std::option::Option<bool>,
    enable_input_streaming: ::std::option::Option<bool>,
    audio_channels: ::std::option::Option<i32>,
    enable_video_hevc: ::std::option::Option<bool>,
    enable_performance_icons: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingClientConfig {
    fn default() -> &'a CStreamingClientConfig {
        <CStreamingClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingClientConfig {
    pub fn new() -> CStreamingClientConfig {
        ::std::default::Default::default()
    }

    // optional .EStreamQualityPreference quality = 1;

    pub fn get_quality(&self) -> EStreamQualityPreference {
        match self.quality {
            Some(e) => e.enum_value_or(EStreamQualityPreference::k_EStreamQualityBalanced),
            None => EStreamQualityPreference::k_EStreamQualityBalanced,
        }
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: EStreamQualityPreference) {
        self.quality = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional uint32 maximum_resolution_x = 2;

    pub fn get_maximum_resolution_x(&self) -> u32 {
        self.maximum_resolution_x.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: u32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_resolution_y = 3;

    pub fn get_maximum_resolution_y(&self) -> u32 {
        self.maximum_resolution_y.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: u32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_framerate_numerator = 4;

    pub fn get_maximum_framerate_numerator(&self) -> u32 {
        self.maximum_framerate_numerator.unwrap_or(0)
    }

    pub fn clear_maximum_framerate_numerator(&mut self) {
        self.maximum_framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_numerator(&self) -> bool {
        self.maximum_framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_numerator(&mut self, v: u32) {
        self.maximum_framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 maximum_framerate_denominator = 5;

    pub fn get_maximum_framerate_denominator(&self) -> u32 {
        self.maximum_framerate_denominator.unwrap_or(0)
    }

    pub fn clear_maximum_framerate_denominator(&mut self) {
        self.maximum_framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_maximum_framerate_denominator(&self) -> bool {
        self.maximum_framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_framerate_denominator(&mut self, v: u32) {
        self.maximum_framerate_denominator = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_bitrate_kbps = 6;

    pub fn get_maximum_bitrate_kbps(&self) -> i32 {
        self.maximum_bitrate_kbps.unwrap_or(-1i32)
    }

    pub fn clear_maximum_bitrate_kbps(&mut self) {
        self.maximum_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_bitrate_kbps(&self) -> bool {
        self.maximum_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_bitrate_kbps(&mut self, v: i32) {
        self.maximum_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_decoding = 7;

    pub fn get_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.unwrap_or(true)
    }

    pub fn clear_enable_hardware_decoding(&mut self) {
        self.enable_hardware_decoding = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_decoding(&mut self, v: bool) {
        self.enable_hardware_decoding = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_overlay = 8;

    pub fn get_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.unwrap_or(false)
    }

    pub fn clear_enable_performance_overlay(&mut self) {
        self.enable_performance_overlay = ::std::option::Option::None;
    }

    pub fn has_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_overlay(&mut self, v: bool) {
        self.enable_performance_overlay = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_streaming = 9;

    pub fn get_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;

    pub fn get_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;

    pub fn get_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channels = 12;

    pub fn get_audio_channels(&self) -> i32 {
        self.audio_channels.unwrap_or(2i32)
    }

    pub fn clear_audio_channels(&mut self) {
        self.audio_channels = ::std::option::Option::None;
    }

    pub fn has_audio_channels(&self) -> bool {
        self.audio_channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channels(&mut self, v: i32) {
        self.audio_channels = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_hevc = 13;

    pub fn get_enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.unwrap_or(false)
    }

    pub fn clear_enable_video_hevc(&mut self) {
        self.enable_video_hevc = ::std::option::Option::None;
    }

    pub fn has_enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_hevc(&mut self, v: bool) {
        self.enable_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_icons = 14;

    pub fn get_enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.unwrap_or(true)
    }

    pub fn clear_enable_performance_icons(&mut self) {
        self.enable_performance_icons = ::std::option::Option::None;
    }

    pub fn has_enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_icons(&mut self, v: bool) {
        self.enable_performance_icons = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingClientConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.quality = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_resolution_x = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_resolution_y = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_framerate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_framerate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.maximum_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_hardware_decoding = ::std::option::Option::Some(is.read_bool()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_performance_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_video_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_audio_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_input_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.audio_channels = ::std::option::Option::Some(is.read_int32()?);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_video_hevc = ::std::option::Option::Some(is.read_bool()?);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_performance_icons = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_framerate_numerator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_framerate_denominator {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum_bitrate_kbps {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_hardware_decoding {
            my_size += 2;
        }
        if let Some(v) = self.enable_performance_overlay {
            my_size += 2;
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 2;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 2;
        }
        if let Some(v) = self.audio_channels {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_video_hevc {
            my_size += 2;
        }
        if let Some(v) = self.enable_performance_icons {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quality {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.maximum_framerate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.maximum_framerate_denominator {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.maximum_bitrate_kbps {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.enable_hardware_decoding {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.enable_performance_overlay {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.audio_channels {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.enable_video_hevc {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.enable_performance_icons {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingClientConfig {
        CStreamingClientConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamQualityPreference>(
                "quality",
                |m: &CStreamingClientConfig| { &m.quality },
                |m: &mut CStreamingClientConfig| { &mut m.quality },
                EStreamQualityPreference::k_EStreamQualityBalanced,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "maximum_resolution_x",
                |m: &CStreamingClientConfig| { &m.maximum_resolution_x },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_resolution_x },
                CStreamingClientConfig::get_maximum_resolution_x,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "maximum_resolution_y",
                |m: &CStreamingClientConfig| { &m.maximum_resolution_y },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_resolution_y },
                CStreamingClientConfig::get_maximum_resolution_y,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "maximum_framerate_numerator",
                |m: &CStreamingClientConfig| { &m.maximum_framerate_numerator },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_framerate_numerator },
                CStreamingClientConfig::get_maximum_framerate_numerator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "maximum_framerate_denominator",
                |m: &CStreamingClientConfig| { &m.maximum_framerate_denominator },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_framerate_denominator },
                CStreamingClientConfig::get_maximum_framerate_denominator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "maximum_bitrate_kbps",
                |m: &CStreamingClientConfig| { &m.maximum_bitrate_kbps },
                |m: &mut CStreamingClientConfig| { &mut m.maximum_bitrate_kbps },
                CStreamingClientConfig::get_maximum_bitrate_kbps,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_hardware_decoding",
                |m: &CStreamingClientConfig| { &m.enable_hardware_decoding },
                |m: &mut CStreamingClientConfig| { &mut m.enable_hardware_decoding },
                CStreamingClientConfig::get_enable_hardware_decoding,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_performance_overlay",
                |m: &CStreamingClientConfig| { &m.enable_performance_overlay },
                |m: &mut CStreamingClientConfig| { &mut m.enable_performance_overlay },
                CStreamingClientConfig::get_enable_performance_overlay,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_video_streaming",
                |m: &CStreamingClientConfig| { &m.enable_video_streaming },
                |m: &mut CStreamingClientConfig| { &mut m.enable_video_streaming },
                CStreamingClientConfig::get_enable_video_streaming,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_audio_streaming",
                |m: &CStreamingClientConfig| { &m.enable_audio_streaming },
                |m: &mut CStreamingClientConfig| { &mut m.enable_audio_streaming },
                CStreamingClientConfig::get_enable_audio_streaming,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_input_streaming",
                |m: &CStreamingClientConfig| { &m.enable_input_streaming },
                |m: &mut CStreamingClientConfig| { &mut m.enable_input_streaming },
                CStreamingClientConfig::get_enable_input_streaming,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "audio_channels",
                |m: &CStreamingClientConfig| { &m.audio_channels },
                |m: &mut CStreamingClientConfig| { &mut m.audio_channels },
                CStreamingClientConfig::get_audio_channels,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_video_hevc",
                |m: &CStreamingClientConfig| { &m.enable_video_hevc },
                |m: &mut CStreamingClientConfig| { &mut m.enable_video_hevc },
                CStreamingClientConfig::get_enable_video_hevc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_performance_icons",
                |m: &CStreamingClientConfig| { &m.enable_performance_icons },
                |m: &mut CStreamingClientConfig| { &mut m.enable_performance_icons },
                CStreamingClientConfig::get_enable_performance_icons,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamingClientConfig>(
                "CStreamingClientConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingClientConfig {
        static instance: ::protobuf::rt::Lazy<CStreamingClientConfig> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamingClientConfig::new)
    }
}

impl ::protobuf::Clear for CStreamingClientConfig {
    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.maximum_framerate_numerator = ::std::option::Option::None;
        self.maximum_framerate_denominator = ::std::option::Option::None;
        self.maximum_bitrate_kbps = ::std::option::Option::None;
        self.enable_hardware_decoding = ::std::option::Option::None;
        self.enable_performance_overlay = ::std::option::Option::None;
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.audio_channels = ::std::option::Option::None;
        self.enable_video_hevc = ::std::option::Option::None;
        self.enable_performance_icons = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingClientConfig {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingServerConfig {
    // message fields
    change_desktop_resolution: ::std::option::Option<bool>,
    dynamically_adjust_resolution: ::std::option::Option<bool>,
    enable_capture_nvfbc: ::std::option::Option<bool>,
    enable_hardware_encoding_nvidia: ::std::option::Option<bool>,
    enable_hardware_encoding_amd: ::std::option::Option<bool>,
    enable_hardware_encoding_intel: ::std::option::Option<bool>,
    software_encoding_threads: ::std::option::Option<i32>,
    enable_traffic_priority: ::std::option::Option<bool>,
    host_play_audio: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamHostPlayAudioPreference>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingServerConfig {
    fn default() -> &'a CStreamingServerConfig {
        <CStreamingServerConfig as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingServerConfig {
    pub fn new() -> CStreamingServerConfig {
        ::std::default::Default::default()
    }

    // optional bool change_desktop_resolution = 1;

    pub fn get_change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.unwrap_or(false)
    }

    pub fn clear_change_desktop_resolution(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
    }

    pub fn has_change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_desktop_resolution(&mut self, v: bool) {
        self.change_desktop_resolution = ::std::option::Option::Some(v);
    }

    // optional bool dynamically_adjust_resolution = 2;

    pub fn get_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.unwrap_or(false)
    }

    pub fn clear_dynamically_adjust_resolution(&mut self) {
        self.dynamically_adjust_resolution = ::std::option::Option::None;
    }

    pub fn has_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamically_adjust_resolution(&mut self, v: bool) {
        self.dynamically_adjust_resolution = ::std::option::Option::Some(v);
    }

    // optional bool enable_capture_nvfbc = 3;

    pub fn get_enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.unwrap_or(false)
    }

    pub fn clear_enable_capture_nvfbc(&mut self) {
        self.enable_capture_nvfbc = ::std::option::Option::None;
    }

    pub fn has_enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_capture_nvfbc(&mut self, v: bool) {
        self.enable_capture_nvfbc = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_nvidia = 4;

    pub fn get_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_nvidia(&mut self) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_nvidia(&mut self, v: bool) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_amd = 5;

    pub fn get_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_amd(&mut self) {
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_amd(&mut self, v: bool) {
        self.enable_hardware_encoding_amd = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_intel = 6;

    pub fn get_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_intel(&mut self) {
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_intel(&mut self, v: bool) {
        self.enable_hardware_encoding_intel = ::std::option::Option::Some(v);
    }

    // optional int32 software_encoding_threads = 7;

    pub fn get_software_encoding_threads(&self) -> i32 {
        self.software_encoding_threads.unwrap_or(0)
    }

    pub fn clear_software_encoding_threads(&mut self) {
        self.software_encoding_threads = ::std::option::Option::None;
    }

    pub fn has_software_encoding_threads(&self) -> bool {
        self.software_encoding_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_software_encoding_threads(&mut self, v: i32) {
        self.software_encoding_threads = ::std::option::Option::Some(v);
    }

    // optional bool enable_traffic_priority = 8;

    pub fn get_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.unwrap_or(false)
    }

    pub fn clear_enable_traffic_priority(&mut self) {
        self.enable_traffic_priority = ::std::option::Option::None;
    }

    pub fn has_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_traffic_priority(&mut self, v: bool) {
        self.enable_traffic_priority = ::std::option::Option::Some(v);
    }

    // optional .EStreamHostPlayAudioPreference host_play_audio = 9;

    pub fn get_host_play_audio(&self) -> EStreamHostPlayAudioPreference {
        match self.host_play_audio {
            Some(e) => e.enum_value_or(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            None => EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
        }
    }

    pub fn clear_host_play_audio(&mut self) {
        self.host_play_audio = ::std::option::Option::None;
    }

    pub fn has_host_play_audio(&self) -> bool {
        self.host_play_audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_play_audio(&mut self, v: EStreamHostPlayAudioPreference) {
        self.host_play_audio = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CStreamingServerConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.change_desktop_resolution = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dynamically_adjust_resolution = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_capture_nvfbc = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_hardware_encoding_amd = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_hardware_encoding_intel = ::std::option::Option::Some(is.read_bool()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.software_encoding_threads = ::std::option::Option::Some(is.read_int32()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_traffic_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_play_audio = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.change_desktop_resolution {
            my_size += 2;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            my_size += 2;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            my_size += 2;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            my_size += 2;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            my_size += 2;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            my_size += 2;
        }
        if let Some(v) = self.software_encoding_threads {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.enable_traffic_priority {
            my_size += 2;
        }
        if let Some(v) = self.host_play_audio {
            my_size += ::protobuf::rt::enum_or_unknown_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.change_desktop_resolution {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.software_encoding_threads {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.enable_traffic_priority {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.host_play_audio {
            os.write_enum(9, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingServerConfig {
        CStreamingServerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "change_desktop_resolution",
                |m: &CStreamingServerConfig| { &m.change_desktop_resolution },
                |m: &mut CStreamingServerConfig| { &mut m.change_desktop_resolution },
                CStreamingServerConfig::get_change_desktop_resolution,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "dynamically_adjust_resolution",
                |m: &CStreamingServerConfig| { &m.dynamically_adjust_resolution },
                |m: &mut CStreamingServerConfig| { &mut m.dynamically_adjust_resolution },
                CStreamingServerConfig::get_dynamically_adjust_resolution,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_capture_nvfbc",
                |m: &CStreamingServerConfig| { &m.enable_capture_nvfbc },
                |m: &mut CStreamingServerConfig| { &mut m.enable_capture_nvfbc },
                CStreamingServerConfig::get_enable_capture_nvfbc,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_hardware_encoding_nvidia",
                |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_nvidia },
                |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_nvidia },
                CStreamingServerConfig::get_enable_hardware_encoding_nvidia,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_hardware_encoding_amd",
                |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_amd },
                |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_amd },
                CStreamingServerConfig::get_enable_hardware_encoding_amd,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_hardware_encoding_intel",
                |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_intel },
                |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_intel },
                CStreamingServerConfig::get_enable_hardware_encoding_intel,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "software_encoding_threads",
                |m: &CStreamingServerConfig| { &m.software_encoding_threads },
                |m: &mut CStreamingServerConfig| { &mut m.software_encoding_threads },
                CStreamingServerConfig::get_software_encoding_threads,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_traffic_priority",
                |m: &CStreamingServerConfig| { &m.enable_traffic_priority },
                |m: &mut CStreamingServerConfig| { &mut m.enable_traffic_priority },
                CStreamingServerConfig::get_enable_traffic_priority,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamHostPlayAudioPreference>(
                "host_play_audio",
                |m: &CStreamingServerConfig| { &m.host_play_audio },
                |m: &mut CStreamingServerConfig| { &mut m.host_play_audio },
                EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamingServerConfig>(
                "CStreamingServerConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingServerConfig {
        static instance: ::protobuf::rt::Lazy<CStreamingServerConfig> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamingServerConfig::new)
    }
}

impl ::protobuf::Clear for CStreamingServerConfig {
    fn clear(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
        self.dynamically_adjust_resolution = ::std::option::Option::None;
        self.enable_capture_nvfbc = ::std::option::Option::None;
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
        self.software_encoding_threads = ::std::option::Option::None;
        self.enable_traffic_priority = ::std::option::Option::None;
        self.host_play_audio = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingServerConfig {
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiatedConfig {
    // message fields
    reliable_data: ::std::option::Option<bool>,
    selected_audio_codec: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamAudioCodec>>,
    selected_video_codec: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamVideoCodec>>,
    pub available_video_modes: ::protobuf::RepeatedField<CStreamVideoMode>,
    enable_remote_hid: ::std::option::Option<bool>,
    enable_touch_input: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiatedConfig {
    fn default() -> &'a CNegotiatedConfig {
        <CNegotiatedConfig as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiatedConfig {
    pub fn new() -> CNegotiatedConfig {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;

    pub fn get_reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec selected_audio_codec = 2;

    pub fn get_selected_audio_codec(&self) -> EStreamAudioCodec {
        match self.selected_audio_codec {
            Some(e) => e.enum_value_or(EStreamAudioCodec::k_EStreamAudioCodecNone),
            None => EStreamAudioCodec::k_EStreamAudioCodecNone,
        }
    }

    pub fn clear_selected_audio_codec(&mut self) {
        self.selected_audio_codec = ::std::option::Option::None;
    }

    pub fn has_selected_audio_codec(&self) -> bool {
        self.selected_audio_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_audio_codec(&mut self, v: EStreamAudioCodec) {
        self.selected_audio_codec = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional .EStreamVideoCodec selected_video_codec = 3;

    pub fn get_selected_video_codec(&self) -> EStreamVideoCodec {
        match self.selected_video_codec {
            Some(e) => e.enum_value_or(EStreamVideoCodec::k_EStreamVideoCodecNone),
            None => EStreamVideoCodec::k_EStreamVideoCodecNone,
        }
    }

    pub fn clear_selected_video_codec(&mut self) {
        self.selected_video_codec = ::std::option::Option::None;
    }

    pub fn has_selected_video_codec(&self) -> bool {
        self.selected_video_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_video_codec(&mut self, v: EStreamVideoCodec) {
        self.selected_video_codec = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional bool enable_remote_hid = 5;

    pub fn get_enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.unwrap_or(false)
    }

    pub fn clear_enable_remote_hid(&mut self) {
        self.enable_remote_hid = ::std::option::Option::None;
    }

    pub fn has_enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_remote_hid(&mut self, v: bool) {
        self.enable_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool enable_touch_input = 6;

    pub fn get_enable_touch_input(&self) -> bool {
        self.enable_touch_input.unwrap_or(false)
    }

    pub fn clear_enable_touch_input(&mut self) {
        self.enable_touch_input = ::std::option::Option::None;
    }

    pub fn has_enable_touch_input(&self) -> bool {
        self.enable_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_touch_input(&mut self, v: bool) {
        self.enable_touch_input = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CNegotiatedConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.available_video_modes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reliable_data = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selected_audio_codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.selected_video_codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.available_video_modes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_remote_hid = ::std::option::Option::Some(is.read_bool()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enable_touch_input = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 2;
        }
        if let Some(v) = self.selected_audio_codec {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        if let Some(v) = self.selected_video_codec {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
        }
        for value in &self.available_video_modes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.enable_remote_hid {
            my_size += 2;
        }
        if let Some(v) = self.enable_touch_input {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.selected_audio_codec {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.selected_video_codec {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        for v in &self.available_video_modes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.enable_remote_hid {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_touch_input {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiatedConfig {
        CNegotiatedConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "reliable_data",
                |m: &CNegotiatedConfig| { &m.reliable_data },
                |m: &mut CNegotiatedConfig| { &mut m.reliable_data },
                CNegotiatedConfig::get_reliable_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamAudioCodec>(
                "selected_audio_codec",
                |m: &CNegotiatedConfig| { &m.selected_audio_codec },
                |m: &mut CNegotiatedConfig| { &mut m.selected_audio_codec },
                EStreamAudioCodec::k_EStreamAudioCodecNone,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamVideoCodec>(
                "selected_video_codec",
                |m: &CNegotiatedConfig| { &m.selected_video_codec },
                |m: &mut CNegotiatedConfig| { &mut m.selected_video_codec },
                EStreamVideoCodec::k_EStreamVideoCodecNone,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CStreamVideoMode>>(
                "available_video_modes",
                |m: &CNegotiatedConfig| { &m.available_video_modes },
                |m: &mut CNegotiatedConfig| { &mut m.available_video_modes },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_remote_hid",
                |m: &CNegotiatedConfig| { &m.enable_remote_hid },
                |m: &mut CNegotiatedConfig| { &mut m.enable_remote_hid },
                CNegotiatedConfig::get_enable_remote_hid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enable_touch_input",
                |m: &CNegotiatedConfig| { &m.enable_touch_input },
                |m: &mut CNegotiatedConfig| { &mut m.enable_touch_input },
                CNegotiatedConfig::get_enable_touch_input,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CNegotiatedConfig>(
                "CNegotiatedConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiatedConfig {
        static instance: ::protobuf::rt::Lazy<CNegotiatedConfig> = ::protobuf::rt::Lazy::INIT;
        instance.get(CNegotiatedConfig::new)
    }
}

impl ::protobuf::Clear for CNegotiatedConfig {
    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.selected_audio_codec = ::std::option::Option::None;
        self.selected_video_codec = ::std::option::Option::None;
        self.available_video_modes.clear();
        self.enable_remote_hid = ::std::option::Option::None;
        self.enable_touch_input = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiatedConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiatedConfig {
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationInitMsg {
    // message fields
    reliable_data: ::std::option::Option<bool>,
    pub supported_audio_codecs: ::std::vec::Vec<::protobuf::ProtobufEnumOrUnknown<EStreamAudioCodec>>,
    pub supported_video_codecs: ::std::vec::Vec<::protobuf::ProtobufEnumOrUnknown<EStreamVideoCodec>>,
    supports_remote_hid: ::std::option::Option<bool>,
    supports_touch_input: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiationInitMsg {
    fn default() -> &'a CNegotiationInitMsg {
        <CNegotiationInitMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationInitMsg {
    pub fn new() -> CNegotiationInitMsg {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;

    pub fn get_reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // optional bool supports_remote_hid = 4;

    pub fn get_supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.unwrap_or(false)
    }

    pub fn clear_supports_remote_hid(&mut self) {
        self.supports_remote_hid = ::std::option::Option::None;
    }

    pub fn has_supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_remote_hid(&mut self, v: bool) {
        self.supports_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool supports_touch_input = 5;

    pub fn get_supports_touch_input(&self) -> bool {
        self.supports_touch_input.unwrap_or(false)
    }

    pub fn clear_supports_touch_input(&mut self) {
        self.supports_touch_input = ::std::option::Option::None;
    }

    pub fn has_supports_touch_input(&self) -> bool {
        self.supports_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_touch_input(&mut self, v: bool) {
        self.supports_touch_input = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CNegotiationInitMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reliable_data = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_or_unknown_into(wire_type, is, &mut self.supported_audio_codecs)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_or_unknown_into(wire_type, is, &mut self.supported_video_codecs)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.supports_remote_hid = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.supports_touch_input = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 2;
        }
        for value in &self.supported_audio_codecs {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, *value);
        };
        for value in &self.supported_video_codecs {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, *value);
        };
        if let Some(v) = self.supports_remote_hid {
            my_size += 2;
        }
        if let Some(v) = self.supports_touch_input {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        for v in &self.supported_audio_codecs {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(v))?;
        };
        for v in &self.supported_video_codecs {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.supports_remote_hid {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.supports_touch_input {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiationInitMsg {
        CNegotiationInitMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "reliable_data",
                |m: &CNegotiationInitMsg| { &m.reliable_data },
                |m: &mut CNegotiationInitMsg| { &mut m.reliable_data },
                CNegotiationInitMsg::get_reliable_data,
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeEnumOrUnknown<EStreamAudioCodec>>(
                "supported_audio_codecs",
                |m: &CNegotiationInitMsg| { &m.supported_audio_codecs },
                |m: &mut CNegotiationInitMsg| { &mut m.supported_audio_codecs },
            ));
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeEnumOrUnknown<EStreamVideoCodec>>(
                "supported_video_codecs",
                |m: &CNegotiationInitMsg| { &m.supported_video_codecs },
                |m: &mut CNegotiationInitMsg| { &mut m.supported_video_codecs },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "supports_remote_hid",
                |m: &CNegotiationInitMsg| { &m.supports_remote_hid },
                |m: &mut CNegotiationInitMsg| { &mut m.supports_remote_hid },
                CNegotiationInitMsg::get_supports_remote_hid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "supports_touch_input",
                |m: &CNegotiationInitMsg| { &m.supports_touch_input },
                |m: &mut CNegotiationInitMsg| { &mut m.supports_touch_input },
                CNegotiationInitMsg::get_supports_touch_input,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CNegotiationInitMsg>(
                "CNegotiationInitMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiationInitMsg {
        static instance: ::protobuf::rt::Lazy<CNegotiationInitMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CNegotiationInitMsg::new)
    }
}

impl ::protobuf::Clear for CNegotiationInitMsg {
    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.supported_audio_codecs.clear();
        self.supported_video_codecs.clear();
        self.supports_remote_hid = ::std::option::Option::None;
        self.supports_touch_input = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationInitMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationInitMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationSetConfigMsg {
    // message fields
    pub config: ::protobuf::SingularPtrField<CNegotiatedConfig>,
    pub streaming_client_config: ::protobuf::SingularPtrField<CStreamingClientConfig>,
    pub streaming_client_caps: ::protobuf::SingularPtrField<CStreamingClientCaps>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiationSetConfigMsg {
    fn default() -> &'a CNegotiationSetConfigMsg {
        <CNegotiationSetConfigMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationSetConfigMsg {
    pub fn new() -> CNegotiationSetConfigMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CNegotiationSetConfigMsg {
    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_caps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CNegotiatedConfig, _>(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into::<CStreamingClientConfig, _>(wire_type, is, &mut self.streaming_client_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into::<CStreamingClientCaps, _>(wire_type, is, &mut self.streaming_client_caps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.streaming_client_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.streaming_client_caps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.streaming_client_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.streaming_client_caps.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiationSetConfigMsg {
        CNegotiationSetConfigMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CNegotiatedConfig>, _>(
                "config",
                |m: &CNegotiationSetConfigMsg| { &m.config },
                |m: &mut CNegotiationSetConfigMsg| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CStreamingClientConfig>, _>(
                "streaming_client_config",
                |m: &CNegotiationSetConfigMsg| { &m.streaming_client_config },
                |m: &mut CNegotiationSetConfigMsg| { &mut m.streaming_client_config },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CStreamingClientCaps>, _>(
                "streaming_client_caps",
                |m: &CNegotiationSetConfigMsg| { &m.streaming_client_caps },
                |m: &mut CNegotiationSetConfigMsg| { &mut m.streaming_client_caps },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CNegotiationSetConfigMsg>(
                "CNegotiationSetConfigMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiationSetConfigMsg {
        static instance: ::protobuf::rt::Lazy<CNegotiationSetConfigMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CNegotiationSetConfigMsg::new)
    }
}

impl ::protobuf::Clear for CNegotiationSetConfigMsg {
    fn clear(&mut self) {
        self.config.clear();
        self.streaming_client_config.clear();
        self.streaming_client_caps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationSetConfigMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationSetConfigMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CNegotiationCompleteMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CNegotiationCompleteMsg {
    fn default() -> &'a CNegotiationCompleteMsg {
        <CNegotiationCompleteMsg as ::protobuf::Message>::default_instance()
    }
}

impl CNegotiationCompleteMsg {
    pub fn new() -> CNegotiationCompleteMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CNegotiationCompleteMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CNegotiationCompleteMsg {
        CNegotiationCompleteMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CNegotiationCompleteMsg>(
                "CNegotiationCompleteMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CNegotiationCompleteMsg {
        static instance: ::protobuf::rt::Lazy<CNegotiationCompleteMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CNegotiationCompleteMsg::new)
    }
}

impl ::protobuf::Clear for CNegotiationCompleteMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CNegotiationCompleteMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNegotiationCompleteMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartAudioDataMsg {
    // message fields
    channel: ::std::option::Option<u32>,
    codec: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamAudioCodec>>,
    codec_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    frequency: ::std::option::Option<u32>,
    channels: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStartAudioDataMsg {
    fn default() -> &'a CStartAudioDataMsg {
        <CStartAudioDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartAudioDataMsg {
    pub fn new() -> CStartAudioDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 2;

    pub fn get_channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec codec = 3;

    pub fn get_codec(&self) -> EStreamAudioCodec {
        match self.codec {
            Some(e) => e.enum_value_or(EStreamAudioCodec::k_EStreamAudioCodecNone),
            None => EStreamAudioCodec::k_EStreamAudioCodecNone,
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamAudioCodec) {
        self.codec = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional bytes codec_data = 4;

    pub fn get_codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_codec_data(&mut self) {
        self.codec_data.clear();
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data.set_default();
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 frequency = 5;

    pub fn get_frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 6;

    pub fn get_channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartAudioDataMsg {
    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.codec_data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frequency = ::std::option::Option::Some(is.read_uint32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channels = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
        }
        if let Some(v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStartAudioDataMsg {
        CStartAudioDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "channel",
                |m: &CStartAudioDataMsg| { &m.channel },
                |m: &mut CStartAudioDataMsg| { &mut m.channel },
                CStartAudioDataMsg::get_channel,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamAudioCodec>(
                "codec",
                |m: &CStartAudioDataMsg| { &m.codec },
                |m: &mut CStartAudioDataMsg| { &mut m.codec },
                EStreamAudioCodec::k_EStreamAudioCodecNone,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "codec_data",
                |m: &CStartAudioDataMsg| { &m.codec_data },
                |m: &mut CStartAudioDataMsg| { &mut m.codec_data },
                CStartAudioDataMsg::get_codec_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "frequency",
                |m: &CStartAudioDataMsg| { &m.frequency },
                |m: &mut CStartAudioDataMsg| { &mut m.frequency },
                CStartAudioDataMsg::get_frequency,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "channels",
                |m: &CStartAudioDataMsg| { &m.channels },
                |m: &mut CStartAudioDataMsg| { &mut m.channels },
                CStartAudioDataMsg::get_channels,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStartAudioDataMsg>(
                "CStartAudioDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStartAudioDataMsg {
        static instance: ::protobuf::rt::Lazy<CStartAudioDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStartAudioDataMsg::new)
    }
}

impl ::protobuf::Clear for CStartAudioDataMsg {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data.clear();
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartAudioDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStopAudioDataMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStopAudioDataMsg {
    fn default() -> &'a CStopAudioDataMsg {
        <CStopAudioDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStopAudioDataMsg {
    pub fn new() -> CStopAudioDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopAudioDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStopAudioDataMsg {
        CStopAudioDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CStopAudioDataMsg>(
                "CStopAudioDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStopAudioDataMsg {
        static instance: ::protobuf::rt::Lazy<CStopAudioDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStopAudioDataMsg::new)
    }
}

impl ::protobuf::Clear for CStopAudioDataMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStopAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStopAudioDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStartVideoDataMsg {
    // message fields
    channel: ::std::option::Option<u32>,
    codec: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamVideoCodec>>,
    codec_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStartVideoDataMsg {
    fn default() -> &'a CStartVideoDataMsg {
        <CStartVideoDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStartVideoDataMsg {
    pub fn new() -> CStartVideoDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 1;

    pub fn get_channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamVideoCodec codec = 2;

    pub fn get_codec(&self) -> EStreamVideoCodec {
        match self.codec {
            Some(e) => e.enum_value_or(EStreamVideoCodec::k_EStreamVideoCodecNone),
            None => EStreamVideoCodec::k_EStreamVideoCodecNone,
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamVideoCodec) {
        self.codec = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional bytes codec_data = 3;

    pub fn get_codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_codec_data(&mut self) {
        self.codec_data.clear();
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.codec_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.codec_data.is_none() {
            self.codec_data.set_default();
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::std::vec::Vec<u8> {
        self.codec_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 width = 4;

    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStartVideoDataMsg {
    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.codec_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.codec {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        if let Some(v) = self.codec_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStartVideoDataMsg {
        CStartVideoDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "channel",
                |m: &CStartVideoDataMsg| { &m.channel },
                |m: &mut CStartVideoDataMsg| { &mut m.channel },
                CStartVideoDataMsg::get_channel,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamVideoCodec>(
                "codec",
                |m: &CStartVideoDataMsg| { &m.codec },
                |m: &mut CStartVideoDataMsg| { &mut m.codec },
                EStreamVideoCodec::k_EStreamVideoCodecNone,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "codec_data",
                |m: &CStartVideoDataMsg| { &m.codec_data },
                |m: &mut CStartVideoDataMsg| { &mut m.codec_data },
                CStartVideoDataMsg::get_codec_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "width",
                |m: &CStartVideoDataMsg| { &m.width },
                |m: &mut CStartVideoDataMsg| { &mut m.width },
                CStartVideoDataMsg::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "height",
                |m: &CStartVideoDataMsg| { &m.height },
                |m: &mut CStartVideoDataMsg| { &mut m.height },
                CStartVideoDataMsg::get_height,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStartVideoDataMsg>(
                "CStartVideoDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStartVideoDataMsg {
        static instance: ::protobuf::rt::Lazy<CStartVideoDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStartVideoDataMsg::new)
    }
}

impl ::protobuf::Clear for CStartVideoDataMsg {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStartVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStartVideoDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStopVideoDataMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStopVideoDataMsg {
    fn default() -> &'a CStopVideoDataMsg {
        <CStopVideoDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStopVideoDataMsg {
    pub fn new() -> CStopVideoDataMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStopVideoDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStopVideoDataMsg {
        CStopVideoDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CStopVideoDataMsg>(
                "CStopVideoDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStopVideoDataMsg {
        static instance: ::protobuf::rt::Lazy<CStopVideoDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStopVideoDataMsg::new)
    }
}

impl ::protobuf::Clear for CStopVideoDataMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStopVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStopVideoDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputLatencyTestMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    color: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputLatencyTestMsg {
    fn default() -> &'a CInputLatencyTestMsg {
        <CInputLatencyTestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputLatencyTestMsg {
    pub fn new() -> CInputLatencyTestMsg {
        ::std::default::Default::default()
    }

    // required uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 2;

    pub fn get_color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputLatencyTestMsg {
    fn is_initialized(&self) -> bool {
        if self.input_mark.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputLatencyTestMsg {
        CInputLatencyTestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputLatencyTestMsg| { &m.input_mark },
                |m: &mut CInputLatencyTestMsg| { &mut m.input_mark },
                CInputLatencyTestMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "color",
                |m: &CInputLatencyTestMsg| { &m.color },
                |m: &mut CInputLatencyTestMsg| { &mut m.color },
                CInputLatencyTestMsg::get_color,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputLatencyTestMsg>(
                "CInputLatencyTestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputLatencyTestMsg {
        static instance: ::protobuf::rt::Lazy<CInputLatencyTestMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputLatencyTestMsg::new)
    }
}

impl ::protobuf::Clear for CInputLatencyTestMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputLatencyTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputLatencyTestMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTouchFingerDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    fingerid: ::std::option::Option<u64>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerDownMsg {
    fn default() -> &'a CInputTouchFingerDownMsg {
        <CInputTouchFingerDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerDownMsg {
    pub fn new() -> CInputTouchFingerDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn get_fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerDownMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTouchFingerDownMsg {
        CInputTouchFingerDownMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputTouchFingerDownMsg| { &m.input_mark },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.input_mark },
                CInputTouchFingerDownMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "fingerid",
                |m: &CInputTouchFingerDownMsg| { &m.fingerid },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.fingerid },
                CInputTouchFingerDownMsg::get_fingerid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "x_normalized",
                |m: &CInputTouchFingerDownMsg| { &m.x_normalized },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.x_normalized },
                CInputTouchFingerDownMsg::get_x_normalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "y_normalized",
                |m: &CInputTouchFingerDownMsg| { &m.y_normalized },
                |m: &mut CInputTouchFingerDownMsg| { &mut m.y_normalized },
                CInputTouchFingerDownMsg::get_y_normalized,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputTouchFingerDownMsg>(
                "CInputTouchFingerDownMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTouchFingerDownMsg {
        static instance: ::protobuf::rt::Lazy<CInputTouchFingerDownMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputTouchFingerDownMsg::new)
    }
}

impl ::protobuf::Clear for CInputTouchFingerDownMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTouchFingerDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTouchFingerDownMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTouchFingerMotionMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    fingerid: ::std::option::Option<u64>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerMotionMsg {
    fn default() -> &'a CInputTouchFingerMotionMsg {
        <CInputTouchFingerMotionMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerMotionMsg {
    pub fn new() -> CInputTouchFingerMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn get_fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerMotionMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTouchFingerMotionMsg {
        CInputTouchFingerMotionMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputTouchFingerMotionMsg| { &m.input_mark },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.input_mark },
                CInputTouchFingerMotionMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "fingerid",
                |m: &CInputTouchFingerMotionMsg| { &m.fingerid },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.fingerid },
                CInputTouchFingerMotionMsg::get_fingerid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "x_normalized",
                |m: &CInputTouchFingerMotionMsg| { &m.x_normalized },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.x_normalized },
                CInputTouchFingerMotionMsg::get_x_normalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "y_normalized",
                |m: &CInputTouchFingerMotionMsg| { &m.y_normalized },
                |m: &mut CInputTouchFingerMotionMsg| { &mut m.y_normalized },
                CInputTouchFingerMotionMsg::get_y_normalized,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputTouchFingerMotionMsg>(
                "CInputTouchFingerMotionMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTouchFingerMotionMsg {
        static instance: ::protobuf::rt::Lazy<CInputTouchFingerMotionMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputTouchFingerMotionMsg::new)
    }
}

impl ::protobuf::Clear for CInputTouchFingerMotionMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTouchFingerMotionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTouchFingerMotionMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTouchFingerUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    fingerid: ::std::option::Option<u64>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerUpMsg {
    fn default() -> &'a CInputTouchFingerUpMsg {
        <CInputTouchFingerUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTouchFingerUpMsg {
    pub fn new() -> CInputTouchFingerUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn get_fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputTouchFingerUpMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTouchFingerUpMsg {
        CInputTouchFingerUpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputTouchFingerUpMsg| { &m.input_mark },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.input_mark },
                CInputTouchFingerUpMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "fingerid",
                |m: &CInputTouchFingerUpMsg| { &m.fingerid },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.fingerid },
                CInputTouchFingerUpMsg::get_fingerid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "x_normalized",
                |m: &CInputTouchFingerUpMsg| { &m.x_normalized },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.x_normalized },
                CInputTouchFingerUpMsg::get_x_normalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "y_normalized",
                |m: &CInputTouchFingerUpMsg| { &m.y_normalized },
                |m: &mut CInputTouchFingerUpMsg| { &mut m.y_normalized },
                CInputTouchFingerUpMsg::get_y_normalized,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputTouchFingerUpMsg>(
                "CInputTouchFingerUpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTouchFingerUpMsg {
        static instance: ::protobuf::rt::Lazy<CInputTouchFingerUpMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputTouchFingerUpMsg::new)
    }
}

impl ::protobuf::Clear for CInputTouchFingerUpMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTouchFingerUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTouchFingerUpMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseMotionMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    dx: ::std::option::Option<i32>,
    dy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseMotionMsg {
    fn default() -> &'a CInputMouseMotionMsg {
        <CInputMouseMotionMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseMotionMsg {
    pub fn new() -> CInputMouseMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 2;

    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 3;

    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    // optional int32 dx = 4;

    pub fn get_dx(&self) -> i32 {
        self.dx.unwrap_or(0)
    }

    pub fn clear_dx(&mut self) {
        self.dx = ::std::option::Option::None;
    }

    pub fn has_dx(&self) -> bool {
        self.dx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dx(&mut self, v: i32) {
        self.dx = ::std::option::Option::Some(v);
    }

    // optional int32 dy = 5;

    pub fn get_dy(&self) -> i32 {
        self.dy.unwrap_or(0)
    }

    pub fn clear_dy(&mut self) {
        self.dy = ::std::option::Option::None;
    }

    pub fn has_dy(&self) -> bool {
        self.dy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dy(&mut self, v: i32) {
        self.dy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputMouseMotionMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dx = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dy = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        if let Some(v) = self.dx {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dy {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.dx {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dy {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseMotionMsg {
        CInputMouseMotionMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputMouseMotionMsg| { &m.input_mark },
                |m: &mut CInputMouseMotionMsg| { &mut m.input_mark },
                CInputMouseMotionMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "x_normalized",
                |m: &CInputMouseMotionMsg| { &m.x_normalized },
                |m: &mut CInputMouseMotionMsg| { &mut m.x_normalized },
                CInputMouseMotionMsg::get_x_normalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "y_normalized",
                |m: &CInputMouseMotionMsg| { &m.y_normalized },
                |m: &mut CInputMouseMotionMsg| { &mut m.y_normalized },
                CInputMouseMotionMsg::get_y_normalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "dx",
                |m: &CInputMouseMotionMsg| { &m.dx },
                |m: &mut CInputMouseMotionMsg| { &mut m.dx },
                CInputMouseMotionMsg::get_dx,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "dy",
                |m: &CInputMouseMotionMsg| { &m.dy },
                |m: &mut CInputMouseMotionMsg| { &mut m.dy },
                CInputMouseMotionMsg::get_dy,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputMouseMotionMsg>(
                "CInputMouseMotionMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseMotionMsg {
        static instance: ::protobuf::rt::Lazy<CInputMouseMotionMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputMouseMotionMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseMotionMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.dx = ::std::option::Option::None;
        self.dy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseMotionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseMotionMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseWheelMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    direction: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamMouseWheelDirection>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseWheelMsg {
    fn default() -> &'a CInputMouseWheelMsg {
        <CInputMouseWheelMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseWheelMsg {
    pub fn new() -> CInputMouseWheelMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseWheelDirection direction = 2;

    pub fn get_direction(&self) -> EStreamMouseWheelDirection {
        match self.direction {
            Some(e) => e.enum_value_or(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            None => EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
        }
    }

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EStreamMouseWheelDirection) {
        self.direction = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CInputMouseWheelMsg {
    fn is_initialized(&self) -> bool {
        if self.direction.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.direction {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseWheelMsg {
        CInputMouseWheelMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputMouseWheelMsg| { &m.input_mark },
                |m: &mut CInputMouseWheelMsg| { &mut m.input_mark },
                CInputMouseWheelMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamMouseWheelDirection>(
                "direction",
                |m: &CInputMouseWheelMsg| { &m.direction },
                |m: &mut CInputMouseWheelMsg| { &mut m.direction },
                EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputMouseWheelMsg>(
                "CInputMouseWheelMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseWheelMsg {
        static instance: ::protobuf::rt::Lazy<CInputMouseWheelMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputMouseWheelMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseWheelMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseWheelMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseWheelMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    button: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamMouseButton>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseDownMsg {
    fn default() -> &'a CInputMouseDownMsg {
        <CInputMouseDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseDownMsg {
    pub fn new() -> CInputMouseDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;

    pub fn get_button(&self) -> EStreamMouseButton {
        match self.button {
            Some(e) => e.enum_value_or(EStreamMouseButton::k_EStreamMouseButtonLeft),
            None => EStreamMouseButton::k_EStreamMouseButtonLeft,
        }
    }

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CInputMouseDownMsg {
    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.button = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseDownMsg {
        CInputMouseDownMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputMouseDownMsg| { &m.input_mark },
                |m: &mut CInputMouseDownMsg| { &mut m.input_mark },
                CInputMouseDownMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamMouseButton>(
                "button",
                |m: &CInputMouseDownMsg| { &m.button },
                |m: &mut CInputMouseDownMsg| { &mut m.button },
                EStreamMouseButton::k_EStreamMouseButtonLeft,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputMouseDownMsg>(
                "CInputMouseDownMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseDownMsg {
        static instance: ::protobuf::rt::Lazy<CInputMouseDownMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputMouseDownMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseDownMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseDownMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputMouseUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    button: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamMouseButton>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputMouseUpMsg {
    fn default() -> &'a CInputMouseUpMsg {
        <CInputMouseUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputMouseUpMsg {
    pub fn new() -> CInputMouseUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;

    pub fn get_button(&self) -> EStreamMouseButton {
        match self.button {
            Some(e) => e.enum_value_or(EStreamMouseButton::k_EStreamMouseButtonLeft),
            None => EStreamMouseButton::k_EStreamMouseButtonLeft,
        }
    }

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for CInputMouseUpMsg {
    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.button = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.button {
            my_size += ::protobuf::rt::enum_or_unknown_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputMouseUpMsg {
        CInputMouseUpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputMouseUpMsg| { &m.input_mark },
                |m: &mut CInputMouseUpMsg| { &mut m.input_mark },
                CInputMouseUpMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamMouseButton>(
                "button",
                |m: &CInputMouseUpMsg| { &m.button },
                |m: &mut CInputMouseUpMsg| { &mut m.button },
                EStreamMouseButton::k_EStreamMouseButtonLeft,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputMouseUpMsg>(
                "CInputMouseUpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputMouseUpMsg {
        static instance: ::protobuf::rt::Lazy<CInputMouseUpMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputMouseUpMsg::new)
    }
}

impl ::protobuf::Clear for CInputMouseUpMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputMouseUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputMouseUpMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputKeyDownMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    scancode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputKeyDownMsg {
    fn default() -> &'a CInputKeyDownMsg {
        <CInputKeyDownMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputKeyDownMsg {
    pub fn new() -> CInputKeyDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;

    pub fn get_scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputKeyDownMsg {
    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scancode = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputKeyDownMsg {
        CInputKeyDownMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputKeyDownMsg| { &m.input_mark },
                |m: &mut CInputKeyDownMsg| { &mut m.input_mark },
                CInputKeyDownMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "scancode",
                |m: &CInputKeyDownMsg| { &m.scancode },
                |m: &mut CInputKeyDownMsg| { &mut m.scancode },
                CInputKeyDownMsg::get_scancode,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputKeyDownMsg>(
                "CInputKeyDownMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputKeyDownMsg {
        static instance: ::protobuf::rt::Lazy<CInputKeyDownMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputKeyDownMsg::new)
    }
}

impl ::protobuf::Clear for CInputKeyDownMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputKeyDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputKeyDownMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputKeyUpMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    scancode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputKeyUpMsg {
    fn default() -> &'a CInputKeyUpMsg {
        <CInputKeyUpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputKeyUpMsg {
    pub fn new() -> CInputKeyUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;

    pub fn get_scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CInputKeyUpMsg {
    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scancode = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scancode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputKeyUpMsg {
        CInputKeyUpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputKeyUpMsg| { &m.input_mark },
                |m: &mut CInputKeyUpMsg| { &mut m.input_mark },
                CInputKeyUpMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "scancode",
                |m: &CInputKeyUpMsg| { &m.scancode },
                |m: &mut CInputKeyUpMsg| { &mut m.scancode },
                CInputKeyUpMsg::get_scancode,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputKeyUpMsg>(
                "CInputKeyUpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputKeyUpMsg {
        static instance: ::protobuf::rt::Lazy<CInputKeyUpMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputKeyUpMsg::new)
    }
}

impl ::protobuf::Clear for CInputKeyUpMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputKeyUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputKeyUpMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CInputTextMsg {
    // message fields
    input_mark: ::std::option::Option<u32>,
    text_utf8: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CInputTextMsg {
    fn default() -> &'a CInputTextMsg {
        <CInputTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CInputTextMsg {
    pub fn new() -> CInputTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required string text_utf8 = 2;

    pub fn get_text_utf8(&self) -> &str {
        match self.text_utf8.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text_utf8(&mut self) {
        self.text_utf8.clear();
    }

    pub fn has_text_utf8(&self) -> bool {
        self.text_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_utf8(&mut self, v: ::std::string::String) {
        self.text_utf8 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text_utf8(&mut self) -> &mut ::std::string::String {
        if self.text_utf8.is_none() {
            self.text_utf8.set_default();
        }
        self.text_utf8.as_mut().unwrap()
    }

    // Take field
    pub fn take_text_utf8(&mut self) -> ::std::string::String {
        self.text_utf8.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CInputTextMsg {
    fn is_initialized(&self) -> bool {
        if self.text_utf8.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text_utf8)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.text_utf8.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text_utf8.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CInputTextMsg {
        CInputTextMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CInputTextMsg| { &m.input_mark },
                |m: &mut CInputTextMsg| { &mut m.input_mark },
                CInputTextMsg::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "text_utf8",
                |m: &CInputTextMsg| { &m.text_utf8 },
                |m: &mut CInputTextMsg| { &mut m.text_utf8 },
                CInputTextMsg::get_text_utf8,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CInputTextMsg>(
                "CInputTextMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CInputTextMsg {
        static instance: ::protobuf::rt::Lazy<CInputTextMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CInputTextMsg::new)
    }
}

impl ::protobuf::Clear for CInputTextMsg {
    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.text_utf8.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CInputTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CInputTextMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTitleMsg {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTitleMsg {
    fn default() -> &'a CSetTitleMsg {
        <CSetTitleMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTitleMsg {
    pub fn new() -> CSetTitleMsg {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSetTitleMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTitleMsg {
        CSetTitleMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "text",
                |m: &CSetTitleMsg| { &m.text },
                |m: &mut CSetTitleMsg| { &mut m.text },
                CSetTitleMsg::get_text,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetTitleMsg>(
                "CSetTitleMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTitleMsg {
        static instance: ::protobuf::rt::Lazy<CSetTitleMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetTitleMsg::new)
    }
}

impl ::protobuf::Clear for CSetTitleMsg {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTitleMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTitleMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCaptureSizeMsg {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetCaptureSizeMsg {
    fn default() -> &'a CSetCaptureSizeMsg {
        <CSetCaptureSizeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCaptureSizeMsg {
    pub fn new() -> CSetCaptureSizeMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCaptureSizeMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetCaptureSizeMsg {
        CSetCaptureSizeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "width",
                |m: &CSetCaptureSizeMsg| { &m.width },
                |m: &mut CSetCaptureSizeMsg| { &mut m.width },
                CSetCaptureSizeMsg::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "height",
                |m: &CSetCaptureSizeMsg| { &m.height },
                |m: &mut CSetCaptureSizeMsg| { &mut m.height },
                CSetCaptureSizeMsg::get_height,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetCaptureSizeMsg>(
                "CSetCaptureSizeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetCaptureSizeMsg {
        static instance: ::protobuf::rt::Lazy<CSetCaptureSizeMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetCaptureSizeMsg::new)
    }
}

impl ::protobuf::Clear for CSetCaptureSizeMsg {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCaptureSizeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCaptureSizeMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetIconMsg {
    // message fields
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetIconMsg {
    fn default() -> &'a CSetIconMsg {
        <CSetIconMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetIconMsg {
    pub fn new() -> CSetIconMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional bytes image = 3;

    pub fn get_image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetIconMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetIconMsg {
        CSetIconMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "width",
                |m: &CSetIconMsg| { &m.width },
                |m: &mut CSetIconMsg| { &mut m.width },
                CSetIconMsg::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "height",
                |m: &CSetIconMsg| { &m.height },
                |m: &mut CSetIconMsg| { &mut m.height },
                CSetIconMsg::get_height,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "image",
                |m: &CSetIconMsg| { &m.image },
                |m: &mut CSetIconMsg| { &mut m.image },
                CSetIconMsg::get_image,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetIconMsg>(
                "CSetIconMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetIconMsg {
        static instance: ::protobuf::rt::Lazy<CSetIconMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetIconMsg::new)
    }
}

impl ::protobuf::Clear for CSetIconMsg {
    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetIconMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetIconMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetFlashStateMsg {
    // message fields
    flags: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    timeout_ms: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetFlashStateMsg {
    fn default() -> &'a CSetFlashStateMsg {
        <CSetFlashStateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetFlashStateMsg {
    pub fn new() -> CSetFlashStateMsg {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 1;

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 2;

    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout_ms = 3;

    pub fn get_timeout_ms(&self) -> u32 {
        self.timeout_ms.unwrap_or(0)
    }

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: u32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetFlashStateMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timeout_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout_ms {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timeout_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetFlashStateMsg {
        CSetFlashStateMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "flags",
                |m: &CSetFlashStateMsg| { &m.flags },
                |m: &mut CSetFlashStateMsg| { &mut m.flags },
                CSetFlashStateMsg::get_flags,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "count",
                |m: &CSetFlashStateMsg| { &m.count },
                |m: &mut CSetFlashStateMsg| { &mut m.count },
                CSetFlashStateMsg::get_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "timeout_ms",
                |m: &CSetFlashStateMsg| { &m.timeout_ms },
                |m: &mut CSetFlashStateMsg| { &mut m.timeout_ms },
                CSetFlashStateMsg::get_timeout_ms,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetFlashStateMsg>(
                "CSetFlashStateMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetFlashStateMsg {
        static instance: ::protobuf::rt::Lazy<CSetFlashStateMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetFlashStateMsg::new)
    }
}

impl ::protobuf::Clear for CSetFlashStateMsg {
    fn clear(&mut self) {
        self.flags = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.timeout_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetFlashStateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetFlashStateMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CShowCursorMsg {
    // message fields
    x_normalized: ::std::option::Option<f32>,
    y_normalized: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CShowCursorMsg {
    fn default() -> &'a CShowCursorMsg {
        <CShowCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CShowCursorMsg {
    pub fn new() -> CShowCursorMsg {
        ::std::default::Default::default()
    }

    // optional float x_normalized = 1;

    pub fn get_x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 2;

    pub fn get_y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CShowCursorMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x_normalized {
            my_size += 5;
        }
        if let Some(v) = self.y_normalized {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x_normalized {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CShowCursorMsg {
        CShowCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "x_normalized",
                |m: &CShowCursorMsg| { &m.x_normalized },
                |m: &mut CShowCursorMsg| { &mut m.x_normalized },
                CShowCursorMsg::get_x_normalized,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "y_normalized",
                |m: &CShowCursorMsg| { &m.y_normalized },
                |m: &mut CShowCursorMsg| { &mut m.y_normalized },
                CShowCursorMsg::get_y_normalized,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CShowCursorMsg>(
                "CShowCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CShowCursorMsg {
        static instance: ::protobuf::rt::Lazy<CShowCursorMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CShowCursorMsg::new)
    }
}

impl ::protobuf::Clear for CShowCursorMsg {
    fn clear(&mut self) {
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CShowCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CShowCursorMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CHideCursorMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CHideCursorMsg {
    fn default() -> &'a CHideCursorMsg {
        <CHideCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CHideCursorMsg {
    pub fn new() -> CHideCursorMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CHideCursorMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CHideCursorMsg {
        CHideCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CHideCursorMsg>(
                "CHideCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CHideCursorMsg {
        static instance: ::protobuf::rt::Lazy<CHideCursorMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CHideCursorMsg::new)
    }
}

impl ::protobuf::Clear for CHideCursorMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CHideCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CHideCursorMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCursorMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetCursorMsg {
    fn default() -> &'a CSetCursorMsg {
        <CSetCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCursorMsg {
    pub fn new() -> CSetCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetCursorMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetCursorMsg {
        CSetCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "cursor_id",
                |m: &CSetCursorMsg| { &m.cursor_id },
                |m: &mut CSetCursorMsg| { &mut m.cursor_id },
                CSetCursorMsg::get_cursor_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetCursorMsg>(
                "CSetCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetCursorMsg {
        static instance: ::protobuf::rt::Lazy<CSetCursorMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetCursorMsg::new)
    }
}

impl ::protobuf::Clear for CSetCursorMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCursorMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CGetCursorImageMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGetCursorImageMsg {
    fn default() -> &'a CGetCursorImageMsg {
        <CGetCursorImageMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetCursorImageMsg {
    pub fn new() -> CGetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGetCursorImageMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGetCursorImageMsg {
        CGetCursorImageMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "cursor_id",
                |m: &CGetCursorImageMsg| { &m.cursor_id },
                |m: &mut CGetCursorImageMsg| { &mut m.cursor_id },
                CGetCursorImageMsg::get_cursor_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CGetCursorImageMsg>(
                "CGetCursorImageMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGetCursorImageMsg {
        static instance: ::protobuf::rt::Lazy<CGetCursorImageMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CGetCursorImageMsg::new)
    }
}

impl ::protobuf::Clear for CGetCursorImageMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGetCursorImageMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetCursorImageMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    width: ::std::option::Option<i32>,
    height: ::std::option::Option<i32>,
    hot_x: ::std::option::Option<i32>,
    hot_y: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetCursorImageMsg {
    fn default() -> &'a CSetCursorImageMsg {
        <CSetCursorImageMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetCursorImageMsg {
    pub fn new() -> CSetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn get_width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn get_height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 hot_x = 4;

    pub fn get_hot_x(&self) -> i32 {
        self.hot_x.unwrap_or(0)
    }

    pub fn clear_hot_x(&mut self) {
        self.hot_x = ::std::option::Option::None;
    }

    pub fn has_hot_x(&self) -> bool {
        self.hot_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_x(&mut self, v: i32) {
        self.hot_x = ::std::option::Option::Some(v);
    }

    // optional int32 hot_y = 5;

    pub fn get_hot_y(&self) -> i32 {
        self.hot_y.unwrap_or(0)
    }

    pub fn clear_hot_y(&mut self) {
        self.hot_y = ::std::option::Option::None;
    }

    pub fn has_hot_y(&self) -> bool {
        self.hot_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_y(&mut self, v: i32) {
        self.hot_y = ::std::option::Option::Some(v);
    }

    // optional bytes image = 6;

    pub fn get_image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::vec::Vec<u8> {
        self.image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetCursorImageMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hot_x = ::std::option::Option::Some(is.read_int32()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hot_y = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hot_x {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hot_y {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hot_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hot_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetCursorImageMsg {
        CSetCursorImageMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "cursor_id",
                |m: &CSetCursorImageMsg| { &m.cursor_id },
                |m: &mut CSetCursorImageMsg| { &mut m.cursor_id },
                CSetCursorImageMsg::get_cursor_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "width",
                |m: &CSetCursorImageMsg| { &m.width },
                |m: &mut CSetCursorImageMsg| { &mut m.width },
                CSetCursorImageMsg::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "height",
                |m: &CSetCursorImageMsg| { &m.height },
                |m: &mut CSetCursorImageMsg| { &mut m.height },
                CSetCursorImageMsg::get_height,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "hot_x",
                |m: &CSetCursorImageMsg| { &m.hot_x },
                |m: &mut CSetCursorImageMsg| { &mut m.hot_x },
                CSetCursorImageMsg::get_hot_x,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "hot_y",
                |m: &CSetCursorImageMsg| { &m.hot_y },
                |m: &mut CSetCursorImageMsg| { &mut m.hot_y },
                CSetCursorImageMsg::get_hot_y,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "image",
                |m: &CSetCursorImageMsg| { &m.image },
                |m: &mut CSetCursorImageMsg| { &mut m.image },
                CSetCursorImageMsg::get_image,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetCursorImageMsg>(
                "CSetCursorImageMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetCursorImageMsg {
        static instance: ::protobuf::rt::Lazy<CSetCursorImageMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetCursorImageMsg::new)
    }
}

impl ::protobuf::Clear for CSetCursorImageMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.hot_x = ::std::option::Option::None;
        self.hot_y = ::std::option::Option::None;
        self.image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetCursorImageMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoDecoderInfoMsg {
    // message fields
    info: ::protobuf::SingularField<::std::string::String>,
    threads: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVideoDecoderInfoMsg {
    fn default() -> &'a CVideoDecoderInfoMsg {
        <CVideoDecoderInfoMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVideoDecoderInfoMsg {
    pub fn new() -> CVideoDecoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;

    pub fn get_info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 threads = 2;

    pub fn get_threads(&self) -> i32 {
        self.threads.unwrap_or(0)
    }

    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: i32) {
        self.threads = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVideoDecoderInfoMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.threads = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.threads {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.threads {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVideoDecoderInfoMsg {
        CVideoDecoderInfoMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "info",
                |m: &CVideoDecoderInfoMsg| { &m.info },
                |m: &mut CVideoDecoderInfoMsg| { &mut m.info },
                CVideoDecoderInfoMsg::get_info,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "threads",
                |m: &CVideoDecoderInfoMsg| { &m.threads },
                |m: &mut CVideoDecoderInfoMsg| { &mut m.threads },
                CVideoDecoderInfoMsg::get_threads,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CVideoDecoderInfoMsg>(
                "CVideoDecoderInfoMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVideoDecoderInfoMsg {
        static instance: ::protobuf::rt::Lazy<CVideoDecoderInfoMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CVideoDecoderInfoMsg::new)
    }
}

impl ::protobuf::Clear for CVideoDecoderInfoMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.threads = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoDecoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoDecoderInfoMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoEncoderInfoMsg {
    // message fields
    info: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVideoEncoderInfoMsg {
    fn default() -> &'a CVideoEncoderInfoMsg {
        <CVideoEncoderInfoMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVideoEncoderInfoMsg {
    pub fn new() -> CVideoEncoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;

    pub fn get_info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVideoEncoderInfoMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVideoEncoderInfoMsg {
        CVideoEncoderInfoMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "info",
                |m: &CVideoEncoderInfoMsg| { &m.info },
                |m: &mut CVideoEncoderInfoMsg| { &mut m.info },
                CVideoEncoderInfoMsg::get_info,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CVideoEncoderInfoMsg>(
                "CVideoEncoderInfoMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVideoEncoderInfoMsg {
        static instance: ::protobuf::rt::Lazy<CVideoEncoderInfoMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CVideoEncoderInfoMsg::new)
    }
}

impl ::protobuf::Clear for CVideoEncoderInfoMsg {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoEncoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoEncoderInfoMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CPauseMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPauseMsg {
    fn default() -> &'a CPauseMsg {
        <CPauseMsg as ::protobuf::Message>::default_instance()
    }
}

impl CPauseMsg {
    pub fn new() -> CPauseMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CPauseMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPauseMsg {
        CPauseMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CPauseMsg>(
                "CPauseMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CPauseMsg {
        static instance: ::protobuf::rt::Lazy<CPauseMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CPauseMsg::new)
    }
}

impl ::protobuf::Clear for CPauseMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPauseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPauseMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CResumeMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CResumeMsg {
    fn default() -> &'a CResumeMsg {
        <CResumeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CResumeMsg {
    pub fn new() -> CResumeMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CResumeMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CResumeMsg {
        CResumeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CResumeMsg>(
                "CResumeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CResumeMsg {
        static instance: ::protobuf::rt::Lazy<CResumeMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CResumeMsg::new)
    }
}

impl ::protobuf::Clear for CResumeMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CResumeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CResumeMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CQuitRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CQuitRequest {
    fn default() -> &'a CQuitRequest {
        <CQuitRequest as ::protobuf::Message>::default_instance()
    }
}

impl CQuitRequest {
    pub fn new() -> CQuitRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CQuitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CQuitRequest {
        CQuitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CQuitRequest>(
                "CQuitRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CQuitRequest {
        static instance: ::protobuf::rt::Lazy<CQuitRequest> = ::protobuf::rt::Lazy::INIT;
        instance.get(CQuitRequest::new)
    }
}

impl ::protobuf::Clear for CQuitRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CQuitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CQuitRequest {
}

#[derive(PartialEq,Clone,Default)]
pub struct CDeleteCursorMsg {
    // message fields
    cursor_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDeleteCursorMsg {
    fn default() -> &'a CDeleteCursorMsg {
        <CDeleteCursorMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDeleteCursorMsg {
    pub fn new() -> CDeleteCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn get_cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CDeleteCursorMsg {
    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDeleteCursorMsg {
        CDeleteCursorMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint64, _>(
                "cursor_id",
                |m: &CDeleteCursorMsg| { &m.cursor_id },
                |m: &mut CDeleteCursorMsg| { &mut m.cursor_id },
                CDeleteCursorMsg::get_cursor_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CDeleteCursorMsg>(
                "CDeleteCursorMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDeleteCursorMsg {
        static instance: ::protobuf::rt::Lazy<CDeleteCursorMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CDeleteCursorMsg::new)
    }
}

impl ::protobuf::Clear for CDeleteCursorMsg {
    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDeleteCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDeleteCursorMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetStreamingClientConfig {
    // message fields
    pub config: ::protobuf::SingularPtrField<CStreamingClientConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetStreamingClientConfig {
    fn default() -> &'a CSetStreamingClientConfig {
        <CSetStreamingClientConfig as ::protobuf::Message>::default_instance()
    }
}

impl CSetStreamingClientConfig {
    pub fn new() -> CSetStreamingClientConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSetStreamingClientConfig {
    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<CStreamingClientConfig, _>(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetStreamingClientConfig {
        CSetStreamingClientConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CStreamingClientConfig>, _>(
                "config",
                |m: &CSetStreamingClientConfig| { &m.config },
                |m: &mut CSetStreamingClientConfig| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetStreamingClientConfig>(
                "CSetStreamingClientConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetStreamingClientConfig {
        static instance: ::protobuf::rt::Lazy<CSetStreamingClientConfig> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetStreamingClientConfig::new)
    }
}

impl ::protobuf::Clear for CSetStreamingClientConfig {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetStreamingClientConfig {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetQoSMsg {
    // message fields
    use_qos: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetQoSMsg {
    fn default() -> &'a CSetQoSMsg {
        <CSetQoSMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetQoSMsg {
    pub fn new() -> CSetQoSMsg {
        ::std::default::Default::default()
    }

    // required bool use_qos = 1;

    pub fn get_use_qos(&self) -> bool {
        self.use_qos.unwrap_or(false)
    }

    pub fn clear_use_qos(&mut self) {
        self.use_qos = ::std::option::Option::None;
    }

    pub fn has_use_qos(&self) -> bool {
        self.use_qos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_qos(&mut self, v: bool) {
        self.use_qos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetQoSMsg {
    fn is_initialized(&self) -> bool {
        if self.use_qos.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.use_qos = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.use_qos {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.use_qos {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetQoSMsg {
        CSetQoSMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "use_qos",
                |m: &CSetQoSMsg| { &m.use_qos },
                |m: &mut CSetQoSMsg| { &mut m.use_qos },
                CSetQoSMsg::get_use_qos,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetQoSMsg>(
                "CSetQoSMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetQoSMsg {
        static instance: ::protobuf::rt::Lazy<CSetQoSMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetQoSMsg::new)
    }
}

impl ::protobuf::Clear for CSetQoSMsg {
    fn clear(&mut self) {
        self.use_qos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetQoSMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetQoSMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTargetFramerateMsg {
    // message fields
    framerate: ::std::option::Option<u32>,
    reasons: ::std::option::Option<u32>,
    framerate_numerator: ::std::option::Option<u32>,
    framerate_denominator: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTargetFramerateMsg {
    fn default() -> &'a CSetTargetFramerateMsg {
        <CSetTargetFramerateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTargetFramerateMsg {
    pub fn new() -> CSetTargetFramerateMsg {
        ::std::default::Default::default()
    }

    // required uint32 framerate = 1;

    pub fn get_framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 reasons = 2;

    pub fn get_reasons(&self) -> u32 {
        self.reasons.unwrap_or(0)
    }

    pub fn clear_reasons(&mut self) {
        self.reasons = ::std::option::Option::None;
    }

    pub fn has_reasons(&self) -> bool {
        self.reasons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reasons(&mut self, v: u32) {
        self.reasons = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_numerator = 3;

    pub fn get_framerate_numerator(&self) -> u32 {
        self.framerate_numerator.unwrap_or(0)
    }

    pub fn clear_framerate_numerator(&mut self) {
        self.framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_framerate_numerator(&self) -> bool {
        self.framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_numerator(&mut self, v: u32) {
        self.framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_denominator = 4;

    pub fn get_framerate_denominator(&self) -> u32 {
        self.framerate_denominator.unwrap_or(0)
    }

    pub fn clear_framerate_denominator(&mut self) {
        self.framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_framerate_denominator(&self) -> bool {
        self.framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_denominator(&mut self, v: u32) {
        self.framerate_denominator = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTargetFramerateMsg {
    fn is_initialized(&self) -> bool {
        if self.framerate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reasons = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.framerate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.framerate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reasons {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.framerate_numerator {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.framerate_denominator {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.framerate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reasons {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.framerate_numerator {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.framerate_denominator {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTargetFramerateMsg {
        CSetTargetFramerateMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "framerate",
                |m: &CSetTargetFramerateMsg| { &m.framerate },
                |m: &mut CSetTargetFramerateMsg| { &mut m.framerate },
                CSetTargetFramerateMsg::get_framerate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "reasons",
                |m: &CSetTargetFramerateMsg| { &m.reasons },
                |m: &mut CSetTargetFramerateMsg| { &mut m.reasons },
                CSetTargetFramerateMsg::get_reasons,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "framerate_numerator",
                |m: &CSetTargetFramerateMsg| { &m.framerate_numerator },
                |m: &mut CSetTargetFramerateMsg| { &mut m.framerate_numerator },
                CSetTargetFramerateMsg::get_framerate_numerator,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "framerate_denominator",
                |m: &CSetTargetFramerateMsg| { &m.framerate_denominator },
                |m: &mut CSetTargetFramerateMsg| { &mut m.framerate_denominator },
                CSetTargetFramerateMsg::get_framerate_denominator,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetTargetFramerateMsg>(
                "CSetTargetFramerateMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTargetFramerateMsg {
        static instance: ::protobuf::rt::Lazy<CSetTargetFramerateMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetTargetFramerateMsg::new)
    }
}

impl ::protobuf::Clear for CSetTargetFramerateMsg {
    fn clear(&mut self) {
        self.framerate = ::std::option::Option::None;
        self.reasons = ::std::option::Option::None;
        self.framerate_numerator = ::std::option::Option::None;
        self.framerate_denominator = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTargetFramerateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTargetFramerateMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTargetBitrateMsg {
    // message fields
    bitrate: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTargetBitrateMsg {
    fn default() -> &'a CSetTargetBitrateMsg {
        <CSetTargetBitrateMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTargetBitrateMsg {
    pub fn new() -> CSetTargetBitrateMsg {
        ::std::default::Default::default()
    }

    // required int32 bitrate = 1;

    pub fn get_bitrate(&self) -> i32 {
        self.bitrate.unwrap_or(0)
    }

    pub fn clear_bitrate(&mut self) {
        self.bitrate = ::std::option::Option::None;
    }

    pub fn has_bitrate(&self) -> bool {
        self.bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: i32) {
        self.bitrate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetTargetBitrateMsg {
    fn is_initialized(&self) -> bool {
        if self.bitrate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bitrate = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bitrate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bitrate {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTargetBitrateMsg {
        CSetTargetBitrateMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "bitrate",
                |m: &CSetTargetBitrateMsg| { &m.bitrate },
                |m: &mut CSetTargetBitrateMsg| { &mut m.bitrate },
                CSetTargetBitrateMsg::get_bitrate,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetTargetBitrateMsg>(
                "CSetTargetBitrateMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTargetBitrateMsg {
        static instance: ::protobuf::rt::Lazy<CSetTargetBitrateMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetTargetBitrateMsg::new)
    }
}

impl ::protobuf::Clear for CSetTargetBitrateMsg {
    fn clear(&mut self) {
        self.bitrate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTargetBitrateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTargetBitrateMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct COverlayEnabledMsg {
    // message fields
    enabled: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a COverlayEnabledMsg {
    fn default() -> &'a COverlayEnabledMsg {
        <COverlayEnabledMsg as ::protobuf::Message>::default_instance()
    }
}

impl COverlayEnabledMsg {
    pub fn new() -> COverlayEnabledMsg {
        ::std::default::Default::default()
    }

    // required bool enabled = 1;

    pub fn get_enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for COverlayEnabledMsg {
    fn is_initialized(&self) -> bool {
        if self.enabled.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> COverlayEnabledMsg {
        COverlayEnabledMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enabled",
                |m: &COverlayEnabledMsg| { &m.enabled },
                |m: &mut COverlayEnabledMsg| { &mut m.enabled },
                COverlayEnabledMsg::get_enabled,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<COverlayEnabledMsg>(
                "COverlayEnabledMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static COverlayEnabledMsg {
        static instance: ::protobuf::rt::Lazy<COverlayEnabledMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(COverlayEnabledMsg::new)
    }
}

impl ::protobuf::Clear for COverlayEnabledMsg {
    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for COverlayEnabledMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for COverlayEnabledMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetGammaRampMsg {
    // message fields
    gamma_ramp: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetGammaRampMsg {
    fn default() -> &'a CSetGammaRampMsg {
        <CSetGammaRampMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetGammaRampMsg {
    pub fn new() -> CSetGammaRampMsg {
        ::std::default::Default::default()
    }

    // optional bytes gamma_ramp = 1;

    pub fn get_gamma_ramp(&self) -> &[u8] {
        match self.gamma_ramp.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gamma_ramp(&mut self) {
        self.gamma_ramp.clear();
    }

    pub fn has_gamma_ramp(&self) -> bool {
        self.gamma_ramp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma_ramp(&mut self, v: ::std::vec::Vec<u8>) {
        self.gamma_ramp = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma_ramp(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gamma_ramp.is_none() {
            self.gamma_ramp.set_default();
        }
        self.gamma_ramp.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma_ramp(&mut self) -> ::std::vec::Vec<u8> {
        self.gamma_ramp.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetGammaRampMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gamma_ramp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gamma_ramp.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gamma_ramp.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetGammaRampMsg {
        CSetGammaRampMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "gamma_ramp",
                |m: &CSetGammaRampMsg| { &m.gamma_ramp },
                |m: &mut CSetGammaRampMsg| { &mut m.gamma_ramp },
                CSetGammaRampMsg::get_gamma_ramp,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetGammaRampMsg>(
                "CSetGammaRampMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetGammaRampMsg {
        static instance: ::protobuf::rt::Lazy<CSetGammaRampMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetGammaRampMsg::new)
    }
}

impl ::protobuf::Clear for CSetGammaRampMsg {
    fn clear(&mut self) {
        self.gamma_ramp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetGammaRampMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetGammaRampMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetActivityMsg {
    // message fields
    activity: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamActivity>>,
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetActivityMsg {
    fn default() -> &'a CSetActivityMsg {
        <CSetActivityMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetActivityMsg {
    pub fn new() -> CSetActivityMsg {
        ::std::default::Default::default()
    }

    // optional .EStreamActivity activity = 1;

    pub fn get_activity(&self) -> EStreamActivity {
        match self.activity {
            Some(e) => e.enum_value_or(EStreamActivity::k_EStreamActivityIdle),
            None => EStreamActivity::k_EStreamActivityIdle,
        }
    }

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: EStreamActivity) {
        self.activity = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional uint32 appid = 2;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetActivityMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.activity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.activity {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetActivityMsg {
        CSetActivityMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamActivity>(
                "activity",
                |m: &CSetActivityMsg| { &m.activity },
                |m: &mut CSetActivityMsg| { &mut m.activity },
                EStreamActivity::k_EStreamActivityIdle,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CSetActivityMsg| { &m.appid },
                |m: &mut CSetActivityMsg| { &mut m.appid },
                CSetActivityMsg::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetActivityMsg>(
                "CSetActivityMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetActivityMsg {
        static instance: ::protobuf::rt::Lazy<CSetActivityMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetActivityMsg::new)
    }
}

impl ::protobuf::Clear for CSetActivityMsg {
    fn clear(&mut self) {
        self.activity = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetActivityMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetActivityMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSystemSuspendMsg {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSystemSuspendMsg {
    fn default() -> &'a CSystemSuspendMsg {
        <CSystemSuspendMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSystemSuspendMsg {
    pub fn new() -> CSystemSuspendMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CSystemSuspendMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSystemSuspendMsg {
        CSystemSuspendMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new::<CSystemSuspendMsg>(
                "CSystemSuspendMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSystemSuspendMsg {
        static instance: ::protobuf::rt::Lazy<CSystemSuspendMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSystemSuspendMsg::new)
    }
}

impl ::protobuf::Clear for CSystemSuspendMsg {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSystemSuspendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSystemSuspendMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereRequestMsg {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVirtualHereRequestMsg {
    fn default() -> &'a CVirtualHereRequestMsg {
        <CVirtualHereRequestMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereRequestMsg {
    pub fn new() -> CVirtualHereRequestMsg {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVirtualHereRequestMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVirtualHereRequestMsg {
        CVirtualHereRequestMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "hostname",
                |m: &CVirtualHereRequestMsg| { &m.hostname },
                |m: &mut CVirtualHereRequestMsg| { &mut m.hostname },
                CVirtualHereRequestMsg::get_hostname,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CVirtualHereRequestMsg>(
                "CVirtualHereRequestMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVirtualHereRequestMsg {
        static instance: ::protobuf::rt::Lazy<CVirtualHereRequestMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CVirtualHereRequestMsg::new)
    }
}

impl ::protobuf::Clear for CVirtualHereRequestMsg {
    fn clear(&mut self) {
        self.hostname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereRequestMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereReadyMsg {
    // message fields
    licensed_device_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVirtualHereReadyMsg {
    fn default() -> &'a CVirtualHereReadyMsg {
        <CVirtualHereReadyMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereReadyMsg {
    pub fn new() -> CVirtualHereReadyMsg {
        ::std::default::Default::default()
    }

    // optional uint32 licensed_device_count = 1;

    pub fn get_licensed_device_count(&self) -> u32 {
        self.licensed_device_count.unwrap_or(0)
    }

    pub fn clear_licensed_device_count(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
    }

    pub fn has_licensed_device_count(&self) -> bool {
        self.licensed_device_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_licensed_device_count(&mut self, v: u32) {
        self.licensed_device_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVirtualHereReadyMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.licensed_device_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.licensed_device_count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.licensed_device_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVirtualHereReadyMsg {
        CVirtualHereReadyMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "licensed_device_count",
                |m: &CVirtualHereReadyMsg| { &m.licensed_device_count },
                |m: &mut CVirtualHereReadyMsg| { &mut m.licensed_device_count },
                CVirtualHereReadyMsg::get_licensed_device_count,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CVirtualHereReadyMsg>(
                "CVirtualHereReadyMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVirtualHereReadyMsg {
        static instance: ::protobuf::rt::Lazy<CVirtualHereReadyMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CVirtualHereReadyMsg::new)
    }
}

impl ::protobuf::Clear for CVirtualHereReadyMsg {
    fn clear(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereReadyMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereReadyMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CVirtualHereShareDeviceMsg {
    // message fields
    device_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVirtualHereShareDeviceMsg {
    fn default() -> &'a CVirtualHereShareDeviceMsg {
        <CVirtualHereShareDeviceMsg as ::protobuf::Message>::default_instance()
    }
}

impl CVirtualHereShareDeviceMsg {
    pub fn new() -> CVirtualHereShareDeviceMsg {
        ::std::default::Default::default()
    }

    // optional string device_address = 1;

    pub fn get_device_address(&self) -> &str {
        match self.device_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_address(&mut self) {
        self.device_address.clear();
    }

    pub fn has_device_address(&self) -> bool {
        self.device_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_address(&mut self, v: ::std::string::String) {
        self.device_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_address(&mut self) -> &mut ::std::string::String {
        if self.device_address.is_none() {
            self.device_address.set_default();
        }
        self.device_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_address(&mut self) -> ::std::string::String {
        self.device_address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CVirtualHereShareDeviceMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.device_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.device_address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.device_address.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVirtualHereShareDeviceMsg {
        CVirtualHereShareDeviceMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "device_address",
                |m: &CVirtualHereShareDeviceMsg| { &m.device_address },
                |m: &mut CVirtualHereShareDeviceMsg| { &mut m.device_address },
                CVirtualHereShareDeviceMsg::get_device_address,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CVirtualHereShareDeviceMsg>(
                "CVirtualHereShareDeviceMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVirtualHereShareDeviceMsg {
        static instance: ::protobuf::rt::Lazy<CVirtualHereShareDeviceMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CVirtualHereShareDeviceMsg::new)
    }
}

impl ::protobuf::Clear for CVirtualHereShareDeviceMsg {
    fn clear(&mut self) {
        self.device_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVirtualHereShareDeviceMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVirtualHereShareDeviceMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetSpectatorModeMsg {
    // message fields
    enabled: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetSpectatorModeMsg {
    fn default() -> &'a CSetSpectatorModeMsg {
        <CSetSpectatorModeMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetSpectatorModeMsg {
    pub fn new() -> CSetSpectatorModeMsg {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn get_enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSetSpectatorModeMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetSpectatorModeMsg {
        CSetSpectatorModeMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBool, _>(
                "enabled",
                |m: &CSetSpectatorModeMsg| { &m.enabled },
                |m: &mut CSetSpectatorModeMsg| { &mut m.enabled },
                CSetSpectatorModeMsg::get_enabled,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetSpectatorModeMsg>(
                "CSetSpectatorModeMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetSpectatorModeMsg {
        static instance: ::protobuf::rt::Lazy<CSetSpectatorModeMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetSpectatorModeMsg::new)
    }
}

impl ::protobuf::Clear for CSetSpectatorModeMsg {
    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetSpectatorModeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetSpectatorModeMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CRemoteHIDMsg {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CRemoteHIDMsg {
    fn default() -> &'a CRemoteHIDMsg {
        <CRemoteHIDMsg as ::protobuf::Message>::default_instance()
    }
}

impl CRemoteHIDMsg {
    pub fn new() -> CRemoteHIDMsg {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CRemoteHIDMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CRemoteHIDMsg {
        CRemoteHIDMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "data",
                |m: &CRemoteHIDMsg| { &m.data },
                |m: &mut CRemoteHIDMsg| { &mut m.data },
                CRemoteHIDMsg::get_data,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CRemoteHIDMsg>(
                "CRemoteHIDMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CRemoteHIDMsg {
        static instance: ::protobuf::rt::Lazy<CRemoteHIDMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CRemoteHIDMsg::new)
    }
}

impl ::protobuf::Clear for CRemoteHIDMsg {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CRemoteHIDMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CRemoteHIDMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CTouchConfigActiveMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    revision: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTouchConfigActiveMsg {
    fn default() -> &'a CTouchConfigActiveMsg {
        <CTouchConfigActiveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchConfigActiveMsg {
    pub fn new() -> CTouchConfigActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;

    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchConfigActiveMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTouchConfigActiveMsg {
        CTouchConfigActiveMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CTouchConfigActiveMsg| { &m.appid },
                |m: &mut CTouchConfigActiveMsg| { &mut m.appid },
                CTouchConfigActiveMsg::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "revision",
                |m: &CTouchConfigActiveMsg| { &m.revision },
                |m: &mut CTouchConfigActiveMsg| { &mut m.revision },
                CTouchConfigActiveMsg::get_revision,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CTouchConfigActiveMsg>(
                "CTouchConfigActiveMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTouchConfigActiveMsg {
        static instance: ::protobuf::rt::Lazy<CTouchConfigActiveMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CTouchConfigActiveMsg::new)
    }
}

impl ::protobuf::Clear for CTouchConfigActiveMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTouchConfigActiveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTouchConfigActiveMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CGetTouchConfigDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGetTouchConfigDataMsg {
    fn default() -> &'a CGetTouchConfigDataMsg {
        <CGetTouchConfigDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetTouchConfigDataMsg {
    pub fn new() -> CGetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGetTouchConfigDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGetTouchConfigDataMsg {
        CGetTouchConfigDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CGetTouchConfigDataMsg| { &m.appid },
                |m: &mut CGetTouchConfigDataMsg| { &mut m.appid },
                CGetTouchConfigDataMsg::get_appid,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CGetTouchConfigDataMsg>(
                "CGetTouchConfigDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGetTouchConfigDataMsg {
        static instance: ::protobuf::rt::Lazy<CGetTouchConfigDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CGetTouchConfigDataMsg::new)
    }
}

impl ::protobuf::Clear for CGetTouchConfigDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGetTouchConfigDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGetTouchConfigDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTouchConfigDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    revision: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    layout: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTouchConfigDataMsg {
    fn default() -> &'a CSetTouchConfigDataMsg {
        <CSetTouchConfigDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTouchConfigDataMsg {
    pub fn new() -> CSetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;

    pub fn get_revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes layout = 4;

    pub fn get_layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_layout(&mut self) {
        self.layout.clear();
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::std::vec::Vec<u8>) {
        self.layout = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.layout.is_none() {
            self.layout.set_default();
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::std::vec::Vec<u8> {
        self.layout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetTouchConfigDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.layout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revision {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.layout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.layout.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTouchConfigDataMsg {
        CSetTouchConfigDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CSetTouchConfigDataMsg| { &m.appid },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.appid },
                CSetTouchConfigDataMsg::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "revision",
                |m: &CSetTouchConfigDataMsg| { &m.revision },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.revision },
                CSetTouchConfigDataMsg::get_revision,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "data",
                |m: &CSetTouchConfigDataMsg| { &m.data },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.data },
                CSetTouchConfigDataMsg::get_data,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "layout",
                |m: &CSetTouchConfigDataMsg| { &m.layout },
                |m: &mut CSetTouchConfigDataMsg| { &mut m.layout },
                CSetTouchConfigDataMsg::get_layout,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetTouchConfigDataMsg>(
                "CSetTouchConfigDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTouchConfigDataMsg {
        static instance: ::protobuf::rt::Lazy<CSetTouchConfigDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetTouchConfigDataMsg::new)
    }
}

impl ::protobuf::Clear for CSetTouchConfigDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.data.clear();
        self.layout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTouchConfigDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTouchConfigDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSaveTouchConfigLayoutMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    layout: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSaveTouchConfigLayoutMsg {
    fn default() -> &'a CSaveTouchConfigLayoutMsg {
        <CSaveTouchConfigLayoutMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSaveTouchConfigLayoutMsg {
    pub fn new() -> CSaveTouchConfigLayoutMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bytes layout = 4;

    pub fn get_layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_layout(&mut self) {
        self.layout.clear();
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::std::vec::Vec<u8>) {
        self.layout = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.layout.is_none() {
            self.layout.set_default();
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::std::vec::Vec<u8> {
        self.layout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSaveTouchConfigLayoutMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.layout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.layout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.layout.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSaveTouchConfigLayoutMsg {
        CSaveTouchConfigLayoutMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CSaveTouchConfigLayoutMsg| { &m.appid },
                |m: &mut CSaveTouchConfigLayoutMsg| { &mut m.appid },
                CSaveTouchConfigLayoutMsg::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "layout",
                |m: &CSaveTouchConfigLayoutMsg| { &m.layout },
                |m: &mut CSaveTouchConfigLayoutMsg| { &mut m.layout },
                CSaveTouchConfigLayoutMsg::get_layout,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSaveTouchConfigLayoutMsg>(
                "CSaveTouchConfigLayoutMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSaveTouchConfigLayoutMsg {
        static instance: ::protobuf::rt::Lazy<CSaveTouchConfigLayoutMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSaveTouchConfigLayoutMsg::new)
    }
}

impl ::protobuf::Clear for CSaveTouchConfigLayoutMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.layout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSaveTouchConfigLayoutMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSaveTouchConfigLayoutMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CTouchActionSetActiveMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    actionset_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetActiveMsg {
    fn default() -> &'a CTouchActionSetActiveMsg {
        <CTouchActionSetActiveMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTouchActionSetActiveMsg {
    pub fn new() -> CTouchActionSetActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;

    pub fn get_actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }

    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTouchActionSetActiveMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.actionset_id = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actionset_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTouchActionSetActiveMsg {
        CTouchActionSetActiveMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CTouchActionSetActiveMsg| { &m.appid },
                |m: &mut CTouchActionSetActiveMsg| { &mut m.appid },
                CTouchActionSetActiveMsg::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "actionset_id",
                |m: &CTouchActionSetActiveMsg| { &m.actionset_id },
                |m: &mut CTouchActionSetActiveMsg| { &mut m.actionset_id },
                CTouchActionSetActiveMsg::get_actionset_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CTouchActionSetActiveMsg>(
                "CTouchActionSetActiveMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTouchActionSetActiveMsg {
        static instance: ::protobuf::rt::Lazy<CTouchActionSetActiveMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CTouchActionSetActiveMsg::new)
    }
}

impl ::protobuf::Clear for CTouchActionSetActiveMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTouchActionSetActiveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTouchActionSetActiveMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CGetTouchIconDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    icon: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGetTouchIconDataMsg {
    fn default() -> &'a CGetTouchIconDataMsg {
        <CGetTouchIconDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CGetTouchIconDataMsg {
    pub fn new() -> CGetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn get_icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CGetTouchIconDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGetTouchIconDataMsg {
        CGetTouchIconDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CGetTouchIconDataMsg| { &m.appid },
                |m: &mut CGetTouchIconDataMsg| { &mut m.appid },
                CGetTouchIconDataMsg::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "icon",
                |m: &CGetTouchIconDataMsg| { &m.icon },
                |m: &mut CGetTouchIconDataMsg| { &mut m.icon },
                CGetTouchIconDataMsg::get_icon,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CGetTouchIconDataMsg>(
                "CGetTouchIconDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGetTouchIconDataMsg {
        static instance: ::protobuf::rt::Lazy<CGetTouchIconDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CGetTouchIconDataMsg::new)
    }
}

impl ::protobuf::Clear for CGetTouchIconDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGetTouchIconDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGetTouchIconDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CSetTouchIconDataMsg {
    // message fields
    appid: ::std::option::Option<u32>,
    icon: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSetTouchIconDataMsg {
    fn default() -> &'a CSetTouchIconDataMsg {
        <CSetTouchIconDataMsg as ::protobuf::Message>::default_instance()
    }
}

impl CSetTouchIconDataMsg {
    pub fn new() -> CSetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn get_icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSetTouchIconDataMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSetTouchIconDataMsg {
        CSetTouchIconDataMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "appid",
                |m: &CSetTouchIconDataMsg| { &m.appid },
                |m: &mut CSetTouchIconDataMsg| { &mut m.appid },
                CSetTouchIconDataMsg::get_appid,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "icon",
                |m: &CSetTouchIconDataMsg| { &m.icon },
                |m: &mut CSetTouchIconDataMsg| { &mut m.icon },
                CSetTouchIconDataMsg::get_icon,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "data",
                |m: &CSetTouchIconDataMsg| { &m.data },
                |m: &mut CSetTouchIconDataMsg| { &mut m.data },
                CSetTouchIconDataMsg::get_data,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CSetTouchIconDataMsg>(
                "CSetTouchIconDataMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSetTouchIconDataMsg {
        static instance: ::protobuf::rt::Lazy<CSetTouchIconDataMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CSetTouchIconDataMsg::new)
    }
}

impl ::protobuf::Clear for CSetTouchIconDataMsg {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSetTouchIconDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSetTouchIconDataMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamDataLostMsg {
    // message fields
    pub packets: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamDataLostMsg {
    fn default() -> &'a CStreamDataLostMsg {
        <CStreamDataLostMsg as ::protobuf::Message>::default_instance()
    }
}

impl CStreamDataLostMsg {
    pub fn new() -> CStreamDataLostMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CStreamDataLostMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.packets {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.packets {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamDataLostMsg {
        CStreamDataLostMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_vec_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32>(
                "packets",
                |m: &CStreamDataLostMsg| { &m.packets },
                |m: &mut CStreamDataLostMsg| { &mut m.packets },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamDataLostMsg>(
                "CStreamDataLostMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamDataLostMsg {
        static instance: ::protobuf::rt::Lazy<CStreamDataLostMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamDataLostMsg::new)
    }
}

impl ::protobuf::Clear for CStreamDataLostMsg {
    fn clear(&mut self) {
        self.packets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamDataLostMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamDataLostMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CAudioFormat {
    // message fields
    format: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EAudioFormat>>,
    frequency: ::std::option::Option<u32>,
    channels: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAudioFormat {
    fn default() -> &'a CAudioFormat {
        <CAudioFormat as ::protobuf::Message>::default_instance()
    }
}

impl CAudioFormat {
    pub fn new() -> CAudioFormat {
        ::std::default::Default::default()
    }

    // required .EAudioFormat format = 1;

    pub fn get_format(&self) -> EAudioFormat {
        match self.format {
            Some(e) => e.enum_value_or(EAudioFormat::k_EAudioFormatNone),
            None => EAudioFormat::k_EAudioFormatNone,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EAudioFormat) {
        self.format = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional uint32 frequency = 2;

    pub fn get_frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 3;

    pub fn get_channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAudioFormat {
    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frequency = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channels = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.frequency {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.channels {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAudioFormat {
        CAudioFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EAudioFormat>(
                "format",
                |m: &CAudioFormat| { &m.format },
                |m: &mut CAudioFormat| { &mut m.format },
                EAudioFormat::k_EAudioFormatNone,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "frequency",
                |m: &CAudioFormat| { &m.frequency },
                |m: &mut CAudioFormat| { &mut m.frequency },
                CAudioFormat::get_frequency,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "channels",
                |m: &CAudioFormat| { &m.channels },
                |m: &mut CAudioFormat| { &mut m.channels },
                CAudioFormat::get_channels,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CAudioFormat>(
                "CAudioFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAudioFormat {
        static instance: ::protobuf::rt::Lazy<CAudioFormat> = ::protobuf::rt::Lazy::INIT;
        instance.get(CAudioFormat::new)
    }
}

impl ::protobuf::Clear for CAudioFormat {
    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAudioFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAudioFormat {
}

#[derive(PartialEq,Clone,Default)]
pub struct CVideoFormat {
    // message fields
    format: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EVideoFormat>>,
    width: ::std::option::Option<u32>,
    height: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CVideoFormat {
    fn default() -> &'a CVideoFormat {
        <CVideoFormat as ::protobuf::Message>::default_instance()
    }
}

impl CVideoFormat {
    pub fn new() -> CVideoFormat {
        ::std::default::Default::default()
    }

    // required .EVideoFormat format = 1;

    pub fn get_format(&self) -> EVideoFormat {
        match self.format {
            Some(e) => e.enum_value_or(EVideoFormat::k_EVideoFormatNone),
            None => EVideoFormat::k_EVideoFormatNone,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EVideoFormat) {
        self.format = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional uint32 width = 2;

    pub fn get_width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;

    pub fn get_height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CVideoFormat {
    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CVideoFormat {
        CVideoFormat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EVideoFormat>(
                "format",
                |m: &CVideoFormat| { &m.format },
                |m: &mut CVideoFormat| { &mut m.format },
                EVideoFormat::k_EVideoFormatNone,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "width",
                |m: &CVideoFormat| { &m.width },
                |m: &mut CVideoFormat| { &mut m.width },
                CVideoFormat::get_width,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "height",
                |m: &CVideoFormat| { &m.height },
                |m: &mut CVideoFormat| { &mut m.height },
                CVideoFormat::get_height,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CVideoFormat>(
                "CVideoFormat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CVideoFormat {
        static instance: ::protobuf::rt::Lazy<CVideoFormat> = ::protobuf::rt::Lazy::INIT;
        instance.get(CVideoFormat::new)
    }
}

impl ::protobuf::Clear for CVideoFormat {
    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CVideoFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVideoFormat {
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameEvent {
    // message fields
    event_id: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamFrameEvent>>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameEvent {
    fn default() -> &'a CFrameEvent {
        <CFrameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CFrameEvent {
    pub fn new() -> CFrameEvent {
        ::std::default::Default::default()
    }

    // required .EStreamFrameEvent event_id = 1;

    pub fn get_event_id(&self) -> EStreamFrameEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(EStreamFrameEvent::k_EStreamInputEventStart),
            None => EStreamFrameEvent::k_EStreamInputEventStart,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EStreamFrameEvent) {
        self.event_id = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // required uint32 timestamp = 2;

    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameEvent {
    fn is_initialized(&self) -> bool {
        if self.event_id.is_none() {
            return false;
        }
        if self.timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameEvent {
        CFrameEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamFrameEvent>(
                "event_id",
                |m: &CFrameEvent| { &m.event_id },
                |m: &mut CFrameEvent| { &mut m.event_id },
                EStreamFrameEvent::k_EStreamInputEventStart,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "timestamp",
                |m: &CFrameEvent| { &m.timestamp },
                |m: &mut CFrameEvent| { &mut m.timestamp },
                CFrameEvent::get_timestamp,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CFrameEvent>(
                "CFrameEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameEvent {
        static instance: ::protobuf::rt::Lazy<CFrameEvent> = ::protobuf::rt::Lazy::INIT;
        instance.get(CFrameEvent::new)
    }
}

impl ::protobuf::Clear for CFrameEvent {
    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameEvent {
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStats {
    // message fields
    frame_id: ::std::option::Option<u32>,
    input_mark: ::std::option::Option<u32>,
    pub events: ::protobuf::RepeatedField<CFrameEvent>,
    result: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamFrameResult>>,
    frame_start_delta: ::std::option::Option<f32>,
    frame_display_delta: ::std::option::Option<f32>,
    ping_time: ::std::option::Option<f32>,
    server_bitrate: ::std::option::Option<f32>,
    client_bitrate: ::std::option::Option<f32>,
    link_bandwidth: ::std::option::Option<f32>,
    packet_loss: ::std::option::Option<f32>,
    frame_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameStats {
    fn default() -> &'a CFrameStats {
        <CFrameStats as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStats {
    pub fn new() -> CFrameStats {
        ::std::default::Default::default()
    }

    // required uint32 frame_id = 1;

    pub fn get_frame_id(&self) -> u32 {
        self.frame_id.unwrap_or(0)
    }

    pub fn clear_frame_id(&mut self) {
        self.frame_id = ::std::option::Option::None;
    }

    pub fn has_frame_id(&self) -> bool {
        self.frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_id(&mut self, v: u32) {
        self.frame_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_mark = 2;

    pub fn get_input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamFrameResult result = 4;

    pub fn get_result(&self) -> EStreamFrameResult {
        match self.result {
            Some(e) => e.enum_value_or(EStreamFrameResult::k_EStreamFrameResultPending),
            None => EStreamFrameResult::k_EStreamFrameResultPending,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EStreamFrameResult) {
        self.result = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional float frame_start_delta = 5;

    pub fn get_frame_start_delta(&self) -> f32 {
        self.frame_start_delta.unwrap_or(0.)
    }

    pub fn clear_frame_start_delta(&mut self) {
        self.frame_start_delta = ::std::option::Option::None;
    }

    pub fn has_frame_start_delta(&self) -> bool {
        self.frame_start_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_start_delta(&mut self, v: f32) {
        self.frame_start_delta = ::std::option::Option::Some(v);
    }

    // optional float frame_display_delta = 6;

    pub fn get_frame_display_delta(&self) -> f32 {
        self.frame_display_delta.unwrap_or(0.)
    }

    pub fn clear_frame_display_delta(&mut self) {
        self.frame_display_delta = ::std::option::Option::None;
    }

    pub fn has_frame_display_delta(&self) -> bool {
        self.frame_display_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_display_delta(&mut self, v: f32) {
        self.frame_display_delta = ::std::option::Option::Some(v);
    }

    // optional float ping_time = 7;

    pub fn get_ping_time(&self) -> f32 {
        self.ping_time.unwrap_or(0.)
    }

    pub fn clear_ping_time(&mut self) {
        self.ping_time = ::std::option::Option::None;
    }

    pub fn has_ping_time(&self) -> bool {
        self.ping_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: f32) {
        self.ping_time = ::std::option::Option::Some(v);
    }

    // optional float server_bitrate = 8;

    pub fn get_server_bitrate(&self) -> f32 {
        self.server_bitrate.unwrap_or(0.)
    }

    pub fn clear_server_bitrate(&mut self) {
        self.server_bitrate = ::std::option::Option::None;
    }

    pub fn has_server_bitrate(&self) -> bool {
        self.server_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_bitrate(&mut self, v: f32) {
        self.server_bitrate = ::std::option::Option::Some(v);
    }

    // optional float client_bitrate = 9;

    pub fn get_client_bitrate(&self) -> f32 {
        self.client_bitrate.unwrap_or(0.)
    }

    pub fn clear_client_bitrate(&mut self) {
        self.client_bitrate = ::std::option::Option::None;
    }

    pub fn has_client_bitrate(&self) -> bool {
        self.client_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_bitrate(&mut self, v: f32) {
        self.client_bitrate = ::std::option::Option::Some(v);
    }

    // optional float link_bandwidth = 10;

    pub fn get_link_bandwidth(&self) -> f32 {
        self.link_bandwidth.unwrap_or(0.)
    }

    pub fn clear_link_bandwidth(&mut self) {
        self.link_bandwidth = ::std::option::Option::None;
    }

    pub fn has_link_bandwidth(&self) -> bool {
        self.link_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_bandwidth(&mut self, v: f32) {
        self.link_bandwidth = ::std::option::Option::Some(v);
    }

    // optional float packet_loss = 11;

    pub fn get_packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }

    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 frame_size = 12;

    pub fn get_frame_size(&self) -> u32 {
        self.frame_size.unwrap_or(0)
    }

    pub fn clear_frame_size(&mut self) {
        self.frame_size = ::std::option::Option::None;
    }

    pub fn has_frame_size(&self) -> bool {
        self.frame_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_size(&mut self, v: u32) {
        self.frame_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStats {
    fn is_initialized(&self) -> bool {
        if self.frame_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frame_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.events)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frame_start_delta = ::std::option::Option::Some(is.read_float()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frame_display_delta = ::std::option::Option::Some(is.read_float()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ping_time = ::std::option::Option::Some(is.read_float()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.server_bitrate = ::std::option::Option::Some(is.read_float()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.client_bitrate = ::std::option::Option::Some(is.read_float()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.link_bandwidth = ::std::option::Option::Some(is.read_float()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.packet_loss = ::std::option::Option::Some(is.read_float()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frame_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frame_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.input_mark {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_or_unknown_size(4, v);
        }
        if let Some(v) = self.frame_start_delta {
            my_size += 5;
        }
        if let Some(v) = self.frame_display_delta {
            my_size += 5;
        }
        if let Some(v) = self.ping_time {
            my_size += 5;
        }
        if let Some(v) = self.server_bitrate {
            my_size += 5;
        }
        if let Some(v) = self.client_bitrate {
            my_size += 5;
        }
        if let Some(v) = self.link_bandwidth {
            my_size += 5;
        }
        if let Some(v) = self.packet_loss {
            my_size += 5;
        }
        if let Some(v) = self.frame_size {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frame_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.input_mark {
            os.write_uint32(2, v)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.result {
            os.write_enum(4, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frame_start_delta {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.frame_display_delta {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ping_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.server_bitrate {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.client_bitrate {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.link_bandwidth {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.packet_loss {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.frame_size {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameStats {
        CFrameStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "frame_id",
                |m: &CFrameStats| { &m.frame_id },
                |m: &mut CFrameStats| { &mut m.frame_id },
                CFrameStats::get_frame_id,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "input_mark",
                |m: &CFrameStats| { &m.input_mark },
                |m: &mut CFrameStats| { &mut m.input_mark },
                CFrameStats::get_input_mark,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CFrameEvent>>(
                "events",
                |m: &CFrameStats| { &m.events },
                |m: &mut CFrameStats| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamFrameResult>(
                "result",
                |m: &CFrameStats| { &m.result },
                |m: &mut CFrameStats| { &mut m.result },
                EStreamFrameResult::k_EStreamFrameResultPending,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "frame_start_delta",
                |m: &CFrameStats| { &m.frame_start_delta },
                |m: &mut CFrameStats| { &mut m.frame_start_delta },
                CFrameStats::get_frame_start_delta,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "frame_display_delta",
                |m: &CFrameStats| { &m.frame_display_delta },
                |m: &mut CFrameStats| { &mut m.frame_display_delta },
                CFrameStats::get_frame_display_delta,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "ping_time",
                |m: &CFrameStats| { &m.ping_time },
                |m: &mut CFrameStats| { &mut m.ping_time },
                CFrameStats::get_ping_time,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "server_bitrate",
                |m: &CFrameStats| { &m.server_bitrate },
                |m: &mut CFrameStats| { &mut m.server_bitrate },
                CFrameStats::get_server_bitrate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "client_bitrate",
                |m: &CFrameStats| { &m.client_bitrate },
                |m: &mut CFrameStats| { &mut m.client_bitrate },
                CFrameStats::get_client_bitrate,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "link_bandwidth",
                |m: &CFrameStats| { &m.link_bandwidth },
                |m: &mut CFrameStats| { &mut m.link_bandwidth },
                CFrameStats::get_link_bandwidth,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "packet_loss",
                |m: &CFrameStats| { &m.packet_loss },
                |m: &mut CFrameStats| { &mut m.packet_loss },
                CFrameStats::get_packet_loss,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeUint32, _>(
                "frame_size",
                |m: &CFrameStats| { &m.frame_size },
                |m: &mut CFrameStats| { &mut m.frame_size },
                CFrameStats::get_frame_size,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CFrameStats>(
                "CFrameStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameStats {
        static instance: ::protobuf::rt::Lazy<CFrameStats> = ::protobuf::rt::Lazy::INIT;
        instance.get(CFrameStats::new)
    }
}

impl ::protobuf::Clear for CFrameStats {
    fn clear(&mut self) {
        self.frame_id = ::std::option::Option::None;
        self.input_mark = ::std::option::Option::None;
        self.events.clear();
        self.result = ::std::option::Option::None;
        self.frame_start_delta = ::std::option::Option::None;
        self.frame_display_delta = ::std::option::Option::None;
        self.ping_time = ::std::option::Option::None;
        self.server_bitrate = ::std::option::Option::None;
        self.client_bitrate = ::std::option::Option::None;
        self.link_bandwidth = ::std::option::Option::None;
        self.packet_loss = ::std::option::Option::None;
        self.frame_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStats {
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStatAccumulatedValue {
    // message fields
    stat_type: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EFrameAccumulatedStat>>,
    count: ::std::option::Option<i32>,
    average: ::std::option::Option<f32>,
    stddev: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameStatAccumulatedValue {
    fn default() -> &'a CFrameStatAccumulatedValue {
        <CFrameStatAccumulatedValue as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStatAccumulatedValue {
    pub fn new() -> CFrameStatAccumulatedValue {
        ::std::default::Default::default()
    }

    // required .EFrameAccumulatedStat stat_type = 1;

    pub fn get_stat_type(&self) -> EFrameAccumulatedStat {
        match self.stat_type {
            Some(e) => e.enum_value_or(EFrameAccumulatedStat::k_EFrameStatFPS),
            None => EFrameAccumulatedStat::k_EFrameStatFPS,
        }
    }

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EFrameAccumulatedStat) {
        self.stat_type = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // required int32 count = 2;

    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // required float average = 3;

    pub fn get_average(&self) -> f32 {
        self.average.unwrap_or(0.)
    }

    pub fn clear_average(&mut self) {
        self.average = ::std::option::Option::None;
    }

    pub fn has_average(&self) -> bool {
        self.average.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average(&mut self, v: f32) {
        self.average = ::std::option::Option::Some(v);
    }

    // optional float stddev = 4;

    pub fn get_stddev(&self) -> f32 {
        self.stddev.unwrap_or(0.)
    }

    pub fn clear_stddev(&mut self) {
        self.stddev = ::std::option::Option::None;
    }

    pub fn has_stddev(&self) -> bool {
        self.stddev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev(&mut self, v: f32) {
        self.stddev = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStatAccumulatedValue {
    fn is_initialized(&self) -> bool {
        if self.stat_type.is_none() {
            return false;
        }
        if self.count.is_none() {
            return false;
        }
        if self.average.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.average = ::std::option::Option::Some(is.read_float()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stddev = ::std::option::Option::Some(is.read_float()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.average {
            my_size += 5;
        }
        if let Some(v) = self.stddev {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.average {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.stddev {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameStatAccumulatedValue {
        CFrameStatAccumulatedValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EFrameAccumulatedStat>(
                "stat_type",
                |m: &CFrameStatAccumulatedValue| { &m.stat_type },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.stat_type },
                EFrameAccumulatedStat::k_EFrameStatFPS,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "count",
                |m: &CFrameStatAccumulatedValue| { &m.count },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.count },
                CFrameStatAccumulatedValue::get_count,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "average",
                |m: &CFrameStatAccumulatedValue| { &m.average },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.average },
                CFrameStatAccumulatedValue::get_average,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "stddev",
                |m: &CFrameStatAccumulatedValue| { &m.stddev },
                |m: &mut CFrameStatAccumulatedValue| { &mut m.stddev },
                CFrameStatAccumulatedValue::get_stddev,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CFrameStatAccumulatedValue>(
                "CFrameStatAccumulatedValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameStatAccumulatedValue {
        static instance: ::protobuf::rt::Lazy<CFrameStatAccumulatedValue> = ::protobuf::rt::Lazy::INIT;
        instance.get(CFrameStatAccumulatedValue::new)
    }
}

impl ::protobuf::Clear for CFrameStatAccumulatedValue {
    fn clear(&mut self) {
        self.stat_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.average = ::std::option::Option::None;
        self.stddev = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStatAccumulatedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStatAccumulatedValue {
}

#[derive(PartialEq,Clone,Default)]
pub struct CFrameStatsListMsg {
    // message fields
    data_type: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<EStreamingDataType>>,
    pub stats: ::protobuf::RepeatedField<CFrameStats>,
    pub accumulated_stats: ::protobuf::RepeatedField<CFrameStatAccumulatedValue>,
    latest_frame_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFrameStatsListMsg {
    fn default() -> &'a CFrameStatsListMsg {
        <CFrameStatsListMsg as ::protobuf::Message>::default_instance()
    }
}

impl CFrameStatsListMsg {
    pub fn new() -> CFrameStatsListMsg {
        ::std::default::Default::default()
    }

    // required .EStreamingDataType data_type = 1;

    pub fn get_data_type(&self) -> EStreamingDataType {
        match self.data_type {
            Some(e) => e.enum_value_or(EStreamingDataType::k_EStreamingAudioData),
            None => EStreamingDataType::k_EStreamingAudioData,
        }
    }

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: EStreamingDataType) {
        self.data_type = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // required int32 latest_frame_id = 4;

    pub fn get_latest_frame_id(&self) -> i32 {
        self.latest_frame_id.unwrap_or(0)
    }

    pub fn clear_latest_frame_id(&mut self) {
        self.latest_frame_id = ::std::option::Option::None;
    }

    pub fn has_latest_frame_id(&self) -> bool {
        self.latest_frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_frame_id(&mut self, v: i32) {
        self.latest_frame_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFrameStatsListMsg {
    fn is_initialized(&self) -> bool {
        if self.data_type.is_none() {
            return false;
        }
        if self.latest_frame_id.is_none() {
            return false;
        }
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accumulated_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.stats)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.accumulated_stats)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.latest_frame_id = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.accumulated_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.latest_frame_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_type {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.accumulated_stats {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.latest_frame_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFrameStatsListMsg {
        CFrameStatsListMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, EStreamingDataType>(
                "data_type",
                |m: &CFrameStatsListMsg| { &m.data_type },
                |m: &mut CFrameStatsListMsg| { &mut m.data_type },
                EStreamingDataType::k_EStreamingAudioData,
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CFrameStats>>(
                "stats",
                |m: &CFrameStatsListMsg| { &m.stats },
                |m: &mut CFrameStatsListMsg| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<CFrameStatAccumulatedValue>>(
                "accumulated_stats",
                |m: &CFrameStatsListMsg| { &m.accumulated_stats },
                |m: &mut CFrameStatsListMsg| { &mut m.accumulated_stats },
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "latest_frame_id",
                |m: &CFrameStatsListMsg| { &m.latest_frame_id },
                |m: &mut CFrameStatsListMsg| { &mut m.latest_frame_id },
                CFrameStatsListMsg::get_latest_frame_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CFrameStatsListMsg>(
                "CFrameStatsListMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFrameStatsListMsg {
        static instance: ::protobuf::rt::Lazy<CFrameStatsListMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CFrameStatsListMsg::new)
    }
}

impl ::protobuf::Clear for CFrameStatsListMsg {
    fn clear(&mut self) {
        self.data_type = ::std::option::Option::None;
        self.stats.clear();
        self.accumulated_stats.clear();
        self.latest_frame_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFrameStatsListMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFrameStatsListMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CStreamingSessionStats {
    // message fields
    frame_loss_percentage: ::std::option::Option<f32>,
    average_network_time_ms: ::std::option::Option<f32>,
    stddev_network_time_ms: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CStreamingSessionStats {
    fn default() -> &'a CStreamingSessionStats {
        <CStreamingSessionStats as ::protobuf::Message>::default_instance()
    }
}

impl CStreamingSessionStats {
    pub fn new() -> CStreamingSessionStats {
        ::std::default::Default::default()
    }

    // optional float frame_loss_percentage = 1;

    pub fn get_frame_loss_percentage(&self) -> f32 {
        self.frame_loss_percentage.unwrap_or(0.)
    }

    pub fn clear_frame_loss_percentage(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
    }

    pub fn has_frame_loss_percentage(&self) -> bool {
        self.frame_loss_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_loss_percentage(&mut self, v: f32) {
        self.frame_loss_percentage = ::std::option::Option::Some(v);
    }

    // optional float average_network_time_ms = 2;

    pub fn get_average_network_time_ms(&self) -> f32 {
        self.average_network_time_ms.unwrap_or(0.)
    }

    pub fn clear_average_network_time_ms(&mut self) {
        self.average_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_average_network_time_ms(&self) -> bool {
        self.average_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_network_time_ms(&mut self, v: f32) {
        self.average_network_time_ms = ::std::option::Option::Some(v);
    }

    // optional float stddev_network_time_ms = 3;

    pub fn get_stddev_network_time_ms(&self) -> f32 {
        self.stddev_network_time_ms.unwrap_or(0.)
    }

    pub fn clear_stddev_network_time_ms(&mut self) {
        self.stddev_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_stddev_network_time_ms(&self) -> bool {
        self.stddev_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_network_time_ms(&mut self, v: f32) {
        self.stddev_network_time_ms = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CStreamingSessionStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.frame_loss_percentage = ::std::option::Option::Some(is.read_float()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.average_network_time_ms = ::std::option::Option::Some(is.read_float()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stddev_network_time_ms = ::std::option::Option::Some(is.read_float()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.frame_loss_percentage {
            my_size += 5;
        }
        if let Some(v) = self.average_network_time_ms {
            my_size += 5;
        }
        if let Some(v) = self.stddev_network_time_ms {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.frame_loss_percentage {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.average_network_time_ms {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.stddev_network_time_ms {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CStreamingSessionStats {
        CStreamingSessionStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "frame_loss_percentage",
                |m: &CStreamingSessionStats| { &m.frame_loss_percentage },
                |m: &mut CStreamingSessionStats| { &mut m.frame_loss_percentage },
                CStreamingSessionStats::get_frame_loss_percentage,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "average_network_time_ms",
                |m: &CStreamingSessionStats| { &m.average_network_time_ms },
                |m: &mut CStreamingSessionStats| { &mut m.average_network_time_ms },
                CStreamingSessionStats::get_average_network_time_ms,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeFloat, _>(
                "stddev_network_time_ms",
                |m: &CStreamingSessionStats| { &m.stddev_network_time_ms },
                |m: &mut CStreamingSessionStats| { &mut m.stddev_network_time_ms },
                CStreamingSessionStats::get_stddev_network_time_ms,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CStreamingSessionStats>(
                "CStreamingSessionStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CStreamingSessionStats {
        static instance: ::protobuf::rt::Lazy<CStreamingSessionStats> = ::protobuf::rt::Lazy::INIT;
        instance.get(CStreamingSessionStats::new)
    }
}

impl ::protobuf::Clear for CStreamingSessionStats {
    fn clear(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
        self.average_network_time_ms = ::std::option::Option::None;
        self.stddev_network_time_ms = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CStreamingSessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CStreamingSessionStats {
}

#[derive(PartialEq,Clone,Default)]
pub struct CDebugDumpMsg {
    // message fields
    screenshot: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CDebugDumpMsg {
    fn default() -> &'a CDebugDumpMsg {
        <CDebugDumpMsg as ::protobuf::Message>::default_instance()
    }
}

impl CDebugDumpMsg {
    pub fn new() -> CDebugDumpMsg {
        ::std::default::Default::default()
    }

    // optional bytes screenshot = 1;

    pub fn get_screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenshot(&mut self) {
        self.screenshot.clear();
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenshot.is_none() {
            self.screenshot.set_default();
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenshot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CDebugDumpMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.screenshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.screenshot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CDebugDumpMsg {
        CDebugDumpMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "screenshot",
                |m: &CDebugDumpMsg| { &m.screenshot },
                |m: &mut CDebugDumpMsg| { &mut m.screenshot },
                CDebugDumpMsg::get_screenshot,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CDebugDumpMsg>(
                "CDebugDumpMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CDebugDumpMsg {
        static instance: ::protobuf::rt::Lazy<CDebugDumpMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CDebugDumpMsg::new)
    }
}

impl ::protobuf::Clear for CDebugDumpMsg {
    fn clear(&mut self) {
        self.screenshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CDebugDumpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDebugDumpMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CLogMsg {
    // message fields
    field_type: ::std::option::Option<i32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CLogMsg {
    fn default() -> &'a CLogMsg {
        <CLogMsg as ::protobuf::Message>::default_instance()
    }
}

impl CLogMsg {
    pub fn new() -> CLogMsg {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CLogMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CLogMsg {
        CLogMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                "type",
                |m: &CLogMsg| { &m.field_type },
                |m: &mut CLogMsg| { &mut m.field_type },
                CLogMsg::get_field_type,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                "message",
                |m: &CLogMsg| { &m.message },
                |m: &mut CLogMsg| { &mut m.message },
                CLogMsg::get_message,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CLogMsg>(
                "CLogMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CLogMsg {
        static instance: ::protobuf::rt::Lazy<CLogMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CLogMsg::new)
    }
}

impl ::protobuf::Clear for CLogMsg {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLogMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLogMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CLogUploadMsg {
    // message fields
    field_type: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<ELogFileType>>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CLogUploadMsg {
    fn default() -> &'a CLogUploadMsg {
        <CLogUploadMsg as ::protobuf::Message>::default_instance()
    }
}

impl CLogUploadMsg {
    pub fn new() -> CLogUploadMsg {
        ::std::default::Default::default()
    }

    // optional .ELogFileType type = 1;

    pub fn get_field_type(&self) -> ELogFileType {
        match self.field_type {
            Some(e) => e.enum_value_or(ELogFileType::k_ELogFileSystemBoot),
            None => ELogFileType::k_ELogFileSystemBoot,
        }
    }

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ELogFileType) {
        self.field_type = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional bytes data = 3;

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CLogUploadMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CLogUploadMsg {
        CLogUploadMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_enum_accessor::<_, ELogFileType>(
                "type",
                |m: &CLogUploadMsg| { &m.field_type },
                |m: &mut CLogUploadMsg| { &mut m.field_type },
                ELogFileType::k_ELogFileSystemBoot,
            ));
            fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes, _>(
                "data",
                |m: &CLogUploadMsg| { &m.data },
                |m: &mut CLogUploadMsg| { &mut m.data },
                CLogUploadMsg::get_data,
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CLogUploadMsg>(
                "CLogUploadMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CLogUploadMsg {
        static instance: ::protobuf::rt::Lazy<CLogUploadMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CLogUploadMsg::new)
    }
}

impl ::protobuf::Clear for CLogUploadMsg {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLogUploadMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLogUploadMsg {
}

#[derive(PartialEq,Clone,Default)]
pub struct CTransportSignalMsg {
    // message fields
    pub webrtc: ::protobuf::SingularPtrField<ctransport_signal_msg::WebRTCMessage>,
    pub sdr: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTransportSignalMsg {
    fn default() -> &'a CTransportSignalMsg {
        <CTransportSignalMsg as ::protobuf::Message>::default_instance()
    }
}

impl CTransportSignalMsg {
    pub fn new() -> CTransportSignalMsg {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CTransportSignalMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.webrtc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into::<ctransport_signal_msg::WebRTCMessage, _>(wire_type, is, &mut self.webrtc)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.sdr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.sdr {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.webrtc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.sdr {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTransportSignalMsg {
        CTransportSignalMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<ctransport_signal_msg::WebRTCMessage>, _>(
                "webrtc",
                |m: &CTransportSignalMsg| { &m.webrtc },
                |m: &mut CTransportSignalMsg| { &mut m.webrtc },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes>(
                "sdr",
                |m: &CTransportSignalMsg| { &m.sdr },
                |m: &mut CTransportSignalMsg| { &mut m.sdr },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<CTransportSignalMsg>(
                "CTransportSignalMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTransportSignalMsg {
        static instance: ::protobuf::rt::Lazy<CTransportSignalMsg> = ::protobuf::rt::Lazy::INIT;
        instance.get(CTransportSignalMsg::new)
    }
}

impl ::protobuf::Clear for CTransportSignalMsg {
    fn clear(&mut self) {
        self.webrtc.clear();
        self.sdr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTransportSignalMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTransportSignalMsg {
}

/// Nested message and enums of message `CTransportSignalMsg`
pub mod ctransport_signal_msg {
    #[derive(PartialEq,Clone,Default)]
    pub struct WebRTCMessage {
        // message oneof groups
        pub msg: ::std::option::Option<web_rtcmessage::Msg>,
        // special fields
        pub unknown_fields: ::protobuf::UnknownFields,
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a WebRTCMessage {
        fn default() -> &'a WebRTCMessage {
            <WebRTCMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl WebRTCMessage {
        pub fn new() -> WebRTCMessage {
            ::std::default::Default::default()
        }

        // optional bool greeting = 1;

        pub fn get_greeting(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::greeting(v)) => v,
                _ => false,
            }
        }

        pub fn clear_greeting(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_greeting(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::greeting(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_greeting(&mut self, v: bool) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::greeting(v))
        }

        // optional string offer = 2;

        pub fn get_offer(&self) -> &str {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::offer(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_offer(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_offer(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::offer(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_offer(&mut self, v: ::std::string::String) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::offer(v))
        }

        // Mutable pointer to the field.
        pub fn mut_offer(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::offer(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::offer(::std::string::String::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::offer(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_offer(&mut self) -> ::std::string::String {
            if self.has_offer() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::offer(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional string answer = 3;

        pub fn get_answer(&self) -> &str {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::answer(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_answer(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_answer(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::answer(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_answer(&mut self, v: ::std::string::String) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::answer(v))
        }

        // Mutable pointer to the field.
        pub fn mut_answer(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::answer(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::answer(::std::string::String::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::answer(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_answer(&mut self) -> ::std::string::String {
            if self.has_answer() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::answer(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;

        pub fn get_candidate(&self) -> &web_rtcmessage::Candidate {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::candidate(ref v)) => v,
                _ => <web_rtcmessage::Candidate as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_candidate(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_candidate(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::candidate(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_candidate(&mut self, v: web_rtcmessage::Candidate) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::candidate(v))
        }

        // Mutable pointer to the field.
        pub fn mut_candidate(&mut self) -> &mut web_rtcmessage::Candidate {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::candidate(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::candidate(web_rtcmessage::Candidate::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::candidate(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_candidate(&mut self) -> web_rtcmessage::Candidate {
            if self.has_candidate() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::candidate(v)) => v,
                    _ => panic!(),
                }
            } else {
                web_rtcmessage::Candidate::new()
            }
        }
    }

    impl ::protobuf::Message for WebRTCMessage {
        fn is_initialized(&self) -> bool {
            if let Some(ctransport_signal_msg::web_rtcmessage::Msg::candidate(ref v)) = self.msg {
                if !v.is_initialized() {
                    return false;
                }
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        if wire_type != ::protobuf::wire_format::WireTypeVarint {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::greeting(is.read_bool()?));
                    },
                    2 => {
                        if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::offer(is.read_string()?));
                    },
                    3 => {
                        if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::answer(is.read_string()?));
                    },
                    4 => {
                        if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                            return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                        }
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::candidate(is.read_message()?));
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.msg {
                match v {
                    &web_rtcmessage::Msg::greeting(v) => {
                        my_size += 2;
                    },
                    &web_rtcmessage::Msg::offer(ref v) => {
                        my_size += ::protobuf::rt::string_size(2, &v);
                    },
                    &web_rtcmessage::Msg::answer(ref v) => {
                        my_size += ::protobuf::rt::string_size(3, &v);
                    },
                    &web_rtcmessage::Msg::candidate(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if let ::std::option::Option::Some(ref v) = self.msg {
                match v {
                    &web_rtcmessage::Msg::greeting(v) => {
                        os.write_bool(1, v)?;
                    },
                    &web_rtcmessage::Msg::offer(ref v) => {
                        os.write_string(2, v)?;
                    },
                    &web_rtcmessage::Msg::answer(ref v) => {
                        os.write_string(3, v)?;
                    },
                    &web_rtcmessage::Msg::candidate(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> WebRTCMessage {
            WebRTCMessage::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_oneof_copy_has_get_set_accessors::<_, ::protobuf::reflect::types::ProtobufTypeBool>(
                    "greeting",
                    WebRTCMessage::has_greeting,
                    WebRTCMessage::get_greeting,
                    WebRTCMessage::set_greeting,
                ));
                fields.push(::protobuf::reflect::rt::make_oneof_deref_has_get_set_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                    "offer",
                    WebRTCMessage::has_offer,
                    WebRTCMessage::get_offer,
                    WebRTCMessage::set_offer,
                ));
                fields.push(::protobuf::reflect::rt::make_oneof_deref_has_get_set_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString>(
                    "answer",
                    WebRTCMessage::has_answer,
                    WebRTCMessage::get_answer,
                    WebRTCMessage::set_answer,
                ));
                fields.push(::protobuf::reflect::rt::make_oneof_message_has_get_mut_set_accessor::<_, web_rtcmessage::Candidate>(
                    "candidate",
                    WebRTCMessage::has_candidate,
                    WebRTCMessage::get_candidate,
                    WebRTCMessage::mut_candidate,
                    WebRTCMessage::set_candidate,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WebRTCMessage>(
                    "CTransportSignalMsg.WebRTCMessage",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static WebRTCMessage {
            static instance: ::protobuf::rt::Lazy<WebRTCMessage> = ::protobuf::rt::Lazy::INIT;
            instance.get(WebRTCMessage::new)
        }
    }

    impl ::protobuf::Clear for WebRTCMessage {
        fn clear(&mut self) {
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for WebRTCMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WebRTCMessage {
    }

    /// Nested message and enums of message `WebRTCMessage`
    pub mod web_rtcmessage {

        #[derive(Clone,PartialEq,Debug)]
        pub enum Msg {
            greeting(bool),
            offer(::std::string::String),
            answer(::std::string::String),
            candidate(Candidate),
        }

        impl ::protobuf::Oneof for Msg {
        }
        #[derive(PartialEq,Clone,Default)]
        pub struct Candidate {
            // message fields
            sdp_mid: ::protobuf::SingularField<::std::string::String>,
            sdp_mline_index: ::std::option::Option<i32>,
            candidate: ::protobuf::SingularField<::std::string::String>,
            // special fields
            pub unknown_fields: ::protobuf::UnknownFields,
            pub cached_size: ::protobuf::rt::CachedSize,
        }

        impl<'a> ::std::default::Default for &'a Candidate {
            fn default() -> &'a Candidate {
                <Candidate as ::protobuf::Message>::default_instance()
            }
        }

        impl Candidate {
            pub fn new() -> Candidate {
                ::std::default::Default::default()
            }

            // optional string sdp_mid = 1;

            pub fn get_sdp_mid(&self) -> &str {
                match self.sdp_mid.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_sdp_mid(&mut self) {
                self.sdp_mid.clear();
            }

            pub fn has_sdp_mid(&self) -> bool {
                self.sdp_mid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sdp_mid(&mut self, v: ::std::string::String) {
                self.sdp_mid = ::protobuf::SingularField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_sdp_mid(&mut self) -> &mut ::std::string::String {
                if self.sdp_mid.is_none() {
                    self.sdp_mid.set_default();
                }
                self.sdp_mid.as_mut().unwrap()
            }

            // Take field
            pub fn take_sdp_mid(&mut self) -> ::std::string::String {
                self.sdp_mid.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 sdp_mline_index = 2;

            pub fn get_sdp_mline_index(&self) -> i32 {
                self.sdp_mline_index.unwrap_or(0)
            }

            pub fn clear_sdp_mline_index(&mut self) {
                self.sdp_mline_index = ::std::option::Option::None;
            }

            pub fn has_sdp_mline_index(&self) -> bool {
                self.sdp_mline_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sdp_mline_index(&mut self, v: i32) {
                self.sdp_mline_index = ::std::option::Option::Some(v);
            }

            // optional string candidate = 3;

            pub fn get_candidate(&self) -> &str {
                match self.candidate.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_candidate(&mut self) {
                self.candidate.clear();
            }

            pub fn has_candidate(&self) -> bool {
                self.candidate.is_some()
            }

            // Param is passed by value, moved
            pub fn set_candidate(&mut self, v: ::std::string::String) {
                self.candidate = ::protobuf::SingularField::some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
                if self.candidate.is_none() {
                    self.candidate.set_default();
                }
                self.candidate.as_mut().unwrap()
            }

            // Take field
            pub fn take_candidate(&mut self) -> ::std::string::String {
                self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::protobuf::Message for Candidate {
            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                while !is.eof()? {
                    let (field_number, wire_type) = is.read_tag_unpack()?;
                    match field_number {
                        1 => {
                            ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sdp_mid)?;
                        },
                        2 => {
                            if wire_type != ::protobuf::wire_format::WireTypeVarint {
                                return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                            }
                            self.sdp_mline_index = ::std::option::Option::Some(is.read_int32()?);
                        },
                        3 => {
                            ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.candidate)?;
                        },
                        _ => {
                            ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u32 {
                let mut my_size = 0;
                if let Some(v) = self.sdp_mid.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.sdp_mline_index {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                }
                if let Some(v) = self.candidate.as_ref() {
                    my_size += ::protobuf::rt::string_size(3, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
                self.cached_size.set(my_size);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
                if let Some(v) = self.sdp_mid.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.sdp_mline_index {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.candidate.as_ref() {
                    os.write_string(3, v)?;
                }
                os.write_unknown_fields(self.get_unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn get_cached_size(&self) -> u32 {
                self.cached_size.get()
            }

            fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
                &self.unknown_fields
            }

            fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
                &mut self.unknown_fields
            }

            fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
                Self::descriptor_static()
            }

            fn new() -> Candidate {
                Candidate::new()
            }

            fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
                descriptor.get(|| {
                    let mut fields = ::std::vec::Vec::new();
                    fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                        "sdp_mid",
                        |m: &Candidate| { &m.sdp_mid },
                        |m: &mut Candidate| { &mut m.sdp_mid },
                        Candidate::get_sdp_mid,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_copy_accessor::<_, ::protobuf::reflect::types::ProtobufTypeInt32, _>(
                        "sdp_mline_index",
                        |m: &Candidate| { &m.sdp_mline_index },
                        |m: &mut Candidate| { &mut m.sdp_mline_index },
                        Candidate::get_sdp_mline_index,
                    ));
                    fields.push(::protobuf::reflect::rt::make_option_get_ref_accessor::<_, ::protobuf::reflect::types::ProtobufTypeString, _>(
                        "candidate",
                        |m: &Candidate| { &m.candidate },
                        |m: &mut Candidate| { &mut m.candidate },
                        Candidate::get_candidate,
                    ));
                    ::protobuf::reflect::MessageDescriptor::new::<Candidate>(
                        "CTransportSignalMsg.WebRTCMessage.Candidate",
                        fields,
                        super::super::file_descriptor_proto()
                    )
                })
            }

            fn default_instance() -> &'static Candidate {
                static instance: ::protobuf::rt::Lazy<Candidate> = ::protobuf::rt::Lazy::INIT;
                instance.get(Candidate::new)
            }
        }

        impl ::protobuf::Clear for Candidate {
            fn clear(&mut self) {
                self.sdp_mid.clear();
                self.sdp_mline_index = ::std::option::Option::None;
                self.candidate.clear();
                self.unknown_fields.clear();
            }
        }

        impl ::std::fmt::Debug for Candidate {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Candidate {
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamChannel {
    k_EStreamChannelInvalid = -1,
    k_EStreamChannelDiscovery = 0,
    k_EStreamChannelControl = 1,
    k_EStreamChannelStats = 2,
    k_EStreamChannelDataChannelStart = 3,
}

impl ::protobuf::ProtobufEnum for EStreamChannel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamChannel> {
        match value {
            -1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelInvalid),
            0 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDiscovery),
            1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelControl),
            2 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelStats),
            3 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDataChannelStart),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamChannel] = &[
            EStreamChannel::k_EStreamChannelInvalid,
            EStreamChannel::k_EStreamChannelDiscovery,
            EStreamChannel::k_EStreamChannelControl,
            EStreamChannel::k_EStreamChannelStats,
            EStreamChannel::k_EStreamChannelDataChannelStart,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamChannel>("EStreamChannel", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamChannel {
    fn default() -> Self {
        EStreamChannel::k_EStreamChannelInvalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamChannel {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDiscoveryMessage {
    k_EStreamDiscoveryPingRequest = 1,
    k_EStreamDiscoveryPingResponse = 2,
}

impl ::protobuf::ProtobufEnum for EStreamDiscoveryMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDiscoveryMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest),
            2 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDiscoveryMessage] = &[
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest,
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamDiscoveryMessage>("EStreamDiscoveryMessage", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDiscoveryMessage {
    fn default() -> Self {
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamDiscoveryMessage {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamControlMessage {
    k_EStreamControlAuthenticationRequest = 1,
    k_EStreamControlAuthenticationResponse = 2,
    k_EStreamControlNegotiationInit = 3,
    k_EStreamControlNegotiationSetConfig = 4,
    k_EStreamControlNegotiationComplete = 5,
    k_EStreamControlClientHandshake = 6,
    k_EStreamControlServerHandshake = 7,
    k_EStreamControlStartNetworkTest = 8,
    k_EStreamControlKeepAlive = 9,
    k_EStreamControl_LAST_SETUP_MESSAGE = 15,
    k_EStreamControlStartAudioData = 50,
    k_EStreamControlStopAudioData = 51,
    k_EStreamControlStartVideoData = 52,
    k_EStreamControlStopVideoData = 53,
    k_EStreamControlInputMouseMotion = 54,
    k_EStreamControlInputMouseWheel = 55,
    k_EStreamControlInputMouseDown = 56,
    k_EStreamControlInputMouseUp = 57,
    k_EStreamControlInputKeyDown = 58,
    k_EStreamControlInputKeyUp = 59,
    k_EStreamControlInputGamepadAttached_OBSOLETE = 60,
    k_EStreamControlInputGamepadEvent_OBSOLETE = 61,
    k_EStreamControlInputGamepadDetached_OBSOLETE = 62,
    k_EStreamControlShowCursor = 63,
    k_EStreamControlHideCursor = 64,
    k_EStreamControlSetCursor = 65,
    k_EStreamControlGetCursorImage = 66,
    k_EStreamControlSetCursorImage = 67,
    k_EStreamControlDeleteCursor = 68,
    k_EStreamControlSetTargetFramerate = 69,
    k_EStreamControlInputLatencyTest = 70,
    k_EStreamControlGamepadRumble_OBSOLETE = 71,
    k_EStreamControlOverlayEnabled = 74,
    k_EStreamControlInputControllerAttached_OBSOLETE = 75,
    k_EStreamControlInputControllerState_OBSOLETE = 76,
    k_EStreamControlTriggerHapticPulse_OBSOLETE = 77,
    k_EStreamControlInputControllerDetached_OBSOLETE = 78,
    k_EStreamControlVideoDecoderInfo = 80,
    k_EStreamControlSetTitle = 81,
    k_EStreamControlSetIcon = 82,
    k_EStreamControlQuitRequest = 83,
    k_EStreamControlSetQoS = 87,
    k_EStreamControlInputControllerWirelessPresence_OBSOLETE = 88,
    k_EStreamControlSetGammaRamp = 89,
    k_EStreamControlVideoEncoderInfo = 90,
    k_EStreamControlInputControllerStateHID_OBSOLETE = 93,
    k_EStreamControlSetTargetBitrate = 94,
    k_EStreamControlSetControllerPairingEnabled_OBSOLETE = 95,
    k_EStreamControlSetControllerPairingResult_OBSOLETE = 96,
    k_EStreamControlTriggerControllerDisconnect_OBSOLETE = 97,
    k_EStreamControlSetActivity = 98,
    k_EStreamControlSetStreamingClientConfig = 99,
    k_EStreamControlSystemSuspend = 100,
    k_EStreamControlSetControllerSettings_OBSOLETE = 101,
    k_EStreamControlVirtualHereRequest = 102,
    k_EStreamControlVirtualHereReady = 103,
    k_EStreamControlVirtualHereShareDevice = 104,
    k_EStreamControlSetSpectatorMode = 105,
    k_EStreamControlRemoteHID = 106,
    k_EStreamControlStartMicrophoneData = 107,
    k_EStreamControlStopMicrophoneData = 108,
    k_EStreamControlInputText = 109,
    k_EStreamControlTouchConfigActive = 110,
    k_EStreamControlGetTouchConfigData = 111,
    k_EStreamControlSetTouchConfigData = 112,
    k_EStreamControlSaveTouchConfigLayout = 113,
    k_EStreamControlTouchActionSetActive = 114,
    k_EStreamControlGetTouchIconData = 115,
    k_EStreamControlSetTouchIconData = 116,
    k_EStreamControlInputTouchFingerDown = 117,
    k_EStreamControlInputTouchFingerMotion = 118,
    k_EStreamControlInputTouchFingerUp = 119,
    k_EStreamControlSetCaptureSize = 120,
    k_EStreamControlSetFlashState = 121,
    k_EStreamControlPause = 122,
    k_EStreamControlResume = 123,
}

impl ::protobuf::ProtobufEnum for EStreamControlMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamControlMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            2 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationResponse),
            3 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationInit),
            4 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationSetConfig),
            5 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationComplete),
            6 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlClientHandshake),
            7 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlServerHandshake),
            8 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNetworkTest),
            9 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlKeepAlive),
            15 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE),
            50 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartAudioData),
            51 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopAudioData),
            52 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartVideoData),
            53 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopVideoData),
            54 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseMotion),
            55 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseWheel),
            56 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseDown),
            57 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseUp),
            58 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyDown),
            59 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyUp),
            60 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE),
            61 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE),
            62 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE),
            63 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowCursor),
            64 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlHideCursor),
            65 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursor),
            66 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetCursorImage),
            67 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorImage),
            68 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDeleteCursor),
            69 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetFramerate),
            70 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputLatencyTest),
            71 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE),
            74 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlOverlayEnabled),
            75 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE),
            76 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE),
            77 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE),
            78 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE),
            80 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoDecoderInfo),
            81 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTitle),
            82 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetIcon),
            83 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlQuitRequest),
            87 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQoS),
            88 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE),
            89 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetGammaRamp),
            90 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoEncoderInfo),
            93 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE),
            94 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetBitrate),
            95 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE),
            96 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE),
            97 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE),
            98 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetActivity),
            99 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetStreamingClientConfig),
            100 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSystemSuspend),
            101 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE),
            102 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereRequest),
            103 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereReady),
            104 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereShareDevice),
            105 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetSpectatorMode),
            106 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemoteHID),
            107 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartMicrophoneData),
            108 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopMicrophoneData),
            109 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputText),
            110 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchConfigActive),
            111 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchConfigData),
            112 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchConfigData),
            113 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout),
            114 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetActive),
            115 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchIconData),
            116 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchIconData),
            117 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerDown),
            118 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerMotion),
            119 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerUp),
            120 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCaptureSize),
            121 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetFlashState),
            122 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPause),
            123 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResume),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamControlMessage] = &[
            EStreamControlMessage::k_EStreamControlAuthenticationRequest,
            EStreamControlMessage::k_EStreamControlAuthenticationResponse,
            EStreamControlMessage::k_EStreamControlNegotiationInit,
            EStreamControlMessage::k_EStreamControlNegotiationSetConfig,
            EStreamControlMessage::k_EStreamControlNegotiationComplete,
            EStreamControlMessage::k_EStreamControlClientHandshake,
            EStreamControlMessage::k_EStreamControlServerHandshake,
            EStreamControlMessage::k_EStreamControlStartNetworkTest,
            EStreamControlMessage::k_EStreamControlKeepAlive,
            EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE,
            EStreamControlMessage::k_EStreamControlStartAudioData,
            EStreamControlMessage::k_EStreamControlStopAudioData,
            EStreamControlMessage::k_EStreamControlStartVideoData,
            EStreamControlMessage::k_EStreamControlStopVideoData,
            EStreamControlMessage::k_EStreamControlInputMouseMotion,
            EStreamControlMessage::k_EStreamControlInputMouseWheel,
            EStreamControlMessage::k_EStreamControlInputMouseDown,
            EStreamControlMessage::k_EStreamControlInputMouseUp,
            EStreamControlMessage::k_EStreamControlInputKeyDown,
            EStreamControlMessage::k_EStreamControlInputKeyUp,
            EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlShowCursor,
            EStreamControlMessage::k_EStreamControlHideCursor,
            EStreamControlMessage::k_EStreamControlSetCursor,
            EStreamControlMessage::k_EStreamControlGetCursorImage,
            EStreamControlMessage::k_EStreamControlSetCursorImage,
            EStreamControlMessage::k_EStreamControlDeleteCursor,
            EStreamControlMessage::k_EStreamControlSetTargetFramerate,
            EStreamControlMessage::k_EStreamControlInputLatencyTest,
            EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE,
            EStreamControlMessage::k_EStreamControlOverlayEnabled,
            EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE,
            EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE,
            EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE,
            EStreamControlMessage::k_EStreamControlVideoDecoderInfo,
            EStreamControlMessage::k_EStreamControlSetTitle,
            EStreamControlMessage::k_EStreamControlSetIcon,
            EStreamControlMessage::k_EStreamControlQuitRequest,
            EStreamControlMessage::k_EStreamControlSetQoS,
            EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetGammaRamp,
            EStreamControlMessage::k_EStreamControlVideoEncoderInfo,
            EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetTargetBitrate,
            EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE,
            EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE,
            EStreamControlMessage::k_EStreamControlSetActivity,
            EStreamControlMessage::k_EStreamControlSetStreamingClientConfig,
            EStreamControlMessage::k_EStreamControlSystemSuspend,
            EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE,
            EStreamControlMessage::k_EStreamControlVirtualHereRequest,
            EStreamControlMessage::k_EStreamControlVirtualHereReady,
            EStreamControlMessage::k_EStreamControlVirtualHereShareDevice,
            EStreamControlMessage::k_EStreamControlSetSpectatorMode,
            EStreamControlMessage::k_EStreamControlRemoteHID,
            EStreamControlMessage::k_EStreamControlStartMicrophoneData,
            EStreamControlMessage::k_EStreamControlStopMicrophoneData,
            EStreamControlMessage::k_EStreamControlInputText,
            EStreamControlMessage::k_EStreamControlTouchConfigActive,
            EStreamControlMessage::k_EStreamControlGetTouchConfigData,
            EStreamControlMessage::k_EStreamControlSetTouchConfigData,
            EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout,
            EStreamControlMessage::k_EStreamControlTouchActionSetActive,
            EStreamControlMessage::k_EStreamControlGetTouchIconData,
            EStreamControlMessage::k_EStreamControlSetTouchIconData,
            EStreamControlMessage::k_EStreamControlInputTouchFingerDown,
            EStreamControlMessage::k_EStreamControlInputTouchFingerMotion,
            EStreamControlMessage::k_EStreamControlInputTouchFingerUp,
            EStreamControlMessage::k_EStreamControlSetCaptureSize,
            EStreamControlMessage::k_EStreamControlSetFlashState,
            EStreamControlMessage::k_EStreamControlPause,
            EStreamControlMessage::k_EStreamControlResume,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamControlMessage>("EStreamControlMessage", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamControlMessage {
    fn default() -> Self {
        EStreamControlMessage::k_EStreamControlAuthenticationRequest
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamControlMessage {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamVersion {
    k_EStreamVersionNone = 0,
    k_EStreamVersionCurrent = 1,
}

impl ::protobuf::ProtobufEnum for EStreamVersion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVersion> {
        match value {
            0 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionNone),
            1 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionCurrent),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamVersion] = &[
            EStreamVersion::k_EStreamVersionNone,
            EStreamVersion::k_EStreamVersionCurrent,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamVersion>("EStreamVersion", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamVersion {
    fn default() -> Self {
        EStreamVersion::k_EStreamVersionNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamVersion {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamAudioCodec {
    k_EStreamAudioCodecNone = 0,
    k_EStreamAudioCodecRaw = 1,
    k_EStreamAudioCodecVorbis = 2,
    k_EStreamAudioCodecOpus = 3,
    k_EStreamAudioCodecMP3 = 4,
    k_EStreamAudioCodecAAC = 5,
}

impl ::protobuf::ProtobufEnum for EStreamAudioCodec {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamAudioCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecNone),
            1 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecRaw),
            2 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecVorbis),
            3 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecOpus),
            4 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecMP3),
            5 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecAAC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamAudioCodec] = &[
            EStreamAudioCodec::k_EStreamAudioCodecNone,
            EStreamAudioCodec::k_EStreamAudioCodecRaw,
            EStreamAudioCodec::k_EStreamAudioCodecVorbis,
            EStreamAudioCodec::k_EStreamAudioCodecOpus,
            EStreamAudioCodec::k_EStreamAudioCodecMP3,
            EStreamAudioCodec::k_EStreamAudioCodecAAC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamAudioCodec>("EStreamAudioCodec", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamAudioCodec {
    fn default() -> Self {
        EStreamAudioCodec::k_EStreamAudioCodecNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamAudioCodec {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamVideoCodec {
    k_EStreamVideoCodecNone = 0,
    k_EStreamVideoCodecRaw = 1,
    k_EStreamVideoCodecVP8 = 2,
    k_EStreamVideoCodecVP9 = 3,
    k_EStreamVideoCodecH264 = 4,
    k_EStreamVideoCodecHEVC = 5,
    k_EStreamVideoCodecORBX1 = 6,
    k_EStreamVideoCodecORBX2 = 7,
}

impl ::protobuf::ProtobufEnum for EStreamVideoCodec {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVideoCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecNone),
            1 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecRaw),
            2 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP8),
            3 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP9),
            4 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH264),
            5 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecHEVC),
            6 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX1),
            7 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamVideoCodec] = &[
            EStreamVideoCodec::k_EStreamVideoCodecNone,
            EStreamVideoCodec::k_EStreamVideoCodecRaw,
            EStreamVideoCodec::k_EStreamVideoCodecVP8,
            EStreamVideoCodec::k_EStreamVideoCodecVP9,
            EStreamVideoCodec::k_EStreamVideoCodecH264,
            EStreamVideoCodec::k_EStreamVideoCodecHEVC,
            EStreamVideoCodec::k_EStreamVideoCodecORBX1,
            EStreamVideoCodec::k_EStreamVideoCodecORBX2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamVideoCodec>("EStreamVideoCodec", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamVideoCodec {
    fn default() -> Self {
        EStreamVideoCodec::k_EStreamVideoCodecNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamVideoCodec {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamQualityPreference {
    k_EStreamQualityFast = 1,
    k_EStreamQualityBalanced = 2,
    k_EStreamQualityBeautiful = 3,
}

impl ::protobuf::ProtobufEnum for EStreamQualityPreference {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamQualityPreference> {
        match value {
            1 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityFast),
            2 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBalanced),
            3 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBeautiful),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamQualityPreference] = &[
            EStreamQualityPreference::k_EStreamQualityFast,
            EStreamQualityPreference::k_EStreamQualityBalanced,
            EStreamQualityPreference::k_EStreamQualityBeautiful,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamQualityPreference>("EStreamQualityPreference", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamQualityPreference {
    fn default() -> Self {
        EStreamQualityPreference::k_EStreamQualityFast
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamQualityPreference {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamBitrate {
    k_EStreamBitrateAutodetect = -1,
    k_EStreamBitrateUnlimited = 0,
}

impl ::protobuf::ProtobufEnum for EStreamBitrate {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamBitrate> {
        match value {
            -1 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateAutodetect),
            0 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateUnlimited),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamBitrate] = &[
            EStreamBitrate::k_EStreamBitrateAutodetect,
            EStreamBitrate::k_EStreamBitrateUnlimited,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamBitrate>("EStreamBitrate", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamBitrate {
    fn default() -> Self {
        EStreamBitrate::k_EStreamBitrateAutodetect
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamBitrate {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamHostPlayAudioPreference {
    k_EStreamHostPlayAudioDefault = 0,
    k_EStreamHostPlayAudioAlways = 1,
}

impl ::protobuf::ProtobufEnum for EStreamHostPlayAudioPreference {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamHostPlayAudioPreference> {
        match value {
            0 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            1 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamHostPlayAudioPreference] = &[
            EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
            EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamHostPlayAudioPreference>("EStreamHostPlayAudioPreference", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamHostPlayAudioPreference {
    fn default() -> Self {
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamHostPlayAudioPreference {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamingDataType {
    k_EStreamingAudioData = 0,
    k_EStreamingVideoData = 1,
    k_EStreamingMicrophoneData = 2,
}

impl ::protobuf::ProtobufEnum for EStreamingDataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamingDataType> {
        match value {
            0 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingAudioData),
            1 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingVideoData),
            2 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingMicrophoneData),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamingDataType] = &[
            EStreamingDataType::k_EStreamingAudioData,
            EStreamingDataType::k_EStreamingVideoData,
            EStreamingDataType::k_EStreamingMicrophoneData,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamingDataType>("EStreamingDataType", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamingDataType {
    fn default() -> Self {
        EStreamingDataType::k_EStreamingAudioData
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamingDataType {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamMouseButton {
    k_EStreamMouseButtonLeft = 1,
    k_EStreamMouseButtonRight = 2,
    k_EStreamMouseButtonMiddle = 16,
    k_EStreamMouseButtonX1 = 32,
    k_EStreamMouseButtonX2 = 64,
    k_EStreamMouseButtonUnknown = 4096,
}

impl ::protobuf::ProtobufEnum for EStreamMouseButton {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseButton> {
        match value {
            1 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonLeft),
            2 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonRight),
            16 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonMiddle),
            32 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX1),
            64 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX2),
            4096 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonUnknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamMouseButton] = &[
            EStreamMouseButton::k_EStreamMouseButtonLeft,
            EStreamMouseButton::k_EStreamMouseButtonRight,
            EStreamMouseButton::k_EStreamMouseButtonMiddle,
            EStreamMouseButton::k_EStreamMouseButtonX1,
            EStreamMouseButton::k_EStreamMouseButtonX2,
            EStreamMouseButton::k_EStreamMouseButtonUnknown,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamMouseButton>("EStreamMouseButton", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseButton {
    fn default() -> Self {
        EStreamMouseButton::k_EStreamMouseButtonLeft
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamMouseButton {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamMouseWheelDirection {
    k_EStreamMouseWheelUp = 120,
    k_EStreamMouseWheelDown = -120,
    k_EStreamMouseWheelLeft = 3,
    k_EStreamMouseWheelRight = 4,
}

impl ::protobuf::ProtobufEnum for EStreamMouseWheelDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseWheelDirection> {
        match value {
            120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            -120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelDown),
            3 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelLeft),
            4 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelRight),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamMouseWheelDirection] = &[
            EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
            EStreamMouseWheelDirection::k_EStreamMouseWheelDown,
            EStreamMouseWheelDirection::k_EStreamMouseWheelLeft,
            EStreamMouseWheelDirection::k_EStreamMouseWheelRight,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamMouseWheelDirection>("EStreamMouseWheelDirection", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseWheelDirection {
    fn default() -> Self {
        EStreamMouseWheelDirection::k_EStreamMouseWheelUp
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamMouseWheelDirection {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamGamepadInputType {
    k_EStreamGamepadInputInvalid = 0,
    k_EStreamGamepadInputDPadUp = 1,
    k_EStreamGamepadInputDPadDown = 2,
    k_EStreamGamepadInputDPadLeft = 4,
    k_EStreamGamepadInputDPadRight = 8,
    k_EStreamGamepadInputStart = 16,
    k_EStreamGamepadInputBack = 32,
    k_EStreamGamepadInputLeftThumb = 64,
    k_EStreamGamepadInputRightThumb = 128,
    k_EStreamGamepadInputLeftShoulder = 256,
    k_EStreamGamepadInputRightShoulder = 512,
    k_EStreamGamepadInputGuide = 1024,
    k_EStreamGamepadInputA = 4096,
    k_EStreamGamepadInputB = 8192,
    k_EStreamGamepadInputX = 16384,
    k_EStreamGamepadInputY = 32768,
    k_EStreamGamepadInputLeftThumbX = 65536,
    k_EStreamGamepadInputLeftThumbY = 131072,
    k_EStreamGamepadInputRightThumbX = 262144,
    k_EStreamGamepadInputRightThumbY = 524288,
    k_EStreamGamepadInputLeftTrigger = 1048576,
    k_EStreamGamepadInputRightTrigger = 2097152,
}

impl ::protobuf::ProtobufEnum for EStreamGamepadInputType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamGamepadInputType> {
        match value {
            0 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputInvalid),
            1 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadUp),
            2 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadDown),
            4 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadLeft),
            8 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputDPadRight),
            16 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputStart),
            32 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputBack),
            64 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftThumb),
            128 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightThumb),
            256 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftShoulder),
            512 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightShoulder),
            1024 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputGuide),
            4096 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputA),
            8192 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputB),
            16384 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputX),
            32768 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputY),
            65536 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbX),
            131072 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbY),
            262144 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightThumbX),
            524288 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightThumbY),
            1048576 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputLeftTrigger),
            2097152 => ::std::option::Option::Some(EStreamGamepadInputType::k_EStreamGamepadInputRightTrigger),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamGamepadInputType] = &[
            EStreamGamepadInputType::k_EStreamGamepadInputInvalid,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadUp,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadDown,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadLeft,
            EStreamGamepadInputType::k_EStreamGamepadInputDPadRight,
            EStreamGamepadInputType::k_EStreamGamepadInputStart,
            EStreamGamepadInputType::k_EStreamGamepadInputBack,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftThumb,
            EStreamGamepadInputType::k_EStreamGamepadInputRightThumb,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftShoulder,
            EStreamGamepadInputType::k_EStreamGamepadInputRightShoulder,
            EStreamGamepadInputType::k_EStreamGamepadInputGuide,
            EStreamGamepadInputType::k_EStreamGamepadInputA,
            EStreamGamepadInputType::k_EStreamGamepadInputB,
            EStreamGamepadInputType::k_EStreamGamepadInputX,
            EStreamGamepadInputType::k_EStreamGamepadInputY,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbX,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftThumbY,
            EStreamGamepadInputType::k_EStreamGamepadInputRightThumbX,
            EStreamGamepadInputType::k_EStreamGamepadInputRightThumbY,
            EStreamGamepadInputType::k_EStreamGamepadInputLeftTrigger,
            EStreamGamepadInputType::k_EStreamGamepadInputRightTrigger,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamGamepadInputType>("EStreamGamepadInputType", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamGamepadInputType {
    fn default() -> Self {
        EStreamGamepadInputType::k_EStreamGamepadInputInvalid
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamGamepadInputType {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFramerateLimiter {
    k_EStreamFramerateSlowCapture = 1,
    k_EStreamFramerateSlowConvert = 2,
    k_EStreamFramerateSlowEncode = 4,
    k_EStreamFramerateSlowNetwork = 8,
    k_EStreamFramerateSlowDecode = 16,
    k_EStreamFramerateSlowGame = 32,
    k_EStreamFramerateSlowDisplay = 64,
}

impl ::protobuf::ProtobufEnum for EStreamFramerateLimiter {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFramerateLimiter> {
        match value {
            1 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowCapture),
            2 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowConvert),
            4 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowEncode),
            8 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork),
            16 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDecode),
            32 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowGame),
            64 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFramerateLimiter] = &[
            EStreamFramerateLimiter::k_EStreamFramerateSlowCapture,
            EStreamFramerateLimiter::k_EStreamFramerateSlowConvert,
            EStreamFramerateLimiter::k_EStreamFramerateSlowEncode,
            EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDecode,
            EStreamFramerateLimiter::k_EStreamFramerateSlowGame,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamFramerateLimiter>("EStreamFramerateLimiter", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamFramerateLimiter {
    fn default() -> Self {
        EStreamFramerateLimiter::k_EStreamFramerateSlowCapture
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamFramerateLimiter {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamActivity {
    k_EStreamActivityIdle = 1,
    k_EStreamActivityGame = 2,
    k_EStreamActivityDesktop = 3,
}

impl ::protobuf::ProtobufEnum for EStreamActivity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamActivity> {
        match value {
            1 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityIdle),
            2 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityGame),
            3 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityDesktop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamActivity] = &[
            EStreamActivity::k_EStreamActivityIdle,
            EStreamActivity::k_EStreamActivityGame,
            EStreamActivity::k_EStreamActivityDesktop,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamActivity>("EStreamActivity", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamActivity {
    fn default() -> Self {
        EStreamActivity::k_EStreamActivityIdle
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamActivity {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamDataMessage {
    k_EStreamDataPacket = 1,
    k_EStreamDataLost = 2,
}

impl ::protobuf::ProtobufEnum for EStreamDataMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDataMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataPacket),
            2 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataLost),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamDataMessage] = &[
            EStreamDataMessage::k_EStreamDataPacket,
            EStreamDataMessage::k_EStreamDataLost,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamDataMessage>("EStreamDataMessage", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDataMessage {
    fn default() -> Self {
        EStreamDataMessage::k_EStreamDataPacket
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamDataMessage {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EAudioFormat {
    k_EAudioFormatNone = 0,
    k_EAudioFormat16BitLittleEndian = 1,
    k_EAudioFormatFloat = 2,
}

impl ::protobuf::ProtobufEnum for EAudioFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAudioFormat> {
        match value {
            0 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatNone),
            1 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormat16BitLittleEndian),
            2 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatFloat),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EAudioFormat] = &[
            EAudioFormat::k_EAudioFormatNone,
            EAudioFormat::k_EAudioFormat16BitLittleEndian,
            EAudioFormat::k_EAudioFormatFloat,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EAudioFormat>("EAudioFormat", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EAudioFormat {
    fn default() -> Self {
        EAudioFormat::k_EAudioFormatNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EAudioFormat {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EVideoFormat {
    k_EVideoFormatNone = 0,
    k_EVideoFormatYV12 = 1,
    k_EVideoFormatAccel = 2,
}

impl ::protobuf::ProtobufEnum for EVideoFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVideoFormat> {
        match value {
            0 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatNone),
            1 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatYV12),
            2 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatAccel),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EVideoFormat] = &[
            EVideoFormat::k_EVideoFormatNone,
            EVideoFormat::k_EVideoFormatYV12,
            EVideoFormat::k_EVideoFormatAccel,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EVideoFormat>("EVideoFormat", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EVideoFormat {
    fn default() -> Self {
        EVideoFormat::k_EVideoFormatNone
    }
}

impl ::protobuf::reflect::ProtobufValue for EVideoFormat {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamStatsMessage {
    k_EStreamStatsFrameEvents = 1,
    k_EStreamStatsDebugDump = 2,
    k_EStreamStatsLogMessage = 3,
    k_EStreamStatsLogUploadBegin = 4,
    k_EStreamStatsLogUploadData = 5,
    k_EStreamStatsLogUploadComplete = 6,
}

impl ::protobuf::ProtobufEnum for EStreamStatsMessage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamStatsMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsFrameEvents),
            2 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsDebugDump),
            3 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogMessage),
            4 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadBegin),
            5 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadData),
            6 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadComplete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamStatsMessage] = &[
            EStreamStatsMessage::k_EStreamStatsFrameEvents,
            EStreamStatsMessage::k_EStreamStatsDebugDump,
            EStreamStatsMessage::k_EStreamStatsLogMessage,
            EStreamStatsMessage::k_EStreamStatsLogUploadBegin,
            EStreamStatsMessage::k_EStreamStatsLogUploadData,
            EStreamStatsMessage::k_EStreamStatsLogUploadComplete,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamStatsMessage>("EStreamStatsMessage", file_descriptor_proto())
        })
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamStatsMessage {
    fn default() -> Self {
        EStreamStatsMessage::k_EStreamStatsFrameEvents
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamStatsMessage {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFrameEvent {
    k_EStreamInputEventStart = 0,
    k_EStreamInputEventSend = 1,
    k_EStreamInputEventRecv = 2,
    k_EStreamInputEventQueued = 3,
    k_EStreamInputEventHandled = 4,
    k_EStreamFrameEventStart = 5,
    k_EStreamFrameEventCaptureBegin = 6,
    k_EStreamFrameEventCaptureEnd = 7,
    k_EStreamFrameEventConvertBegin = 8,
    k_EStreamFrameEventConvertEnd = 9,
    k_EStreamFrameEventEncodeBegin = 10,
    k_EStreamFrameEventEncodeEnd = 11,
    k_EStreamFrameEventSend = 12,
    k_EStreamFrameEventRecv = 13,
    k_EStreamFrameEventDecodeBegin = 14,
    k_EStreamFrameEventDecodeEnd = 15,
    k_EStreamFrameEventUploadBegin = 16,
    k_EStreamFrameEventUploadEnd = 17,
    k_EStreamFrameEventComplete = 18,
}

impl ::protobuf::ProtobufEnum for EStreamFrameEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameEvent> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventStart),
            1 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventSend),
            2 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventRecv),
            3 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventQueued),
            4 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventHandled),
            5 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventStart),
            6 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureBegin),
            7 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureEnd),
            8 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertBegin),
            9 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertEnd),
            10 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeBegin),
            11 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeEnd),
            12 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventSend),
            13 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventRecv),
            14 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeBegin),
            15 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeEnd),
            16 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadBegin),
            17 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadEnd),
            18 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventComplete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFrameEvent] = &[
            EStreamFrameEvent::k_EStreamInputEventStart,
            EStreamFrameEvent::k_EStreamInputEventSend,
            EStreamFrameEvent::k_EStreamInputEventRecv,
            EStreamFrameEvent::k_EStreamInputEventQueued,
            EStreamFrameEvent::k_EStreamInputEventHandled,
            EStreamFrameEvent::k_EStreamFrameEventStart,
            EStreamFrameEvent::k_EStreamFrameEventCaptureBegin,
            EStreamFrameEvent::k_EStreamFrameEventCaptureEnd,
            EStreamFrameEvent::k_EStreamFrameEventConvertBegin,
            EStreamFrameEvent::k_EStreamFrameEventConvertEnd,
            EStreamFrameEvent::k_EStreamFrameEventEncodeBegin,
            EStreamFrameEvent::k_EStreamFrameEventEncodeEnd,
            EStreamFrameEvent::k_EStreamFrameEventSend,
            EStreamFrameEvent::k_EStreamFrameEventRecv,
            EStreamFrameEvent::k_EStreamFrameEventDecodeBegin,
            EStreamFrameEvent::k_EStreamFrameEventDecodeEnd,
            EStreamFrameEvent::k_EStreamFrameEventUploadBegin,
            EStreamFrameEvent::k_EStreamFrameEventUploadEnd,
            EStreamFrameEvent::k_EStreamFrameEventComplete,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamFrameEvent>("EStreamFrameEvent", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamFrameEvent {
    fn default() -> Self {
        EStreamFrameEvent::k_EStreamInputEventStart
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamFrameEvent {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EStreamFrameResult {
    k_EStreamFrameResultPending = 0,
    k_EStreamFrameResultDisplayed = 1,
    k_EStreamFrameResultDroppedNetworkSlow = 2,
    k_EStreamFrameResultDroppedNetworkLost = 3,
    k_EStreamFrameResultDroppedDecodeSlow = 4,
    k_EStreamFrameResultDroppedDecodeCorrupt = 5,
    k_EStreamFrameResultDroppedLate = 6,
    k_EStreamFrameResultDroppedReset = 7,
}

impl ::protobuf::ProtobufEnum for EStreamFrameResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameResult> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultPending),
            1 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDisplayed),
            2 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow),
            3 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost),
            4 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow),
            5 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt),
            6 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedLate),
            7 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedReset),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EStreamFrameResult] = &[
            EStreamFrameResult::k_EStreamFrameResultPending,
            EStreamFrameResult::k_EStreamFrameResultDisplayed,
            EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow,
            EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost,
            EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow,
            EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt,
            EStreamFrameResult::k_EStreamFrameResultDroppedLate,
            EStreamFrameResult::k_EStreamFrameResultDroppedReset,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EStreamFrameResult>("EStreamFrameResult", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EStreamFrameResult {
    fn default() -> Self {
        EStreamFrameResult::k_EStreamFrameResultPending
    }
}

impl ::protobuf::reflect::ProtobufValue for EStreamFrameResult {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum EFrameAccumulatedStat {
    k_EFrameStatFPS = 0,
    k_EFrameStatCaptureDurationMS = 1,
    k_EFrameStatConvertDurationMS = 2,
    k_EFrameStatEncodeDurationMS = 3,
    k_EFrameStatSteamDurationMS = 4,
    k_EFrameStatServerDurationMS = 5,
    k_EFrameStatNetworkDurationMS = 6,
    k_EFrameStatDecodeDurationMS = 7,
    k_EFrameStatDisplayDurationMS = 8,
    k_EFrameStatClientDurationMS = 9,
    k_EFrameStatFrameDurationMS = 10,
    k_EFrameStatInputLatencyMS = 11,
    k_EFrameStatGameLatencyMS = 12,
    k_EFrameStatRoundTripLatencyMS = 13,
    k_EFrameStatPingTimeMS = 14,
    k_EFrameStatServerBitrateKbitPerSec = 15,
    k_EFrameStatClientBitrateKbitPerSec = 16,
    k_EFrameStatLinkBandwidthKbitPerSec = 17,
    k_EFrameStatPacketLossPercentage = 18,
}

impl ::protobuf::ProtobufEnum for EFrameAccumulatedStat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFrameAccumulatedStat> {
        match value {
            0 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFPS),
            1 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS),
            2 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatConvertDurationMS),
            3 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS),
            4 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatSteamDurationMS),
            5 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerDurationMS),
            6 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS),
            7 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS),
            8 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS),
            9 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientDurationMS),
            10 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFrameDurationMS),
            11 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatInputLatencyMS),
            12 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatGameLatencyMS),
            13 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS),
            14 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPingTimeMS),
            15 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec),
            16 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec),
            17 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec),
            18 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EFrameAccumulatedStat] = &[
            EFrameAccumulatedStat::k_EFrameStatFPS,
            EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS,
            EFrameAccumulatedStat::k_EFrameStatConvertDurationMS,
            EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS,
            EFrameAccumulatedStat::k_EFrameStatSteamDurationMS,
            EFrameAccumulatedStat::k_EFrameStatServerDurationMS,
            EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS,
            EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS,
            EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS,
            EFrameAccumulatedStat::k_EFrameStatClientDurationMS,
            EFrameAccumulatedStat::k_EFrameStatFrameDurationMS,
            EFrameAccumulatedStat::k_EFrameStatInputLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatGameLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS,
            EFrameAccumulatedStat::k_EFrameStatPingTimeMS,
            EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec,
            EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<EFrameAccumulatedStat>("EFrameAccumulatedStat", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for EFrameAccumulatedStat {
    fn default() -> Self {
        EFrameAccumulatedStat::k_EFrameStatFPS
    }
}

impl ::protobuf::reflect::ProtobufValue for EFrameAccumulatedStat {
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
pub enum ELogFileType {
    k_ELogFileSystemBoot = 0,
    k_ELogFileSystemReset = 1,
    k_ELogFileSystemDebug = 2,
}

impl ::protobuf::ProtobufEnum for ELogFileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELogFileType> {
        match value {
            0 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemBoot),
            1 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemReset),
            2 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemDebug),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ELogFileType] = &[
            ELogFileType::k_ELogFileSystemBoot,
            ELogFileType::k_ELogFileSystemReset,
            ELogFileType::k_ELogFileSystemDebug,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new::<ELogFileType>("ELogFileType", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for ELogFileType {
    fn default() -> Self {
        ELogFileType::k_ELogFileSystemBoot
    }
}

impl ::protobuf::reflect::ProtobufValue for ELogFileType {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cstream.proto\"g\n\x15CDiscoveryPingRequest\x12\x1a\n\x08sequence\
    \x18\x01\x20\x01(\rR\x08sequence\x122\n\x15packet_size_requested\x18\x02\
    \x20\x01(\rR\x13packetSizeRequested\"f\n\x16CDiscoveryPingResponse\x12\
    \x1a\n\x08sequence\x18\x01\x20\x01(\rR\x08sequence\x120\n\x14packet_size\
    _received\x18\x02\x20\x01(\rR\x12packetSizeReceived\"B\n\x1dCStreamingCl\
    ientHandshakeInfo\x12!\n\x0cnetwork_test\x18\x02\x20\x01(\x05R\x0bnetwor\
    kTest\"I\n\x13CClientHandshakeMsg\x122\n\x04info\x18\x01\x20\x02(\x0b2\
    \x1e.CStreamingClientHandshakeInfoR\x04info\"1\n\x1dCStreamingServerHand\
    shakeInfo\x12\x10\n\x03mtu\x18\x01\x20\x01(\x05R\x03mtu\"I\n\x13CServerH\
    andshakeMsg\x122\n\x04info\x18\x01\x20\x02(\x0b2\x1e.CStreamingServerHan\
    dshakeInfoR\x04info\"r\n\x19CAuthenticationRequestMsg\x12\x14\n\x05token\
    \x18\x01\x20\x01(\x0cR\x05token\x12?\n\x07version\x18\x02\x20\x01(\x0e2\
    \x0f.EStreamVersion:\x14k_EStreamVersionNoneR\x07version\"\xe5\x01\n\x1a\
    CAuthenticationResponseMsg\x12S\n\x06result\x18\x01\x20\x01(\x0e20.CAuth\
    enticationResponseMsg.AuthenticationResult:\tSUCCEEDEDR\x06result\x12?\n\
    \x07version\x18\x02\x20\x01(\x0e2\x0f.EStreamVersion:\x14k_EStreamVersio\
    nNoneR\x07version\"1\n\x14AuthenticationResult\x12\r\n\tSUCCEEDED\x10\0\
    \x12\n\n\x06FAILED\x10\x01\"\x0f\n\rCKeepAliveMsg\"\xc4\x01\n\x14CStartN\
    etworkTestMsg\x12\x16\n\x06frames\x18\x01\x20\x01(\rR\x06frames\x12\x1c\
    \n\tframerate\x18\x02\x20\x01(\rR\tframerate\x12!\n\x0cbitrate_kbps\x18\
    \x03\x20\x01(\rR\x0bbitrateKbps\x12,\n\x12burst_bitrate_kbps\x18\x04\x20\
    \x01(\rR\x10burstBitrateKbps\x12%\n\x0ebandwidth_test\x18\x05\x20\x01(\
    \x08R\rbandwidthTest\"\xd3\x01\n\x10CStreamVideoMode\x12\x14\n\x05width\
    \x18\x01\x20\x02(\rR\x05width\x12\x16\n\x06height\x18\x02\x20\x02(\rR\
    \x06height\x12!\n\x0crefresh_rate\x18\x03\x20\x01(\rR\x0brefreshRate\x12\
    4\n\x16refresh_rate_numerator\x18\x04\x20\x01(\rR\x14refreshRateNumerato\
    r\x128\n\x18refresh_rate_denominator\x18\x05\x20\x01(\rR\x16refreshRateD\
    enominator\"\xc8\x04\n\x14CStreamingClientCaps\x12\x1f\n\x0bsystem_info\
    \x18\x01\x20\x01(\tR\nsystemInfo\x12,\n\x12system_can_suspend\x18\x02\
    \x20\x01(\x08R\x10systemCanSuspend\x12=\n\x1bmaximum_decode_bitrate_kbps\
    \x18\x03\x20\x01(\x05R\x18maximumDecodeBitrateKbps\x12;\n\x1amaximum_bur\
    st_bitrate_kbps\x18\x04\x20\x01(\x05R\x17maximumBurstBitrateKbps\x12.\n\
    \x13supports_video_hevc\x18\x05\x20\x01(\x08R\x11supportsVideoHevc\x12.\
    \n\x13disable_steam_store\x18\x06\x20\x01(\x08R\x11disableSteamStore\x12\
    2\n\x15disable_client_cursor\x18\x07\x20\x01(\x08R\x13disableClientCurso\
    r\x12E\n\x1fdisable_intel_hardware_encoding\x18\x08\x20\x01(\x08R\x1cdis\
    ableIntelHardwareEncoding\x12A\n\x1ddisable_amd_hardware_encoding\x18\t\
    \x20\x01(\x08R\x1adisableAmdHardwareEncoding\x12G\n\x20disable_nvidia_ha\
    rdware_encoding\x18\n\x20\x01(\x08R\x1ddisableNvidiaHardwareEncoding\"\
    \xdb\x06\n\x16CStreamingClientConfig\x12M\n\x07quality\x18\x01\x20\x01(\
    \x0e2\x19.EStreamQualityPreference:\x18k_EStreamQualityBalancedR\x07qual\
    ity\x120\n\x14maximum_resolution_x\x18\x02\x20\x01(\rR\x12maximumResolut\
    ionX\x120\n\x14maximum_resolution_y\x18\x03\x20\x01(\rR\x12maximumResolu\
    tionY\x12>\n\x1bmaximum_framerate_numerator\x18\x04\x20\x01(\rR\x19maxim\
    umFramerateNumerator\x12B\n\x1dmaximum_framerate_denominator\x18\x05\x20\
    \x01(\rR\x1bmaximumFramerateDenominator\x124\n\x14maximum_bitrate_kbps\
    \x18\x06\x20\x01(\x05:\x02-1R\x12maximumBitrateKbps\x12>\n\x18enable_har\
    dware_decoding\x18\x07\x20\x01(\x08:\x04trueR\x16enableHardwareDecoding\
    \x12C\n\x1aenable_performance_overlay\x18\x08\x20\x01(\x08:\x05falseR\
    \x18enablePerformanceOverlay\x12:\n\x16enable_video_streaming\x18\t\x20\
    \x01(\x08:\x04trueR\x14enableVideoStreaming\x12:\n\x16enable_audio_strea\
    ming\x18\n\x20\x01(\x08:\x04trueR\x14enableAudioStreaming\x12:\n\x16enab\
    le_input_streaming\x18\x0b\x20\x01(\x08:\x04trueR\x14enableInputStreamin\
    g\x12(\n\x0eaudio_channels\x18\x0c\x20\x01(\x05:\x012R\raudioChannels\
    \x121\n\x11enable_video_hevc\x18\r\x20\x01(\x08:\x05falseR\x0fenableVide\
    oHevc\x12>\n\x18enable_performance_icons\x18\x0e\x20\x01(\x08:\x04trueR\
    \x16enablePerformanceIcons\"\xf3\x04\n\x16CStreamingServerConfig\x12:\n\
    \x19change_desktop_resolution\x18\x01\x20\x01(\x08R\x17changeDesktopReso\
    lution\x12B\n\x1ddynamically_adjust_resolution\x18\x02\x20\x01(\x08R\x1b\
    dynamicallyAdjustResolution\x120\n\x14enable_capture_nvfbc\x18\x03\x20\
    \x01(\x08R\x12enableCaptureNvfbc\x12E\n\x1fenable_hardware_encoding_nvid\
    ia\x18\x04\x20\x01(\x08R\x1cenableHardwareEncodingNvidia\x12?\n\x1cenabl\
    e_hardware_encoding_amd\x18\x05\x20\x01(\x08R\x19enableHardwareEncodingA\
    md\x12C\n\x1eenable_hardware_encoding_intel\x18\x06\x20\x01(\x08R\x1bena\
    bleHardwareEncodingIntel\x12:\n\x19software_encoding_threads\x18\x07\x20\
    \x01(\x05R\x17softwareEncodingThreads\x126\n\x17enable_traffic_priority\
    \x18\x08\x20\x01(\x08R\x15enableTrafficPriority\x12f\n\x0fhost_play_audi\
    o\x18\t\x20\x01(\x0e2\x1f.EStreamHostPlayAudioPreference:\x1dk_EStreamHo\
    stPlayAudioDefaultR\rhostPlayAudio\"\x97\x03\n\x11CNegotiatedConfig\x12#\
    \n\rreliable_data\x18\x01\x20\x01(\x08R\x0creliableData\x12]\n\x14select\
    ed_audio_codec\x18\x02\x20\x01(\x0e2\x12.EStreamAudioCodec:\x17k_EStream\
    AudioCodecNoneR\x12selectedAudioCodec\x12]\n\x14selected_video_codec\x18\
    \x03\x20\x01(\x0e2\x12.EStreamVideoCodec:\x17k_EStreamVideoCodecNoneR\
    \x12selectedVideoCodec\x12E\n\x15available_video_modes\x18\x04\x20\x03(\
    \x0b2\x11.CStreamVideoModeR\x13availableVideoModes\x12*\n\x11enable_remo\
    te_hid\x18\x05\x20\x01(\x08R\x0fenableRemoteHid\x12,\n\x12enable_touch_i\
    nput\x18\x06\x20\x01(\x08R\x10enableTouchInput\"\xb0\x02\n\x13CNegotiati\
    onInitMsg\x12#\n\rreliable_data\x18\x01\x20\x01(\x08R\x0creliableData\
    \x12H\n\x16supported_audio_codecs\x18\x02\x20\x03(\x0e2\x12.EStreamAudio\
    CodecR\x14supportedAudioCodecs\x12H\n\x16supported_video_codecs\x18\x03\
    \x20\x03(\x0e2\x12.EStreamVideoCodecR\x14supportedVideoCodecs\x12.\n\x13\
    supports_remote_hid\x18\x04\x20\x01(\x08R\x11supportsRemoteHid\x120\n\
    \x14supports_touch_input\x18\x05\x20\x01(\x08R\x12supportsTouchInput\"\
    \xe2\x01\n\x18CNegotiationSetConfigMsg\x12*\n\x06config\x18\x01\x20\x02(\
    \x0b2\x12.CNegotiatedConfigR\x06config\x12O\n\x17streaming_client_config\
    \x18\x02\x20\x01(\x0b2\x17.CStreamingClientConfigR\x15streamingClientCon\
    fig\x12I\n\x15streaming_client_caps\x18\x03\x20\x01(\x0b2\x15.CStreaming\
    ClientCapsR\x13streamingClientCaps\"\x19\n\x17CNegotiationCompleteMsg\"\
    \xca\x01\n\x12CStartAudioDataMsg\x12\x18\n\x07channel\x18\x02\x20\x02(\r\
    R\x07channel\x12A\n\x05codec\x18\x03\x20\x01(\x0e2\x12.EStreamAudioCodec\
    :\x17k_EStreamAudioCodecNoneR\x05codec\x12\x1d\n\ncodec_data\x18\x04\x20\
    \x01(\x0cR\tcodecData\x12\x1c\n\tfrequency\x18\x05\x20\x01(\rR\tfrequenc\
    y\x12\x1a\n\x08channels\x18\x06\x20\x01(\rR\x08channels\"\x13\n\x11CStop\
    AudioDataMsg\"\xbe\x01\n\x12CStartVideoDataMsg\x12\x18\n\x07channel\x18\
    \x01\x20\x02(\rR\x07channel\x12A\n\x05codec\x18\x02\x20\x01(\x0e2\x12.ES\
    treamVideoCodec:\x17k_EStreamVideoCodecNoneR\x05codec\x12\x1d\n\ncodec_d\
    ata\x18\x03\x20\x01(\x0cR\tcodecData\x12\x14\n\x05width\x18\x04\x20\x01(\
    \rR\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\rR\x06height\"\x13\n\
    \x11CStopVideoDataMsg\"K\n\x14CInputLatencyTestMsg\x12\x1d\n\ninput_mark\
    \x18\x01\x20\x02(\rR\tinputMark\x12\x14\n\x05color\x18\x02\x20\x01(\rR\
    \x05color\"\x9b\x01\n\x18CInputTouchFingerDownMsg\x12\x1d\n\ninput_mark\
    \x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08fingerid\x18\x02\x20\x01(\
    \x04R\x08fingerid\x12!\n\x0cx_normalized\x18\x03\x20\x01(\x02R\x0bxNorma\
    lized\x12!\n\x0cy_normalized\x18\x04\x20\x01(\x02R\x0byNormalized\"\x9d\
    \x01\n\x1aCInputTouchFingerMotionMsg\x12\x1d\n\ninput_mark\x18\x01\x20\
    \x01(\rR\tinputMark\x12\x1a\n\x08fingerid\x18\x02\x20\x01(\x04R\x08finge\
    rid\x12!\n\x0cx_normalized\x18\x03\x20\x01(\x02R\x0bxNormalized\x12!\n\
    \x0cy_normalized\x18\x04\x20\x01(\x02R\x0byNormalized\"\x99\x01\n\x16CIn\
    putTouchFingerUpMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\
    \x12\x1a\n\x08fingerid\x18\x02\x20\x01(\x04R\x08fingerid\x12!\n\x0cx_nor\
    malized\x18\x03\x20\x01(\x02R\x0bxNormalized\x12!\n\x0cy_normalized\x18\
    \x04\x20\x01(\x02R\x0byNormalized\"\x9b\x01\n\x14CInputMouseMotionMsg\
    \x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12!\n\x0cx_normal\
    ized\x18\x02\x20\x01(\x02R\x0bxNormalized\x12!\n\x0cy_normalized\x18\x03\
    \x20\x01(\x02R\x0byNormalized\x12\x0e\n\x02dx\x18\x04\x20\x01(\x05R\x02d\
    x\x12\x0e\n\x02dy\x18\x05\x20\x01(\x05R\x02dy\"\x86\x01\n\x13CInputMouse\
    WheelMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12P\n\tdi\
    rection\x18\x02\x20\x02(\x0e2\x1b.EStreamMouseWheelDirection:\x15k_EStre\
    amMouseWheelUpR\tdirection\"z\n\x12CInputMouseDownMsg\x12\x1d\n\ninput_m\
    ark\x18\x01\x20\x01(\rR\tinputMark\x12E\n\x06button\x18\x02\x20\x02(\x0e\
    2\x13.EStreamMouseButton:\x18k_EStreamMouseButtonLeftR\x06button\"x\n\
    \x10CInputMouseUpMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMar\
    k\x12E\n\x06button\x18\x02\x20\x02(\x0e2\x13.EStreamMouseButton:\x18k_ES\
    treamMouseButtonLeftR\x06button\"M\n\x10CInputKeyDownMsg\x12\x1d\n\ninpu\
    t_mark\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08scancode\x18\x02\x20\
    \x02(\rR\x08scancode\"K\n\x0eCInputKeyUpMsg\x12\x1d\n\ninput_mark\x18\
    \x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08scancode\x18\x02\x20\x02(\rR\
    \x08scancode\"K\n\rCInputTextMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\
    \rR\tinputMark\x12\x1b\n\ttext_utf8\x18\x02\x20\x02(\tR\x08textUtf8\"\"\
    \n\x0cCSetTitleMsg\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"B\n\
    \x12CSetCaptureSizeMsg\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05width\
    \x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\"Q\n\x0bCSetIconMsg\
    \x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05width\x12\x16\n\x06height\
    \x18\x02\x20\x01(\x05R\x06height\x12\x14\n\x05image\x18\x03\x20\x01(\x0c\
    R\x05image\"^\n\x11CSetFlashStateMsg\x12\x14\n\x05flags\x18\x01\x20\x01(\
    \rR\x05flags\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05count\x12\x1d\n\n\
    timeout_ms\x18\x03\x20\x01(\rR\ttimeoutMs\"V\n\x0eCShowCursorMsg\x12!\n\
    \x0cx_normalized\x18\x01\x20\x01(\x02R\x0bxNormalized\x12!\n\x0cy_normal\
    ized\x18\x02\x20\x01(\x02R\x0byNormalized\"\x10\n\x0eCHideCursorMsg\",\n\
    \rCSetCursorMsg\x12\x1b\n\tcursor_id\x18\x01\x20\x02(\x04R\x08cursorId\"\
    1\n\x12CGetCursorImageMsg\x12\x1b\n\tcursor_id\x18\x01\x20\x02(\x04R\x08\
    cursorId\"\x9f\x01\n\x12CSetCursorImageMsg\x12\x1b\n\tcursor_id\x18\x01\
    \x20\x02(\x04R\x08cursorId\x12\x14\n\x05width\x18\x02\x20\x01(\x05R\x05w\
    idth\x12\x16\n\x06height\x18\x03\x20\x01(\x05R\x06height\x12\x13\n\x05ho\
    t_x\x18\x04\x20\x01(\x05R\x04hotX\x12\x13\n\x05hot_y\x18\x05\x20\x01(\
    \x05R\x04hotY\x12\x14\n\x05image\x18\x06\x20\x01(\x0cR\x05image\"D\n\x14\
    CVideoDecoderInfoMsg\x12\x12\n\x04info\x18\x01\x20\x01(\tR\x04info\x12\
    \x18\n\x07threads\x18\x02\x20\x01(\x05R\x07threads\"*\n\x14CVideoEncoder\
    InfoMsg\x12\x12\n\x04info\x18\x01\x20\x01(\tR\x04info\"\x0b\n\tCPauseMsg\
    \"\x0c\n\nCResumeMsg\"\x0e\n\x0cCQuitRequest\"/\n\x10CDeleteCursorMsg\
    \x12\x1b\n\tcursor_id\x18\x01\x20\x02(\x04R\x08cursorId\"L\n\x19CSetStre\
    amingClientConfig\x12/\n\x06config\x18\x01\x20\x02(\x0b2\x17.CStreamingC\
    lientConfigR\x06config\"%\n\nCSetQoSMsg\x12\x17\n\x07use_qos\x18\x01\x20\
    \x02(\x08R\x06useQos\"\xb6\x01\n\x16CSetTargetFramerateMsg\x12\x1c\n\tfr\
    amerate\x18\x01\x20\x02(\rR\tframerate\x12\x18\n\x07reasons\x18\x02\x20\
    \x01(\rR\x07reasons\x12/\n\x13framerate_numerator\x18\x03\x20\x01(\rR\
    \x12framerateNumerator\x123\n\x15framerate_denominator\x18\x04\x20\x01(\
    \rR\x14framerateDenominator\"0\n\x14CSetTargetBitrateMsg\x12\x18\n\x07bi\
    trate\x18\x01\x20\x02(\x05R\x07bitrate\".\n\x12COverlayEnabledMsg\x12\
    \x18\n\x07enabled\x18\x01\x20\x02(\x08R\x07enabled\"1\n\x10CSetGammaRamp\
    Msg\x12\x1d\n\ngamma_ramp\x18\x01\x20\x01(\x0cR\tgammaRamp\"l\n\x0fCSetA\
    ctivityMsg\x12C\n\x08activity\x18\x01\x20\x01(\x0e2\x10.EStreamActivity:\
    \x15k_EStreamActivityIdleR\x08activity\x12\x14\n\x05appid\x18\x02\x20\
    \x01(\rR\x05appid\"\x13\n\x11CSystemSuspendMsg\"4\n\x16CVirtualHereReque\
    stMsg\x12\x1a\n\x08hostname\x18\x01\x20\x01(\tR\x08hostname\"J\n\x14CVir\
    tualHereReadyMsg\x122\n\x15licensed_device_count\x18\x01\x20\x01(\rR\x13\
    licensedDeviceCount\"C\n\x1aCVirtualHereShareDeviceMsg\x12%\n\x0edevice_\
    address\x18\x01\x20\x01(\tR\rdeviceAddress\"0\n\x14CSetSpectatorModeMsg\
    \x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\"#\n\rCRemoteHIDM\
    sg\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"I\n\x15CTouchConfigA\
    ctiveMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1a\n\x08re\
    vision\x18\x02\x20\x01(\rR\x08revision\".\n\x16CGetTouchConfigDataMsg\
    \x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"v\n\x16CSetTouchConfig\
    DataMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1a\n\x08rev\
    ision\x18\x02\x20\x01(\rR\x08revision\x12\x12\n\x04data\x18\x03\x20\x01(\
    \x0cR\x04data\x12\x16\n\x06layout\x18\x04\x20\x01(\x0cR\x06layout\"I\n\
    \x19CSaveTouchConfigLayoutMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05\
    appid\x12\x16\n\x06layout\x18\x04\x20\x01(\x0cR\x06layout\"S\n\x18CTouch\
    ActionSetActiveMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\
    \n\x0cactionset_id\x18\x02\x20\x01(\x05R\x0bactionsetId\"@\n\x14CGetTouc\
    hIconDataMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\
    \x04icon\x18\x02\x20\x01(\tR\x04icon\"T\n\x14CSetTouchIconDataMsg\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04icon\x18\x02\
    \x20\x01(\tR\x04icon\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\".\
    \n\x12CStreamDataLostMsg\x12\x18\n\x07packets\x18\x01\x20\x03(\rR\x07pac\
    kets\"\x83\x01\n\x0cCAudioFormat\x129\n\x06format\x18\x01\x20\x02(\x0e2\
    \r.EAudioFormat:\x12k_EAudioFormatNoneR\x06format\x12\x1c\n\tfrequency\
    \x18\x02\x20\x01(\rR\tfrequency\x12\x1a\n\x08channels\x18\x03\x20\x01(\r\
    R\x08channels\"w\n\x0cCVideoFormat\x129\n\x06format\x18\x01\x20\x02(\x0e\
    2\r.EVideoFormat:\x12k_EVideoFormatNoneR\x06format\x12\x14\n\x05width\
    \x18\x02\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x03\x20\x01(\rR\
    \x06height\"t\n\x0bCFrameEvent\x12G\n\x08event_id\x18\x01\x20\x02(\x0e2\
    \x12.EStreamFrameEvent:\x18k_EStreamInputEventStartR\x07eventId\x12\x1c\
    \n\ttimestamp\x18\x02\x20\x02(\rR\ttimestamp\"\xe5\x03\n\x0bCFrameStats\
    \x12\x19\n\x08frame_id\x18\x01\x20\x02(\rR\x07frameId\x12\x1d\n\ninput_m\
    ark\x18\x02\x20\x01(\rR\tinputMark\x12$\n\x06events\x18\x03\x20\x03(\x0b\
    2\x0c.CFrameEventR\x06events\x12H\n\x06result\x18\x04\x20\x02(\x0e2\x13.\
    EStreamFrameResult:\x1bk_EStreamFrameResultPendingR\x06result\x12*\n\x11\
    frame_start_delta\x18\x05\x20\x01(\x02R\x0fframeStartDelta\x12.\n\x13fra\
    me_display_delta\x18\x06\x20\x01(\x02R\x11frameDisplayDelta\x12\x1b\n\tp\
    ing_time\x18\x07\x20\x01(\x02R\x08pingTime\x12%\n\x0eserver_bitrate\x18\
    \x08\x20\x01(\x02R\rserverBitrate\x12%\n\x0eclient_bitrate\x18\t\x20\x01\
    (\x02R\rclientBitrate\x12%\n\x0elink_bandwidth\x18\n\x20\x01(\x02R\rlink\
    Bandwidth\x12\x1f\n\x0bpacket_loss\x18\x0b\x20\x01(\x02R\npacketLoss\x12\
    \x1d\n\nframe_size\x18\x0c\x20\x01(\rR\tframeSize\"\xaa\x01\n\x1aCFrameS\
    tatAccumulatedValue\x12D\n\tstat_type\x18\x01\x20\x02(\x0e2\x16.EFrameAc\
    cumulatedStat:\x0fk_EFrameStatFPSR\x08statType\x12\x14\n\x05count\x18\
    \x02\x20\x02(\x05R\x05count\x12\x18\n\x07average\x18\x03\x20\x02(\x02R\
    \x07average\x12\x16\n\x06stddev\x18\x04\x20\x01(\x02R\x06stddev\"\xf3\
    \x01\n\x12CFrameStatsListMsg\x12G\n\tdata_type\x18\x01\x20\x02(\x0e2\x13\
    .EStreamingDataType:\x15k_EStreamingAudioDataR\x08dataType\x12\"\n\x05st\
    ats\x18\x02\x20\x03(\x0b2\x0c.CFrameStatsR\x05stats\x12H\n\x11accumulate\
    d_stats\x18\x03\x20\x03(\x0b2\x1b.CFrameStatAccumulatedValueR\x10accumul\
    atedStats\x12&\n\x0flatest_frame_id\x18\x04\x20\x02(\x05R\rlatestFrameId\
    \"\xb8\x01\n\x16CStreamingSessionStats\x122\n\x15frame_loss_percentage\
    \x18\x01\x20\x01(\x02R\x13frameLossPercentage\x125\n\x17average_network_\
    time_ms\x18\x02\x20\x01(\x02R\x14averageNetworkTimeMs\x123\n\x16stddev_n\
    etwork_time_ms\x18\x03\x20\x01(\x02R\x13stddevNetworkTimeMs\"/\n\rCDebug\
    DumpMsg\x12\x1e\n\nscreenshot\x18\x01\x20\x01(\x0cR\nscreenshot\"7\n\x07\
    CLogMsg\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x18\n\x07mes\
    sage\x18\x02\x20\x01(\tR\x07message\"\\\n\rCLogUploadMsg\x127\n\x04type\
    \x18\x01\x20\x01(\x0e2\r.ELogFileType:\x14k_ELogFileSystemBootR\x04type\
    \x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\x86\x03\n\x13CTranspo\
    rtSignalMsg\x12:\n\x06webrtc\x18\x01\x20\x01(\x0b2\".CTransportSignalMsg\
    .WebRTCMessageR\x06webrtc\x12\x10\n\x03sdr\x18\x02\x20\x03(\x0cR\x03sdr\
    \x1a\xa0\x02\n\rWebRTCMessage\x12\x1c\n\x08greeting\x18\x01\x20\x01(\x08\
    H\0R\x08greeting\x12\x16\n\x05offer\x18\x02\x20\x01(\tH\0R\x05offer\x12\
    \x18\n\x06answer\x18\x03\x20\x01(\tH\0R\x06answer\x12L\n\tcandidate\x18\
    \x04\x20\x01(\x0b2,.CTransportSignalMsg.WebRTCMessage.CandidateH\0R\tcan\
    didate\x1aj\n\tCandidate\x12\x17\n\x07sdp_mid\x18\x01\x20\x01(\tR\x06sdp\
    Mid\x12&\n\x0fsdp_mline_index\x18\x02\x20\x01(\x05R\rsdpMlineIndex\x12\
    \x1c\n\tcandidate\x18\x03\x20\x01(\tR\tcandidateB\x05\n\x03msg*\xb3\x01\
    \n\x0eEStreamChannel\x12$\n\x17k_EStreamChannelInvalid\x10\xff\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01\x12\x1d\n\x19k_EStreamChannelDiscovery\x10\
    \0\x12\x1b\n\x17k_EStreamChannelControl\x10\x01\x12\x19\n\x15k_EStreamCh\
    annelStats\x10\x02\x12$\n\x20k_EStreamChannelDataChannelStart\x10\x03*`\
    \n\x17EStreamDiscoveryMessage\x12!\n\x1dk_EStreamDiscoveryPingRequest\
    \x10\x01\x12\"\n\x1ek_EStreamDiscoveryPingResponse\x10\x02*\xe2\x17\n\
    \x15EStreamControlMessage\x12)\n%k_EStreamControlAuthenticationRequest\
    \x10\x01\x12*\n&k_EStreamControlAuthenticationResponse\x10\x02\x12#\n\
    \x1fk_EStreamControlNegotiationInit\x10\x03\x12(\n$k_EStreamControlNegot\
    iationSetConfig\x10\x04\x12'\n#k_EStreamControlNegotiationComplete\x10\
    \x05\x12#\n\x1fk_EStreamControlClientHandshake\x10\x06\x12#\n\x1fk_EStre\
    amControlServerHandshake\x10\x07\x12$\n\x20k_EStreamControlStartNetworkT\
    est\x10\x08\x12\x1d\n\x19k_EStreamControlKeepAlive\x10\t\x12'\n#k_EStrea\
    mControl_LAST_SETUP_MESSAGE\x10\x0f\x12\"\n\x1ek_EStreamControlStartAudi\
    oData\x102\x12!\n\x1dk_EStreamControlStopAudioData\x103\x12\"\n\x1ek_ESt\
    reamControlStartVideoData\x104\x12!\n\x1dk_EStreamControlStopVideoData\
    \x105\x12$\n\x20k_EStreamControlInputMouseMotion\x106\x12#\n\x1fk_EStrea\
    mControlInputMouseWheel\x107\x12\"\n\x1ek_EStreamControlInputMouseDown\
    \x108\x12\x20\n\x1ck_EStreamControlInputMouseUp\x109\x12\x20\n\x1ck_EStr\
    eamControlInputKeyDown\x10:\x12\x1e\n\x1ak_EStreamControlInputKeyUp\x10;\
    \x121\n-k_EStreamControlInputGamepadAttached_OBSOLETE\x10<\x12.\n*k_EStr\
    eamControlInputGamepadEvent_OBSOLETE\x10=\x121\n-k_EStreamControlInputGa\
    mepadDetached_OBSOLETE\x10>\x12\x1e\n\x1ak_EStreamControlShowCursor\x10?\
    \x12\x1e\n\x1ak_EStreamControlHideCursor\x10@\x12\x1d\n\x19k_EStreamCont\
    rolSetCursor\x10A\x12\"\n\x1ek_EStreamControlGetCursorImage\x10B\x12\"\n\
    \x1ek_EStreamControlSetCursorImage\x10C\x12\x20\n\x1ck_EStreamControlDel\
    eteCursor\x10D\x12&\n\"k_EStreamControlSetTargetFramerate\x10E\x12$\n\
    \x20k_EStreamControlInputLatencyTest\x10F\x12*\n&k_EStreamControlGamepad\
    Rumble_OBSOLETE\x10G\x12\"\n\x1ek_EStreamControlOverlayEnabled\x10J\x124\
    \n0k_EStreamControlInputControllerAttached_OBSOLETE\x10K\x121\n-k_EStrea\
    mControlInputControllerState_OBSOLETE\x10L\x12/\n+k_EStreamControlTrigge\
    rHapticPulse_OBSOLETE\x10M\x124\n0k_EStreamControlInputControllerDetache\
    d_OBSOLETE\x10N\x12$\n\x20k_EStreamControlVideoDecoderInfo\x10P\x12\x1c\
    \n\x18k_EStreamControlSetTitle\x10Q\x12\x1b\n\x17k_EStreamControlSetIcon\
    \x10R\x12\x1f\n\x1bk_EStreamControlQuitRequest\x10S\x12\x1a\n\x16k_EStre\
    amControlSetQoS\x10W\x12<\n8k_EStreamControlInputControllerWirelessPrese\
    nce_OBSOLETE\x10X\x12\x20\n\x1ck_EStreamControlSetGammaRamp\x10Y\x12$\n\
    \x20k_EStreamControlVideoEncoderInfo\x10Z\x124\n0k_EStreamControlInputCo\
    ntrollerStateHID_OBSOLETE\x10]\x12$\n\x20k_EStreamControlSetTargetBitrat\
    e\x10^\x128\n4k_EStreamControlSetControllerPairingEnabled_OBSOLETE\x10_\
    \x127\n3k_EStreamControlSetControllerPairingResult_OBSOLETE\x10`\x128\n4\
    k_EStreamControlTriggerControllerDisconnect_OBSOLETE\x10a\x12\x1f\n\x1bk\
    _EStreamControlSetActivity\x10b\x12,\n(k_EStreamControlSetStreamingClien\
    tConfig\x10c\x12!\n\x1dk_EStreamControlSystemSuspend\x10d\x122\n.k_EStre\
    amControlSetControllerSettings_OBSOLETE\x10e\x12&\n\"k_EStreamControlVir\
    tualHereRequest\x10f\x12$\n\x20k_EStreamControlVirtualHereReady\x10g\x12\
    *\n&k_EStreamControlVirtualHereShareDevice\x10h\x12$\n\x20k_EStreamContr\
    olSetSpectatorMode\x10i\x12\x1d\n\x19k_EStreamControlRemoteHID\x10j\x12'\
    \n#k_EStreamControlStartMicrophoneData\x10k\x12&\n\"k_EStreamControlStop\
    MicrophoneData\x10l\x12\x1d\n\x19k_EStreamControlInputText\x10m\x12%\n!k\
    _EStreamControlTouchConfigActive\x10n\x12&\n\"k_EStreamControlGetTouchCo\
    nfigData\x10o\x12&\n\"k_EStreamControlSetTouchConfigData\x10p\x12)\n%k_E\
    StreamControlSaveTouchConfigLayout\x10q\x12(\n$k_EStreamControlTouchActi\
    onSetActive\x10r\x12$\n\x20k_EStreamControlGetTouchIconData\x10s\x12$\n\
    \x20k_EStreamControlSetTouchIconData\x10t\x12(\n$k_EStreamControlInputTo\
    uchFingerDown\x10u\x12*\n&k_EStreamControlInputTouchFingerMotion\x10v\
    \x12&\n\"k_EStreamControlInputTouchFingerUp\x10w\x12\"\n\x1ek_EStreamCon\
    trolSetCaptureSize\x10x\x12!\n\x1dk_EStreamControlSetFlashState\x10y\x12\
    \x19\n\x15k_EStreamControlPause\x10z\x12\x1a\n\x16k_EStreamControlResume\
    \x10{*G\n\x0eEStreamVersion\x12\x18\n\x14k_EStreamVersionNone\x10\0\x12\
    \x1b\n\x17k_EStreamVersionCurrent\x10\x01*\xc0\x01\n\x11EStreamAudioCode\
    c\x12\x1b\n\x17k_EStreamAudioCodecNone\x10\0\x12\x1a\n\x16k_EStreamAudio\
    CodecRaw\x10\x01\x12\x1d\n\x19k_EStreamAudioCodecVorbis\x10\x02\x12\x1b\
    \n\x17k_EStreamAudioCodecOpus\x10\x03\x12\x1a\n\x16k_EStreamAudioCodecMP\
    3\x10\x04\x12\x1a\n\x16k_EStreamAudioCodecAAC\x10\x05*\xfa\x01\n\x11EStr\
    eamVideoCodec\x12\x1b\n\x17k_EStreamVideoCodecNone\x10\0\x12\x1a\n\x16k_\
    EStreamVideoCodecRaw\x10\x01\x12\x1a\n\x16k_EStreamVideoCodecVP8\x10\x02\
    \x12\x1a\n\x16k_EStreamVideoCodecVP9\x10\x03\x12\x1b\n\x17k_EStreamVideo\
    CodecH264\x10\x04\x12\x1b\n\x17k_EStreamVideoCodecHEVC\x10\x05\x12\x1c\n\
    \x18k_EStreamVideoCodecORBX1\x10\x06\x12\x1c\n\x18k_EStreamVideoCodecORB\
    X2\x10\x07*q\n\x18EStreamQualityPreference\x12\x18\n\x14k_EStreamQuality\
    Fast\x10\x01\x12\x1c\n\x18k_EStreamQualityBalanced\x10\x02\x12\x1d\n\x19\
    k_EStreamQualityBeautiful\x10\x03*X\n\x0eEStreamBitrate\x12'\n\x1ak_EStr\
    eamBitrateAutodetect\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1d\
    \n\x19k_EStreamBitrateUnlimited\x10\0*e\n\x1eEStreamHostPlayAudioPrefere\
    nce\x12!\n\x1dk_EStreamHostPlayAudioDefault\x10\0\x12\x20\n\x1ck_EStream\
    HostPlayAudioAlways\x10\x01*j\n\x12EStreamingDataType\x12\x19\n\x15k_ESt\
    reamingAudioData\x10\0\x12\x19\n\x15k_EStreamingVideoData\x10\x01\x12\
    \x1e\n\x1ak_EStreamingMicrophoneData\x10\x02*\xcb\x01\n\x12EStreamMouseB\
    utton\x12\x1c\n\x18k_EStreamMouseButtonLeft\x10\x01\x12\x1d\n\x19k_EStre\
    amMouseButtonRight\x10\x02\x12\x1e\n\x1ak_EStreamMouseButtonMiddle\x10\
    \x10\x12\x1a\n\x16k_EStreamMouseButtonX1\x10\x20\x12\x1a\n\x16k_EStreamM\
    ouseButtonX2\x10@\x12\x20\n\x1bk_EStreamMouseButtonUnknown\x10\x80\x20*\
    \x98\x01\n\x1aEStreamMouseWheelDirection\x12\x19\n\x15k_EStreamMouseWhee\
    lUp\x10x\x12$\n\x17k_EStreamMouseWheelDown\x10\x88\xff\xff\xff\xff\xff\
    \xff\xff\xff\x01\x12\x1b\n\x17k_EStreamMouseWheelLeft\x10\x03\x12\x1c\n\
    \x18k_EStreamMouseWheelRight\x10\x04*\xa7\x06\n\x17EStreamGamepadInputTy\
    pe\x12\x20\n\x1ck_EStreamGamepadInputInvalid\x10\0\x12\x1f\n\x1bk_EStrea\
    mGamepadInputDPadUp\x10\x01\x12!\n\x1dk_EStreamGamepadInputDPadDown\x10\
    \x02\x12!\n\x1dk_EStreamGamepadInputDPadLeft\x10\x04\x12\"\n\x1ek_EStrea\
    mGamepadInputDPadRight\x10\x08\x12\x1e\n\x1ak_EStreamGamepadInputStart\
    \x10\x10\x12\x1d\n\x19k_EStreamGamepadInputBack\x10\x20\x12\"\n\x1ek_ESt\
    reamGamepadInputLeftThumb\x10@\x12$\n\x1fk_EStreamGamepadInputRightThumb\
    \x10\x80\x01\x12&\n!k_EStreamGamepadInputLeftShoulder\x10\x80\x02\x12'\n\
    \"k_EStreamGamepadInputRightShoulder\x10\x80\x04\x12\x1f\n\x1ak_EStreamG\
    amepadInputGuide\x10\x80\x08\x12\x1b\n\x16k_EStreamGamepadInputA\x10\x80\
    \x20\x12\x1b\n\x16k_EStreamGamepadInputB\x10\x80@\x12\x1c\n\x16k_EStream\
    GamepadInputX\x10\x80\x80\x01\x12\x1c\n\x16k_EStreamGamepadInputY\x10\
    \x80\x80\x02\x12%\n\x1fk_EStreamGamepadInputLeftThumbX\x10\x80\x80\x04\
    \x12%\n\x1fk_EStreamGamepadInputLeftThumbY\x10\x80\x80\x08\x12&\n\x20k_E\
    StreamGamepadInputRightThumbX\x10\x80\x80\x10\x12&\n\x20k_EStreamGamepad\
    InputRightThumbY\x10\x80\x80\x20\x12&\n\x20k_EStreamGamepadInputLeftTrig\
    ger\x10\x80\x80@\x12(\n!k_EStreamGamepadInputRightTrigger\x10\x80\x80\
    \x80\x01*\x89\x02\n\x17EStreamFramerateLimiter\x12!\n\x1dk_EStreamFramer\
    ateSlowCapture\x10\x01\x12!\n\x1dk_EStreamFramerateSlowConvert\x10\x02\
    \x12\x20\n\x1ck_EStreamFramerateSlowEncode\x10\x04\x12!\n\x1dk_EStreamFr\
    amerateSlowNetwork\x10\x08\x12\x20\n\x1ck_EStreamFramerateSlowDecode\x10\
    \x10\x12\x1e\n\x1ak_EStreamFramerateSlowGame\x10\x20\x12!\n\x1dk_EStream\
    FramerateSlowDisplay\x10@*e\n\x0fEStreamActivity\x12\x19\n\x15k_EStreamA\
    ctivityIdle\x10\x01\x12\x19\n\x15k_EStreamActivityGame\x10\x02\x12\x1c\n\
    \x18k_EStreamActivityDesktop\x10\x03*D\n\x12EStreamDataMessage\x12\x17\n\
    \x13k_EStreamDataPacket\x10\x01\x12\x15\n\x11k_EStreamDataLost\x10\x02*d\
    \n\x0cEAudioFormat\x12\x16\n\x12k_EAudioFormatNone\x10\0\x12#\n\x1fk_EAu\
    dioFormat16BitLittleEndian\x10\x01\x12\x17\n\x13k_EAudioFormatFloat\x10\
    \x02*W\n\x0cEVideoFormat\x12\x16\n\x12k_EVideoFormatNone\x10\0\x12\x16\n\
    \x12k_EVideoFormatYV12\x10\x01\x12\x17\n\x13k_EVideoFormatAccel\x10\x02*\
    \xd7\x01\n\x13EStreamStatsMessage\x12\x1d\n\x19k_EStreamStatsFrameEvents\
    \x10\x01\x12\x1b\n\x17k_EStreamStatsDebugDump\x10\x02\x12\x1c\n\x18k_ESt\
    reamStatsLogMessage\x10\x03\x12\x20\n\x1ck_EStreamStatsLogUploadBegin\
    \x10\x04\x12\x1f\n\x1bk_EStreamStatsLogUploadData\x10\x05\x12#\n\x1fk_ES\
    treamStatsLogUploadComplete\x10\x06*\x85\x05\n\x11EStreamFrameEvent\x12\
    \x1c\n\x18k_EStreamInputEventStart\x10\0\x12\x1b\n\x17k_EStreamInputEven\
    tSend\x10\x01\x12\x1b\n\x17k_EStreamInputEventRecv\x10\x02\x12\x1d\n\x19\
    k_EStreamInputEventQueued\x10\x03\x12\x1e\n\x1ak_EStreamInputEventHandle\
    d\x10\x04\x12\x1c\n\x18k_EStreamFrameEventStart\x10\x05\x12#\n\x1fk_EStr\
    eamFrameEventCaptureBegin\x10\x06\x12!\n\x1dk_EStreamFrameEventCaptureEn\
    d\x10\x07\x12#\n\x1fk_EStreamFrameEventConvertBegin\x10\x08\x12!\n\x1dk_\
    EStreamFrameEventConvertEnd\x10\t\x12\"\n\x1ek_EStreamFrameEventEncodeBe\
    gin\x10\n\x12\x20\n\x1ck_EStreamFrameEventEncodeEnd\x10\x0b\x12\x1b\n\
    \x17k_EStreamFrameEventSend\x10\x0c\x12\x1b\n\x17k_EStreamFrameEventRecv\
    \x10\r\x12\"\n\x1ek_EStreamFrameEventDecodeBegin\x10\x0e\x12\x20\n\x1ck_\
    EStreamFrameEventDecodeEnd\x10\x0f\x12\"\n\x1ek_EStreamFrameEventUploadB\
    egin\x10\x10\x12\x20\n\x1ck_EStreamFrameEventUploadEnd\x10\x11\x12\x1f\n\
    \x1bk_EStreamFrameEventComplete\x10\x12*\xd4\x02\n\x12EStreamFrameResult\
    \x12\x1f\n\x1bk_EStreamFrameResultPending\x10\0\x12!\n\x1dk_EStreamFrame\
    ResultDisplayed\x10\x01\x12*\n&k_EStreamFrameResultDroppedNetworkSlow\
    \x10\x02\x12*\n&k_EStreamFrameResultDroppedNetworkLost\x10\x03\x12)\n%k_\
    EStreamFrameResultDroppedDecodeSlow\x10\x04\x12,\n(k_EStreamFrameResultD\
    roppedDecodeCorrupt\x10\x05\x12#\n\x1fk_EStreamFrameResultDroppedLate\
    \x10\x06\x12$\n\x20k_EStreamFrameResultDroppedReset\x10\x07*\xa2\x05\n\
    \x15EFrameAccumulatedStat\x12\x13\n\x0fk_EFrameStatFPS\x10\0\x12!\n\x1dk\
    _EFrameStatCaptureDurationMS\x10\x01\x12!\n\x1dk_EFrameStatConvertDurati\
    onMS\x10\x02\x12\x20\n\x1ck_EFrameStatEncodeDurationMS\x10\x03\x12\x1f\n\
    \x1bk_EFrameStatSteamDurationMS\x10\x04\x12\x20\n\x1ck_EFrameStatServerD\
    urationMS\x10\x05\x12!\n\x1dk_EFrameStatNetworkDurationMS\x10\x06\x12\
    \x20\n\x1ck_EFrameStatDecodeDurationMS\x10\x07\x12!\n\x1dk_EFrameStatDis\
    playDurationMS\x10\x08\x12\x20\n\x1ck_EFrameStatClientDurationMS\x10\t\
    \x12\x1f\n\x1bk_EFrameStatFrameDurationMS\x10\n\x12\x1e\n\x1ak_EFrameSta\
    tInputLatencyMS\x10\x0b\x12\x1d\n\x19k_EFrameStatGameLatencyMS\x10\x0c\
    \x12\"\n\x1ek_EFrameStatRoundTripLatencyMS\x10\r\x12\x1a\n\x16k_EFrameSt\
    atPingTimeMS\x10\x0e\x12'\n#k_EFrameStatServerBitrateKbitPerSec\x10\x0f\
    \x12'\n#k_EFrameStatClientBitrateKbitPerSec\x10\x10\x12'\n#k_EFrameStatL\
    inkBandwidthKbitPerSec\x10\x11\x12$\n\x20k_EFrameStatPacketLossPercentag\
    e\x10\x12*^\n\x0cELogFileType\x12\x18\n\x14k_ELogFileSystemBoot\x10\0\
    \x12\x19\n\x15k_ELogFileSystemReset\x10\x01\x12\x19\n\x15k_ELogFileSyste\
    mDebug\x10\x02B\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
