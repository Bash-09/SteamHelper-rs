// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_friendmessages.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_GetRecentMessages_Request {
    // message fields
    steamid1: ::std::option::Option<u64>,
    steamid2: ::std::option::Option<u64>,
    count: ::std::option::Option<u32>,
    most_recent_conversation: ::std::option::Option<bool>,
    rtime32_start_time: ::std::option::Option<u32>,
    bbcode_format: ::std::option::Option<bool>,
    start_ordinal: ::std::option::Option<u32>,
    time_last: ::std::option::Option<u32>,
    ordinal_last: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_GetRecentMessages_Request {
    fn default() -> &'a CFriendMessages_GetRecentMessages_Request {
        <CFriendMessages_GetRecentMessages_Request as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_GetRecentMessages_Request {
    pub fn new() -> CFriendMessages_GetRecentMessages_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid1 = 1;


    pub fn get_steamid1(&self) -> u64 {
        self.steamid1.unwrap_or(0)
    }
    pub fn clear_steamid1(&mut self) {
        self.steamid1 = ::std::option::Option::None;
    }

    pub fn has_steamid1(&self) -> bool {
        self.steamid1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid1(&mut self, v: u64) {
        self.steamid1 = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid2 = 2;


    pub fn get_steamid2(&self) -> u64 {
        self.steamid2.unwrap_or(0)
    }
    pub fn clear_steamid2(&mut self) {
        self.steamid2 = ::std::option::Option::None;
    }

    pub fn has_steamid2(&self) -> bool {
        self.steamid2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid2(&mut self, v: u64) {
        self.steamid2 = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional bool most_recent_conversation = 4;


    pub fn get_most_recent_conversation(&self) -> bool {
        self.most_recent_conversation.unwrap_or(false)
    }
    pub fn clear_most_recent_conversation(&mut self) {
        self.most_recent_conversation = ::std::option::Option::None;
    }

    pub fn has_most_recent_conversation(&self) -> bool {
        self.most_recent_conversation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_most_recent_conversation(&mut self, v: bool) {
        self.most_recent_conversation = ::std::option::Option::Some(v);
    }

    // optional fixed32 rtime32_start_time = 5;


    pub fn get_rtime32_start_time(&self) -> u32 {
        self.rtime32_start_time.unwrap_or(0)
    }
    pub fn clear_rtime32_start_time(&mut self) {
        self.rtime32_start_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_start_time(&self) -> bool {
        self.rtime32_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_start_time(&mut self, v: u32) {
        self.rtime32_start_time = ::std::option::Option::Some(v);
    }

    // optional bool bbcode_format = 6;


    pub fn get_bbcode_format(&self) -> bool {
        self.bbcode_format.unwrap_or(false)
    }
    pub fn clear_bbcode_format(&mut self) {
        self.bbcode_format = ::std::option::Option::None;
    }

    pub fn has_bbcode_format(&self) -> bool {
        self.bbcode_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bbcode_format(&mut self, v: bool) {
        self.bbcode_format = ::std::option::Option::Some(v);
    }

    // optional uint32 start_ordinal = 7;


    pub fn get_start_ordinal(&self) -> u32 {
        self.start_ordinal.unwrap_or(0)
    }
    pub fn clear_start_ordinal(&mut self) {
        self.start_ordinal = ::std::option::Option::None;
    }

    pub fn has_start_ordinal(&self) -> bool {
        self.start_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_ordinal(&mut self, v: u32) {
        self.start_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last = 8;


    pub fn get_time_last(&self) -> u32 {
        self.time_last.unwrap_or(0)
    }
    pub fn clear_time_last(&mut self) {
        self.time_last = ::std::option::Option::None;
    }

    pub fn has_time_last(&self) -> bool {
        self.time_last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last(&mut self, v: u32) {
        self.time_last = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal_last = 9;


    pub fn get_ordinal_last(&self) -> u32 {
        self.ordinal_last.unwrap_or(0)
    }
    pub fn clear_ordinal_last(&mut self) {
        self.ordinal_last = ::std::option::Option::None;
    }

    pub fn has_ordinal_last(&self) -> bool {
        self.ordinal_last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal_last(&mut self, v: u32) {
        self.ordinal_last = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendMessages_GetRecentMessages_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid1 = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid2 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.most_recent_conversation = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_start_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bbcode_format = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.start_ordinal = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal_last = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid1 {
            my_size += 9;
        }
        if let Some(v) = self.steamid2 {
            my_size += 9;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.most_recent_conversation {
            my_size += 2;
        }
        if let Some(v) = self.rtime32_start_time {
            my_size += 5;
        }
        if let Some(v) = self.bbcode_format {
            my_size += 2;
        }
        if let Some(v) = self.start_ordinal {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal_last {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid1 {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steamid2 {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.most_recent_conversation {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.rtime32_start_time {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.bbcode_format {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.start_ordinal {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.time_last {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.ordinal_last {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_GetRecentMessages_Request {
        CFriendMessages_GetRecentMessages_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid1",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.steamid1 },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.steamid1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid2",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.steamid2 },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.steamid2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.count },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "most_recent_conversation",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.most_recent_conversation },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.most_recent_conversation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_start_time",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.rtime32_start_time },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.rtime32_start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bbcode_format",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.bbcode_format },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.bbcode_format },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "start_ordinal",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.start_ordinal },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.start_ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.time_last },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.time_last },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal_last",
                |m: &CFriendMessages_GetRecentMessages_Request| { &m.ordinal_last },
                |m: &mut CFriendMessages_GetRecentMessages_Request| { &mut m.ordinal_last },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_GetRecentMessages_Request>(
                "CFriendMessages_GetRecentMessages_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_GetRecentMessages_Request {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_GetRecentMessages_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_GetRecentMessages_Request::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_GetRecentMessages_Request {
    fn clear(&mut self) {
        self.steamid1 = ::std::option::Option::None;
        self.steamid2 = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.most_recent_conversation = ::std::option::Option::None;
        self.rtime32_start_time = ::std::option::Option::None;
        self.bbcode_format = ::std::option::Option::None;
        self.start_ordinal = ::std::option::Option::None;
        self.time_last = ::std::option::Option::None;
        self.ordinal_last = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_GetRecentMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_GetRecentMessages_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_GetRecentMessages_Response {
    // message fields
    pub messages: ::protobuf::RepeatedField<CFriendMessages_GetRecentMessages_Response_FriendMessage>,
    more_available: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_GetRecentMessages_Response {
    fn default() -> &'a CFriendMessages_GetRecentMessages_Response {
        <CFriendMessages_GetRecentMessages_Response as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_GetRecentMessages_Response {
    pub fn new() -> CFriendMessages_GetRecentMessages_Response {
        ::std::default::Default::default()
    }

    // repeated .CFriendMessages_GetRecentMessages_Response.FriendMessage messages = 1;


    pub fn get_messages(&self) -> &[CFriendMessages_GetRecentMessages_Response_FriendMessage] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<CFriendMessages_GetRecentMessages_Response_FriendMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<CFriendMessages_GetRecentMessages_Response_FriendMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<CFriendMessages_GetRecentMessages_Response_FriendMessage> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }

    // optional bool more_available = 4;


    pub fn get_more_available(&self) -> bool {
        self.more_available.unwrap_or(false)
    }
    pub fn clear_more_available(&mut self) {
        self.more_available = ::std::option::Option::None;
    }

    pub fn has_more_available(&self) -> bool {
        self.more_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_more_available(&mut self, v: bool) {
        self.more_available = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendMessages_GetRecentMessages_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.more_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.more_available {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.more_available {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_GetRecentMessages_Response {
        CFriendMessages_GetRecentMessages_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFriendMessages_GetRecentMessages_Response_FriendMessage>>(
                "messages",
                |m: &CFriendMessages_GetRecentMessages_Response| { &m.messages },
                |m: &mut CFriendMessages_GetRecentMessages_Response| { &mut m.messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "more_available",
                |m: &CFriendMessages_GetRecentMessages_Response| { &m.more_available },
                |m: &mut CFriendMessages_GetRecentMessages_Response| { &mut m.more_available },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_GetRecentMessages_Response>(
                "CFriendMessages_GetRecentMessages_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_GetRecentMessages_Response {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_GetRecentMessages_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_GetRecentMessages_Response::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_GetRecentMessages_Response {
    fn clear(&mut self) {
        self.messages.clear();
        self.more_available = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_GetRecentMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_GetRecentMessages_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_GetRecentMessages_Response_FriendMessage {
    // message fields
    accountid: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    ordinal: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_GetRecentMessages_Response_FriendMessage {
    fn default() -> &'a CFriendMessages_GetRecentMessages_Response_FriendMessage {
        <CFriendMessages_GetRecentMessages_Response_FriendMessage as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_GetRecentMessages_Response_FriendMessage {
    pub fn new() -> CFriendMessages_GetRecentMessages_Response_FriendMessage {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 4;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendMessages_GetRecentMessages_Response_FriendMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_GetRecentMessages_Response_FriendMessage {
        CFriendMessages_GetRecentMessages_Response_FriendMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CFriendMessages_GetRecentMessages_Response_FriendMessage| { &m.accountid },
                |m: &mut CFriendMessages_GetRecentMessages_Response_FriendMessage| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CFriendMessages_GetRecentMessages_Response_FriendMessage| { &m.timestamp },
                |m: &mut CFriendMessages_GetRecentMessages_Response_FriendMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CFriendMessages_GetRecentMessages_Response_FriendMessage| { &m.message },
                |m: &mut CFriendMessages_GetRecentMessages_Response_FriendMessage| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CFriendMessages_GetRecentMessages_Response_FriendMessage| { &m.ordinal },
                |m: &mut CFriendMessages_GetRecentMessages_Response_FriendMessage| { &mut m.ordinal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_GetRecentMessages_Response_FriendMessage>(
                "CFriendMessages_GetRecentMessages_Response.FriendMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_GetRecentMessages_Response_FriendMessage {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_GetRecentMessages_Response_FriendMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_GetRecentMessages_Response_FriendMessage::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_GetRecentMessages_Response_FriendMessage {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.message.clear();
        self.ordinal = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_GetRecentMessages_Response_FriendMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_GetRecentMessages_Response_FriendMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendsMessages_GetActiveMessageSessions_Request {
    // message fields
    lastmessage_since: ::std::option::Option<u32>,
    only_sessions_with_messages: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendsMessages_GetActiveMessageSessions_Request {
    fn default() -> &'a CFriendsMessages_GetActiveMessageSessions_Request {
        <CFriendsMessages_GetActiveMessageSessions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CFriendsMessages_GetActiveMessageSessions_Request {
    pub fn new() -> CFriendsMessages_GetActiveMessageSessions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 lastmessage_since = 1;


    pub fn get_lastmessage_since(&self) -> u32 {
        self.lastmessage_since.unwrap_or(0)
    }
    pub fn clear_lastmessage_since(&mut self) {
        self.lastmessage_since = ::std::option::Option::None;
    }

    pub fn has_lastmessage_since(&self) -> bool {
        self.lastmessage_since.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastmessage_since(&mut self, v: u32) {
        self.lastmessage_since = ::std::option::Option::Some(v);
    }

    // optional bool only_sessions_with_messages = 2;


    pub fn get_only_sessions_with_messages(&self) -> bool {
        self.only_sessions_with_messages.unwrap_or(false)
    }
    pub fn clear_only_sessions_with_messages(&mut self) {
        self.only_sessions_with_messages = ::std::option::Option::None;
    }

    pub fn has_only_sessions_with_messages(&self) -> bool {
        self.only_sessions_with_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_sessions_with_messages(&mut self, v: bool) {
        self.only_sessions_with_messages = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendsMessages_GetActiveMessageSessions_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lastmessage_since = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_sessions_with_messages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lastmessage_since {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.only_sessions_with_messages {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lastmessage_since {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.only_sessions_with_messages {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendsMessages_GetActiveMessageSessions_Request {
        CFriendsMessages_GetActiveMessageSessions_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lastmessage_since",
                |m: &CFriendsMessages_GetActiveMessageSessions_Request| { &m.lastmessage_since },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Request| { &mut m.lastmessage_since },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "only_sessions_with_messages",
                |m: &CFriendsMessages_GetActiveMessageSessions_Request| { &m.only_sessions_with_messages },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Request| { &mut m.only_sessions_with_messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendsMessages_GetActiveMessageSessions_Request>(
                "CFriendsMessages_GetActiveMessageSessions_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendsMessages_GetActiveMessageSessions_Request {
        static instance: ::protobuf::rt::LazyV2<CFriendsMessages_GetActiveMessageSessions_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendsMessages_GetActiveMessageSessions_Request::new)
    }
}

impl ::protobuf::Clear for CFriendsMessages_GetActiveMessageSessions_Request {
    fn clear(&mut self) {
        self.lastmessage_since = ::std::option::Option::None;
        self.only_sessions_with_messages = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendsMessages_GetActiveMessageSessions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendsMessages_GetActiveMessageSessions_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendsMessages_GetActiveMessageSessions_Response {
    // message fields
    pub message_sessions: ::protobuf::RepeatedField<CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendsMessages_GetActiveMessageSessions_Response {
    fn default() -> &'a CFriendsMessages_GetActiveMessageSessions_Response {
        <CFriendsMessages_GetActiveMessageSessions_Response as ::protobuf::Message>::default_instance()
    }
}

impl CFriendsMessages_GetActiveMessageSessions_Response {
    pub fn new() -> CFriendsMessages_GetActiveMessageSessions_Response {
        ::std::default::Default::default()
    }

    // repeated .CFriendsMessages_GetActiveMessageSessions_Response.FriendMessageSession message_sessions = 1;


    pub fn get_message_sessions(&self) -> &[CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession] {
        &self.message_sessions
    }
    pub fn clear_message_sessions(&mut self) {
        self.message_sessions.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_sessions(&mut self, v: ::protobuf::RepeatedField<CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession>) {
        self.message_sessions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_sessions(&mut self) -> &mut ::protobuf::RepeatedField<CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession> {
        &mut self.message_sessions
    }

    // Take field
    pub fn take_message_sessions(&mut self) -> ::protobuf::RepeatedField<CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession> {
        ::std::mem::replace(&mut self.message_sessions, ::protobuf::RepeatedField::new())
    }

    // optional uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendsMessages_GetActiveMessageSessions_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.message_sessions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.message_sessions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.message_sessions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.message_sessions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendsMessages_GetActiveMessageSessions_Response {
        CFriendsMessages_GetActiveMessageSessions_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession>>(
                "message_sessions",
                |m: &CFriendsMessages_GetActiveMessageSessions_Response| { &m.message_sessions },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Response| { &mut m.message_sessions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CFriendsMessages_GetActiveMessageSessions_Response| { &m.timestamp },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Response| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendsMessages_GetActiveMessageSessions_Response>(
                "CFriendsMessages_GetActiveMessageSessions_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendsMessages_GetActiveMessageSessions_Response {
        static instance: ::protobuf::rt::LazyV2<CFriendsMessages_GetActiveMessageSessions_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendsMessages_GetActiveMessageSessions_Response::new)
    }
}

impl ::protobuf::Clear for CFriendsMessages_GetActiveMessageSessions_Response {
    fn clear(&mut self) {
        self.message_sessions.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendsMessages_GetActiveMessageSessions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendsMessages_GetActiveMessageSessions_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
    // message fields
    accountid_friend: ::std::option::Option<u32>,
    last_message: ::std::option::Option<u32>,
    last_view: ::std::option::Option<u32>,
    unread_message_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
    fn default() -> &'a CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
        <CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession as ::protobuf::Message>::default_instance()
    }
}

impl CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
    pub fn new() -> CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
        ::std::default::Default::default()
    }

    // optional uint32 accountid_friend = 1;


    pub fn get_accountid_friend(&self) -> u32 {
        self.accountid_friend.unwrap_or(0)
    }
    pub fn clear_accountid_friend(&mut self) {
        self.accountid_friend = ::std::option::Option::None;
    }

    pub fn has_accountid_friend(&self) -> bool {
        self.accountid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_friend(&mut self, v: u32) {
        self.accountid_friend = ::std::option::Option::Some(v);
    }

    // optional uint32 last_message = 2;


    pub fn get_last_message(&self) -> u32 {
        self.last_message.unwrap_or(0)
    }
    pub fn clear_last_message(&mut self) {
        self.last_message = ::std::option::Option::None;
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: u32) {
        self.last_message = ::std::option::Option::Some(v);
    }

    // optional uint32 last_view = 3;


    pub fn get_last_view(&self) -> u32 {
        self.last_view.unwrap_or(0)
    }
    pub fn clear_last_view(&mut self) {
        self.last_view = ::std::option::Option::None;
    }

    pub fn has_last_view(&self) -> bool {
        self.last_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_view(&mut self, v: u32) {
        self.last_view = ::std::option::Option::Some(v);
    }

    // optional uint32 unread_message_count = 4;


    pub fn get_unread_message_count(&self) -> u32 {
        self.unread_message_count.unwrap_or(0)
    }
    pub fn clear_unread_message_count(&mut self) {
        self.unread_message_count = ::std::option::Option::None;
    }

    pub fn has_unread_message_count(&self) -> bool {
        self.unread_message_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_message_count(&mut self, v: u32) {
        self.unread_message_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid_friend = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_message = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_view = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unread_message_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid_friend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_message {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_view {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unread_message_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid_friend {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.last_message {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_view {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.unread_message_count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
        CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid_friend",
                |m: &CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &m.accountid_friend },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &mut m.accountid_friend },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_message",
                |m: &CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &m.last_message },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &mut m.last_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_view",
                |m: &CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &m.last_view },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &mut m.last_view },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "unread_message_count",
                |m: &CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &m.unread_message_count },
                |m: &mut CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession| { &mut m.unread_message_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession>(
                "CFriendsMessages_GetActiveMessageSessions_Response.FriendMessageSession",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
        static instance: ::protobuf::rt::LazyV2<CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession::new)
    }
}

impl ::protobuf::Clear for CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
    fn clear(&mut self) {
        self.accountid_friend = ::std::option::Option::None;
        self.last_message = ::std::option::Option::None;
        self.last_view = ::std::option::Option::None;
        self.unread_message_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendsMessages_GetActiveMessageSessions_Response_FriendMessageSession {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_SendMessage_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    message: ::protobuf::SingularField<::std::string::String>,
    contains_bbcode: ::std::option::Option<bool>,
    echo_to_sender: ::std::option::Option<bool>,
    low_priority: ::std::option::Option<bool>,
    client_message_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_SendMessage_Request {
    fn default() -> &'a CFriendMessages_SendMessage_Request {
        <CFriendMessages_SendMessage_Request as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_SendMessage_Request {
    pub fn new() -> CFriendMessages_SendMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;


    pub fn get_chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }
    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool contains_bbcode = 4;


    pub fn get_contains_bbcode(&self) -> bool {
        self.contains_bbcode.unwrap_or(false)
    }
    pub fn clear_contains_bbcode(&mut self) {
        self.contains_bbcode = ::std::option::Option::None;
    }

    pub fn has_contains_bbcode(&self) -> bool {
        self.contains_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contains_bbcode(&mut self, v: bool) {
        self.contains_bbcode = ::std::option::Option::Some(v);
    }

    // optional bool echo_to_sender = 5;


    pub fn get_echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }
    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 6;


    pub fn get_low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }
    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    // optional string client_message_id = 8;


    pub fn get_client_message_id(&self) -> &str {
        match self.client_message_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client_message_id(&mut self) {
        self.client_message_id.clear();
    }

    pub fn has_client_message_id(&self) -> bool {
        self.client_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_message_id(&mut self, v: ::std::string::String) {
        self.client_message_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_message_id(&mut self) -> &mut ::std::string::String {
        if self.client_message_id.is_none() {
            self.client_message_id.set_default();
        }
        self.client_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_message_id(&mut self) -> ::std::string::String {
        self.client_message_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CFriendMessages_SendMessage_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_entry_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.contains_bbcode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.echo_to_sender = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.low_priority = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.contains_bbcode {
            my_size += 2;
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 2;
        }
        if let Some(v) = self.low_priority {
            my_size += 2;
        }
        if let Some(ref v) = self.client_message_id.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.contains_bbcode {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.client_message_id.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_SendMessage_Request {
        CFriendMessages_SendMessage_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CFriendMessages_SendMessage_Request| { &m.steamid },
                |m: &mut CFriendMessages_SendMessage_Request| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_entry_type",
                |m: &CFriendMessages_SendMessage_Request| { &m.chat_entry_type },
                |m: &mut CFriendMessages_SendMessage_Request| { &mut m.chat_entry_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CFriendMessages_SendMessage_Request| { &m.message },
                |m: &mut CFriendMessages_SendMessage_Request| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "contains_bbcode",
                |m: &CFriendMessages_SendMessage_Request| { &m.contains_bbcode },
                |m: &mut CFriendMessages_SendMessage_Request| { &mut m.contains_bbcode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "echo_to_sender",
                |m: &CFriendMessages_SendMessage_Request| { &m.echo_to_sender },
                |m: &mut CFriendMessages_SendMessage_Request| { &mut m.echo_to_sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "low_priority",
                |m: &CFriendMessages_SendMessage_Request| { &m.low_priority },
                |m: &mut CFriendMessages_SendMessage_Request| { &mut m.low_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_message_id",
                |m: &CFriendMessages_SendMessage_Request| { &m.client_message_id },
                |m: &mut CFriendMessages_SendMessage_Request| { &mut m.client_message_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_SendMessage_Request>(
                "CFriendMessages_SendMessage_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_SendMessage_Request {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_SendMessage_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_SendMessage_Request::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_SendMessage_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.message.clear();
        self.contains_bbcode = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.client_message_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_SendMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_SendMessage_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_SendMessage_Response {
    // message fields
    modified_message: ::protobuf::SingularField<::std::string::String>,
    server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    message_without_bb_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_SendMessage_Response {
    fn default() -> &'a CFriendMessages_SendMessage_Response {
        <CFriendMessages_SendMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_SendMessage_Response {
    pub fn new() -> CFriendMessages_SendMessage_Response {
        ::std::default::Default::default()
    }

    // optional string modified_message = 1;


    pub fn get_modified_message(&self) -> &str {
        match self.modified_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_modified_message(&mut self) {
        self.modified_message.clear();
    }

    pub fn has_modified_message(&self) -> bool {
        self.modified_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_message(&mut self, v: ::std::string::String) {
        self.modified_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_message(&mut self) -> &mut ::std::string::String {
        if self.modified_message.is_none() {
            self.modified_message.set_default();
        }
        self.modified_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_message(&mut self) -> ::std::string::String {
        self.modified_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_timestamp = 2;


    pub fn get_server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }
    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional string message_without_bb_code = 4;


    pub fn get_message_without_bb_code(&self) -> &str {
        match self.message_without_bb_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_without_bb_code(&mut self) {
        self.message_without_bb_code.clear();
    }

    pub fn has_message_without_bb_code(&self) -> bool {
        self.message_without_bb_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_without_bb_code(&mut self, v: ::std::string::String) {
        self.message_without_bb_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_without_bb_code(&mut self) -> &mut ::std::string::String {
        if self.message_without_bb_code.is_none() {
            self.message_without_bb_code.set_default();
        }
        self.message_without_bb_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_without_bb_code(&mut self) -> ::std::string::String {
        self.message_without_bb_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CFriendMessages_SendMessage_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.modified_message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_without_bb_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.modified_message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_without_bb_code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.modified_message.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.message_without_bb_code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_SendMessage_Response {
        CFriendMessages_SendMessage_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "modified_message",
                |m: &CFriendMessages_SendMessage_Response| { &m.modified_message },
                |m: &mut CFriendMessages_SendMessage_Response| { &mut m.modified_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_timestamp",
                |m: &CFriendMessages_SendMessage_Response| { &m.server_timestamp },
                |m: &mut CFriendMessages_SendMessage_Response| { &mut m.server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CFriendMessages_SendMessage_Response| { &m.ordinal },
                |m: &mut CFriendMessages_SendMessage_Response| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_without_bb_code",
                |m: &CFriendMessages_SendMessage_Response| { &m.message_without_bb_code },
                |m: &mut CFriendMessages_SendMessage_Response| { &mut m.message_without_bb_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_SendMessage_Response>(
                "CFriendMessages_SendMessage_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_SendMessage_Response {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_SendMessage_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_SendMessage_Response::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_SendMessage_Response {
    fn clear(&mut self) {
        self.modified_message.clear();
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.message_without_bb_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_SendMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_SendMessage_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_AckMessage_Notification {
    // message fields
    steamid_partner: ::std::option::Option<u64>,
    timestamp: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_AckMessage_Notification {
    fn default() -> &'a CFriendMessages_AckMessage_Notification {
        <CFriendMessages_AckMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_AckMessage_Notification {
    pub fn new() -> CFriendMessages_AckMessage_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_partner = 1;


    pub fn get_steamid_partner(&self) -> u64 {
        self.steamid_partner.unwrap_or(0)
    }
    pub fn clear_steamid_partner(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
    }

    pub fn has_steamid_partner(&self) -> bool {
        self.steamid_partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_partner(&mut self, v: u64) {
        self.steamid_partner = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendMessages_AckMessage_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_partner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_partner {
            my_size += 9;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_partner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_AckMessage_Notification {
        CFriendMessages_AckMessage_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_partner",
                |m: &CFriendMessages_AckMessage_Notification| { &m.steamid_partner },
                |m: &mut CFriendMessages_AckMessage_Notification| { &mut m.steamid_partner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CFriendMessages_AckMessage_Notification| { &m.timestamp },
                |m: &mut CFriendMessages_AckMessage_Notification| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_AckMessage_Notification>(
                "CFriendMessages_AckMessage_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_AckMessage_Notification {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_AckMessage_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_AckMessage_Notification::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_AckMessage_Notification {
    fn clear(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_AckMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_AckMessage_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_IsInFriendsUIBeta_Request {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_IsInFriendsUIBeta_Request {
    fn default() -> &'a CFriendMessages_IsInFriendsUIBeta_Request {
        <CFriendMessages_IsInFriendsUIBeta_Request as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_IsInFriendsUIBeta_Request {
    pub fn new() -> CFriendMessages_IsInFriendsUIBeta_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendMessages_IsInFriendsUIBeta_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_IsInFriendsUIBeta_Request {
        CFriendMessages_IsInFriendsUIBeta_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CFriendMessages_IsInFriendsUIBeta_Request| { &m.steamid },
                |m: &mut CFriendMessages_IsInFriendsUIBeta_Request| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_IsInFriendsUIBeta_Request>(
                "CFriendMessages_IsInFriendsUIBeta_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_IsInFriendsUIBeta_Request {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_IsInFriendsUIBeta_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_IsInFriendsUIBeta_Request::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_IsInFriendsUIBeta_Request {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_IsInFriendsUIBeta_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_IsInFriendsUIBeta_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_IsInFriendsUIBeta_Response {
    // message fields
    online_in_friendsui: ::std::option::Option<bool>,
    has_used_friendsui: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_IsInFriendsUIBeta_Response {
    fn default() -> &'a CFriendMessages_IsInFriendsUIBeta_Response {
        <CFriendMessages_IsInFriendsUIBeta_Response as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_IsInFriendsUIBeta_Response {
    pub fn new() -> CFriendMessages_IsInFriendsUIBeta_Response {
        ::std::default::Default::default()
    }

    // optional bool online_in_friendsui = 1;


    pub fn get_online_in_friendsui(&self) -> bool {
        self.online_in_friendsui.unwrap_or(false)
    }
    pub fn clear_online_in_friendsui(&mut self) {
        self.online_in_friendsui = ::std::option::Option::None;
    }

    pub fn has_online_in_friendsui(&self) -> bool {
        self.online_in_friendsui.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online_in_friendsui(&mut self, v: bool) {
        self.online_in_friendsui = ::std::option::Option::Some(v);
    }

    // optional bool has_used_friendsui = 2;


    pub fn get_has_used_friendsui(&self) -> bool {
        self.has_used_friendsui.unwrap_or(false)
    }
    pub fn clear_has_used_friendsui(&mut self) {
        self.has_used_friendsui = ::std::option::Option::None;
    }

    pub fn has_has_used_friendsui(&self) -> bool {
        self.has_used_friendsui.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_used_friendsui(&mut self, v: bool) {
        self.has_used_friendsui = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendMessages_IsInFriendsUIBeta_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.online_in_friendsui = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_used_friendsui = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.online_in_friendsui {
            my_size += 2;
        }
        if let Some(v) = self.has_used_friendsui {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.online_in_friendsui {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.has_used_friendsui {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_IsInFriendsUIBeta_Response {
        CFriendMessages_IsInFriendsUIBeta_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "online_in_friendsui",
                |m: &CFriendMessages_IsInFriendsUIBeta_Response| { &m.online_in_friendsui },
                |m: &mut CFriendMessages_IsInFriendsUIBeta_Response| { &mut m.online_in_friendsui },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_used_friendsui",
                |m: &CFriendMessages_IsInFriendsUIBeta_Response| { &m.has_used_friendsui },
                |m: &mut CFriendMessages_IsInFriendsUIBeta_Response| { &mut m.has_used_friendsui },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_IsInFriendsUIBeta_Response>(
                "CFriendMessages_IsInFriendsUIBeta_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_IsInFriendsUIBeta_Response {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_IsInFriendsUIBeta_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_IsInFriendsUIBeta_Response::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_IsInFriendsUIBeta_Response {
    fn clear(&mut self) {
        self.online_in_friendsui = ::std::option::Option::None;
        self.has_used_friendsui = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_IsInFriendsUIBeta_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_IsInFriendsUIBeta_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CFriendMessages_IncomingMessage_Notification {
    // message fields
    steamid_friend: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    from_limited_account: ::std::option::Option<bool>,
    message: ::protobuf::SingularField<::std::string::String>,
    rtime32_server_timestamp: ::std::option::Option<u32>,
    ordinal: ::std::option::Option<u32>,
    local_echo: ::std::option::Option<bool>,
    message_no_bbcode: ::protobuf::SingularField<::std::string::String>,
    low_priority: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CFriendMessages_IncomingMessage_Notification {
    fn default() -> &'a CFriendMessages_IncomingMessage_Notification {
        <CFriendMessages_IncomingMessage_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CFriendMessages_IncomingMessage_Notification {
    pub fn new() -> CFriendMessages_IncomingMessage_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_friend = 1;


    pub fn get_steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }
    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;


    pub fn get_chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }
    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bool from_limited_account = 3;


    pub fn get_from_limited_account(&self) -> bool {
        self.from_limited_account.unwrap_or(false)
    }
    pub fn clear_from_limited_account(&mut self) {
        self.from_limited_account = ::std::option::Option::None;
    }

    pub fn has_from_limited_account(&self) -> bool {
        self.from_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_limited_account(&mut self, v: bool) {
        self.from_limited_account = ::std::option::Option::Some(v);
    }

    // optional string message = 4;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 rtime32_server_timestamp = 5;


    pub fn get_rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }
    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 6;


    pub fn get_ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }
    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional bool local_echo = 7;


    pub fn get_local_echo(&self) -> bool {
        self.local_echo.unwrap_or(false)
    }
    pub fn clear_local_echo(&mut self) {
        self.local_echo = ::std::option::Option::None;
    }

    pub fn has_local_echo(&self) -> bool {
        self.local_echo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_echo(&mut self, v: bool) {
        self.local_echo = ::std::option::Option::Some(v);
    }

    // optional string message_no_bbcode = 8;


    pub fn get_message_no_bbcode(&self) -> &str {
        match self.message_no_bbcode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message_no_bbcode(&mut self) {
        self.message_no_bbcode.clear();
    }

    pub fn has_message_no_bbcode(&self) -> bool {
        self.message_no_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_no_bbcode(&mut self, v: ::std::string::String) {
        self.message_no_bbcode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_no_bbcode(&mut self) -> &mut ::std::string::String {
        if self.message_no_bbcode.is_none() {
            self.message_no_bbcode.set_default();
        }
        self.message_no_bbcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_no_bbcode(&mut self) -> ::std::string::String {
        self.message_no_bbcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool low_priority = 9;


    pub fn get_low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }
    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CFriendMessages_IncomingMessage_Notification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_friend = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_entry_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.from_limited_account = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_server_timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ordinal = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local_echo = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message_no_bbcode)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.low_priority = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_friend {
            my_size += 9;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_limited_account {
            my_size += 2;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.ordinal {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_echo {
            my_size += 2;
        }
        if let Some(ref v) = self.message_no_bbcode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.low_priority {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_limited_account {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.local_echo {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.message_no_bbcode.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CFriendMessages_IncomingMessage_Notification {
        CFriendMessages_IncomingMessage_Notification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_friend",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.steamid_friend },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.steamid_friend },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_entry_type",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.chat_entry_type },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.chat_entry_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "from_limited_account",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.from_limited_account },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.from_limited_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.message },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_server_timestamp",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.rtime32_server_timestamp },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.rtime32_server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ordinal",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.ordinal },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.ordinal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local_echo",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.local_echo },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.local_echo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message_no_bbcode",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.message_no_bbcode },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.message_no_bbcode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "low_priority",
                |m: &CFriendMessages_IncomingMessage_Notification| { &m.low_priority },
                |m: &mut CFriendMessages_IncomingMessage_Notification| { &mut m.low_priority },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CFriendMessages_IncomingMessage_Notification>(
                "CFriendMessages_IncomingMessage_Notification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CFriendMessages_IncomingMessage_Notification {
        static instance: ::protobuf::rt::LazyV2<CFriendMessages_IncomingMessage_Notification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CFriendMessages_IncomingMessage_Notification::new)
    }
}

impl ::protobuf::Clear for CFriendMessages_IncomingMessage_Notification {
    fn clear(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.from_limited_account = ::std::option::Option::None;
        self.message.clear();
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.local_echo = ::std::option::Option::None;
        self.message_no_bbcode.clear();
        self.low_priority = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CFriendMessages_IncomingMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CFriendMessages_IncomingMessage_Notification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n.steammessages_friendmessages.steamclient.proto\x1a,steammessages_unif\
    ied_base.steamclient.proto\"\xea\x06\n)CFriendMessages_GetRecentMessages\
    _Request\x12\x1a\n\x08steamid1\x18\x01\x20\x01(\x06R\x08steamid1\x12\x1a\
    \n\x08steamid2\x18\x02\x20\x01(\x06R\x08steamid2\x12S\n\x05count\x18\x03\
    \x20\x01(\rR\x05countB=\x82\xb5\x189If\x20non-zero,\x20cap\x20the\x20num\
    ber\x20of\x20recent\x20messages\x20to\x20return.\x12\x8b\x01\n\x18most_r\
    ecent_conversation\x18\x04\x20\x01(\x08R\x16mostRecentConversationBQ\x82\
    \xb5\x18MGrab\x20the\x20block\x20of\x20chat\x20from\x20the\x20most\x20re\
    cent\x20conversation\x20(a\x20~5\x20minute\x20period)\x12\xbb\x01\n\x12r\
    time32_start_time\x18\x05\x20\x01(\x07R\x10rtime32StartTimeB\x8c\x01\x82\
    \xb5\x18\x87\x01If\x20non-zero,\x20return\x20only\x20messages\x20with\
    \x20timestamps\x20greater\x20or\x20equal\x20to\x20this.\x20If\x20zero,\
    \x20we\x20only\x20return\x20messages\x20from\x20a\x20recent\x20time\x20c\
    utoff.\x12S\n\rbbcode_format\x18\x06\x20\x01(\x08R\x0cbbcodeFormatB.\x82\
    \xb5\x18*Return\x20the\x20results\x20with\x20bbcode\x20formatting.\x12\
    \x92\x01\n\rstart_ordinal\x18\x07\x20\x01(\rR\x0cstartOrdinalBm\x82\xb5\
    \x18iCombined\x20with\x20start\x20time,\x20only\x20messages\x20after\x20\
    this\x20ordinal\x20are\x20returned\x20(dedupes\x20messages\x20in\x20same\
    \x20second)\x12W\n\ttime_last\x18\x08\x20\x01(\rR\x08timeLastB:\x82\xb5\
    \x186if\x20present/non-zero,\x20return\x20only\x20messages\x20before\x20\
    this.\x12!\n\x0cordinal_last\x18\t\x20\x01(\rR\x0bordinalLast\"\xdf\x02\
    \n*CFriendMessages_GetRecentMessages_Response\x12\x88\x01\n\x08messages\
    \x18\x01\x20\x03(\x0b29.CFriendMessages_GetRecentMessages_Response.Frien\
    dMessageR\x08messagesB1\x82\xb5\x18-Array\x20of\x20messages,\x20returned\
    \x20newest\x20to\x20oldest.\x12%\n\x0emore_available\x18\x04\x20\x01(\
    \x08R\rmoreAvailable\x1a\x7f\n\rFriendMessage\x12\x1c\n\taccountid\x18\
    \x01\x20\x01(\rR\taccountid\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\tti\
    mestamp\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x18\n\
    \x07ordinal\x18\x04\x20\x01(\rR\x07ordinal\"\x8c\x03\n1CFriendsMessages_\
    GetActiveMessageSessions_Request\x12\x91\x01\n\x11lastmessage_since\x18\
    \x01\x20\x01(\rR\x10lastmessageSinceBd\x82\xb5\x18`return\x20only\x20ses\
    sion\x20information\x20where\x20a\x20chat\x20message\x20has\x20been\x20s\
    ent\x20since\x20this\x20time\x20(for\x20polling)\x12\xc2\x01\n\x1bonly_s\
    essions_with_messages\x18\x02\x20\x01(\x08R\x18onlySessionsWithMessagesB\
    \x82\x01\x82\xb5\x18~If\x20non-zero,\x20return\x20only\x20message\x20ses\
    sions\x20that\x20have\x20messages\x20since\x20our\x20message\x20cutoff.\
    \x20If\x20zero,\x20we\x20return\x20all\x20active\x20sessions.\"\xd5\x03\
    \n2CFriendsMessages_GetActiveMessageSessions_Response\x12s\n\x10message_\
    sessions\x18\x01\x20\x03(\x0b2H.CFriendsMessages_GetActiveMessageSession\
    s_Response.FriendMessageSessionR\x0fmessageSessions\x12t\n\ttimestamp\
    \x18\x02\x20\x01(\rR\ttimestampBV\x82\xb5\x18RThis\x20should\x20be\x20pa\
    ssed\x20in\x20the\x20next\x20request\x20as\x20lastmessage_since\x20to\
    \x20poll\x20for\x20updates\x1a\xb3\x01\n\x14FriendMessageSession\x12)\n\
    \x10accountid_friend\x18\x01\x20\x01(\rR\x0faccountidFriend\x12!\n\x0cla\
    st_message\x18\x02\x20\x01(\rR\x0blastMessage\x12\x1b\n\tlast_view\x18\
    \x03\x20\x01(\rR\x08lastView\x120\n\x14unread_message_count\x18\x04\x20\
    \x01(\rR\x12unreadMessageCount\"\x9f\x02\n#CFriendMessages_SendMessage_R\
    equest\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12&\n\x0fc\
    hat_entry_type\x18\x02\x20\x01(\x05R\rchatEntryType\x12\x18\n\x07message\
    \x18\x03\x20\x01(\tR\x07message\x12'\n\x0fcontains_bbcode\x18\x04\x20\
    \x01(\x08R\x0econtainsBbcode\x12$\n\x0eecho_to_sender\x18\x05\x20\x01(\
    \x08R\x0cechoToSender\x12!\n\x0clow_priority\x18\x06\x20\x01(\x08R\x0blo\
    wPriority\x12*\n\x11client_message_id\x18\x08\x20\x01(\tR\x0fclientMessa\
    geId\"\xcd\x01\n$CFriendMessages_SendMessage_Response\x12)\n\x10modified\
    _message\x18\x01\x20\x01(\tR\x0fmodifiedMessage\x12)\n\x10server_timesta\
    mp\x18\x02\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x03\
    \x20\x01(\rR\x07ordinal\x125\n\x17message_without_bb_code\x18\x04\x20\
    \x01(\tR\x14messageWithoutBbCode\"p\n'CFriendMessages_AckMessage_Notific\
    ation\x12'\n\x0fsteamid_partner\x18\x01\x20\x01(\x06R\x0esteamidPartner\
    \x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\"E\n)CFriendMessage\
    s_IsInFriendsUIBeta_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\
    \x07steamid\"\x8a\x01\n*CFriendMessages_IsInFriendsUIBeta_Response\x12.\
    \n\x13online_in_friendsui\x18\x01\x20\x01(\x08R\x11onlineInFriendsui\x12\
    ,\n\x12has_used_friendsui\x18\x02\x20\x01(\x08R\x10hasUsedFriendsui\"\
    \x8b\x03\n,CFriendMessages_IncomingMessage_Notification\x12%\n\x0esteami\
    d_friend\x18\x01\x20\x01(\x06R\rsteamidFriend\x12&\n\x0fchat_entry_type\
    \x18\x02\x20\x01(\x05R\rchatEntryType\x120\n\x14from_limited_account\x18\
    \x03\x20\x01(\x08R\x12fromLimitedAccount\x12\x18\n\x07message\x18\x04\
    \x20\x01(\tR\x07message\x128\n\x18rtime32_server_timestamp\x18\x05\x20\
    \x01(\x07R\x16rtime32ServerTimestamp\x12\x18\n\x07ordinal\x18\x06\x20\
    \x01(\rR\x07ordinal\x12\x1d\n\nlocal_echo\x18\x07\x20\x01(\x08R\tlocalEc\
    ho\x12*\n\x11message_no_bbcode\x18\x08\x20\x01(\tR\x0fmessageNoBbcode\
    \x12!\n\x0clow_priority\x18\t\x20\x01(\x08R\x0blowPriority2\x8c\x07\n\
    \x0eFriendMessages\x12\xa5\x01\n\x11GetRecentMessages\x12*.CFriendMessag\
    es_GetRecentMessages_Request\x1a+.CFriendMessages_GetRecentMessages_Resp\
    onse\"7\x82\xb5\x183Get\x20a\x20log\x20of\x20recent\x20chat\x20messages\
    \x20between\x20two\x20users\x12\xc0\x01\n\x18GetActiveMessageSessions\
    \x122.CFriendsMessages_GetActiveMessageSessions_Request\x1a3.CFriendsMes\
    sages_GetActiveMessageSessions_Response\";\x82\xb5\x187Get\x20informatio\
    n\x20about\x20recent\x20offline\x20messages\x20and\x20chats\x12\x7f\n\
    \x0bSendMessage\x12$.CFriendMessages_SendMessage_Request\x1a%.CFriendMes\
    sages_SendMessage_Response\"#\x82\xb5\x18\x1fSend\x20a\x20chat\x20messag\
    e\x20to\x20a\x20friend\x12\x8c\x01\n\nAckMessage\x12(.CFriendMessages_Ac\
    kMessage_Notification\x1a\x0b.NoResponse\"G\x82\xb5\x18CAcknowledge\x20t\
    hat\x20we\x20have\x20seen\x20the\x20most\x20recent\x20message\x20from\
    \x20a\x20friend\x12\x9b\x01\n\x11IsInFriendsUIBeta\x12*.CFriendMessages_\
    IsInFriendsUIBeta_Request\x1a+.CFriendMessages_IsInFriendsUIBeta_Respons\
    e\"-\x82\xb5\x18)See\x20if\x20a\x20friend\x20is\x20in\x20the\x20friendsu\
    i\x20beta.\x1aa\x82\xb5\x18]A\x20service\x20for\x20relaying\x20and\x20lo\
    gging\x20friend\x20messages\x20(user-to-user\x20chats\x20and\x20offline\
    \x20messaging)2\xa0\x02\n\x14FriendMessagesClient\x12r\n\x0fIncomingMess\
    age\x12-.CFriendMessages_IncomingMessage_Notification\x1a\x0b.NoResponse\
    \"#\x82\xb5\x18\x1fNew\x20chat\x20message\x20from\x20a\x20friend.\x12\
    \x8d\x01\n\x14NotifyAckMessageEcho\x12(.CFriendMessages_AckMessage_Notif\
    ication\x1a\x0b.NoResponse\">\x82\xb5\x18:A\x20session\x20acked\x20an\
    \x20unread\x20message,\x20echo\x20to\x20other\x20sessions.\x1a\x04\xc0\
    \xb5\x18\x02B\x03\x80\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
