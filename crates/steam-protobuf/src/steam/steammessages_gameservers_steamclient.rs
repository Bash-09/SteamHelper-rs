// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_gameservers.steamclient.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CGameServers_GetServerList_Request {
    // message fields
    filter: ::protobuf::SingularField<::std::string::String>,
    limit: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGameServers_GetServerList_Request {
    fn default() -> &'a CGameServers_GetServerList_Request {
        <CGameServers_GetServerList_Request as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_GetServerList_Request {
    pub fn new() -> CGameServers_GetServerList_Request {
        ::std::default::Default::default()
    }

    // optional string filter = 1;


    pub fn get_filter(&self) -> &str {
        match self.filter.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        self.filter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 limit = 2;


    pub fn get_limit(&self) -> u32 {
        self.limit.unwrap_or(100u32)
    }
    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGameServers_GetServerList_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filter)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.limit {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGameServers_GetServerList_Request {
        CGameServers_GetServerList_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &CGameServers_GetServerList_Request| { &m.filter },
                |m: &mut CGameServers_GetServerList_Request| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "limit",
                |m: &CGameServers_GetServerList_Request| { &m.limit },
                |m: &mut CGameServers_GetServerList_Request| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGameServers_GetServerList_Request>(
                "CGameServers_GetServerList_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGameServers_GetServerList_Request {
        static instance: ::protobuf::rt::LazyV2<CGameServers_GetServerList_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGameServers_GetServerList_Request::new)
    }
}

impl ::protobuf::Clear for CGameServers_GetServerList_Request {
    fn clear(&mut self) {
        self.filter.clear();
        self.limit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGameServers_GetServerList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_GetServerList_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CGameServers_GetServerList_Response {
    // message fields
    pub servers: ::protobuf::RepeatedField<CGameServers_GetServerList_Response_Server>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGameServers_GetServerList_Response {
    fn default() -> &'a CGameServers_GetServerList_Response {
        <CGameServers_GetServerList_Response as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_GetServerList_Response {
    pub fn new() -> CGameServers_GetServerList_Response {
        ::std::default::Default::default()
    }

    // repeated .CGameServers_GetServerList_Response.Server servers = 1;


    pub fn get_servers(&self) -> &[CGameServers_GetServerList_Response_Server] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CGameServers_GetServerList_Response_Server>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CGameServers_GetServerList_Response_Server> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CGameServers_GetServerList_Response_Server> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CGameServers_GetServerList_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGameServers_GetServerList_Response {
        CGameServers_GetServerList_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CGameServers_GetServerList_Response_Server>>(
                "servers",
                |m: &CGameServers_GetServerList_Response| { &m.servers },
                |m: &mut CGameServers_GetServerList_Response| { &mut m.servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGameServers_GetServerList_Response>(
                "CGameServers_GetServerList_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGameServers_GetServerList_Response {
        static instance: ::protobuf::rt::LazyV2<CGameServers_GetServerList_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGameServers_GetServerList_Response::new)
    }
}

impl ::protobuf::Clear for CGameServers_GetServerList_Response {
    fn clear(&mut self) {
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGameServers_GetServerList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_GetServerList_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CGameServers_GetServerList_Response_Server {
    // message fields
    addr: ::protobuf::SingularField<::std::string::String>,
    gameport: ::std::option::Option<u32>,
    specport: ::std::option::Option<u32>,
    steamid: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    appid: ::std::option::Option<u32>,
    gamedir: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    product: ::protobuf::SingularField<::std::string::String>,
    region: ::std::option::Option<i32>,
    players: ::std::option::Option<i32>,
    max_players: ::std::option::Option<i32>,
    bots: ::std::option::Option<i32>,
    map: ::protobuf::SingularField<::std::string::String>,
    secure: ::std::option::Option<bool>,
    dedicated: ::std::option::Option<bool>,
    os: ::protobuf::SingularField<::std::string::String>,
    gametype: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGameServers_GetServerList_Response_Server {
    fn default() -> &'a CGameServers_GetServerList_Response_Server {
        <CGameServers_GetServerList_Response_Server as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_GetServerList_Response_Server {
    pub fn new() -> CGameServers_GetServerList_Response_Server {
        ::std::default::Default::default()
    }

    // optional string addr = 1;


    pub fn get_addr(&self) -> &str {
        match self.addr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        if self.addr.is_none() {
            self.addr.set_default();
        }
        self.addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        self.addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gameport = 2;


    pub fn get_gameport(&self) -> u32 {
        self.gameport.unwrap_or(0)
    }
    pub fn clear_gameport(&mut self) {
        self.gameport = ::std::option::Option::None;
    }

    pub fn has_gameport(&self) -> bool {
        self.gameport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameport(&mut self, v: u32) {
        self.gameport = ::std::option::Option::Some(v);
    }

    // optional uint32 specport = 3;


    pub fn get_specport(&self) -> u32 {
        self.specport.unwrap_or(0)
    }
    pub fn clear_specport(&mut self) {
        self.specport = ::std::option::Option::None;
    }

    pub fn has_specport(&self) -> bool {
        self.specport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specport(&mut self, v: u32) {
        self.specport = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string name = 5;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 6;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string gamedir = 7;


    pub fn get_gamedir(&self) -> &str {
        match self.gamedir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gamedir(&mut self) {
        self.gamedir.clear();
    }

    pub fn has_gamedir(&self) -> bool {
        self.gamedir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamedir(&mut self, v: ::std::string::String) {
        self.gamedir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamedir(&mut self) -> &mut ::std::string::String {
        if self.gamedir.is_none() {
            self.gamedir.set_default();
        }
        self.gamedir.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamedir(&mut self) -> ::std::string::String {
        self.gamedir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 8;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product = 9;


    pub fn get_product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product.set_default();
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 region = 10;


    pub fn get_region(&self) -> i32 {
        self.region.unwrap_or(0)
    }
    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: i32) {
        self.region = ::std::option::Option::Some(v);
    }

    // optional int32 players = 11;


    pub fn get_players(&self) -> i32 {
        self.players.unwrap_or(0)
    }
    pub fn clear_players(&mut self) {
        self.players = ::std::option::Option::None;
    }

    pub fn has_players(&self) -> bool {
        self.players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: i32) {
        self.players = ::std::option::Option::Some(v);
    }

    // optional int32 max_players = 12;


    pub fn get_max_players(&self) -> i32 {
        self.max_players.unwrap_or(0)
    }
    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: i32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional int32 bots = 13;


    pub fn get_bots(&self) -> i32 {
        self.bots.unwrap_or(0)
    }
    pub fn clear_bots(&mut self) {
        self.bots = ::std::option::Option::None;
    }

    pub fn has_bots(&self) -> bool {
        self.bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bots(&mut self, v: i32) {
        self.bots = ::std::option::Option::Some(v);
    }

    // optional string map = 14;


    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool secure = 15;


    pub fn get_secure(&self) -> bool {
        self.secure.unwrap_or(false)
    }
    pub fn clear_secure(&mut self) {
        self.secure = ::std::option::Option::None;
    }

    pub fn has_secure(&self) -> bool {
        self.secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure(&mut self, v: bool) {
        self.secure = ::std::option::Option::Some(v);
    }

    // optional bool dedicated = 16;


    pub fn get_dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }
    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional string os = 17;


    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string gametype = 18;


    pub fn get_gametype(&self) -> &str {
        match self.gametype.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gametype(&mut self) {
        self.gametype.clear();
    }

    pub fn has_gametype(&self) -> bool {
        self.gametype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametype(&mut self, v: ::std::string::String) {
        self.gametype = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gametype(&mut self) -> &mut ::std::string::String {
        if self.gametype.is_none() {
            self.gametype.set_default();
        }
        self.gametype.as_mut().unwrap()
    }

    // Take field
    pub fn take_gametype(&mut self) -> ::std::string::String {
        self.gametype.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CGameServers_GetServerList_Response_Server {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameport = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.specport = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gamedir)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.product)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.region = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.players = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_players = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bots = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.secure = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dedicated = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gametype)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addr.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.gameport {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.specport {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.gamedir.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.region {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.players {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_players {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bots {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.secure {
            my_size += 2;
        }
        if let Some(v) = self.dedicated {
            my_size += 3;
        }
        if let Some(ref v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.gametype.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addr.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.gameport {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.specport {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.gamedir.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.product.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.region {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.players {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.max_players {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.bots {
            os.write_int32(13, v)?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.secure {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.dedicated {
            os.write_bool(16, v)?;
        }
        if let Some(ref v) = self.os.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.gametype.as_ref() {
            os.write_string(18, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGameServers_GetServerList_Response_Server {
        CGameServers_GetServerList_Response_Server::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addr",
                |m: &CGameServers_GetServerList_Response_Server| { &m.addr },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameport",
                |m: &CGameServers_GetServerList_Response_Server| { &m.gameport },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.gameport },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "specport",
                |m: &CGameServers_GetServerList_Response_Server| { &m.specport },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.specport },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CGameServers_GetServerList_Response_Server| { &m.steamid },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CGameServers_GetServerList_Response_Server| { &m.name },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CGameServers_GetServerList_Response_Server| { &m.appid },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gamedir",
                |m: &CGameServers_GetServerList_Response_Server| { &m.gamedir },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.gamedir },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &CGameServers_GetServerList_Response_Server| { &m.version },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product",
                |m: &CGameServers_GetServerList_Response_Server| { &m.product },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.product },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "region",
                |m: &CGameServers_GetServerList_Response_Server| { &m.region },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.region },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "players",
                |m: &CGameServers_GetServerList_Response_Server| { &m.players },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_players",
                |m: &CGameServers_GetServerList_Response_Server| { &m.max_players },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.max_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bots",
                |m: &CGameServers_GetServerList_Response_Server| { &m.bots },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.bots },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map",
                |m: &CGameServers_GetServerList_Response_Server| { &m.map },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.map },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "secure",
                |m: &CGameServers_GetServerList_Response_Server| { &m.secure },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.secure },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dedicated",
                |m: &CGameServers_GetServerList_Response_Server| { &m.dedicated },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.dedicated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os",
                |m: &CGameServers_GetServerList_Response_Server| { &m.os },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.os },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gametype",
                |m: &CGameServers_GetServerList_Response_Server| { &m.gametype },
                |m: &mut CGameServers_GetServerList_Response_Server| { &mut m.gametype },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGameServers_GetServerList_Response_Server>(
                "CGameServers_GetServerList_Response.Server",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGameServers_GetServerList_Response_Server {
        static instance: ::protobuf::rt::LazyV2<CGameServers_GetServerList_Response_Server> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGameServers_GetServerList_Response_Server::new)
    }
}

impl ::protobuf::Clear for CGameServers_GetServerList_Response_Server {
    fn clear(&mut self) {
        self.addr.clear();
        self.gameport = ::std::option::Option::None;
        self.specport = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.name.clear();
        self.appid = ::std::option::Option::None;
        self.gamedir.clear();
        self.version.clear();
        self.product.clear();
        self.region = ::std::option::Option::None;
        self.players = ::std::option::Option::None;
        self.max_players = ::std::option::Option::None;
        self.bots = ::std::option::Option::None;
        self.map.clear();
        self.secure = ::std::option::Option::None;
        self.dedicated = ::std::option::Option::None;
        self.os.clear();
        self.gametype.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGameServers_GetServerList_Response_Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_GetServerList_Response_Server {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CGameServers_GetServerSteamIDsByIP_Request {
    // message fields
    pub server_ips: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGameServers_GetServerSteamIDsByIP_Request {
    fn default() -> &'a CGameServers_GetServerSteamIDsByIP_Request {
        <CGameServers_GetServerSteamIDsByIP_Request as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_GetServerSteamIDsByIP_Request {
    pub fn new() -> CGameServers_GetServerSteamIDsByIP_Request {
        ::std::default::Default::default()
    }

    // repeated string server_ips = 1;


    pub fn get_server_ips(&self) -> &[::std::string::String] {
        &self.server_ips
    }
    pub fn clear_server_ips(&mut self) {
        self.server_ips.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_ips(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.server_ips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_ips(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.server_ips
    }

    // Take field
    pub fn take_server_ips(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.server_ips, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CGameServers_GetServerSteamIDsByIP_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.server_ips)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.server_ips {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.server_ips {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGameServers_GetServerSteamIDsByIP_Request {
        CGameServers_GetServerSteamIDsByIP_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server_ips",
                |m: &CGameServers_GetServerSteamIDsByIP_Request| { &m.server_ips },
                |m: &mut CGameServers_GetServerSteamIDsByIP_Request| { &mut m.server_ips },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGameServers_GetServerSteamIDsByIP_Request>(
                "CGameServers_GetServerSteamIDsByIP_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGameServers_GetServerSteamIDsByIP_Request {
        static instance: ::protobuf::rt::LazyV2<CGameServers_GetServerSteamIDsByIP_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGameServers_GetServerSteamIDsByIP_Request::new)
    }
}

impl ::protobuf::Clear for CGameServers_GetServerSteamIDsByIP_Request {
    fn clear(&mut self) {
        self.server_ips.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGameServers_GetServerSteamIDsByIP_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_GetServerSteamIDsByIP_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CGameServers_IPsWithSteamIDs_Response {
    // message fields
    pub servers: ::protobuf::RepeatedField<CGameServers_IPsWithSteamIDs_Response_Server>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGameServers_IPsWithSteamIDs_Response {
    fn default() -> &'a CGameServers_IPsWithSteamIDs_Response {
        <CGameServers_IPsWithSteamIDs_Response as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_IPsWithSteamIDs_Response {
    pub fn new() -> CGameServers_IPsWithSteamIDs_Response {
        ::std::default::Default::default()
    }

    // repeated .CGameServers_IPsWithSteamIDs_Response.Server servers = 1;


    pub fn get_servers(&self) -> &[CGameServers_IPsWithSteamIDs_Response_Server] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CGameServers_IPsWithSteamIDs_Response_Server>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CGameServers_IPsWithSteamIDs_Response_Server> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CGameServers_IPsWithSteamIDs_Response_Server> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CGameServers_IPsWithSteamIDs_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGameServers_IPsWithSteamIDs_Response {
        CGameServers_IPsWithSteamIDs_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CGameServers_IPsWithSteamIDs_Response_Server>>(
                "servers",
                |m: &CGameServers_IPsWithSteamIDs_Response| { &m.servers },
                |m: &mut CGameServers_IPsWithSteamIDs_Response| { &mut m.servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGameServers_IPsWithSteamIDs_Response>(
                "CGameServers_IPsWithSteamIDs_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGameServers_IPsWithSteamIDs_Response {
        static instance: ::protobuf::rt::LazyV2<CGameServers_IPsWithSteamIDs_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGameServers_IPsWithSteamIDs_Response::new)
    }
}

impl ::protobuf::Clear for CGameServers_IPsWithSteamIDs_Response {
    fn clear(&mut self) {
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGameServers_IPsWithSteamIDs_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_IPsWithSteamIDs_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CGameServers_IPsWithSteamIDs_Response_Server {
    // message fields
    addr: ::protobuf::SingularField<::std::string::String>,
    steamid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGameServers_IPsWithSteamIDs_Response_Server {
    fn default() -> &'a CGameServers_IPsWithSteamIDs_Response_Server {
        <CGameServers_IPsWithSteamIDs_Response_Server as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_IPsWithSteamIDs_Response_Server {
    pub fn new() -> CGameServers_IPsWithSteamIDs_Response_Server {
        ::std::default::Default::default()
    }

    // optional string addr = 1;


    pub fn get_addr(&self) -> &str {
        match self.addr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        if self.addr.is_none() {
            self.addr.set_default();
        }
        self.addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        self.addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGameServers_IPsWithSteamIDs_Response_Server {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addr.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addr.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGameServers_IPsWithSteamIDs_Response_Server {
        CGameServers_IPsWithSteamIDs_Response_Server::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addr",
                |m: &CGameServers_IPsWithSteamIDs_Response_Server| { &m.addr },
                |m: &mut CGameServers_IPsWithSteamIDs_Response_Server| { &mut m.addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CGameServers_IPsWithSteamIDs_Response_Server| { &m.steamid },
                |m: &mut CGameServers_IPsWithSteamIDs_Response_Server| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGameServers_IPsWithSteamIDs_Response_Server>(
                "CGameServers_IPsWithSteamIDs_Response.Server",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGameServers_IPsWithSteamIDs_Response_Server {
        static instance: ::protobuf::rt::LazyV2<CGameServers_IPsWithSteamIDs_Response_Server> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGameServers_IPsWithSteamIDs_Response_Server::new)
    }
}

impl ::protobuf::Clear for CGameServers_IPsWithSteamIDs_Response_Server {
    fn clear(&mut self) {
        self.addr.clear();
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGameServers_IPsWithSteamIDs_Response_Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_IPsWithSteamIDs_Response_Server {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CGameServers_GetServerIPsBySteamID_Request {
    // message fields
    pub server_steamids: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGameServers_GetServerIPsBySteamID_Request {
    fn default() -> &'a CGameServers_GetServerIPsBySteamID_Request {
        <CGameServers_GetServerIPsBySteamID_Request as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_GetServerIPsBySteamID_Request {
    pub fn new() -> CGameServers_GetServerIPsBySteamID_Request {
        ::std::default::Default::default()
    }

    // repeated fixed64 server_steamids = 1;


    pub fn get_server_steamids(&self) -> &[u64] {
        &self.server_steamids
    }
    pub fn clear_server_steamids(&mut self) {
        self.server_steamids.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_steamids(&mut self, v: ::std::vec::Vec<u64>) {
        self.server_steamids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_steamids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.server_steamids
    }

    // Take field
    pub fn take_server_steamids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.server_steamids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CGameServers_GetServerIPsBySteamID_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.server_steamids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.server_steamids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.server_steamids {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGameServers_GetServerIPsBySteamID_Request {
        CGameServers_GetServerIPsBySteamID_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "server_steamids",
                |m: &CGameServers_GetServerIPsBySteamID_Request| { &m.server_steamids },
                |m: &mut CGameServers_GetServerIPsBySteamID_Request| { &mut m.server_steamids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGameServers_GetServerIPsBySteamID_Request>(
                "CGameServers_GetServerIPsBySteamID_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGameServers_GetServerIPsBySteamID_Request {
        static instance: ::protobuf::rt::LazyV2<CGameServers_GetServerIPsBySteamID_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGameServers_GetServerIPsBySteamID_Request::new)
    }
}

impl ::protobuf::Clear for CGameServers_GetServerIPsBySteamID_Request {
    fn clear(&mut self) {
        self.server_steamids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGameServers_GetServerIPsBySteamID_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_GetServerIPsBySteamID_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n+steammessages_gameservers.steamclient.proto\x1a,steammessages_unified\
    _base.steamclient.proto\"\xae\x01\n\"CGameServers_GetServerList_Request\
    \x120\n\x06filter\x18\x01\x20\x01(\tR\x06filterB\x18\x82\xb5\x18\x14Quer\
    y\x20filter\x20string.\x12V\n\x05limit\x18\x02\x20\x01(\r:\x03100R\x05li\
    mitB;\x82\xb5\x187The\x20maximum\x20number\x20of\x20servers\x20to\x20ret\
    urn\x20in\x20the\x20response\"\xfd\x04\n#CGameServers_GetServerList_Resp\
    onse\x12n\n\x07servers\x18\x01\x20\x03(\x0b2+.CGameServers_GetServerList\
    _Response.ServerR\x07serversB'\x82\xb5\x18#List\x20of\x20servers\x20matc\
    hing\x20the\x20filter\x1a\xe5\x03\n\x06Server\x126\n\x04addr\x18\x01\x20\
    \x01(\tR\x04addrB\"\x82\xb5\x18\x1eThe\x20server's\x20IP\x20and\x20query\
    \x20port\x12\x1a\n\x08gameport\x18\x02\x20\x01(\rR\x08gameport\x12\x1a\n\
    \x08specport\x18\x03\x20\x01(\rR\x08specport\x12\x18\n\x07steamid\x18\
    \x04\x20\x01(\x06R\x07steamid\x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04n\
    ame\x12\x14\n\x05appid\x18\x06\x20\x01(\rR\x05appid\x12\x18\n\x07gamedir\
    \x18\x07\x20\x01(\tR\x07gamedir\x12\x18\n\x07version\x18\x08\x20\x01(\tR\
    \x07version\x12\x18\n\x07product\x18\t\x20\x01(\tR\x07product\x12\x16\n\
    \x06region\x18\n\x20\x01(\x05R\x06region\x12\x18\n\x07players\x18\x0b\
    \x20\x01(\x05R\x07players\x12\x1f\n\x0bmax_players\x18\x0c\x20\x01(\x05R\
    \nmaxPlayers\x12\x12\n\x04bots\x18\r\x20\x01(\x05R\x04bots\x12\x10\n\x03\
    map\x18\x0e\x20\x01(\tR\x03map\x12\x16\n\x06secure\x18\x0f\x20\x01(\x08R\
    \x06secure\x12\x1c\n\tdedicated\x18\x10\x20\x01(\x08R\tdedicated\x12\x0e\
    \n\x02os\x18\x11\x20\x01(\tR\x02os\x12\x1a\n\x08gametype\x18\x12\x20\x01\
    (\tR\x08gametype\"K\n*CGameServers_GetServerSteamIDsByIP_Request\x12\x1d\
    \n\nserver_ips\x18\x01\x20\x03(\tR\tserverIps\"\xa8\x01\n%CGameServers_I\
    PsWithSteamIDs_Response\x12G\n\x07servers\x18\x01\x20\x03(\x0b2-.CGameSe\
    rvers_IPsWithSteamIDs_Response.ServerR\x07servers\x1a6\n\x06Server\x12\
    \x12\n\x04addr\x18\x01\x20\x01(\tR\x04addr\x12\x18\n\x07steamid\x18\x02\
    \x20\x01(\x06R\x07steamid\"U\n*CGameServers_GetServerIPsBySteamID_Reques\
    t\x12'\n\x0fserver_steamids\x18\x01\x20\x03(\x06R\x0eserverSteamids2\xab\
    \x04\n\x0bGameServers\x12\x8c\x01\n\rGetServerList\x12#.CGameServers_Get\
    ServerList_Request\x1a$.CGameServers_GetServerList_Response\"0\x82\xb5\
    \x18,Gets\x20a\x20list\x20of\x20servers\x20given\x20a\x20filter\x20strin\
    g\x12\xa4\x01\n\x15GetServerSteamIDsByIP\x12+.CGameServers_GetServerStea\
    mIDsByIP_Request\x1a&.CGameServers_IPsWithSteamIDs_Response\"6\x82\xb5\
    \x182Gets\x20a\x20list\x20of\x20server\x20SteamIDs\x20given\x20a\x20list\
    \x20of\x20IPs\x12\xad\x01\n\x15GetServerIPsBySteamID\x12+.CGameServers_G\
    etServerIPsBySteamID_Request\x1a&.CGameServers_IPsWithSteamIDs_Response\
    \"?\x82\xb5\x18;Gets\x20a\x20list\x20of\x20server\x20IP\x20addresses\x20\
    given\x20a\x20list\x20of\x20SteamIDs\x1a6\x82\xb5\x182A\x20service\x20fo\
    r\x20searching\x20and\x20managing\x20game\x20servers.B\x03\x80\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
